name: Go Tests

on:
  push:
    branches-ignore:
      - master
  pull_request:
    branches-ignore:
      - gh-pages

jobs:
  go-lint:
    # TODO(JayF): Configure this to only run when golang code has changed
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        go: [ '1.18' ]
    steps:
      - uses: actions/checkout@v3
      - uses: ./.github/workflows/go-setup

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          version: "latest"
          skip-pkg-cache: true
          skip-build-cache: true
          args: "-c ./.golangci.yml --timeout=10m --issues-exit-code=1 --max-issues-per-linter=0 --sort-results ./..."

      - name: make code-checks
        run: make code-checks

      # TODO(JayF): Consider moving this into its own job, that runs under a larger set of circumstances
      #             since it's possible for this to fail without any go changes being made.
      - name: Validate no changes in generated proto files
        run: |
          make proto
          make dotnet
          git status -s -uno
          git --no-pager diff
          exit $(git status -s -uno | wc -l)

  go-unit-tests:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        go: [ '1.18' ]
    steps:
      - uses: actions/checkout@v3
      - uses: ./.github/workflows/go-setup

      - name: make tests
        run: make tests

      - name: make junit-report
        run: make junit-report

      - name: Upload junit report
        uses: actions/upload-artifact@v2.2.4
        with:
          name: junit.xml
          path: test_reports/junit.xml

      - name: Assemble container tag
        id: container_tag
        uses: pr-mpt/actions-commit-hash@v1
        with:
          commit: "${{ github.sha }}"
          prefix: "${{ github.ref_name }}"

      - name: Upload dev images to dockerhub
        run: |
            # Note(JayF): All the offical docker actions for uploading these
            # containers also assume you need to rebuild them. That makes them
            # ill-suited for our workflow.
            TAG=$(echo -n "${{ steps.container_tag.outputs.long }}" | sed 's|/|-|g')

            # TODO(JayF): how to get these secrets in here safely?
            echo ${DOCKERHUB_PASS} | docker login -u ${DOCKERHUB_USER} --password-stdin
      
            IMAGES_TO_UPLOAD=(
              "armada:armada-server"
              "armada-executor:armada-executor"
              "armadactl:armada-armadactl"
              "testsuite:armada-testsuite"
              "armada-load-tester:armada-load-tester"
              "armada-fakeexecutor:armada-fakeexecutor"
              "armada-lookout:armada-lookout"
              "armada-lookout-ingester:armada-lookout-ingestor"
              "armada-event-ingester:armada-event-ingestor"
              "armada-binoculars:armada-binoculars"
              "armada-jobservice:armada-jobservice"
            )
          
            for image_info in "${IMAGES_TO_UPLOAD[@]}"; do
              LOCAL=${image_info%%:*}
              REMOTE=${image_info#*:}
              docker tag ${LOCAL} gresearchdev/${REMOTE}-dev:${TAG}
              docker push gresearchdev/${REMOTE}-dev:${TAG}
            done
