// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/executorapi/executorapi.proto

package executorapi

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	v1 "k8s.io/api/core/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"

	api "github.com/armadaproject/armada/pkg/api"
	armadaevents "github.com/armadaproject/armada/pkg/armadaevents"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Used by the scheduler when allocating jobs to executors.
type NodeInfo struct {
	Name   string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Taints []v1.Taint        `protobuf:"bytes,2,rep,name=taints,proto3" json:"taints"`
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// To be deprecated in favour of total_resources + allocated_resources.
	AllocatableResources map[string]resource.Quantity `protobuf:"bytes,4,rep,name=allocatable_resources,json=allocatableResources,proto3" json:"allocatableResources" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// To be deprecated in favour of total_resources + allocated_resources.
	AvailableResources map[string]resource.Quantity `protobuf:"bytes,5,rep,name=available_resources,json=availableResources,proto3" json:"availableResources" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Total node resources.
	// Resources available for allocation is given by the difference between this and allocated_resources.
	TotalResources map[string]resource.Quantity `protobuf:"bytes,6,rep,name=total_resources,json=totalResources,proto3" json:"totalResources" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Each pod is created with a priority class. Each priority class has an integer priority associated with it.
	// This is a map from priority to the total amount of resources allocated to pods with that priority.
	// It is used by the scheduler to decide whether more jobs should be sent to an executor.
	// In particular, jobs may be sent to an executor even if all resources are allocated
	// if the sent jobs are of higher priority.
	AllocatedResources map[int32]ComputeResource `protobuf:"bytes,7,rep,name=allocated_resources,json=allocatedResources,proto3" json:"allocatedResources" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// All run ids of jobs on the node, mapped to their current state
	// this should be of type armadaevents.uuid, but this creates a circular loop
	// once the old scheduler has gone, we can correct this
	RunIdsByState map[string]api.JobState `protobuf:"bytes,8,rep,name=run_ids_by_state,json=runIdsByState,proto3" json:"runIdsByState" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=api.JobState"`
	// The amount of resource allocated to non-armada pods by priority
	NonArmadaAllocatedResources map[int32]ComputeResource `protobuf:"bytes,9,rep,name=non_armada_allocated_resources,json=nonArmadaAllocatedResources,proto3" json:"nonArmadaAllocatedResources" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Unschedulable               bool                      `protobuf:"varint,10,opt,name=unschedulable,proto3" json:"unschedulable,omitempty"`
	// This should only be used for metrics
	// An aggregated real usage of jobs by queue
	ResourceUsageByQueue map[string]*ComputeResource `protobuf:"bytes,11,rep,name=resource_usage_by_queue,json=resourceUsageByQueue,proto3" json:"resourceUsageByQueue,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// This should only be used for metrics
	// This is the type the node should be reported as. It is simple a label to categorise the group the node belongs to
	NodeType string `protobuf:"bytes,12,opt,name=node_type,json=nodeType,proto3" json:"nodeType,omitempty"`
}

func (m *NodeInfo) Reset()      { *m = NodeInfo{} }
func (*NodeInfo) ProtoMessage() {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_57e0d9d0e484e459, []int{0}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeInfo) GetTaints() []v1.Taint {
	if m != nil {
		return m.Taints
	}
	return nil
}

func (m *NodeInfo) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *NodeInfo) GetAllocatableResources() map[string]resource.Quantity {
	if m != nil {
		return m.AllocatableResources
	}
	return nil
}

func (m *NodeInfo) GetAvailableResources() map[string]resource.Quantity {
	if m != nil {
		return m.AvailableResources
	}
	return nil
}

func (m *NodeInfo) GetTotalResources() map[string]resource.Quantity {
	if m != nil {
		return m.TotalResources
	}
	return nil
}

func (m *NodeInfo) GetAllocatedResources() map[int32]ComputeResource {
	if m != nil {
		return m.AllocatedResources
	}
	return nil
}

func (m *NodeInfo) GetRunIdsByState() map[string]api.JobState {
	if m != nil {
		return m.RunIdsByState
	}
	return nil
}

func (m *NodeInfo) GetNonArmadaAllocatedResources() map[int32]ComputeResource {
	if m != nil {
		return m.NonArmadaAllocatedResources
	}
	return nil
}

func (m *NodeInfo) GetUnschedulable() bool {
	if m != nil {
		return m.Unschedulable
	}
	return false
}

func (m *NodeInfo) GetResourceUsageByQueue() map[string]*ComputeResource {
	if m != nil {
		return m.ResourceUsageByQueue
	}
	return nil
}

func (m *NodeInfo) GetNodeType() string {
	if m != nil {
		return m.NodeType
	}
	return ""
}

type ComputeResource struct {
	Resources map[string]resource.Quantity `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ComputeResource) Reset()      { *m = ComputeResource{} }
func (*ComputeResource) ProtoMessage() {}
func (*ComputeResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_57e0d9d0e484e459, []int{1}
}
func (m *ComputeResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComputeResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComputeResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComputeResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComputeResource.Merge(m, src)
}
func (m *ComputeResource) XXX_Size() int {
	return m.Size()
}
func (m *ComputeResource) XXX_DiscardUnknown() {
	xxx_messageInfo_ComputeResource.DiscardUnknown(m)
}

var xxx_messageInfo_ComputeResource proto.InternalMessageInfo

func (m *ComputeResource) GetResources() map[string]resource.Quantity {
	if m != nil {
		return m.Resources
	}
	return nil
}

type EventList struct {
	Events []*armadaevents.EventSequence `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *EventList) Reset()      { *m = EventList{} }
func (*EventList) ProtoMessage() {}
func (*EventList) Descriptor() ([]byte, []int) {
	return fileDescriptor_57e0d9d0e484e459, []int{2}
}
func (m *EventList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventList.Merge(m, src)
}
func (m *EventList) XXX_Size() int {
	return m.Size()
}
func (m *EventList) XXX_DiscardUnknown() {
	xxx_messageInfo_EventList.DiscardUnknown(m)
}

var xxx_messageInfo_EventList proto.InternalMessageInfo

func (m *EventList) GetEvents() []*armadaevents.EventSequence {
	if m != nil {
		return m.Events
	}
	return nil
}

type LeaseRequest struct {
	// Each executor has a unique name associated with it.
	ExecutorId string `protobuf:"bytes,1,opt,name=executor_id,json=executorId,proto3" json:"executorId,omitempty"`
	// Nodes are split into pools. This field indicates for which pool jobs are leased.
	Pool string `protobuf:"bytes,2,opt,name=pool,proto3" json:"pool,omitempty"`
	// Total resources available for scheduling across all nodes.
	Resources map[string]resource.Quantity `protobuf:"bytes,3,rep,name=resources,proto3" json:"resources" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Jobs submitted to this executor must require at least this amount of resources.
	MinimumJobSize map[string]resource.Quantity `protobuf:"bytes,4,rep,name=minimum_job_size,json=minimumJobSize,proto3" json:"minimumJobSize" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// For each node in the cluster:
	// - The total allocatable resources on that node.
	// - The job runs running on those nodes,
	// - Any taints and labels on the node.
	Nodes []*NodeInfo `protobuf:"bytes,5,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Run Ids of jobs owned by the executor but not currently assigned to a node.
	UnassignedJobRunIds []armadaevents.Uuid `protobuf:"bytes,6,rep,name=unassigned_job_run_ids,json=unassignedJobRunIds,proto3" json:"unassignedJobRunIds"`
	// Max number of jobs this request should return
	MaxJobsToLease uint32 `protobuf:"varint,7,opt,name=max_jobs_to_lease,json=maxJobsToLease,proto3" json:"maxJobsToLease,omitempty"`
}

func (m *LeaseRequest) Reset()      { *m = LeaseRequest{} }
func (*LeaseRequest) ProtoMessage() {}
func (*LeaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_57e0d9d0e484e459, []int{3}
}
func (m *LeaseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseRequest.Merge(m, src)
}
func (m *LeaseRequest) XXX_Size() int {
	return m.Size()
}
func (m *LeaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseRequest proto.InternalMessageInfo

func (m *LeaseRequest) GetExecutorId() string {
	if m != nil {
		return m.ExecutorId
	}
	return ""
}

func (m *LeaseRequest) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *LeaseRequest) GetResources() map[string]resource.Quantity {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *LeaseRequest) GetMinimumJobSize() map[string]resource.Quantity {
	if m != nil {
		return m.MinimumJobSize
	}
	return nil
}

func (m *LeaseRequest) GetNodes() []*NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *LeaseRequest) GetUnassignedJobRunIds() []armadaevents.Uuid {
	if m != nil {
		return m.UnassignedJobRunIds
	}
	return nil
}

func (m *LeaseRequest) GetMaxJobsToLease() uint32 {
	if m != nil {
		return m.MaxJobsToLease
	}
	return 0
}

// Indicates that a job run is now leased.
type JobRunLease struct {
	JobRunId *armadaevents.Uuid      `protobuf:"bytes,1,opt,name=job_run_id,json=jobRunId,proto3" json:"jobRunId,omitempty"`
	Queue    string                  `protobuf:"bytes,2,opt,name=queue,proto3" json:"queue,omitempty"`
	Jobset   string                  `protobuf:"bytes,3,opt,name=jobset,proto3" json:"jobset,omitempty"`
	User     string                  `protobuf:"bytes,4,opt,name=user,proto3" json:"user,omitempty"`
	Groups   []string                `protobuf:"bytes,5,rep,name=groups,proto3" json:"groups,omitempty"`
	Job      *armadaevents.SubmitJob `protobuf:"bytes,6,opt,name=job,proto3" json:"job,omitempty"`
}

func (m *JobRunLease) Reset()      { *m = JobRunLease{} }
func (*JobRunLease) ProtoMessage() {}
func (*JobRunLease) Descriptor() ([]byte, []int) {
	return fileDescriptor_57e0d9d0e484e459, []int{4}
}
func (m *JobRunLease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunLease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunLease.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunLease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunLease.Merge(m, src)
}
func (m *JobRunLease) XXX_Size() int {
	return m.Size()
}
func (m *JobRunLease) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunLease.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunLease proto.InternalMessageInfo

func (m *JobRunLease) GetJobRunId() *armadaevents.Uuid {
	if m != nil {
		return m.JobRunId
	}
	return nil
}

func (m *JobRunLease) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *JobRunLease) GetJobset() string {
	if m != nil {
		return m.Jobset
	}
	return ""
}

func (m *JobRunLease) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *JobRunLease) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *JobRunLease) GetJob() *armadaevents.SubmitJob {
	if m != nil {
		return m.Job
	}
	return nil
}

// Indicates that the job runs with the given ids should be cancelled.
type CancelRuns struct {
	JobRunIdsToCancel []*armadaevents.Uuid `protobuf:"bytes,1,rep,name=job_run_ids_to_cancel,json=jobRunIdsToCancel,proto3" json:"jobRunIdsToCancel,omitempty"`
}

func (m *CancelRuns) Reset()      { *m = CancelRuns{} }
func (*CancelRuns) ProtoMessage() {}
func (*CancelRuns) Descriptor() ([]byte, []int) {
	return fileDescriptor_57e0d9d0e484e459, []int{5}
}
func (m *CancelRuns) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelRuns) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelRuns.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelRuns) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelRuns.Merge(m, src)
}
func (m *CancelRuns) XXX_Size() int {
	return m.Size()
}
func (m *CancelRuns) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelRuns.DiscardUnknown(m)
}

var xxx_messageInfo_CancelRuns proto.InternalMessageInfo

func (m *CancelRuns) GetJobRunIdsToCancel() []*armadaevents.Uuid {
	if m != nil {
		return m.JobRunIdsToCancel
	}
	return nil
}

// Indicates that the job runs with the given ids should be preempted.
type PreemptRuns struct {
	JobRunIdsToPreempt []*armadaevents.Uuid `protobuf:"bytes,1,rep,name=job_run_ids_to_preempt,json=jobRunIdsToPreempt,proto3" json:"jobRunIdsToPreempt,omitempty"`
}

func (m *PreemptRuns) Reset()      { *m = PreemptRuns{} }
func (*PreemptRuns) ProtoMessage() {}
func (*PreemptRuns) Descriptor() ([]byte, []int) {
	return fileDescriptor_57e0d9d0e484e459, []int{6}
}
func (m *PreemptRuns) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreemptRuns) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreemptRuns.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreemptRuns) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreemptRuns.Merge(m, src)
}
func (m *PreemptRuns) XXX_Size() int {
	return m.Size()
}
func (m *PreemptRuns) XXX_DiscardUnknown() {
	xxx_messageInfo_PreemptRuns.DiscardUnknown(m)
}

var xxx_messageInfo_PreemptRuns proto.InternalMessageInfo

func (m *PreemptRuns) GetJobRunIdsToPreempt() []*armadaevents.Uuid {
	if m != nil {
		return m.JobRunIdsToPreempt
	}
	return nil
}

// Indicates the end of the lease stream.
type EndMarker struct {
}

func (m *EndMarker) Reset()      { *m = EndMarker{} }
func (*EndMarker) ProtoMessage() {}
func (*EndMarker) Descriptor() ([]byte, []int) {
	return fileDescriptor_57e0d9d0e484e459, []int{7}
}
func (m *EndMarker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndMarker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndMarker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndMarker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndMarker.Merge(m, src)
}
func (m *EndMarker) XXX_Size() int {
	return m.Size()
}
func (m *EndMarker) XXX_DiscardUnknown() {
	xxx_messageInfo_EndMarker.DiscardUnknown(m)
}

var xxx_messageInfo_EndMarker proto.InternalMessageInfo

type LeaseStreamMessage struct {
	// Types that are valid to be assigned to Event:
	//	*LeaseStreamMessage_Lease
	//	*LeaseStreamMessage_CancelRuns
	//	*LeaseStreamMessage_End
	//	*LeaseStreamMessage_PreemptRuns
	Event isLeaseStreamMessage_Event `protobuf_oneof:"event"`
}

func (m *LeaseStreamMessage) Reset()      { *m = LeaseStreamMessage{} }
func (*LeaseStreamMessage) ProtoMessage() {}
func (*LeaseStreamMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_57e0d9d0e484e459, []int{8}
}
func (m *LeaseStreamMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseStreamMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseStreamMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseStreamMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseStreamMessage.Merge(m, src)
}
func (m *LeaseStreamMessage) XXX_Size() int {
	return m.Size()
}
func (m *LeaseStreamMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseStreamMessage.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseStreamMessage proto.InternalMessageInfo

type isLeaseStreamMessage_Event interface {
	isLeaseStreamMessage_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LeaseStreamMessage_Lease struct {
	Lease *JobRunLease `protobuf:"bytes,1,opt,name=lease,proto3,oneof" json:"lease,omitempty"`
}
type LeaseStreamMessage_CancelRuns struct {
	CancelRuns *CancelRuns `protobuf:"bytes,2,opt,name=cancel_runs,json=cancelRuns,proto3,oneof" json:"cancelRuns,omitempty"`
}
type LeaseStreamMessage_End struct {
	End *EndMarker `protobuf:"bytes,3,opt,name=end,proto3,oneof" json:"end,omitempty"`
}
type LeaseStreamMessage_PreemptRuns struct {
	PreemptRuns *PreemptRuns `protobuf:"bytes,4,opt,name=preempt_runs,json=preemptRuns,proto3,oneof" json:"preemptRuns,omitempty"`
}

func (*LeaseStreamMessage_Lease) isLeaseStreamMessage_Event()       {}
func (*LeaseStreamMessage_CancelRuns) isLeaseStreamMessage_Event()  {}
func (*LeaseStreamMessage_End) isLeaseStreamMessage_Event()         {}
func (*LeaseStreamMessage_PreemptRuns) isLeaseStreamMessage_Event() {}

func (m *LeaseStreamMessage) GetEvent() isLeaseStreamMessage_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *LeaseStreamMessage) GetLease() *JobRunLease {
	if x, ok := m.GetEvent().(*LeaseStreamMessage_Lease); ok {
		return x.Lease
	}
	return nil
}

func (m *LeaseStreamMessage) GetCancelRuns() *CancelRuns {
	if x, ok := m.GetEvent().(*LeaseStreamMessage_CancelRuns); ok {
		return x.CancelRuns
	}
	return nil
}

func (m *LeaseStreamMessage) GetEnd() *EndMarker {
	if x, ok := m.GetEvent().(*LeaseStreamMessage_End); ok {
		return x.End
	}
	return nil
}

func (m *LeaseStreamMessage) GetPreemptRuns() *PreemptRuns {
	if x, ok := m.GetEvent().(*LeaseStreamMessage_PreemptRuns); ok {
		return x.PreemptRuns
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LeaseStreamMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LeaseStreamMessage_Lease)(nil),
		(*LeaseStreamMessage_CancelRuns)(nil),
		(*LeaseStreamMessage_End)(nil),
		(*LeaseStreamMessage_PreemptRuns)(nil),
	}
}

func init() {
	proto.RegisterType((*NodeInfo)(nil), "executorapi.NodeInfo")
	proto.RegisterMapType((map[string]resource.Quantity)(nil), "executorapi.NodeInfo.AllocatableResourcesEntry")
	proto.RegisterMapType((map[int32]ComputeResource)(nil), "executorapi.NodeInfo.AllocatedResourcesEntry")
	proto.RegisterMapType((map[string]resource.Quantity)(nil), "executorapi.NodeInfo.AvailableResourcesEntry")
	proto.RegisterMapType((map[string]string)(nil), "executorapi.NodeInfo.LabelsEntry")
	proto.RegisterMapType((map[int32]ComputeResource)(nil), "executorapi.NodeInfo.NonArmadaAllocatedResourcesEntry")
	proto.RegisterMapType((map[string]*ComputeResource)(nil), "executorapi.NodeInfo.ResourceUsageByQueueEntry")
	proto.RegisterMapType((map[string]api.JobState)(nil), "executorapi.NodeInfo.RunIdsByStateEntry")
	proto.RegisterMapType((map[string]resource.Quantity)(nil), "executorapi.NodeInfo.TotalResourcesEntry")
	proto.RegisterType((*ComputeResource)(nil), "executorapi.ComputeResource")
	proto.RegisterMapType((map[string]resource.Quantity)(nil), "executorapi.ComputeResource.ResourcesEntry")
	proto.RegisterType((*EventList)(nil), "executorapi.EventList")
	proto.RegisterType((*LeaseRequest)(nil), "executorapi.LeaseRequest")
	proto.RegisterMapType((map[string]resource.Quantity)(nil), "executorapi.LeaseRequest.MinimumJobSizeEntry")
	proto.RegisterMapType((map[string]resource.Quantity)(nil), "executorapi.LeaseRequest.ResourcesEntry")
	proto.RegisterType((*JobRunLease)(nil), "executorapi.JobRunLease")
	proto.RegisterType((*CancelRuns)(nil), "executorapi.CancelRuns")
	proto.RegisterType((*PreemptRuns)(nil), "executorapi.PreemptRuns")
	proto.RegisterType((*EndMarker)(nil), "executorapi.EndMarker")
	proto.RegisterType((*LeaseStreamMessage)(nil), "executorapi.LeaseStreamMessage")
}

func init() { proto.RegisterFile("pkg/executorapi/executorapi.proto", fileDescriptor_57e0d9d0e484e459) }

var fileDescriptor_57e0d9d0e484e459 = []byte{
	// 1533 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4d, 0x6f, 0x1b, 0xc5,
	0x1b, 0xcf, 0xe6, 0xc5, 0x4d, 0xc6, 0x49, 0xda, 0x4c, 0xde, 0x36, 0x4e, 0xfe, 0x76, 0xea, 0x4a,
	0x7f, 0xa5, 0xa2, 0x5d, 0xd3, 0x14, 0xa1, 0x82, 0x00, 0x11, 0x57, 0x51, 0x9b, 0xa8, 0x2d, 0x74,
	0x93, 0x22, 0x8a, 0x90, 0xac, 0x59, 0xef, 0xd4, 0x59, 0xc7, 0xbb, 0xb3, 0xdd, 0x99, 0x4d, 0xeb,
	0x9e, 0x10, 0x07, 0x0e, 0x20, 0x24, 0x0e, 0x5c, 0x38, 0x54, 0xf0, 0x11, 0xf8, 0x10, 0x1c, 0x7a,
	0xac, 0xc4, 0xa5, 0x27, 0x8b, 0xa6, 0x37, 0x7f, 0x0a, 0x34, 0x2f, 0x1b, 0xcf, 0x3a, 0xeb, 0xa4,
	0x48, 0x48, 0xe4, 0x14, 0xcf, 0xf3, 0xf6, 0x7b, 0x5e, 0xe6, 0x79, 0xe6, 0xc9, 0x82, 0x8b, 0xe1,
	0x7e, 0xa3, 0x82, 0x9f, 0xe2, 0x7a, 0xcc, 0x48, 0x84, 0x42, 0x4f, 0xff, 0x6d, 0x85, 0x11, 0x61,
	0x04, 0xe6, 0x35, 0x52, 0xe1, 0x7f, 0x5c, 0x1e, 0x45, 0x3e, 0x72, 0x11, 0x3e, 0xc0, 0x01, 0xa3,
	0x15, 0xf9, 0x47, 0xca, 0x16, 0xe6, 0x04, 0x3b, 0xf4, 0x2a, 0x34, 0x76, 0x7c, 0x8f, 0x29, 0xea,
	0x72, 0x83, 0x90, 0x46, 0x0b, 0x57, 0xc4, 0xc9, 0x89, 0x1f, 0x55, 0xb0, 0x1f, 0xb2, 0xb6, 0x62,
	0x5e, 0x6d, 0x78, 0x6c, 0x2f, 0x76, 0xac, 0x3a, 0xf1, 0x2b, 0x0d, 0xd2, 0x20, 0x3d, 0x29, 0x7e,
	0x12, 0x07, 0xf1, 0x4b, 0x89, 0x97, 0xf7, 0x6f, 0x50, 0xcb, 0x23, 0x02, 0xa4, 0x4e, 0x22, 0x5c,
	0x39, 0xb8, 0x56, 0x69, 0xe0, 0x00, 0x47, 0x88, 0x61, 0x57, 0xc9, 0xbc, 0xd7, 0x93, 0xf1, 0x51,
	0x7d, 0xcf, 0x0b, 0x70, 0xd4, 0xae, 0x24, 0x9e, 0x45, 0x98, 0x92, 0x38, 0xaa, 0xe3, 0x7e, 0xad,
	0xf2, 0xef, 0x10, 0x8c, 0xdf, 0x23, 0x2e, 0xde, 0x0a, 0x1e, 0x11, 0xf8, 0x7f, 0x30, 0x1a, 0x20,
	0x1f, 0x9b, 0xc6, 0xaa, 0xb1, 0x36, 0x51, 0x85, 0xdd, 0x4e, 0x69, 0x9a, 0x9f, 0xaf, 0x10, 0xdf,
	0x63, 0xc2, 0x7b, 0x5b, 0xf0, 0xe1, 0x06, 0xc8, 0x31, 0xe4, 0x05, 0x8c, 0x9a, 0xc3, 0xab, 0x23,
	0x6b, 0xf9, 0xf5, 0x25, 0x4b, 0x62, 0x5b, 0x3c, 0x7f, 0xdc, 0x3f, 0xeb, 0xe0, 0x9a, 0xb5, 0xcb,
	0x25, 0xaa, 0xd3, 0x2f, 0x3a, 0xa5, 0xa1, 0x6e, 0xa7, 0xa4, 0x14, 0x6c, 0xf5, 0x17, 0x7e, 0x06,
	0x72, 0x2d, 0xe4, 0xe0, 0x16, 0x35, 0x47, 0x84, 0x89, 0x8b, 0x96, 0x5e, 0x83, 0xc4, 0x23, 0xeb,
	0x8e, 0x90, 0xd9, 0x0c, 0x58, 0xd4, 0xae, 0xce, 0x75, 0x3b, 0xa5, 0x0b, 0x52, 0x49, 0xf3, 0x48,
	0x99, 0x81, 0xdf, 0x1a, 0x60, 0x1e, 0xb5, 0x5a, 0xa4, 0x8e, 0x18, 0x72, 0x5a, 0xb8, 0x96, 0x44,
	0x4c, 0xcd, 0x51, 0x01, 0x50, 0xc9, 0x06, 0xd8, 0xe8, 0xa9, 0xd8, 0x89, 0x86, 0x84, 0x5b, 0x51,
	0x9e, 0xcf, 0xa1, 0x0c, 0x11, 0x3b, 0x93, 0x0a, 0x9f, 0x81, 0x59, 0x74, 0x80, 0xbc, 0x56, 0x9f,
	0x07, 0x63, 0xc2, 0x83, 0xab, 0x03, 0x3c, 0x48, 0x14, 0xfa, 0xf0, 0x0b, 0x0a, 0x1f, 0xa2, 0x63,
	0x02, 0x76, 0x06, 0x0d, 0x36, 0xc1, 0x79, 0x46, 0x18, 0x6a, 0x69, 0xb8, 0x39, 0x81, 0x7b, 0x39,
	0x1b, 0x77, 0x97, 0x0b, 0xf7, 0x61, 0x2e, 0x28, 0xcc, 0x69, 0x96, 0x62, 0xda, 0x7d, 0x67, 0x11,
	0xa7, 0x8c, 0x1f, 0xbb, 0x1a, 0xde, 0xb9, 0x13, 0xe3, 0x4c, 0x14, 0x06, 0xc6, 0x79, 0x4c, 0xc0,
	0xce, 0xa0, 0xc1, 0x3d, 0x70, 0x21, 0x8a, 0x83, 0x9a, 0xe7, 0xd2, 0x9a, 0xd3, 0xae, 0x51, 0x86,
	0x18, 0x36, 0xc7, 0x05, 0xf0, 0x5a, 0x36, 0xb0, 0x1d, 0x07, 0x5b, 0x2e, 0xad, 0xb6, 0x77, 0xb8,
	0xa8, 0xc4, 0x9c, 0x57, 0x98, 0x53, 0x91, 0xce, 0xb3, 0xd3, 0x47, 0xf8, 0x9b, 0x01, 0x8a, 0x01,
	0x09, 0x6a, 0xb2, 0xf3, 0x6b, 0x59, 0x11, 0x4f, 0x08, 0xe0, 0xf7, 0xb3, 0x81, 0xef, 0x91, 0x60,
	0x43, 0xa8, 0x0e, 0x0a, 0xfd, 0x92, 0x72, 0x63, 0x39, 0x18, 0x2c, 0x69, 0x9f, 0xc4, 0x84, 0x1b,
	0x60, 0x2a, 0x0e, 0x68, 0x7d, 0x0f, 0xbb, 0xb1, 0xb8, 0x0e, 0x26, 0x58, 0x35, 0xd6, 0xc6, 0xab,
	0xcb, 0xdd, 0x4e, 0x69, 0x31, 0xc5, 0xd0, 0x3a, 0x26, 0xad, 0x01, 0xbf, 0x37, 0xc0, 0x62, 0x12,
	0x50, 0x2d, 0xa6, 0xa8, 0x81, 0x79, 0x5e, 0x1f, 0xc7, 0x38, 0xc6, 0x66, 0xfe, 0xa4, 0xd6, 0x49,
	0xbc, 0x78, 0xc0, 0x75, 0xaa, 0xed, 0xfb, 0x5c, 0x43, 0xc6, 0x55, 0xee, 0x76, 0x4a, 0xc5, 0x28,
	0x83, 0xad, 0x79, 0x31, 0x97, 0xc5, 0x87, 0xd7, 0xc1, 0x44, 0x40, 0x5c, 0x5c, 0x63, 0xed, 0x10,
	0x9b, 0x93, 0x62, 0x0c, 0x2d, 0xf0, 0xbb, 0xc1, 0x89, 0xbb, 0xed, 0x50, 0x37, 0x30, 0x9e, 0xd0,
	0x0a, 0x08, 0xe4, 0xb5, 0x39, 0x01, 0x2f, 0x81, 0x91, 0x7d, 0xdc, 0x56, 0x43, 0x6c, 0x86, 0x57,
	0x79, 0x1f, 0xb7, 0x35, 0x45, 0xce, 0x85, 0x97, 0xc1, 0xd8, 0x01, 0x6a, 0xc5, 0xd8, 0x1c, 0x16,
	0x62, 0xb3, 0xdd, 0x4e, 0xe9, 0xbc, 0x20, 0x68, 0x82, 0x52, 0xe2, 0xc3, 0xe1, 0x1b, 0x46, 0xe1,
	0x57, 0x03, 0x2c, 0x0d, 0x1c, 0x15, 0x6f, 0x87, 0xf8, 0x50, 0x47, 0xcc, 0xaf, 0x5b, 0xda, 0xcc,
	0x3c, 0x9a, 0xd7, 0x56, 0xb8, 0xdf, 0x10, 0x43, 0x34, 0x49, 0x8e, 0x75, 0x3f, 0x46, 0x01, 0xf3,
	0x58, 0xfb, 0x54, 0x0f, 0x9f, 0x1b, 0x60, 0x71, 0xc0, 0x28, 0x39, 0x13, 0xfe, 0xfd, 0x62, 0x80,
	0xd9, 0x8c, 0x91, 0x73, 0x26, 0x7c, 0xfb, 0x81, 0xe7, 0x2e, 0xbb, 0x47, 0x75, 0xff, 0xc6, 0x06,
	0xfa, 0x77, 0x2b, 0xed, 0xdf, 0x4a, 0xaa, 0x61, 0x6e, 0x12, 0x3f, 0x8c, 0xd9, 0x51, 0x4d, 0x4e,
	0xf5, 0xe6, 0x09, 0x80, 0xc7, 0x47, 0xd6, 0xdb, 0xe5, 0xe9, 0x86, 0xee, 0xc7, 0xf4, 0xfa, 0x94,
	0xc8, 0xc7, 0x36, 0x71, 0x84, 0x9d, 0x53, 0x81, 0x7f, 0x36, 0xc0, 0xea, 0x69, 0x33, 0xeb, 0x3f,
	0xc8, 0xc7, 0x8f, 0x06, 0x58, 0x1a, 0x38, 0x6b, 0xde, 0x2e, 0x2f, 0xff, 0xa6, 0x3f, 0xe5, 0xef,
	0x86, 0xc1, 0xf9, 0x3e, 0x1d, 0xf8, 0x35, 0x98, 0xe8, 0x3d, 0x0a, 0x86, 0x98, 0x9a, 0xef, 0x9c,
	0x04, 0x62, 0xf5, 0xbd, 0x04, 0x33, 0xea, 0x25, 0xe8, 0x59, 0xb1, 0x7b, 0x3f, 0x79, 0x61, 0xa6,
	0xcf, 0x5e, 0xdb, 0x94, 0xbf, 0x00, 0x13, 0x9b, 0x7c, 0x0f, 0xbe, 0xe3, 0x51, 0x06, 0xb7, 0x40,
	0x4e, 0x2e, 0xc5, 0x2a, 0xfc, 0x65, 0x4b, 0x5f, 0x98, 0x2d, 0x21, 0xb8, 0x83, 0x1f, 0xc7, 0x38,
	0xa8, 0x63, 0xb9, 0xca, 0x49, 0x8e, 0xbe, 0xca, 0x49, 0x4a, 0xf9, 0x75, 0x0e, 0x4c, 0xde, 0xc1,
	0x88, 0x62, 0x9b, 0xcb, 0x53, 0x06, 0x3f, 0x00, 0x47, 0xeb, 0x78, 0xcd, 0x73, 0x55, 0xd0, 0x26,
	0xdf, 0xcd, 0x12, 0xf2, 0x96, 0xab, 0xd9, 0x01, 0x3d, 0x2a, 0x5f, 0x69, 0x43, 0x42, 0x5a, 0x6a,
	0xcc, 0x8b, 0x95, 0x96, 0x9f, 0xf5, 0x95, 0x96, 0x9f, 0xe1, 0x43, 0xbd, 0x80, 0x23, 0x19, 0xeb,
	0x84, 0xee, 0xd0, 0x3f, 0xaa, 0x1e, 0x24, 0xe0, 0x82, 0xef, 0x05, 0x9e, 0x1f, 0xfb, 0xb5, 0x26,
	0x71, 0x6a, 0xd4, 0x7b, 0x86, 0xd5, 0x4e, 0x7a, 0x75, 0x30, 0xc2, 0x5d, 0xa9, 0xc1, 0x7b, 0xd7,
	0x7b, 0x86, 0xfb, 0xb6, 0x33, 0x3f, 0xc5, 0xb4, 0xfb, 0xce, 0xf0, 0x53, 0x30, 0xc6, 0xdf, 0xc6,
	0x64, 0xef, 0x9c, 0xcf, 0x7c, 0xbe, 0x65, 0x75, 0x85, 0x9c, 0x5e, 0x5d, 0x41, 0x80, 0x2e, 0x58,
	0x88, 0x03, 0x44, 0xa9, 0xd7, 0x08, 0xb0, 0x2b, 0xbc, 0x56, 0x2b, 0x97, 0x5a, 0x29, 0x61, 0xba,
	0xb8, 0x0f, 0x62, 0xcf, 0xad, 0x2e, 0x2b, 0xef, 0x66, 0x7b, 0x9a, 0xdb, 0xc4, 0x91, 0x93, 0xcc,
	0xce, 0x22, 0xc2, 0x5b, 0x60, 0xc6, 0x47, 0x4f, 0xb9, 0x79, 0x5a, 0x63, 0xa4, 0xd6, 0xe2, 0xf1,
	0x9b, 0xe7, 0x56, 0x8d, 0xb5, 0xa9, 0xea, 0x4a, 0xb7, 0x53, 0x32, 0x7d, 0xf4, 0x74, 0x9b, 0x38,
	0x74, 0x97, 0x88, 0xcc, 0x68, 0x5e, 0x4e, 0xa7, 0x39, 0x67, 0xb4, 0x3f, 0xc4, 0x93, 0x97, 0x51,
	0xc7, 0x33, 0xd1, 0xbb, 0x7f, 0x0c, 0x83, 0xbc, 0xac, 0x84, 0x48, 0x21, 0xbc, 0x0d, 0x40, 0xaf,
	0xcc, 0xc2, 0xb5, 0xec, 0x2a, 0x8b, 0x6d, 0xac, 0xa9, 0x4a, 0xa8, 0x6f, 0x63, 0x09, 0x8d, 0x6f,
	0x56, 0x72, 0x79, 0xd4, 0x36, 0xab, 0xc7, 0x7d, 0xcb, 0x9f, 0x94, 0x80, 0x57, 0x40, 0x8e, 0x17,
	0x1f, 0x33, 0x73, 0x44, 0xc8, 0x8a, 0xb1, 0x20, 0x29, 0xfa, 0x58, 0x90, 0x14, 0xde, 0xca, 0x31,
	0xc5, 0x91, 0x39, 0xda, 0x6b, 0x65, 0x7e, 0xd6, 0x5b, 0x99, 0x9f, 0xb9, 0xd5, 0x46, 0x44, 0xe2,
	0x50, 0xde, 0x7f, 0x65, 0x55, 0x52, 0x74, 0xab, 0x92, 0x02, 0x3f, 0x02, 0x23, 0x4d, 0xe2, 0x98,
	0x39, 0x11, 0xf1, 0x62, 0x3a, 0xe2, 0x1d, 0xf1, 0xff, 0xfc, 0x36, 0x71, 0x64, 0x95, 0x9a, 0xc4,
	0xd1, 0xab, 0xd4, 0x24, 0x4e, 0x99, 0x02, 0x70, 0x13, 0x05, 0x75, 0xdc, 0xb2, 0xe3, 0x80, 0x42,
	0x0c, 0xe6, 0xb5, 0x5e, 0xe1, 0x77, 0xba, 0x2e, 0x98, 0x6a, 0x24, 0x66, 0xe5, 0xb3, 0xc4, 0xd7,
	0xff, 0x24, 0x77, 0x74, 0x97, 0x48, 0x6b, 0x1a, 0xcc, 0xcc, 0x31, 0x66, 0xf9, 0x09, 0xc8, 0x7f,
	0x1e, 0x61, 0xce, 0x16, 0xa8, 0x7b, 0x60, 0xa1, 0x0f, 0x35, 0x94, 0xdc, 0x13, 0x60, 0x57, 0xbb,
	0x9d, 0xd2, 0x8a, 0x66, 0x59, 0xd9, 0xd3, 0x70, 0xe1, 0x71, 0x6e, 0x39, 0x0f, 0x26, 0x36, 0x03,
	0xf7, 0x2e, 0x8a, 0xf6, 0x71, 0x54, 0xfe, 0x73, 0x18, 0x40, 0x71, 0x77, 0x76, 0x58, 0x84, 0x91,
	0x7f, 0x17, 0x53, 0xfe, 0x36, 0xc3, 0x4d, 0x30, 0x26, 0x1b, 0x59, 0xde, 0x21, 0x33, 0x35, 0x7c,
	0xb4, 0x1b, 0x27, 0x2f, 0x46, 0x2b, 0xdd, 0xd9, 0xb7, 0x87, 0x6c, 0xa9, 0x0d, 0x77, 0x41, 0x5e,
	0xe6, 0x8e, 0xc7, 0x45, 0x55, 0x13, 0x2c, 0xa6, 0x9f, 0xd4, 0xa3, 0xc4, 0xcb, 0xb7, 0xa0, 0x7e,
	0x74, 0x4e, 0x19, 0x04, 0x3d, 0x3a, 0xfc, 0x18, 0x8c, 0xe0, 0xc0, 0x15, 0xb7, 0x2d, 0xbf, 0xbe,
	0x90, 0xb2, 0x76, 0x14, 0x98, 0xac, 0x35, 0x0e, 0xdc, 0x94, 0x15, 0xae, 0x07, 0xbf, 0x04, 0x93,
	0x2a, 0xb5, 0xd2, 0xab, 0xd1, 0x8c, 0x10, 0xb5, 0xca, 0x54, 0x97, 0xba, 0x9d, 0xd2, 0x7c, 0xd8,
	0x23, 0xa4, 0x2c, 0xe6, 0x35, 0x46, 0xf5, 0x1c, 0x18, 0x13, 0xe5, 0x59, 0x7f, 0x6e, 0x80, 0xfc,
	0xa6, 0x32, 0xb7, 0x11, 0x7a, 0xf0, 0x9e, 0x7a, 0x0a, 0x65, 0xe6, 0x28, 0x5c, 0x1a, 0xf8, 0x64,
	0x14, 0x4a, 0xc7, 0x59, 0xa9, 0xd2, 0xac, 0x19, 0xef, 0x1a, 0xf0, 0x13, 0x30, 0x69, 0xe3, 0x90,
	0x44, 0x4c, 0x3c, 0xc8, 0x14, 0xf6, 0x25, 0x21, 0x79, 0xce, 0x0b, 0x0b, 0x96, 0xfc, 0x7c, 0x65,
	0x25, 0x1f, 0xa6, 0xac, 0x4d, 0xee, 0x77, 0xf5, 0xfe, 0xab, 0xd7, 0xc5, 0xa1, 0x6f, 0x0e, 0x8b,
	0xc6, 0x8b, 0xc3, 0xa2, 0xf1, 0xf2, 0xb0, 0x68, 0xfc, 0x75, 0x58, 0x34, 0x7e, 0x7a, 0x53, 0x1c,
	0x7a, 0xf9, 0xa6, 0x38, 0xf4, 0xea, 0x4d, 0x71, 0xe8, 0xab, 0x8a, 0xf6, 0x69, 0x4b, 0x5e, 0xbc,
	0x30, 0x22, 0x4d, 0x5c, 0x67, 0xea, 0x54, 0xe9, 0xfb, 0xf8, 0xe6, 0xe4, 0x04, 0xc4, 0xf5, 0xbf,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x5e, 0x37, 0xd8, 0xe3, 0x96, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ExecutorApiClient is the client API for ExecutorApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExecutorApiClient interface {
	// Reports usage information to the scheduler.
	// In return, the scheduler provides:
	// - Slice of job runs that the executor is currently running that should be cancelled.
	// - Slice of job runs that the executor is currently running that should be preempted.
	// - Slice job runs that the executor is not currently running that should be scheduled.
	// This call also acts as a signal to the scheduler that the executor is alive and accepting jobs.
	LeaseJobRuns(ctx context.Context, opts ...grpc.CallOption) (ExecutorApi_LeaseJobRunsClient, error)
	// Reports job run events to the scheduler.
	ReportEvents(ctx context.Context, in *EventList, opts ...grpc.CallOption) (*types.Empty, error)
}

type executorApiClient struct {
	cc *grpc.ClientConn
}

func NewExecutorApiClient(cc *grpc.ClientConn) ExecutorApiClient {
	return &executorApiClient{cc}
}

func (c *executorApiClient) LeaseJobRuns(ctx context.Context, opts ...grpc.CallOption) (ExecutorApi_LeaseJobRunsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ExecutorApi_serviceDesc.Streams[0], "/executorapi.ExecutorApi/LeaseJobRuns", opts...)
	if err != nil {
		return nil, err
	}
	x := &executorApiLeaseJobRunsClient{stream}
	return x, nil
}

type ExecutorApi_LeaseJobRunsClient interface {
	Send(*LeaseRequest) error
	Recv() (*LeaseStreamMessage, error)
	grpc.ClientStream
}

type executorApiLeaseJobRunsClient struct {
	grpc.ClientStream
}

func (x *executorApiLeaseJobRunsClient) Send(m *LeaseRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *executorApiLeaseJobRunsClient) Recv() (*LeaseStreamMessage, error) {
	m := new(LeaseStreamMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *executorApiClient) ReportEvents(ctx context.Context, in *EventList, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/executorapi.ExecutorApi/ReportEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExecutorApiServer is the server API for ExecutorApi service.
type ExecutorApiServer interface {
	// Reports usage information to the scheduler.
	// In return, the scheduler provides:
	// - Slice of job runs that the executor is currently running that should be cancelled.
	// - Slice of job runs that the executor is currently running that should be preempted.
	// - Slice job runs that the executor is not currently running that should be scheduled.
	// This call also acts as a signal to the scheduler that the executor is alive and accepting jobs.
	LeaseJobRuns(ExecutorApi_LeaseJobRunsServer) error
	// Reports job run events to the scheduler.
	ReportEvents(context.Context, *EventList) (*types.Empty, error)
}

// UnimplementedExecutorApiServer can be embedded to have forward compatible implementations.
type UnimplementedExecutorApiServer struct {
}

func (*UnimplementedExecutorApiServer) LeaseJobRuns(srv ExecutorApi_LeaseJobRunsServer) error {
	return status.Errorf(codes.Unimplemented, "method LeaseJobRuns not implemented")
}
func (*UnimplementedExecutorApiServer) ReportEvents(ctx context.Context, req *EventList) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportEvents not implemented")
}

func RegisterExecutorApiServer(s *grpc.Server, srv ExecutorApiServer) {
	s.RegisterService(&_ExecutorApi_serviceDesc, srv)
}

func _ExecutorApi_LeaseJobRuns_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ExecutorApiServer).LeaseJobRuns(&executorApiLeaseJobRunsServer{stream})
}

type ExecutorApi_LeaseJobRunsServer interface {
	Send(*LeaseStreamMessage) error
	Recv() (*LeaseRequest, error)
	grpc.ServerStream
}

type executorApiLeaseJobRunsServer struct {
	grpc.ServerStream
}

func (x *executorApiLeaseJobRunsServer) Send(m *LeaseStreamMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *executorApiLeaseJobRunsServer) Recv() (*LeaseRequest, error) {
	m := new(LeaseRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ExecutorApi_ReportEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecutorApiServer).ReportEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/executorapi.ExecutorApi/ReportEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecutorApiServer).ReportEvents(ctx, req.(*EventList))
	}
	return interceptor(ctx, in, info, handler)
}

var _ExecutorApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "executorapi.ExecutorApi",
	HandlerType: (*ExecutorApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportEvents",
			Handler:    _ExecutorApi_ReportEvents_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "LeaseJobRuns",
			Handler:       _ExecutorApi_LeaseJobRuns_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pkg/executorapi/executorapi.proto",
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeType) > 0 {
		i -= len(m.NodeType)
		copy(dAtA[i:], m.NodeType)
		i = encodeVarintExecutorapi(dAtA, i, uint64(len(m.NodeType)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ResourceUsageByQueue) > 0 {
		for k := range m.ResourceUsageByQueue {
			v := m.ResourceUsageByQueue[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintExecutorapi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Unschedulable {
		i--
		if m.Unschedulable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.NonArmadaAllocatedResources) > 0 {
		for k := range m.NonArmadaAllocatedResources {
			v := m.NonArmadaAllocatedResources[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintExecutorapi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.RunIdsByState) > 0 {
		for k := range m.RunIdsByState {
			v := m.RunIdsByState[k]
			baseI := i
			i = encodeVarintExecutorapi(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.AllocatedResources) > 0 {
		for k := range m.AllocatedResources {
			v := m.AllocatedResources[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintExecutorapi(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.TotalResources) > 0 {
		for k := range m.TotalResources {
			v := m.TotalResources[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AvailableResources) > 0 {
		for k := range m.AvailableResources {
			v := m.AvailableResources[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AllocatableResources) > 0 {
		for k := range m.AllocatableResources {
			v := m.AllocatableResources[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Taints) > 0 {
		for iNdEx := len(m.Taints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Taints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintExecutorapi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComputeResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComputeResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComputeResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for k := range m.Resources {
			v := m.Resources[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LeaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxJobsToLease != 0 {
		i = encodeVarintExecutorapi(dAtA, i, uint64(m.MaxJobsToLease))
		i--
		dAtA[i] = 0x38
	}
	if len(m.UnassignedJobRunIds) > 0 {
		for iNdEx := len(m.UnassignedJobRunIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnassignedJobRunIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MinimumJobSize) > 0 {
		for k := range m.MinimumJobSize {
			v := m.MinimumJobSize[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Resources) > 0 {
		for k := range m.Resources {
			v := m.Resources[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintExecutorapi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Pool) > 0 {
		i -= len(m.Pool)
		copy(dAtA[i:], m.Pool)
		i = encodeVarintExecutorapi(dAtA, i, uint64(len(m.Pool)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ExecutorId) > 0 {
		i -= len(m.ExecutorId)
		copy(dAtA[i:], m.ExecutorId)
		i = encodeVarintExecutorapi(dAtA, i, uint64(len(m.ExecutorId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunLease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunLease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunLease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutorapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Groups[iNdEx])
			copy(dAtA[i:], m.Groups[iNdEx])
			i = encodeVarintExecutorapi(dAtA, i, uint64(len(m.Groups[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintExecutorapi(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Jobset) > 0 {
		i -= len(m.Jobset)
		copy(dAtA[i:], m.Jobset)
		i = encodeVarintExecutorapi(dAtA, i, uint64(len(m.Jobset)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintExecutorapi(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x12
	}
	if m.JobRunId != nil {
		{
			size, err := m.JobRunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutorapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelRuns) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelRuns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelRuns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobRunIdsToCancel) > 0 {
		for iNdEx := len(m.JobRunIdsToCancel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JobRunIdsToCancel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PreemptRuns) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreemptRuns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreemptRuns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobRunIdsToPreempt) > 0 {
		for iNdEx := len(m.JobRunIdsToPreempt) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JobRunIdsToPreempt[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintExecutorapi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EndMarker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndMarker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndMarker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *LeaseStreamMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseStreamMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseStreamMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LeaseStreamMessage_Lease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseStreamMessage_Lease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Lease != nil {
		{
			size, err := m.Lease.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutorapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LeaseStreamMessage_CancelRuns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseStreamMessage_CancelRuns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelRuns != nil {
		{
			size, err := m.CancelRuns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutorapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LeaseStreamMessage_End) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseStreamMessage_End) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutorapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *LeaseStreamMessage_PreemptRuns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseStreamMessage_PreemptRuns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PreemptRuns != nil {
		{
			size, err := m.PreemptRuns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintExecutorapi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func encodeVarintExecutorapi(dAtA []byte, offset int, v uint64) int {
	offset -= sovExecutorapi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	if len(m.Taints) > 0 {
		for _, e := range m.Taints {
			l = e.Size()
			n += 1 + l + sovExecutorapi(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovExecutorapi(uint64(len(k))) + 1 + len(v) + sovExecutorapi(uint64(len(v)))
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	if len(m.AllocatableResources) > 0 {
		for k, v := range m.AllocatableResources {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovExecutorapi(uint64(len(k))) + 1 + l + sovExecutorapi(uint64(l))
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	if len(m.AvailableResources) > 0 {
		for k, v := range m.AvailableResources {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovExecutorapi(uint64(len(k))) + 1 + l + sovExecutorapi(uint64(l))
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	if len(m.TotalResources) > 0 {
		for k, v := range m.TotalResources {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovExecutorapi(uint64(len(k))) + 1 + l + sovExecutorapi(uint64(l))
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	if len(m.AllocatedResources) > 0 {
		for k, v := range m.AllocatedResources {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovExecutorapi(uint64(k)) + 1 + l + sovExecutorapi(uint64(l))
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	if len(m.RunIdsByState) > 0 {
		for k, v := range m.RunIdsByState {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovExecutorapi(uint64(len(k))) + 1 + sovExecutorapi(uint64(v))
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	if len(m.NonArmadaAllocatedResources) > 0 {
		for k, v := range m.NonArmadaAllocatedResources {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovExecutorapi(uint64(k)) + 1 + l + sovExecutorapi(uint64(l))
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	if m.Unschedulable {
		n += 2
	}
	if len(m.ResourceUsageByQueue) > 0 {
		for k, v := range m.ResourceUsageByQueue {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovExecutorapi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovExecutorapi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	l = len(m.NodeType)
	if l > 0 {
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	return n
}

func (m *ComputeResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for k, v := range m.Resources {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovExecutorapi(uint64(len(k))) + 1 + l + sovExecutorapi(uint64(l))
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EventList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovExecutorapi(uint64(l))
		}
	}
	return n
}

func (m *LeaseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExecutorId)
	if l > 0 {
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	l = len(m.Pool)
	if l > 0 {
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	if len(m.Resources) > 0 {
		for k, v := range m.Resources {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovExecutorapi(uint64(len(k))) + 1 + l + sovExecutorapi(uint64(l))
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	if len(m.MinimumJobSize) > 0 {
		for k, v := range m.MinimumJobSize {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovExecutorapi(uint64(len(k))) + 1 + l + sovExecutorapi(uint64(l))
			n += mapEntrySize + 1 + sovExecutorapi(uint64(mapEntrySize))
		}
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovExecutorapi(uint64(l))
		}
	}
	if len(m.UnassignedJobRunIds) > 0 {
		for _, e := range m.UnassignedJobRunIds {
			l = e.Size()
			n += 1 + l + sovExecutorapi(uint64(l))
		}
	}
	if m.MaxJobsToLease != 0 {
		n += 1 + sovExecutorapi(uint64(m.MaxJobsToLease))
	}
	return n
}

func (m *JobRunLease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunId != nil {
		l = m.JobRunId.Size()
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	l = len(m.Jobset)
	if l > 0 {
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			l = len(s)
			n += 1 + l + sovExecutorapi(uint64(l))
		}
	}
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	return n
}

func (m *CancelRuns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobRunIdsToCancel) > 0 {
		for _, e := range m.JobRunIdsToCancel {
			l = e.Size()
			n += 1 + l + sovExecutorapi(uint64(l))
		}
	}
	return n
}

func (m *PreemptRuns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobRunIdsToPreempt) > 0 {
		for _, e := range m.JobRunIdsToPreempt {
			l = e.Size()
			n += 1 + l + sovExecutorapi(uint64(l))
		}
	}
	return n
}

func (m *EndMarker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *LeaseStreamMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *LeaseStreamMessage_Lease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lease != nil {
		l = m.Lease.Size()
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	return n
}
func (m *LeaseStreamMessage_CancelRuns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelRuns != nil {
		l = m.CancelRuns.Size()
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	return n
}
func (m *LeaseStreamMessage_End) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	return n
}
func (m *LeaseStreamMessage_PreemptRuns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreemptRuns != nil {
		l = m.PreemptRuns.Size()
		n += 1 + l + sovExecutorapi(uint64(l))
	}
	return n
}

func sovExecutorapi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozExecutorapi(x uint64) (n int) {
	return sovExecutorapi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NodeInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTaints := "[]Taint{"
	for _, f := range this.Taints {
		repeatedStringForTaints += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForTaints += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAllocatableResources := make([]string, 0, len(this.AllocatableResources))
	for k, _ := range this.AllocatableResources {
		keysForAllocatableResources = append(keysForAllocatableResources, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAllocatableResources)
	mapStringForAllocatableResources := "map[string]resource.Quantity{"
	for _, k := range keysForAllocatableResources {
		mapStringForAllocatableResources += fmt.Sprintf("%v: %v,", k, this.AllocatableResources[k])
	}
	mapStringForAllocatableResources += "}"
	keysForAvailableResources := make([]string, 0, len(this.AvailableResources))
	for k, _ := range this.AvailableResources {
		keysForAvailableResources = append(keysForAvailableResources, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAvailableResources)
	mapStringForAvailableResources := "map[string]resource.Quantity{"
	for _, k := range keysForAvailableResources {
		mapStringForAvailableResources += fmt.Sprintf("%v: %v,", k, this.AvailableResources[k])
	}
	mapStringForAvailableResources += "}"
	keysForTotalResources := make([]string, 0, len(this.TotalResources))
	for k, _ := range this.TotalResources {
		keysForTotalResources = append(keysForTotalResources, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTotalResources)
	mapStringForTotalResources := "map[string]resource.Quantity{"
	for _, k := range keysForTotalResources {
		mapStringForTotalResources += fmt.Sprintf("%v: %v,", k, this.TotalResources[k])
	}
	mapStringForTotalResources += "}"
	keysForAllocatedResources := make([]int32, 0, len(this.AllocatedResources))
	for k, _ := range this.AllocatedResources {
		keysForAllocatedResources = append(keysForAllocatedResources, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForAllocatedResources)
	mapStringForAllocatedResources := "map[int32]ComputeResource{"
	for _, k := range keysForAllocatedResources {
		mapStringForAllocatedResources += fmt.Sprintf("%v: %v,", k, this.AllocatedResources[k])
	}
	mapStringForAllocatedResources += "}"
	keysForRunIdsByState := make([]string, 0, len(this.RunIdsByState))
	for k, _ := range this.RunIdsByState {
		keysForRunIdsByState = append(keysForRunIdsByState, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRunIdsByState)
	mapStringForRunIdsByState := "map[string]api.JobState{"
	for _, k := range keysForRunIdsByState {
		mapStringForRunIdsByState += fmt.Sprintf("%v: %v,", k, this.RunIdsByState[k])
	}
	mapStringForRunIdsByState += "}"
	keysForNonArmadaAllocatedResources := make([]int32, 0, len(this.NonArmadaAllocatedResources))
	for k, _ := range this.NonArmadaAllocatedResources {
		keysForNonArmadaAllocatedResources = append(keysForNonArmadaAllocatedResources, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForNonArmadaAllocatedResources)
	mapStringForNonArmadaAllocatedResources := "map[int32]ComputeResource{"
	for _, k := range keysForNonArmadaAllocatedResources {
		mapStringForNonArmadaAllocatedResources += fmt.Sprintf("%v: %v,", k, this.NonArmadaAllocatedResources[k])
	}
	mapStringForNonArmadaAllocatedResources += "}"
	keysForResourceUsageByQueue := make([]string, 0, len(this.ResourceUsageByQueue))
	for k, _ := range this.ResourceUsageByQueue {
		keysForResourceUsageByQueue = append(keysForResourceUsageByQueue, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForResourceUsageByQueue)
	mapStringForResourceUsageByQueue := "map[string]*ComputeResource{"
	for _, k := range keysForResourceUsageByQueue {
		mapStringForResourceUsageByQueue += fmt.Sprintf("%v: %v,", k, this.ResourceUsageByQueue[k])
	}
	mapStringForResourceUsageByQueue += "}"
	s := strings.Join([]string{`&NodeInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Taints:` + repeatedStringForTaints + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`AllocatableResources:` + mapStringForAllocatableResources + `,`,
		`AvailableResources:` + mapStringForAvailableResources + `,`,
		`TotalResources:` + mapStringForTotalResources + `,`,
		`AllocatedResources:` + mapStringForAllocatedResources + `,`,
		`RunIdsByState:` + mapStringForRunIdsByState + `,`,
		`NonArmadaAllocatedResources:` + mapStringForNonArmadaAllocatedResources + `,`,
		`Unschedulable:` + fmt.Sprintf("%v", this.Unschedulable) + `,`,
		`ResourceUsageByQueue:` + mapStringForResourceUsageByQueue + `,`,
		`NodeType:` + fmt.Sprintf("%v", this.NodeType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ComputeResource) String() string {
	if this == nil {
		return "nil"
	}
	keysForResources := make([]string, 0, len(this.Resources))
	for k, _ := range this.Resources {
		keysForResources = append(keysForResources, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForResources)
	mapStringForResources := "map[string]resource.Quantity{"
	for _, k := range keysForResources {
		mapStringForResources += fmt.Sprintf("%v: %v,", k, this.Resources[k])
	}
	mapStringForResources += "}"
	s := strings.Join([]string{`&ComputeResource{`,
		`Resources:` + mapStringForResources + `,`,
		`}`,
	}, "")
	return s
}
func (this *EventList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEvents := "[]*EventSequence{"
	for _, f := range this.Events {
		repeatedStringForEvents += strings.Replace(fmt.Sprintf("%v", f), "EventSequence", "armadaevents.EventSequence", 1) + ","
	}
	repeatedStringForEvents += "}"
	s := strings.Join([]string{`&EventList{`,
		`Events:` + repeatedStringForEvents + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeaseRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNodes := "[]*NodeInfo{"
	for _, f := range this.Nodes {
		repeatedStringForNodes += strings.Replace(f.String(), "NodeInfo", "NodeInfo", 1) + ","
	}
	repeatedStringForNodes += "}"
	repeatedStringForUnassignedJobRunIds := "[]Uuid{"
	for _, f := range this.UnassignedJobRunIds {
		repeatedStringForUnassignedJobRunIds += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForUnassignedJobRunIds += "}"
	keysForResources := make([]string, 0, len(this.Resources))
	for k, _ := range this.Resources {
		keysForResources = append(keysForResources, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForResources)
	mapStringForResources := "map[string]resource.Quantity{"
	for _, k := range keysForResources {
		mapStringForResources += fmt.Sprintf("%v: %v,", k, this.Resources[k])
	}
	mapStringForResources += "}"
	keysForMinimumJobSize := make([]string, 0, len(this.MinimumJobSize))
	for k, _ := range this.MinimumJobSize {
		keysForMinimumJobSize = append(keysForMinimumJobSize, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMinimumJobSize)
	mapStringForMinimumJobSize := "map[string]resource.Quantity{"
	for _, k := range keysForMinimumJobSize {
		mapStringForMinimumJobSize += fmt.Sprintf("%v: %v,", k, this.MinimumJobSize[k])
	}
	mapStringForMinimumJobSize += "}"
	s := strings.Join([]string{`&LeaseRequest{`,
		`ExecutorId:` + fmt.Sprintf("%v", this.ExecutorId) + `,`,
		`Pool:` + fmt.Sprintf("%v", this.Pool) + `,`,
		`Resources:` + mapStringForResources + `,`,
		`MinimumJobSize:` + mapStringForMinimumJobSize + `,`,
		`Nodes:` + repeatedStringForNodes + `,`,
		`UnassignedJobRunIds:` + repeatedStringForUnassignedJobRunIds + `,`,
		`MaxJobsToLease:` + fmt.Sprintf("%v", this.MaxJobsToLease) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobRunLease) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JobRunLease{`,
		`JobRunId:` + strings.Replace(fmt.Sprintf("%v", this.JobRunId), "Uuid", "armadaevents.Uuid", 1) + `,`,
		`Queue:` + fmt.Sprintf("%v", this.Queue) + `,`,
		`Jobset:` + fmt.Sprintf("%v", this.Jobset) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`Groups:` + fmt.Sprintf("%v", this.Groups) + `,`,
		`Job:` + strings.Replace(fmt.Sprintf("%v", this.Job), "SubmitJob", "armadaevents.SubmitJob", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CancelRuns) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForJobRunIdsToCancel := "[]*Uuid{"
	for _, f := range this.JobRunIdsToCancel {
		repeatedStringForJobRunIdsToCancel += strings.Replace(fmt.Sprintf("%v", f), "Uuid", "armadaevents.Uuid", 1) + ","
	}
	repeatedStringForJobRunIdsToCancel += "}"
	s := strings.Join([]string{`&CancelRuns{`,
		`JobRunIdsToCancel:` + repeatedStringForJobRunIdsToCancel + `,`,
		`}`,
	}, "")
	return s
}
func (this *PreemptRuns) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForJobRunIdsToPreempt := "[]*Uuid{"
	for _, f := range this.JobRunIdsToPreempt {
		repeatedStringForJobRunIdsToPreempt += strings.Replace(fmt.Sprintf("%v", f), "Uuid", "armadaevents.Uuid", 1) + ","
	}
	repeatedStringForJobRunIdsToPreempt += "}"
	s := strings.Join([]string{`&PreemptRuns{`,
		`JobRunIdsToPreempt:` + repeatedStringForJobRunIdsToPreempt + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndMarker) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndMarker{`,
		`}`,
	}, "")
	return s
}
func (this *LeaseStreamMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeaseStreamMessage{`,
		`Event:` + fmt.Sprintf("%v", this.Event) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeaseStreamMessage_Lease) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeaseStreamMessage_Lease{`,
		`Lease:` + strings.Replace(fmt.Sprintf("%v", this.Lease), "JobRunLease", "JobRunLease", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeaseStreamMessage_CancelRuns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeaseStreamMessage_CancelRuns{`,
		`CancelRuns:` + strings.Replace(fmt.Sprintf("%v", this.CancelRuns), "CancelRuns", "CancelRuns", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeaseStreamMessage_End) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeaseStreamMessage_End{`,
		`End:` + strings.Replace(fmt.Sprintf("%v", this.End), "EndMarker", "EndMarker", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LeaseStreamMessage_PreemptRuns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LeaseStreamMessage_PreemptRuns{`,
		`PreemptRuns:` + strings.Replace(fmt.Sprintf("%v", this.PreemptRuns), "PreemptRuns", "PreemptRuns", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringExecutorapi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutorapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Taints = append(m.Taints, v1.Taint{})
			if err := m.Taints[len(m.Taints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatableResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllocatableResources == nil {
				m.AllocatableResources = make(map[string]resource.Quantity)
			}
			var mapkey string
			mapvalue := &resource.Quantity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AllocatableResources[mapkey] = *mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AvailableResources == nil {
				m.AvailableResources = make(map[string]resource.Quantity)
			}
			var mapkey string
			mapvalue := &resource.Quantity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AvailableResources[mapkey] = *mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalResources == nil {
				m.TotalResources = make(map[string]resource.Quantity)
			}
			var mapkey string
			mapvalue := &resource.Quantity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TotalResources[mapkey] = *mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AllocatedResources == nil {
				m.AllocatedResources = make(map[int32]ComputeResource)
			}
			var mapkey int32
			mapvalue := &ComputeResource{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ComputeResource{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AllocatedResources[mapkey] = *mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunIdsByState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunIdsByState == nil {
				m.RunIdsByState = make(map[string]api.JobState)
			}
			var mapkey string
			var mapvalue api.JobState
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= api.JobState(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RunIdsByState[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonArmadaAllocatedResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NonArmadaAllocatedResources == nil {
				m.NonArmadaAllocatedResources = make(map[int32]ComputeResource)
			}
			var mapkey int32
			mapvalue := &ComputeResource{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ComputeResource{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NonArmadaAllocatedResources[mapkey] = *mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unschedulable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unschedulable = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUsageByQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceUsageByQueue == nil {
				m.ResourceUsageByQueue = make(map[string]*ComputeResource)
			}
			var mapkey string
			var mapvalue *ComputeResource
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ComputeResource{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResourceUsageByQueue[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutorapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComputeResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutorapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComputeResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComputeResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = make(map[string]resource.Quantity)
			}
			var mapkey string
			mapvalue := &resource.Quantity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Resources[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutorapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutorapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &armadaevents.EventSequence{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutorapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutorapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = make(map[string]resource.Quantity)
			}
			var mapkey string
			mapvalue := &resource.Quantity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Resources[mapkey] = *mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumJobSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinimumJobSize == nil {
				m.MinimumJobSize = make(map[string]resource.Quantity)
			}
			var mapkey string
			mapvalue := &resource.Quantity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowExecutorapi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowExecutorapi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthExecutorapi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipExecutorapi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthExecutorapi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MinimumJobSize[mapkey] = *mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &NodeInfo{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnassignedJobRunIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnassignedJobRunIds = append(m.UnassignedJobRunIds, armadaevents.Uuid{})
			if err := m.UnassignedJobRunIds[len(m.UnassignedJobRunIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxJobsToLease", wireType)
			}
			m.MaxJobsToLease = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxJobsToLease |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipExecutorapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunLease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutorapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunLease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunLease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobRunId == nil {
				m.JobRunId = &armadaevents.Uuid{}
			}
			if err := m.JobRunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &armadaevents.SubmitJob{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutorapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelRuns) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutorapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelRuns: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelRuns: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunIdsToCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobRunIdsToCancel = append(m.JobRunIdsToCancel, &armadaevents.Uuid{})
			if err := m.JobRunIdsToCancel[len(m.JobRunIdsToCancel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutorapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreemptRuns) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutorapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreemptRuns: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreemptRuns: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunIdsToPreempt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobRunIdsToPreempt = append(m.JobRunIdsToPreempt, &armadaevents.Uuid{})
			if err := m.JobRunIdsToPreempt[len(m.JobRunIdsToPreempt)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutorapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndMarker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutorapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndMarker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndMarker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipExecutorapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseStreamMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowExecutorapi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseStreamMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseStreamMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lease", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunLease{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &LeaseStreamMessage_Lease{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelRuns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CancelRuns{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &LeaseStreamMessage_CancelRuns{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndMarker{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &LeaseStreamMessage_End{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreemptRuns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthExecutorapi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PreemptRuns{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &LeaseStreamMessage_PreemptRuns{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipExecutorapi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthExecutorapi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipExecutorapi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowExecutorapi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowExecutorapi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthExecutorapi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupExecutorapi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthExecutorapi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthExecutorapi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowExecutorapi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupExecutorapi = fmt.Errorf("proto: unexpected end of group")
)
