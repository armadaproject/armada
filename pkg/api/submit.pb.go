// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/api/submit.proto

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	v1 "k8s.io/api/core/v1"
	v11 "k8s.io/api/networking/v1"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Ingress type is being kept here to maintain backwards compatibility for a while.
type IngressType int32

const (
	IngressType_Ingress IngressType = 0
)

var IngressType_name = map[int32]string{
	0: "Ingress",
}

var IngressType_value = map[string]int32{
	"Ingress": 0,
}

func (x IngressType) String() string {
	return proto.EnumName(IngressType_name, int32(x))
}

func (IngressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{0}
}

type ServiceType int32

const (
	ServiceType_NodePort ServiceType = 0
	ServiceType_Headless ServiceType = 1
)

var ServiceType_name = map[int32]string{
	0: "NodePort",
	1: "Headless",
}

var ServiceType_value = map[string]int32{
	"NodePort": 0,
	"Headless": 1,
}

func (x ServiceType) String() string {
	return proto.EnumName(ServiceType_name, int32(x))
}

func (ServiceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{1}
}

// swagger:model
type JobState int32

const (
	JobState_QUEUED    JobState = 0
	JobState_PENDING   JobState = 1
	JobState_RUNNING   JobState = 2
	JobState_SUCCEEDED JobState = 3
	JobState_FAILED    JobState = 4
	JobState_UNKNOWN   JobState = 5
)

var JobState_name = map[int32]string{
	0: "QUEUED",
	1: "PENDING",
	2: "RUNNING",
	3: "SUCCEEDED",
	4: "FAILED",
	5: "UNKNOWN",
}

var JobState_value = map[string]int32{
	"QUEUED":    0,
	"PENDING":   1,
	"RUNNING":   2,
	"SUCCEEDED": 3,
	"FAILED":    4,
	"UNKNOWN":   5,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}

func (JobState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{2}
}

type JobSubmitRequestItem struct {
	Priority           float64           `protobuf:"fixed64,1,opt,name=priority,proto3" json:"priority,omitempty"`
	Namespace          string            `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
	ClientId           string            `protobuf:"bytes,8,opt,name=client_id,json=clientId,proto3" json:"clientId,omitempty"`
	Labels             map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Annotations        map[string]string `protobuf:"bytes,5,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RequiredNodeLabels map[string]string `protobuf:"bytes,6,rep,name=required_node_labels,json=requiredNodeLabels,proto3" json:"requiredNodeLabels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"` // Deprecated: Do not use.
	PodSpec            *v1.PodSpec       `protobuf:"bytes,2,opt,name=pod_spec,json=podSpec,proto3" json:"podSpec,omitempty"`                                                                                                                           // Deprecated: Do not use.
	PodSpecs           []*v1.PodSpec     `protobuf:"bytes,7,rep,name=pod_specs,json=podSpecs,proto3" json:"podSpecs,omitempty"`
	Ingress            []*IngressConfig  `protobuf:"bytes,9,rep,name=ingress,proto3" json:"ingress,omitempty"`
	Services           []*ServiceConfig  `protobuf:"bytes,10,rep,name=services,proto3" json:"services,omitempty"`
	// Indicates which scheduler should manage this job.
	// If empty, the default scheduler is used.
	Scheduler string `protobuf:"bytes,11,opt,name=scheduler,proto3" json:"scheduler,omitempty"`
	// Queuing TTL for this job in seconds. If this job queues for more than this duration it will be cancelled. Zero indicates an infinite lifetime.
	QueueTtlSeconds int64 `protobuf:"varint,12,opt,name=queue_ttl_seconds,json=queueTtlSeconds,proto3" json:"queueTtlSeconds,omitempty"`
}

func (m *JobSubmitRequestItem) Reset()      { *m = JobSubmitRequestItem{} }
func (*JobSubmitRequestItem) ProtoMessage() {}
func (*JobSubmitRequestItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{0}
}
func (m *JobSubmitRequestItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSubmitRequestItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSubmitRequestItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSubmitRequestItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSubmitRequestItem.Merge(m, src)
}
func (m *JobSubmitRequestItem) XXX_Size() int {
	return m.Size()
}
func (m *JobSubmitRequestItem) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSubmitRequestItem.DiscardUnknown(m)
}

var xxx_messageInfo_JobSubmitRequestItem proto.InternalMessageInfo

func (m *JobSubmitRequestItem) GetPriority() float64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *JobSubmitRequestItem) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *JobSubmitRequestItem) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *JobSubmitRequestItem) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *JobSubmitRequestItem) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// Deprecated: Do not use.
func (m *JobSubmitRequestItem) GetRequiredNodeLabels() map[string]string {
	if m != nil {
		return m.RequiredNodeLabels
	}
	return nil
}

// Deprecated: Do not use.
func (m *JobSubmitRequestItem) GetPodSpec() *v1.PodSpec {
	if m != nil {
		return m.PodSpec
	}
	return nil
}

func (m *JobSubmitRequestItem) GetPodSpecs() []*v1.PodSpec {
	if m != nil {
		return m.PodSpecs
	}
	return nil
}

func (m *JobSubmitRequestItem) GetIngress() []*IngressConfig {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *JobSubmitRequestItem) GetServices() []*ServiceConfig {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *JobSubmitRequestItem) GetScheduler() string {
	if m != nil {
		return m.Scheduler
	}
	return ""
}

func (m *JobSubmitRequestItem) GetQueueTtlSeconds() int64 {
	if m != nil {
		return m.QueueTtlSeconds
	}
	return 0
}

type IngressConfig struct {
	Type         IngressType       `protobuf:"varint,1,opt,name=type,proto3,enum=api.IngressType" json:"type,omitempty"` // Deprecated: Do not use.
	Ports        []uint32          `protobuf:"varint,2,rep,packed,name=ports,proto3" json:"ports,omitempty"`
	Annotations  map[string]string `protobuf:"bytes,3,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TlsEnabled   bool              `protobuf:"varint,4,opt,name=tls_enabled,json=tlsEnabled,proto3" json:"tlsEnabled,omitempty"`
	CertName     string            `protobuf:"bytes,5,opt,name=cert_name,json=certName,proto3" json:"certName,omitempty"`
	UseClusterIP bool              `protobuf:"varint,6,opt,name=use_clusterIP,json=useClusterIP,proto3" json:"useClusterIP,omitempty"`
}

func (m *IngressConfig) Reset()      { *m = IngressConfig{} }
func (*IngressConfig) ProtoMessage() {}
func (*IngressConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{1}
}
func (m *IngressConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressConfig.Merge(m, src)
}
func (m *IngressConfig) XXX_Size() int {
	return m.Size()
}
func (m *IngressConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IngressConfig proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *IngressConfig) GetType() IngressType {
	if m != nil {
		return m.Type
	}
	return IngressType_Ingress
}

func (m *IngressConfig) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *IngressConfig) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *IngressConfig) GetTlsEnabled() bool {
	if m != nil {
		return m.TlsEnabled
	}
	return false
}

func (m *IngressConfig) GetCertName() string {
	if m != nil {
		return m.CertName
	}
	return ""
}

func (m *IngressConfig) GetUseClusterIP() bool {
	if m != nil {
		return m.UseClusterIP
	}
	return false
}

type ServiceConfig struct {
	Type  ServiceType `protobuf:"varint,1,opt,name=type,proto3,enum=api.ServiceType" json:"type,omitempty"`
	Ports []uint32    `protobuf:"varint,2,rep,packed,name=ports,proto3" json:"ports,omitempty"`
}

func (m *ServiceConfig) Reset()      { *m = ServiceConfig{} }
func (*ServiceConfig) ProtoMessage() {}
func (*ServiceConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{2}
}
func (m *ServiceConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceConfig.Merge(m, src)
}
func (m *ServiceConfig) XXX_Size() int {
	return m.Size()
}
func (m *ServiceConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceConfig proto.InternalMessageInfo

func (m *ServiceConfig) GetType() ServiceType {
	if m != nil {
		return m.Type
	}
	return ServiceType_NodePort
}

func (m *ServiceConfig) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

// swagger:model
type JobSubmitRequest struct {
	Queue           string                  `protobuf:"bytes,1,opt,name=queue,proto3" json:"queue,omitempty"`
	JobSetId        string                  `protobuf:"bytes,2,opt,name=job_set_id,json=jobSetId,proto3" json:"jobSetId,omitempty"`
	JobRequestItems []*JobSubmitRequestItem `protobuf:"bytes,3,rep,name=job_request_items,json=jobRequestItems,proto3" json:"jobRequestItems,omitempty"`
}

func (m *JobSubmitRequest) Reset()      { *m = JobSubmitRequest{} }
func (*JobSubmitRequest) ProtoMessage() {}
func (*JobSubmitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{3}
}
func (m *JobSubmitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSubmitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSubmitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSubmitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSubmitRequest.Merge(m, src)
}
func (m *JobSubmitRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobSubmitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSubmitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobSubmitRequest proto.InternalMessageInfo

func (m *JobSubmitRequest) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *JobSubmitRequest) GetJobSetId() string {
	if m != nil {
		return m.JobSetId
	}
	return ""
}

func (m *JobSubmitRequest) GetJobRequestItems() []*JobSubmitRequestItem {
	if m != nil {
		return m.JobRequestItems
	}
	return nil
}

// swagger:model
type JobCancelRequest struct {
	JobId    string   `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	JobSetId string   `protobuf:"bytes,2,opt,name=job_set_id,json=jobSetId,proto3" json:"jobSetId,omitempty"`
	Queue    string   `protobuf:"bytes,3,opt,name=queue,proto3" json:"queue,omitempty"`
	JobIds   []string `protobuf:"bytes,4,rep,name=job_ids,json=jobIds,proto3" json:"jobIds,omitempty"`
	Reason   string   `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *JobCancelRequest) Reset()      { *m = JobCancelRequest{} }
func (*JobCancelRequest) ProtoMessage() {}
func (*JobCancelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{4}
}
func (m *JobCancelRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobCancelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobCancelRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobCancelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobCancelRequest.Merge(m, src)
}
func (m *JobCancelRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobCancelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobCancelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobCancelRequest proto.InternalMessageInfo

func (m *JobCancelRequest) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobCancelRequest) GetJobSetId() string {
	if m != nil {
		return m.JobSetId
	}
	return ""
}

func (m *JobCancelRequest) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *JobCancelRequest) GetJobIds() []string {
	if m != nil {
		return m.JobIds
	}
	return nil
}

func (m *JobCancelRequest) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// swagger:model
type JobSetCancelRequest struct {
	JobSetId string        `protobuf:"bytes,1,opt,name=job_set_id,json=jobSetId,proto3" json:"jobSetId,omitempty"`
	Queue    string        `protobuf:"bytes,2,opt,name=queue,proto3" json:"queue,omitempty"`
	Filter   *JobSetFilter `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
	Reason   string        `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *JobSetCancelRequest) Reset()      { *m = JobSetCancelRequest{} }
func (*JobSetCancelRequest) ProtoMessage() {}
func (*JobSetCancelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{5}
}
func (m *JobSetCancelRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSetCancelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSetCancelRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSetCancelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSetCancelRequest.Merge(m, src)
}
func (m *JobSetCancelRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobSetCancelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSetCancelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobSetCancelRequest proto.InternalMessageInfo

func (m *JobSetCancelRequest) GetJobSetId() string {
	if m != nil {
		return m.JobSetId
	}
	return ""
}

func (m *JobSetCancelRequest) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *JobSetCancelRequest) GetFilter() *JobSetFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *JobSetCancelRequest) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// swagger:model
type JobSetFilter struct {
	States []JobState `protobuf:"varint,1,rep,packed,name=states,proto3,enum=api.JobState" json:"states,omitempty"`
}

func (m *JobSetFilter) Reset()      { *m = JobSetFilter{} }
func (*JobSetFilter) ProtoMessage() {}
func (*JobSetFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{6}
}
func (m *JobSetFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSetFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSetFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSetFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSetFilter.Merge(m, src)
}
func (m *JobSetFilter) XXX_Size() int {
	return m.Size()
}
func (m *JobSetFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSetFilter.DiscardUnknown(m)
}

var xxx_messageInfo_JobSetFilter proto.InternalMessageInfo

func (m *JobSetFilter) GetStates() []JobState {
	if m != nil {
		return m.States
	}
	return nil
}

type Job struct {
	Id                                 string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ClientId                           string            `protobuf:"bytes,13,opt,name=client_id,json=clientId,proto3" json:"clientId,omitempty"`
	JobSetId                           string            `protobuf:"bytes,2,opt,name=job_set_id,json=jobSetId,proto3" json:"jobSetId,omitempty"`
	Queue                              string            `protobuf:"bytes,3,opt,name=queue,proto3" json:"queue,omitempty"`
	Namespace                          string            `protobuf:"bytes,7,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Labels                             map[string]string `protobuf:"bytes,9,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Annotations                        map[string]string `protobuf:"bytes,10,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RequiredNodeLabels                 map[string]string `protobuf:"bytes,11,rep,name=required_node_labels,json=requiredNodeLabels,proto3" json:"requiredNodeLabels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"` // Deprecated: Do not use.
	Owner                              string            `protobuf:"bytes,8,opt,name=owner,proto3" json:"owner,omitempty"`
	QueueOwnershipUserGroups           []string          `protobuf:"bytes,15,rep,name=queue_ownership_user_groups,json=queueOwnershipUserGroups,proto3" json:"queueOwnershipUserGroups,omitempty"`
	CompressedQueueOwnershipUserGroups []byte            `protobuf:"bytes,19,opt,name=compressed_queue_ownership_user_groups,json=compressedQueueOwnershipUserGroups,proto3" json:"compressedQueueOwnershipUserGroups,omitempty"`
	Priority                           float64           `protobuf:"fixed64,4,opt,name=priority,proto3" json:"priority,omitempty"`
	PodSpec                            *v1.PodSpec       `protobuf:"bytes,5,opt,name=pod_spec,json=podSpec,proto3" json:"podSpec,omitempty"` // Deprecated: Do not use.
	PodSpecs                           []*v1.PodSpec     `protobuf:"bytes,12,rep,name=pod_specs,json=podSpecs,proto3" json:"podSpecs,omitempty"`
	// Resource requests and limits necessary for scheduling the main pod of this job.
	// The requests and limits herein are set to:
	//
	// max(
	//
	//	sum across all containers,
	//	max over all init containers,
	//
	// )
	//
	// This is because containers run in parallel, whereas initContainers run serially.
	// This field is populated automatically at submission.
	// Submitting a job with this field already populated results in an error.
	SchedulingResourceRequirements v1.ResourceRequirements `protobuf:"bytes,21,opt,name=scheduling_resource_requirements,json=schedulingResourceRequirements,proto3" json:"schedulingResourceRequirements"`
	Created                        time.Time               `protobuf:"bytes,6,opt,name=created,proto3,stdtime" json:"created"`
	// Services can be provided either as Armada-specific config objects or as proper k8s objects.
	// These options are exclusive, i.e., if either ingress or services is provided,
	// then neither of k8s_ingress or k8s_service can be provided, and vice versa.
	Ingress    []*IngressConfig `protobuf:"bytes,14,rep,name=ingress,proto3" json:"ingress,omitempty"`
	Services   []*ServiceConfig `protobuf:"bytes,16,rep,name=services,proto3" json:"services,omitempty"`
	K8SIngress []*v11.Ingress   `protobuf:"bytes,17,rep,name=k8s_ingress,json=k8sIngress,proto3" json:"k8sIngress,omitempty"`
	K8SService []*v1.Service    `protobuf:"bytes,18,rep,name=k8s_service,json=k8sService,proto3" json:"k8sService,omitempty"`
	// Indicates which scheduler should manage this job.
	// If empty, the default scheduler is used.
	Scheduler string `protobuf:"bytes,20,opt,name=scheduler,proto3" json:"scheduler,omitempty"`
	// Queuing TTL for this job in seconds. If this job queues for more than this duration it will be cancelled. Zero indicates an infinite lifetime.
	QueueTtlSeconds int64 `protobuf:"varint,22,opt,name=queue_ttl_seconds,json=queueTtlSeconds,proto3" json:"queueTtlSeconds,omitempty"`
}

func (m *Job) Reset()      { *m = Job{} }
func (*Job) ProtoMessage() {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{7}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Job.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Job) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Job) GetJobSetId() string {
	if m != nil {
		return m.JobSetId
	}
	return ""
}

func (m *Job) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *Job) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Job) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Job) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// Deprecated: Do not use.
func (m *Job) GetRequiredNodeLabels() map[string]string {
	if m != nil {
		return m.RequiredNodeLabels
	}
	return nil
}

func (m *Job) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Job) GetQueueOwnershipUserGroups() []string {
	if m != nil {
		return m.QueueOwnershipUserGroups
	}
	return nil
}

func (m *Job) GetCompressedQueueOwnershipUserGroups() []byte {
	if m != nil {
		return m.CompressedQueueOwnershipUserGroups
	}
	return nil
}

func (m *Job) GetPriority() float64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// Deprecated: Do not use.
func (m *Job) GetPodSpec() *v1.PodSpec {
	if m != nil {
		return m.PodSpec
	}
	return nil
}

func (m *Job) GetPodSpecs() []*v1.PodSpec {
	if m != nil {
		return m.PodSpecs
	}
	return nil
}

func (m *Job) GetSchedulingResourceRequirements() v1.ResourceRequirements {
	if m != nil {
		return m.SchedulingResourceRequirements
	}
	return v1.ResourceRequirements{}
}

func (m *Job) GetCreated() time.Time {
	if m != nil {
		return m.Created
	}
	return time.Time{}
}

func (m *Job) GetIngress() []*IngressConfig {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *Job) GetServices() []*ServiceConfig {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *Job) GetK8SIngress() []*v11.Ingress {
	if m != nil {
		return m.K8SIngress
	}
	return nil
}

func (m *Job) GetK8SService() []*v1.Service {
	if m != nil {
		return m.K8SService
	}
	return nil
}

func (m *Job) GetScheduler() string {
	if m != nil {
		return m.Scheduler
	}
	return ""
}

func (m *Job) GetQueueTtlSeconds() int64 {
	if m != nil {
		return m.QueueTtlSeconds
	}
	return 0
}

// swagger:model
type JobReprioritizeRequest struct {
	JobIds      []string `protobuf:"bytes,1,rep,name=job_ids,json=jobIds,proto3" json:"jobIds,omitempty"`
	JobSetId    string   `protobuf:"bytes,2,opt,name=job_set_id,json=jobSetId,proto3" json:"jobSetId,omitempty"`
	Queue       string   `protobuf:"bytes,3,opt,name=queue,proto3" json:"queue,omitempty"`
	NewPriority float64  `protobuf:"fixed64,4,opt,name=new_priority,json=newPriority,proto3" json:"newPriority,omitempty"`
}

func (m *JobReprioritizeRequest) Reset()      { *m = JobReprioritizeRequest{} }
func (*JobReprioritizeRequest) ProtoMessage() {}
func (*JobReprioritizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{8}
}
func (m *JobReprioritizeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobReprioritizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobReprioritizeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobReprioritizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobReprioritizeRequest.Merge(m, src)
}
func (m *JobReprioritizeRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobReprioritizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobReprioritizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobReprioritizeRequest proto.InternalMessageInfo

func (m *JobReprioritizeRequest) GetJobIds() []string {
	if m != nil {
		return m.JobIds
	}
	return nil
}

func (m *JobReprioritizeRequest) GetJobSetId() string {
	if m != nil {
		return m.JobSetId
	}
	return ""
}

func (m *JobReprioritizeRequest) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *JobReprioritizeRequest) GetNewPriority() float64 {
	if m != nil {
		return m.NewPriority
	}
	return 0
}

// swagger:model
type JobReprioritizeResponse struct {
	ReprioritizationResults map[string]string `protobuf:"bytes,1,rep,name=reprioritization_results,json=reprioritizationResults,proto3" json:"reprioritizationResults,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *JobReprioritizeResponse) Reset()      { *m = JobReprioritizeResponse{} }
func (*JobReprioritizeResponse) ProtoMessage() {}
func (*JobReprioritizeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{9}
}
func (m *JobReprioritizeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobReprioritizeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobReprioritizeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobReprioritizeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobReprioritizeResponse.Merge(m, src)
}
func (m *JobReprioritizeResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobReprioritizeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobReprioritizeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobReprioritizeResponse proto.InternalMessageInfo

func (m *JobReprioritizeResponse) GetReprioritizationResults() map[string]string {
	if m != nil {
		return m.ReprioritizationResults
	}
	return nil
}

type JobSubmitResponseItem struct {
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *JobSubmitResponseItem) Reset()      { *m = JobSubmitResponseItem{} }
func (*JobSubmitResponseItem) ProtoMessage() {}
func (*JobSubmitResponseItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{10}
}
func (m *JobSubmitResponseItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSubmitResponseItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSubmitResponseItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSubmitResponseItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSubmitResponseItem.Merge(m, src)
}
func (m *JobSubmitResponseItem) XXX_Size() int {
	return m.Size()
}
func (m *JobSubmitResponseItem) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSubmitResponseItem.DiscardUnknown(m)
}

var xxx_messageInfo_JobSubmitResponseItem proto.InternalMessageInfo

func (m *JobSubmitResponseItem) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobSubmitResponseItem) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// swagger:model
type JobSubmitResponse struct {
	JobResponseItems []*JobSubmitResponseItem `protobuf:"bytes,1,rep,name=job_response_items,json=jobResponseItems,proto3" json:"jobResponseItems,omitempty"`
}

func (m *JobSubmitResponse) Reset()      { *m = JobSubmitResponse{} }
func (*JobSubmitResponse) ProtoMessage() {}
func (*JobSubmitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{11}
}
func (m *JobSubmitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSubmitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSubmitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSubmitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSubmitResponse.Merge(m, src)
}
func (m *JobSubmitResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobSubmitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSubmitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobSubmitResponse proto.InternalMessageInfo

func (m *JobSubmitResponse) GetJobResponseItems() []*JobSubmitResponseItem {
	if m != nil {
		return m.JobResponseItems
	}
	return nil
}

// swagger:model
type Queue struct {
	Name           string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	PriorityFactor float64              `protobuf:"fixed64,2,opt,name=priority_factor,json=priorityFactor,proto3" json:"priorityFactor,omitempty"`
	UserOwners     []string             `protobuf:"bytes,3,rep,name=user_owners,json=userOwners,proto3" json:"userOwners,omitempty"`
	GroupOwners    []string             `protobuf:"bytes,4,rep,name=group_owners,json=groupOwners,proto3" json:"groupOwners,omitempty"`
	ResourceLimits map[string]float64   `protobuf:"bytes,5,rep,name=resource_limits,json=resourceLimits,proto3" json:"resourceLimits,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	Permissions    []*Queue_Permissions `protobuf:"bytes,6,rep,name=permissions,proto3" json:"permissions,omitempty"`
}

func (m *Queue) Reset()      { *m = Queue{} }
func (*Queue) ProtoMessage() {}
func (*Queue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{12}
}
func (m *Queue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Queue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Queue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Queue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Queue.Merge(m, src)
}
func (m *Queue) XXX_Size() int {
	return m.Size()
}
func (m *Queue) XXX_DiscardUnknown() {
	xxx_messageInfo_Queue.DiscardUnknown(m)
}

var xxx_messageInfo_Queue proto.InternalMessageInfo

func (m *Queue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Queue) GetPriorityFactor() float64 {
	if m != nil {
		return m.PriorityFactor
	}
	return 0
}

func (m *Queue) GetUserOwners() []string {
	if m != nil {
		return m.UserOwners
	}
	return nil
}

func (m *Queue) GetGroupOwners() []string {
	if m != nil {
		return m.GroupOwners
	}
	return nil
}

func (m *Queue) GetResourceLimits() map[string]float64 {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *Queue) GetPermissions() []*Queue_Permissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type Queue_Permissions struct {
	Subjects []*Queue_Permissions_Subject `protobuf:"bytes,1,rep,name=subjects,proto3" json:"subjects,omitempty"`
	Verbs    []string                     `protobuf:"bytes,2,rep,name=verbs,proto3" json:"verbs,omitempty"`
}

func (m *Queue_Permissions) Reset()      { *m = Queue_Permissions{} }
func (*Queue_Permissions) ProtoMessage() {}
func (*Queue_Permissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{12, 0}
}
func (m *Queue_Permissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Queue_Permissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Queue_Permissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Queue_Permissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Queue_Permissions.Merge(m, src)
}
func (m *Queue_Permissions) XXX_Size() int {
	return m.Size()
}
func (m *Queue_Permissions) XXX_DiscardUnknown() {
	xxx_messageInfo_Queue_Permissions.DiscardUnknown(m)
}

var xxx_messageInfo_Queue_Permissions proto.InternalMessageInfo

func (m *Queue_Permissions) GetSubjects() []*Queue_Permissions_Subject {
	if m != nil {
		return m.Subjects
	}
	return nil
}

func (m *Queue_Permissions) GetVerbs() []string {
	if m != nil {
		return m.Verbs
	}
	return nil
}

type Queue_Permissions_Subject struct {
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Queue_Permissions_Subject) Reset()      { *m = Queue_Permissions_Subject{} }
func (*Queue_Permissions_Subject) ProtoMessage() {}
func (*Queue_Permissions_Subject) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{12, 0, 0}
}
func (m *Queue_Permissions_Subject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Queue_Permissions_Subject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Queue_Permissions_Subject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Queue_Permissions_Subject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Queue_Permissions_Subject.Merge(m, src)
}
func (m *Queue_Permissions_Subject) XXX_Size() int {
	return m.Size()
}
func (m *Queue_Permissions_Subject) XXX_DiscardUnknown() {
	xxx_messageInfo_Queue_Permissions_Subject.DiscardUnknown(m)
}

var xxx_messageInfo_Queue_Permissions_Subject proto.InternalMessageInfo

func (m *Queue_Permissions_Subject) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *Queue_Permissions_Subject) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// swagger:model
type QueueList struct {
	Queues []*Queue `protobuf:"bytes,1,rep,name=queues,proto3" json:"queues,omitempty"`
}

func (m *QueueList) Reset()      { *m = QueueList{} }
func (*QueueList) ProtoMessage() {}
func (*QueueList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{13}
}
func (m *QueueList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueList.Merge(m, src)
}
func (m *QueueList) XXX_Size() int {
	return m.Size()
}
func (m *QueueList) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueList.DiscardUnknown(m)
}

var xxx_messageInfo_QueueList proto.InternalMessageInfo

func (m *QueueList) GetQueues() []*Queue {
	if m != nil {
		return m.Queues
	}
	return nil
}

// swagger:model
type CancellationResult struct {
	CancelledIds []string `protobuf:"bytes,1,rep,name=cancelled_ids,json=cancelledIds,proto3" json:"cancelledIds,omitempty"`
}

func (m *CancellationResult) Reset()      { *m = CancellationResult{} }
func (*CancellationResult) ProtoMessage() {}
func (*CancellationResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{14}
}
func (m *CancellationResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancellationResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancellationResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancellationResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancellationResult.Merge(m, src)
}
func (m *CancellationResult) XXX_Size() int {
	return m.Size()
}
func (m *CancellationResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CancellationResult.DiscardUnknown(m)
}

var xxx_messageInfo_CancellationResult proto.InternalMessageInfo

func (m *CancellationResult) GetCancelledIds() []string {
	if m != nil {
		return m.CancelledIds
	}
	return nil
}

//swagger:model
type QueueGetRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *QueueGetRequest) Reset()      { *m = QueueGetRequest{} }
func (*QueueGetRequest) ProtoMessage() {}
func (*QueueGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{15}
}
func (m *QueueGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueGetRequest.Merge(m, src)
}
func (m *QueueGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueueGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueueGetRequest proto.InternalMessageInfo

func (m *QueueGetRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

//swagger:model
type StreamingQueueGetRequest struct {
	Num uint32 `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
}

func (m *StreamingQueueGetRequest) Reset()      { *m = StreamingQueueGetRequest{} }
func (*StreamingQueueGetRequest) ProtoMessage() {}
func (*StreamingQueueGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{16}
}
func (m *StreamingQueueGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamingQueueGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamingQueueGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamingQueueGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamingQueueGetRequest.Merge(m, src)
}
func (m *StreamingQueueGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamingQueueGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamingQueueGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamingQueueGetRequest proto.InternalMessageInfo

func (m *StreamingQueueGetRequest) GetNum() uint32 {
	if m != nil {
		return m.Num
	}
	return 0
}

//swagger:model
type QueueDeleteRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *QueueDeleteRequest) Reset()      { *m = QueueDeleteRequest{} }
func (*QueueDeleteRequest) ProtoMessage() {}
func (*QueueDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{17}
}
func (m *QueueDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueDeleteRequest.Merge(m, src)
}
func (m *QueueDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueueDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueueDeleteRequest proto.InternalMessageInfo

func (m *QueueDeleteRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type JobSetInfo struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	QueuedJobs int32  `protobuf:"varint,2,opt,name=queued_jobs,json=queuedJobs,proto3" json:"queuedJobs,omitempty"`
	LeasedJobs int32  `protobuf:"varint,3,opt,name=leased_jobs,json=leasedJobs,proto3" json:"leasedJobs,omitempty"`
}

func (m *JobSetInfo) Reset()      { *m = JobSetInfo{} }
func (*JobSetInfo) ProtoMessage() {}
func (*JobSetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{18}
}
func (m *JobSetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSetInfo.Merge(m, src)
}
func (m *JobSetInfo) XXX_Size() int {
	return m.Size()
}
func (m *JobSetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_JobSetInfo proto.InternalMessageInfo

func (m *JobSetInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *JobSetInfo) GetQueuedJobs() int32 {
	if m != nil {
		return m.QueuedJobs
	}
	return 0
}

func (m *JobSetInfo) GetLeasedJobs() int32 {
	if m != nil {
		return m.LeasedJobs
	}
	return 0
}

type QueueUpdateResponse struct {
	Queue *Queue `protobuf:"bytes,1,opt,name=queue,proto3" json:"queue,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *QueueUpdateResponse) Reset()      { *m = QueueUpdateResponse{} }
func (*QueueUpdateResponse) ProtoMessage() {}
func (*QueueUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{19}
}
func (m *QueueUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueUpdateResponse.Merge(m, src)
}
func (m *QueueUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueueUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueueUpdateResponse proto.InternalMessageInfo

func (m *QueueUpdateResponse) GetQueue() *Queue {
	if m != nil {
		return m.Queue
	}
	return nil
}

func (m *QueueUpdateResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type BatchQueueUpdateResponse struct {
	FailedQueues []*QueueUpdateResponse `protobuf:"bytes,1,rep,name=failed_queues,json=failedQueues,proto3" json:"failedQueues,omitempty"`
}

func (m *BatchQueueUpdateResponse) Reset()      { *m = BatchQueueUpdateResponse{} }
func (*BatchQueueUpdateResponse) ProtoMessage() {}
func (*BatchQueueUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{20}
}
func (m *BatchQueueUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchQueueUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchQueueUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchQueueUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchQueueUpdateResponse.Merge(m, src)
}
func (m *BatchQueueUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchQueueUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchQueueUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchQueueUpdateResponse proto.InternalMessageInfo

func (m *BatchQueueUpdateResponse) GetFailedQueues() []*QueueUpdateResponse {
	if m != nil {
		return m.FailedQueues
	}
	return nil
}

type QueueCreateResponse struct {
	Queue *Queue `protobuf:"bytes,1,opt,name=queue,proto3" json:"queue,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *QueueCreateResponse) Reset()      { *m = QueueCreateResponse{} }
func (*QueueCreateResponse) ProtoMessage() {}
func (*QueueCreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{21}
}
func (m *QueueCreateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueCreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueCreateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueCreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueCreateResponse.Merge(m, src)
}
func (m *QueueCreateResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueueCreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueCreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueueCreateResponse proto.InternalMessageInfo

func (m *QueueCreateResponse) GetQueue() *Queue {
	if m != nil {
		return m.Queue
	}
	return nil
}

func (m *QueueCreateResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type BatchQueueCreateResponse struct {
	FailedQueues []*QueueCreateResponse `protobuf:"bytes,1,rep,name=failed_queues,json=failedQueues,proto3" json:"failedQueues,omitempty"`
}

func (m *BatchQueueCreateResponse) Reset()      { *m = BatchQueueCreateResponse{} }
func (*BatchQueueCreateResponse) ProtoMessage() {}
func (*BatchQueueCreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{22}
}
func (m *BatchQueueCreateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchQueueCreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchQueueCreateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchQueueCreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchQueueCreateResponse.Merge(m, src)
}
func (m *BatchQueueCreateResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchQueueCreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchQueueCreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchQueueCreateResponse proto.InternalMessageInfo

func (m *BatchQueueCreateResponse) GetFailedQueues() []*QueueCreateResponse {
	if m != nil {
		return m.FailedQueues
	}
	return nil
}

// Indicates the end of streams
type EndMarker struct {
}

func (m *EndMarker) Reset()      { *m = EndMarker{} }
func (*EndMarker) ProtoMessage() {}
func (*EndMarker) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{23}
}
func (m *EndMarker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EndMarker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EndMarker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EndMarker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EndMarker.Merge(m, src)
}
func (m *EndMarker) XXX_Size() int {
	return m.Size()
}
func (m *EndMarker) XXX_DiscardUnknown() {
	xxx_messageInfo_EndMarker.DiscardUnknown(m)
}

var xxx_messageInfo_EndMarker proto.InternalMessageInfo

type StreamingQueueMessage struct {
	// Types that are valid to be assigned to Event:
	//	*StreamingQueueMessage_Queue
	//	*StreamingQueueMessage_End
	Event isStreamingQueueMessage_Event `protobuf_oneof:"event"`
}

func (m *StreamingQueueMessage) Reset()      { *m = StreamingQueueMessage{} }
func (*StreamingQueueMessage) ProtoMessage() {}
func (*StreamingQueueMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_e998bacb27df16c1, []int{24}
}
func (m *StreamingQueueMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamingQueueMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamingQueueMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamingQueueMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamingQueueMessage.Merge(m, src)
}
func (m *StreamingQueueMessage) XXX_Size() int {
	return m.Size()
}
func (m *StreamingQueueMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamingQueueMessage.DiscardUnknown(m)
}

var xxx_messageInfo_StreamingQueueMessage proto.InternalMessageInfo

type isStreamingQueueMessage_Event interface {
	isStreamingQueueMessage_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StreamingQueueMessage_Queue struct {
	Queue *Queue `protobuf:"bytes,1,opt,name=queue,proto3,oneof" json:"queue,omitempty"`
}
type StreamingQueueMessage_End struct {
	End *EndMarker `protobuf:"bytes,2,opt,name=end,proto3,oneof" json:"end,omitempty"`
}

func (*StreamingQueueMessage_Queue) isStreamingQueueMessage_Event() {}
func (*StreamingQueueMessage_End) isStreamingQueueMessage_Event()   {}

func (m *StreamingQueueMessage) GetEvent() isStreamingQueueMessage_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *StreamingQueueMessage) GetQueue() *Queue {
	if x, ok := m.GetEvent().(*StreamingQueueMessage_Queue); ok {
		return x.Queue
	}
	return nil
}

func (m *StreamingQueueMessage) GetEnd() *EndMarker {
	if x, ok := m.GetEvent().(*StreamingQueueMessage_End); ok {
		return x.End
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StreamingQueueMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StreamingQueueMessage_Queue)(nil),
		(*StreamingQueueMessage_End)(nil),
	}
}

func init() {
	proto.RegisterEnum("api.IngressType", IngressType_name, IngressType_value)
	proto.RegisterEnum("api.ServiceType", ServiceType_name, ServiceType_value)
	proto.RegisterEnum("api.JobState", JobState_name, JobState_value)
	proto.RegisterType((*JobSubmitRequestItem)(nil), "api.JobSubmitRequestItem")
	proto.RegisterMapType((map[string]string)(nil), "api.JobSubmitRequestItem.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "api.JobSubmitRequestItem.LabelsEntry")
	proto.RegisterMapType((map[string]string)(nil), "api.JobSubmitRequestItem.RequiredNodeLabelsEntry")
	proto.RegisterType((*IngressConfig)(nil), "api.IngressConfig")
	proto.RegisterMapType((map[string]string)(nil), "api.IngressConfig.AnnotationsEntry")
	proto.RegisterType((*ServiceConfig)(nil), "api.ServiceConfig")
	proto.RegisterType((*JobSubmitRequest)(nil), "api.JobSubmitRequest")
	proto.RegisterType((*JobCancelRequest)(nil), "api.JobCancelRequest")
	proto.RegisterType((*JobSetCancelRequest)(nil), "api.JobSetCancelRequest")
	proto.RegisterType((*JobSetFilter)(nil), "api.JobSetFilter")
	proto.RegisterType((*Job)(nil), "api.Job")
	proto.RegisterMapType((map[string]string)(nil), "api.Job.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "api.Job.LabelsEntry")
	proto.RegisterMapType((map[string]string)(nil), "api.Job.RequiredNodeLabelsEntry")
	proto.RegisterType((*JobReprioritizeRequest)(nil), "api.JobReprioritizeRequest")
	proto.RegisterType((*JobReprioritizeResponse)(nil), "api.JobReprioritizeResponse")
	proto.RegisterMapType((map[string]string)(nil), "api.JobReprioritizeResponse.ReprioritizationResultsEntry")
	proto.RegisterType((*JobSubmitResponseItem)(nil), "api.JobSubmitResponseItem")
	proto.RegisterType((*JobSubmitResponse)(nil), "api.JobSubmitResponse")
	proto.RegisterType((*Queue)(nil), "api.Queue")
	proto.RegisterMapType((map[string]float64)(nil), "api.Queue.ResourceLimitsEntry")
	proto.RegisterType((*Queue_Permissions)(nil), "api.Queue.Permissions")
	proto.RegisterType((*Queue_Permissions_Subject)(nil), "api.Queue.Permissions.Subject")
	proto.RegisterType((*QueueList)(nil), "api.QueueList")
	proto.RegisterType((*CancellationResult)(nil), "api.CancellationResult")
	proto.RegisterType((*QueueGetRequest)(nil), "api.QueueGetRequest")
	proto.RegisterType((*StreamingQueueGetRequest)(nil), "api.StreamingQueueGetRequest")
	proto.RegisterType((*QueueDeleteRequest)(nil), "api.QueueDeleteRequest")
	proto.RegisterType((*JobSetInfo)(nil), "api.JobSetInfo")
	proto.RegisterType((*QueueUpdateResponse)(nil), "api.QueueUpdateResponse")
	proto.RegisterType((*BatchQueueUpdateResponse)(nil), "api.BatchQueueUpdateResponse")
	proto.RegisterType((*QueueCreateResponse)(nil), "api.QueueCreateResponse")
	proto.RegisterType((*BatchQueueCreateResponse)(nil), "api.BatchQueueCreateResponse")
	proto.RegisterType((*EndMarker)(nil), "api.EndMarker")
	proto.RegisterType((*StreamingQueueMessage)(nil), "api.StreamingQueueMessage")
}

func init() { proto.RegisterFile("pkg/api/submit.proto", fileDescriptor_e998bacb27df16c1) }

var fileDescriptor_e998bacb27df16c1 = []byte{
	// 2616 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x4b, 0x6f, 0x1b, 0xd7,
	0xf5, 0xd7, 0x90, 0x12, 0x25, 0x1e, 0x52, 0x12, 0x75, 0x45, 0x49, 0x23, 0x5a, 0x21, 0x99, 0xc9,
	0x3f, 0xfe, 0xd3, 0x42, 0x42, 0xc6, 0x4a, 0x83, 0xca, 0x6e, 0x00, 0xc3, 0x94, 0x68, 0x5b, 0x8e,
	0xa3, 0x28, 0x54, 0x94, 0x47, 0x51, 0x94, 0x19, 0x72, 0xae, 0xa8, 0x91, 0xc8, 0x99, 0xf1, 0xcc,
	0x50, 0x86, 0x5b, 0x04, 0x08, 0x8a, 0x02, 0xdd, 0x1a, 0xe8, 0xae, 0xfd, 0x06, 0xe9, 0xa6, 0x1f,
	0x23, 0xcb, 0x00, 0xdd, 0xa4, 0x1b, 0xa6, 0xb5, 0xfb, 0x00, 0xb8, 0xeb, 0xbe, 0x8b, 0xe2, 0x9e,
	0x3b, 0xc3, 0xb9, 0xc3, 0x87, 0x1e, 0x8e, 0x9d, 0x6e, 0xba, 0xd3, 0xfd, 0xdd, 0xf3, 0xbc, 0x73,
	0xee, 0x79, 0x5c, 0x11, 0xd2, 0xd6, 0x49, 0xb3, 0xa4, 0x5a, 0x7a, 0xc9, 0xe9, 0xd4, 0xdb, 0xba,
	0x5b, 0xb4, 0x6c, 0xd3, 0x35, 0x49, 0x54, 0xb5, 0xf4, 0xcc, 0x95, 0xa6, 0x69, 0x36, 0x5b, 0xb4,
	0x84, 0x50, 0xbd, 0x73, 0x58, 0xa2, 0x6d, 0xcb, 0x7d, 0xcc, 0x29, 0x32, 0xb9, 0xc1, 0x4d, 0x57,
	0x6f, 0x53, 0xc7, 0x55, 0xdb, 0x96, 0x47, 0xa0, 0x9c, 0x6c, 0x3a, 0x45, 0xdd, 0x44, 0xd9, 0x0d,
	0xd3, 0xa6, 0xa5, 0xd3, 0xeb, 0xa5, 0x26, 0x35, 0xa8, 0xad, 0xba, 0x54, 0xf3, 0x68, 0x0a, 0x02,
	0x8d, 0x41, 0xdd, 0x47, 0xa6, 0x7d, 0xa2, 0x1b, 0xcd, 0x51, 0x94, 0x6b, 0x9e, 0x3a, 0x46, 0xa9,
	0x1a, 0x86, 0xe9, 0xaa, 0xae, 0x6e, 0x1a, 0x8e, 0xb7, 0xfb, 0x66, 0x53, 0x77, 0x8f, 0x3a, 0xf5,
	0x62, 0xc3, 0x6c, 0x97, 0x9a, 0x66, 0xd3, 0x0c, 0xac, 0x62, 0x2b, 0x5c, 0xe0, 0x5f, 0x1e, 0x79,
	0xdf, 0xe7, 0x23, 0xaa, 0xb6, 0xdc, 0x23, 0x8e, 0x2a, 0xbd, 0x38, 0xa4, 0xef, 0x9b, 0xf5, 0x7d,
	0x3c, 0x87, 0x2a, 0x7d, 0xd8, 0xa1, 0x8e, 0xbb, 0xe3, 0xd2, 0x36, 0xd9, 0x80, 0x19, 0xcb, 0xd6,
	0x4d, 0x5b, 0x77, 0x1f, 0xcb, 0x52, 0x5e, 0x2a, 0x48, 0xe5, 0xe5, 0x5e, 0x37, 0x47, 0x7c, 0xec,
	0x0d, 0xb3, 0xad, 0xbb, 0x78, 0x34, 0xd5, 0x3e, 0x1d, 0x79, 0x07, 0xe2, 0x86, 0xda, 0xa6, 0x8e,
	0xa5, 0x36, 0xa8, 0x1c, 0xcd, 0x4b, 0x85, 0x78, 0x79, 0xa5, 0xd7, 0xcd, 0x2d, 0xf6, 0x41, 0x81,
	0x2b, 0xa0, 0x24, 0x6f, 0x43, 0xbc, 0xd1, 0xd2, 0xa9, 0xe1, 0xd6, 0x74, 0x4d, 0x9e, 0x41, 0x36,
	0xd4, 0xc5, 0xc1, 0x1d, 0x4d, 0xd4, 0xe5, 0x63, 0x64, 0x1f, 0x62, 0x2d, 0xb5, 0x4e, 0x5b, 0x8e,
	0x3c, 0x99, 0x8f, 0x16, 0x12, 0x1b, 0xaf, 0x17, 0x55, 0x4b, 0x2f, 0x8e, 0x72, 0xa5, 0xf8, 0x00,
	0xe9, 0x2a, 0x86, 0x6b, 0x3f, 0x2e, 0xa7, 0x7b, 0xdd, 0x5c, 0x8a, 0x33, 0x0a, 0x62, 0x3d, 0x51,
	0xa4, 0x09, 0x09, 0xe1, 0x9c, 0xe5, 0x29, 0x94, 0xbc, 0x3e, 0x5e, 0xf2, 0xed, 0x80, 0x98, 0x8b,
	0x5f, 0xed, 0x75, 0x73, 0x4b, 0x82, 0x08, 0x41, 0x87, 0x28, 0x99, 0xfc, 0x46, 0x82, 0xb4, 0x4d,
	0x1f, 0x76, 0x74, 0x9b, 0x6a, 0x35, 0xc3, 0xd4, 0x68, 0xcd, 0x73, 0x26, 0x86, 0x2a, 0xaf, 0x8f,
	0x57, 0x59, 0xf5, 0xb8, 0x76, 0x4d, 0x8d, 0x8a, 0x8e, 0x29, 0xbd, 0x6e, 0x6e, 0xcd, 0x1e, 0xda,
	0x0c, 0x0c, 0x90, 0xa5, 0x2a, 0x19, 0xde, 0x27, 0x1f, 0xc0, 0x8c, 0x65, 0x6a, 0x35, 0xc7, 0xa2,
	0x0d, 0x39, 0x92, 0x97, 0x0a, 0x89, 0x8d, 0x2b, 0x45, 0x1e, 0xa0, 0x68, 0x03, 0x0b, 0xe2, 0xe2,
	0xe9, 0xf5, 0xe2, 0x9e, 0xa9, 0xed, 0x5b, 0xb4, 0x81, 0xdf, 0x73, 0xc1, 0xe2, 0x8b, 0x90, 0xec,
	0x69, 0x0f, 0x24, 0x7b, 0x10, 0xf7, 0x05, 0x3a, 0xf2, 0x34, 0xba, 0x73, 0xa6, 0x44, 0x1e, 0x56,
	0x7c, 0xe1, 0x84, 0xc2, 0xca, 0xc3, 0xc8, 0x16, 0x4c, 0xeb, 0x46, 0xd3, 0xa6, 0x8e, 0x23, 0xc7,
	0x51, 0x1e, 0x41, 0x41, 0x3b, 0x1c, 0xdb, 0x32, 0x8d, 0x43, 0xbd, 0x59, 0x5e, 0x62, 0x86, 0x79,
	0x64, 0x82, 0x14, 0x9f, 0x93, 0xdc, 0x81, 0x19, 0x87, 0xda, 0xa7, 0x7a, 0x83, 0x3a, 0x32, 0x08,
	0x52, 0xf6, 0x39, 0xe8, 0x49, 0x41, 0x63, 0x7c, 0x3a, 0xd1, 0x18, 0x1f, 0x63, 0x31, 0xee, 0x34,
	0x8e, 0xa8, 0xd6, 0x69, 0x51, 0x5b, 0x4e, 0x04, 0x31, 0xde, 0x07, 0xc5, 0x18, 0xef, 0x83, 0x64,
	0x07, 0x16, 0x1e, 0x76, 0x68, 0x87, 0xd6, 0x5c, 0xb7, 0x55, 0x73, 0x68, 0xc3, 0x34, 0x34, 0x47,
	0x4e, 0xe6, 0xa5, 0x42, 0xb4, 0xfc, 0x4a, 0xaf, 0x9b, 0x5b, 0xc5, 0xcd, 0x8f, 0xdc, 0xd6, 0x3e,
	0xdf, 0x12, 0x84, 0xcc, 0x0f, 0x6c, 0x65, 0x54, 0x48, 0x08, 0x1f, 0x9e, 0xbc, 0x06, 0xd1, 0x13,
	0xca, 0xef, 0x68, 0xbc, 0xbc, 0xd0, 0xeb, 0xe6, 0x66, 0x4f, 0xa8, 0x78, 0x3d, 0xd9, 0x2e, 0xb9,
	0x06, 0x53, 0xa7, 0x6a, 0xab, 0x43, 0xf1, 0x13, 0xc7, 0xcb, 0x8b, 0xbd, 0x6e, 0x6e, 0x1e, 0x01,
	0x81, 0x90, 0x53, 0xdc, 0x8c, 0x6c, 0x4a, 0x99, 0x43, 0x48, 0x0d, 0x86, 0xf6, 0x4b, 0xd1, 0xd3,
	0x86, 0x95, 0x31, 0xf1, 0xfc, 0x32, 0xd4, 0x29, 0xff, 0x8a, 0xc2, 0x6c, 0x28, 0x6a, 0xc8, 0x4d,
	0x98, 0x74, 0x1f, 0x5b, 0x14, 0xd5, 0xcc, 0x6d, 0xa4, 0xc4, 0xb8, 0xfa, 0xe8, 0xb1, 0x45, 0x31,
	0x5d, 0xcc, 0x31, 0x8a, 0x50, 0xac, 0x23, 0x0f, 0x53, 0x6e, 0x99, 0xb6, 0xeb, 0xc8, 0x91, 0x7c,
	0xb4, 0x30, 0xcb, 0x95, 0x23, 0x20, 0x2a, 0x47, 0x80, 0x7c, 0x1e, 0xce, 0x2b, 0x51, 0x8c, 0xbf,
	0xd7, 0x86, 0xa3, 0xf8, 0xf9, 0x13, 0xca, 0x0d, 0x48, 0xb8, 0x2d, 0xa7, 0x46, 0x0d, 0xb5, 0xde,
	0xa2, 0x9a, 0x3c, 0x99, 0x97, 0x0a, 0x33, 0x65, 0xb9, 0xd7, 0xcd, 0xa5, 0x5d, 0x76, 0xa2, 0x88,
	0x0a, 0xbc, 0x10, 0xa0, 0x98, 0x7e, 0xa9, 0xed, 0xd6, 0x58, 0x42, 0x96, 0xa7, 0x84, 0xf4, 0x4b,
	0x6d, 0x77, 0x57, 0x6d, 0xd3, 0x50, 0xfa, 0xf5, 0x30, 0x72, 0x0b, 0x66, 0x3b, 0x0e, 0xad, 0x35,
	0x5a, 0x1d, 0xc7, 0xa5, 0xf6, 0xce, 0x9e, 0x1c, 0x43, 0x8d, 0x99, 0x5e, 0x37, 0xb7, 0xdc, 0x71,
	0xe8, 0x96, 0x8f, 0x0b, 0xcc, 0x49, 0x11, 0xff, 0xa1, 0x42, 0x4c, 0x71, 0x61, 0x36, 0x74, 0xc5,
	0xc9, 0xe6, 0x88, 0x4f, 0xee, 0x51, 0xe0, 0x27, 0x27, 0xc3, 0x9f, 0xfc, 0xd2, 0x1f, 0x5c, 0xf9,
	0xb3, 0x04, 0xa9, 0xc1, 0xf4, 0xcd, 0xf8, 0xf1, 0x2e, 0x7b, 0x0e, 0x22, 0x3f, 0x02, 0x22, 0x3f,
	0x02, 0xe4, 0x47, 0x00, 0xc7, 0x66, 0xbd, 0xe6, 0x50, 0xac, 0x89, 0x91, 0xe0, 0xa3, 0x1c, 0x9b,
	0xf5, 0x7d, 0x3a, 0x50, 0x13, 0x7d, 0x8c, 0x68, 0xb0, 0xc0, 0xb8, 0x6c, 0xae, 0xaf, 0xc6, 0x08,
	0xfc, 0x60, 0x5b, 0x1d, 0x5b, 0x51, 0x78, 0xfe, 0x39, 0x36, 0xeb, 0x02, 0x16, 0xca, 0x3f, 0x03,
	0x5b, 0xca, 0xbf, 0xb9, 0x6f, 0x5b, 0xaa, 0xd1, 0xa0, 0x2d, 0xdf, 0xb7, 0x75, 0x88, 0x31, 0xd5,
	0xba, 0x26, 0x3a, 0x77, 0x6c, 0xd6, 0x43, 0x96, 0x4e, 0x21, 0xf0, 0x9c, 0xce, 0xf5, 0x4f, 0x2f,
	0x7a, 0xee, 0xe9, 0xbd, 0x09, 0xd3, 0xdc, 0x18, 0xde, 0x1c, 0xc4, 0x79, 0xd5, 0x47, 0xe5, 0xa1,
	0xaa, 0xcf, 0x11, 0xf2, 0x06, 0xc4, 0x6c, 0xaa, 0x3a, 0xa6, 0xe1, 0x45, 0x3f, 0x52, 0x73, 0x44,
	0xa4, 0xe6, 0x88, 0xf2, 0x77, 0x09, 0x16, 0xef, 0xa3, 0x51, 0xe1, 0x13, 0x08, 0x7b, 0x25, 0x5d,
	0xd6, 0xab, 0xc8, 0xb9, 0x5e, 0xdd, 0x82, 0xd8, 0xa1, 0xde, 0x72, 0xa9, 0x8d, 0x27, 0x90, 0xd8,
	0x58, 0xe8, 0x7f, 0x52, 0xea, 0xde, 0xc1, 0x0d, 0x6e, 0x39, 0x27, 0x12, 0x2d, 0xe7, 0x88, 0xe0,
	0xe7, 0xe4, 0x05, 0xfc, 0x7c, 0x0f, 0x92, 0xa2, 0x6c, 0xf2, 0x13, 0x88, 0x39, 0xae, 0xea, 0x52,
	0x47, 0x96, 0xf2, 0xd1, 0xc2, 0xdc, 0xc6, 0x6c, 0x5f, 0x3d, 0x43, 0xb9, 0x30, 0x4e, 0x20, 0x0a,
	0xe3, 0x88, 0xf2, 0xdd, 0x3c, 0x44, 0xef, 0x9b, 0x75, 0x92, 0x87, 0x48, 0xff, 0x70, 0x52, 0xbd,
	0x6e, 0x2e, 0xa9, 0x8b, 0xc7, 0x12, 0xd1, 0xb5, 0x70, 0x33, 0x38, 0x7b, 0xc1, 0x66, 0xf0, 0xa5,
	0x47, 0x54, 0xa8, 0xb3, 0x9d, 0xbe, 0x70, 0x67, 0x5b, 0xee, 0x37, 0xa9, 0xbc, 0x71, 0x49, 0xfb,
	0x67, 0x76, 0x89, 0x9e, 0xf4, 0xe3, 0x70, 0xed, 0x80, 0xf0, 0x75, 0x7e, 0xfe, 0x8a, 0x71, 0x3a,
	0xa6, 0x03, 0x4d, 0xa0, 0x82, 0x7c, 0x5f, 0xc1, 0x8b, 0x6e, 0x38, 0xaf, 0xc1, 0x94, 0xf9, 0xc8,
	0xa0, 0xb6, 0xd7, 0xe9, 0xe3, 0xa9, 0x23, 0x20, 0x9e, 0x3a, 0x02, 0x84, 0xc2, 0x15, 0xde, 0x34,
	0xe1, 0xd2, 0x39, 0xd2, 0xad, 0x5a, 0xc7, 0xa1, 0x76, 0xad, 0x69, 0x9b, 0x1d, 0xcb, 0x91, 0xe7,
	0xf1, 0x6e, 0x5f, 0xed, 0x75, 0x73, 0x0a, 0x92, 0x7d, 0xe0, 0x53, 0x1d, 0x38, 0xd4, 0xbe, 0x8b,
	0x34, 0x82, 0x4c, 0x79, 0x1c, 0x0d, 0xf9, 0xb5, 0x04, 0x57, 0x1b, 0x66, 0xdb, 0x62, 0x75, 0x98,
	0x6a, 0xb5, 0xb3, 0x54, 0x2e, 0xe6, 0xa5, 0x42, 0xb2, 0xfc, 0x56, 0xaf, 0x9b, 0x7b, 0x23, 0xe0,
	0xf8, 0xf0, 0x7c, 0xe5, 0xca, 0xf9, 0xd4, 0xa1, 0x89, 0x6b, 0xf2, 0x82, 0x13, 0x97, 0xd8, 0xbd,
	0x4f, 0xbd, 0xf0, 0xee, 0x3d, 0xf9, 0x22, 0xba, 0xf7, 0xdf, 0x49, 0x90, 0xf7, 0xfa, 0x60, 0xdd,
	0x68, 0xd6, 0x6c, 0xea, 0x98, 0x1d, 0xbb, 0x41, 0x6b, 0x5e, 0x68, 0xb4, 0xa9, 0xe1, 0x3a, 0xf2,
	0x12, 0xda, 0x5e, 0x18, 0xa5, 0xa9, 0xea, 0x31, 0x54, 0x05, 0xfa, 0xf2, 0xd5, 0xaf, 0xbb, 0xb9,
	0x89, 0x5e, 0x37, 0x97, 0x0d, 0x24, 0x8f, 0xa2, 0xab, 0x9e, 0xb3, 0x4f, 0x76, 0x60, 0xba, 0x61,
	0x53, 0x36, 0x72, 0x63, 0x03, 0x93, 0xd8, 0xc8, 0x14, 0xf9, 0xcc, 0x5d, 0xf4, 0x87, 0xe9, 0xe2,
	0x47, 0xfe, 0x88, 0x5f, 0x5e, 0xf4, 0x94, 0xfa, 0x2c, 0x4f, 0xbe, 0xcb, 0x49, 0x55, 0x7f, 0x21,
	0x4e, 0x29, 0x73, 0x2f, 0x64, 0x4a, 0x49, 0x7d, 0x8f, 0x29, 0xe5, 0x67, 0x90, 0x38, 0xd9, 0x74,
	0x6a, 0xbe, 0x41, 0x0b, 0x28, 0xea, 0x55, 0xf1, 0x78, 0x83, 0x97, 0x07, 0x76, 0xc8, 0x9e, 0x95,
	0xbc, 0x63, 0x3c, 0xd9, 0x74, 0x76, 0x86, 0x4c, 0x84, 0x00, 0x65, 0x29, 0x89, 0x49, 0xf7, 0xb4,
	0xc9, 0x64, 0x7c, 0x98, 0x78, 0x76, 0xf7, 0xe5, 0x7a, 0xeb, 0x01, 0xb9, 0x1e, 0x1a, 0x9e, 0xad,
	0xd2, 0xdf, 0x6f, 0xb6, 0x5a, 0xfe, 0xdf, 0x6c, 0xf5, 0x83, 0xce, 0x56, 0xff, 0x90, 0x60, 0xf9,
	0x3e, 0xeb, 0x14, 0xbd, 0xdc, 0xa4, 0xff, 0x82, 0xfa, 0x9d, 0x91, 0xd0, 0x8e, 0x49, 0x17, 0x68,
	0xc7, 0x5e, 0x7a, 0x31, 0x7f, 0x17, 0x92, 0x06, 0x7d, 0x54, 0x1b, 0x48, 0xb6, 0x58, 0x37, 0x0d,
	0xfa, 0x68, 0x6f, 0x38, 0xdf, 0x26, 0x04, 0x58, 0xf9, 0x43, 0x04, 0x56, 0x86, 0x1c, 0x75, 0x2c,
	0xd3, 0x70, 0x28, 0xf9, 0xbd, 0x04, 0xb2, 0x1d, 0x6c, 0xe0, 0x27, 0x66, 0x19, 0xaf, 0xd3, 0x72,
	0xb9, 0xef, 0x89, 0x8d, 0x1b, 0x7e, 0x61, 0x1d, 0x25, 0xa0, 0x58, 0x1d, 0x60, 0xae, 0x72, 0x5e,
	0x5e, 0x71, 0x5f, 0xef, 0x75, 0x73, 0xaf, 0xda, 0xa3, 0x29, 0x04, 0x6b, 0x57, 0xc6, 0x90, 0x64,
	0x6c, 0x58, 0x3b, 0x4b, 0xfe, 0x4b, 0x09, 0x0b, 0x03, 0x96, 0x84, 0xa1, 0x83, 0x7b, 0x89, 0xef,
	0x8b, 0x97, 0x19, 0x18, 0xae, 0xc1, 0x14, 0xb5, 0x6d, 0xd3, 0x16, 0x75, 0x22, 0x20, 0x92, 0x22,
	0xa0, 0x7c, 0x01, 0x0b, 0x43, 0xfa, 0xc8, 0x11, 0x10, 0x3e, 0x17, 0xf1, 0xb5, 0x37, 0x18, 0xf1,
	0xef, 0x91, 0x19, 0x1c, 0x8c, 0x02, 0x1b, 0xcb, 0xd9, 0x5e, 0x37, 0x97, 0xc1, 0xf1, 0x27, 0x00,
	0xc5, 0x93, 0x4e, 0x0d, 0xee, 0x29, 0x5f, 0xc6, 0x60, 0x0a, 0x0b, 0x3c, 0xb9, 0x0a, 0x93, 0x38,
	0x50, 0x73, 0xef, 0x70, 0xa8, 0x34, 0xc2, 0xc3, 0x34, 0xee, 0x93, 0x0a, 0xcc, 0xfb, 0x81, 0x58,
	0x3b, 0x54, 0x1b, 0xae, 0xe7, 0xa5, 0x54, 0x5e, 0xeb, 0x75, 0x73, 0xb2, 0xbf, 0x75, 0x07, 0x77,
	0x04, 0xe6, 0xb9, 0xf0, 0x0e, 0x9b, 0xff, 0xb1, 0x4f, 0xe1, 0x6d, 0x0b, 0x0e, 0x7d, 0x71, 0x9e,
	0x75, 0x19, 0xcc, 0xdb, 0x0d, 0x31, 0xeb, 0x06, 0x28, 0xbb, 0x0e, 0xd8, 0xdd, 0xf8, 0xbc, 0x7c,
	0x64, 0xc2, 0xeb, 0x80, 0xf8, 0x10, 0x73, 0x42, 0x80, 0x09, 0x85, 0xf9, 0x7e, 0x49, 0x6f, 0xe9,
	0x6d, 0xdd, 0xf5, 0x9f, 0x4d, 0xb3, 0x78, 0xb0, 0x78, 0x18, 0xfd, 0x1a, 0xfe, 0x00, 0x09, 0x78,
	0x34, 0xa3, 0x7f, 0x76, 0x68, 0x43, 0xf4, 0x2f, 0xbc, 0x43, 0xf6, 0x21, 0x61, 0x51, 0xbb, 0xad,
	0x3b, 0x0e, 0x76, 0xc1, 0xfc, 0x99, 0x74, 0x59, 0x50, 0xb1, 0x17, 0xec, 0x72, 0xdb, 0x05, 0x72,
	0xd1, 0x76, 0x01, 0xce, 0xfc, 0x53, 0x82, 0x84, 0xc0, 0x47, 0xaa, 0x30, 0xe3, 0x74, 0xea, 0xc7,
	0xb4, 0xd1, 0xbf, 0xad, 0xd9, 0xd1, 0x1a, 0x8a, 0xfb, 0x9c, 0xcc, 0xab, 0xc4, 0x1e, 0x4f, 0xa8,
	0x12, 0x7b, 0x18, 0xde, 0x17, 0x6a, 0xd7, 0xf9, 0xa3, 0x81, 0x7f, 0x5f, 0x18, 0x10, 0xba, 0x2f,
	0x0c, 0xc8, 0x7c, 0x06, 0xd3, 0x9e, 0x5c, 0x16, 0x3d, 0x27, 0xba, 0xa1, 0x89, 0xd1, 0xc3, 0xd6,
	0x62, 0xf4, 0xb0, 0x75, 0x3f, 0xca, 0x22, 0x67, 0x47, 0x59, 0x46, 0x87, 0xc5, 0x11, 0xdf, 0xe0,
	0x39, 0x6e, 0xbc, 0x74, 0xee, 0x8d, 0xaf, 0x40, 0x1c, 0xcf, 0xeb, 0x81, 0xee, 0xb8, 0x64, 0x13,
	0x62, 0x98, 0x73, 0xfd, 0xf3, 0x84, 0xe0, 0x3c, 0x79, 0x15, 0xe0, 0xbb, 0x62, 0x15, 0xe0, 0x88,
	0x72, 0x00, 0x84, 0xcf, 0xd7, 0x2d, 0x21, 0x51, 0x91, 0x5b, 0x30, 0xdb, 0xe0, 0x28, 0xd5, 0x84,
	0x82, 0x82, 0xcf, 0x4e, 0xfd, 0x8d, 0x70, 0x59, 0x49, 0x8a, 0xb8, 0x72, 0x03, 0xe6, 0x51, 0xfb,
	0x5d, 0xda, 0x7f, 0x96, 0xb9, 0xe0, 0x4d, 0x55, 0x6e, 0x81, 0xbc, 0xef, 0xda, 0x54, 0x6d, 0xeb,
	0x46, 0x73, 0x50, 0xc6, 0x6b, 0x10, 0x35, 0x3a, 0x6d, 0x14, 0x31, 0xcb, 0x0f, 0xd2, 0xe8, 0xb4,
	0xc5, 0x83, 0x34, 0x3a, 0x6d, 0xe5, 0x5d, 0x20, 0xc8, 0xb7, 0x4d, 0x5b, 0xd4, 0xa5, 0x97, 0x55,
	0xff, 0x95, 0x04, 0xc0, 0x07, 0xf2, 0x1d, 0xe3, 0xd0, 0xbc, 0x70, 0x7e, 0xb9, 0x01, 0x09, 0x3c,
	0x51, 0xad, 0x76, 0x6c, 0x62, 0x14, 0x4a, 0x85, 0x29, 0x9e, 0x18, 0x38, 0x7c, 0xdf, 0x0c, 0x85,
	0x22, 0x04, 0x28, 0x63, 0x6d, 0x51, 0xd5, 0xf1, 0x59, 0xa3, 0x01, 0x2b, 0x87, 0x07, 0x59, 0x03,
	0x54, 0x79, 0x04, 0x8b, 0xe8, 0xea, 0x81, 0xa5, 0xa9, 0x6e, 0x50, 0x1f, 0xdf, 0x11, 0x5f, 0xc0,
	0xc2, 0xd1, 0x70, 0x56, 0xc1, 0xbe, 0x44, 0xfe, 0xef, 0x80, 0x5c, 0x56, 0xdd, 0xc6, 0xd1, 0x28,
	0xed, 0x9f, 0xc1, 0xec, 0xa1, 0xaa, 0xb7, 0xfc, 0x11, 0xcf, 0x8f, 0x49, 0x39, 0xb0, 0x22, 0xcc,
	0xc0, 0xc3, 0x8a, 0xb3, 0x7c, 0x38, 0x18, 0xa7, 0x49, 0x11, 0xef, 0xfb, 0xbb, 0x85, 0xc3, 0xc0,
	0x7f, 0xcb, 0xdf, 0x01, 0xed, 0xe7, 0xfb, 0x1b, 0x66, 0xb8, 0x84, 0xbf, 0x09, 0x88, 0x57, 0x0c,
	0xed, 0x7d, 0xd5, 0x3e, 0xa1, 0xb6, 0xf2, 0x44, 0x82, 0xa5, 0xf0, 0xcd, 0x78, 0x9f, 0x3a, 0x8e,
	0xda, 0xa4, 0xe4, 0xc7, 0x97, 0xf3, 0xff, 0xde, 0x44, 0xf0, 0xde, 0x12, 0xa5, 0x86, 0xe6, 0xfd,
	0x43, 0x6a, 0x0e, 0xd9, 0xfa, 0xfa, 0xf8, 0xfd, 0xa2, 0x62, 0x36, 0xbc, 0x37, 0x51, 0x65, 0xf4,
	0xe5, 0x69, 0x98, 0xa2, 0xa7, 0xd4, 0x70, 0xd7, 0x33, 0x90, 0x10, 0x9e, 0xf1, 0x49, 0x02, 0xa6,
	0xbd, 0x65, 0x6a, 0x62, 0xfd, 0x1a, 0x24, 0x84, 0xf7, 0x5e, 0x92, 0x84, 0x19, 0xd6, 0x1f, 0xef,
	0x99, 0xb6, 0x9b, 0x9a, 0x60, 0xab, 0x7b, 0x54, 0xd5, 0x5a, 0x8c, 0x54, 0x5a, 0xff, 0x14, 0x66,
	0xfc, 0x07, 0x2e, 0x02, 0x10, 0xfb, 0xf0, 0xa0, 0x72, 0x50, 0xd9, 0x4e, 0x4d, 0x30, 0x79, 0x7b,
	0x95, 0xdd, 0xed, 0x9d, 0xdd, 0xbb, 0x29, 0x89, 0x2d, 0xaa, 0x07, 0xbb, 0xbb, 0x6c, 0x11, 0x21,
	0xb3, 0x10, 0xdf, 0x3f, 0xd8, 0xda, 0xaa, 0x54, 0xb6, 0x2b, 0xdb, 0xa9, 0x28, 0x63, 0xba, 0x73,
	0x7b, 0xe7, 0x41, 0x65, 0x3b, 0x35, 0xc9, 0xe8, 0x0e, 0x76, 0xdf, 0xdb, 0xfd, 0xe0, 0x93, 0xdd,
	0xd4, 0xd4, 0xc6, 0x1f, 0x67, 0x20, 0xc6, 0x3b, 0x0e, 0xf2, 0x31, 0x00, 0xff, 0x0b, 0x2f, 0xdd,
	0xd2, 0xc8, 0x87, 0xda, 0xcc, 0xf2, 0xe8, 0x36, 0x45, 0x59, 0xfd, 0xd5, 0x9f, 0xfe, 0xf6, 0xdb,
	0xc8, 0xa2, 0x32, 0x57, 0x3a, 0xbd, 0x5e, 0x3a, 0x36, 0xeb, 0xde, 0x7f, 0xb4, 0x6f, 0x4a, 0xeb,
	0xe4, 0x13, 0x00, 0x9e, 0x41, 0xc3, 0x72, 0x43, 0xaf, 0x96, 0x99, 0x15, 0x84, 0x87, 0x33, 0xed,
	0xb0, 0x60, 0x9e, 0x46, 0x99, 0xe0, 0x9f, 0x43, 0xb2, 0x2f, 0x78, 0x9f, 0xba, 0x44, 0x16, 0x1e,
	0x22, 0xc3, 0xd2, 0x97, 0x87, 0xa6, 0xe9, 0x0a, 0xfb, 0x5c, 0xca, 0x1a, 0x0a, 0x5f, 0x56, 0x16,
	0x3c, 0xe1, 0x0e, 0x75, 0x05, 0xf9, 0x06, 0xa4, 0xc4, 0xe6, 0x18, 0xcd, 0xbf, 0x32, 0xba, 0x6d,
	0xe6, 0x6a, 0xd6, 0xce, 0xea, 0xa9, 0x95, 0x1c, 0x2a, 0x5b, 0x55, 0xd2, 0xbe, 0x27, 0x42, 0x7f,
	0x4c, 0x99, 0xbe, 0xbb, 0x90, 0xe0, 0x17, 0x81, 0x77, 0x6e, 0x42, 0x94, 0x8e, 0x75, 0x20, 0x8d,
	0x32, 0xe7, 0x94, 0x38, 0x93, 0x89, 0x21, 0xcb, 0x04, 0x35, 0x20, 0x29, 0x08, 0x72, 0xc8, 0x5c,
	0x20, 0x89, 0x55, 0xc3, 0xcc, 0x2b, 0xb8, 0x1e, 0x77, 0x5f, 0x95, 0xff, 0x43, 0xa1, 0x59, 0x65,
	0x95, 0x09, 0xad, 0x33, 0x2a, 0xaa, 0x95, 0xf8, 0xf3, 0x82, 0x77, 0x83, 0x99, 0x92, 0x5d, 0x48,
	0xf0, 0x34, 0x75, 0x71, 0x6b, 0xaf, 0xa0, 0xe0, 0xa5, 0x4c, 0xaa, 0x6f, 0x6d, 0xe9, 0x97, 0xac,
	0x38, 0x7c, 0xe1, 0x19, 0x2d, 0xc8, 0x3b, 0xdf, 0xe8, 0x70, 0x8e, 0xf4, 0x8d, 0xce, 0x84, 0x8c,
	0xee, 0x20, 0x8d, 0x60, 0xf4, 0xa7, 0x90, 0xe0, 0x55, 0x8f, 0x1b, 0xbd, 0x12, 0xe8, 0x08, 0x15,
	0xc3, 0xb1, 0x1e, 0xc8, 0xa8, 0x85, 0xac, 0x0f, 0x79, 0x40, 0xee, 0xc0, 0xcc, 0x5d, 0xea, 0x72,
	0xb1, 0xe9, 0x40, 0x6c, 0x50, 0x9b, 0x33, 0xc2, 0x09, 0xf9, 0x72, 0xc8, 0xb0, 0x1c, 0x0d, 0xe2,
	0xbe, 0x1c, 0x87, 0x70, 0x9f, 0xc7, 0x55, 0xfb, 0x4c, 0x66, 0xc4, 0xb6, 0x97, 0xf2, 0x94, 0x0c,
	0x6a, 0x48, 0x13, 0x22, 0x9e, 0x07, 0x3f, 0x88, 0xb7, 0x24, 0x72, 0x13, 0x62, 0xf7, 0xf0, 0xe7,
	0x17, 0x64, 0x8c, 0xa7, 0x19, 0x7e, 0x99, 0x38, 0xd1, 0xd6, 0x11, 0x6d, 0x9c, 0xf4, 0xb3, 0xf3,
	0xe7, 0xdf, 0xfe, 0x35, 0x3b, 0xf1, 0xe5, 0xd3, 0xac, 0xf4, 0xf5, 0xd3, 0xac, 0xf4, 0xcd, 0xd3,
	0xac, 0xf4, 0x97, 0xa7, 0x59, 0xe9, 0xc9, 0xb3, 0xec, 0xc4, 0x37, 0xcf, 0xb2, 0x13, 0xdf, 0x3e,
	0xcb, 0x4e, 0xfc, 0xf4, 0xff, 0x85, 0x5f, 0x84, 0xa8, 0x76, 0x5b, 0xd5, 0x54, 0xcb, 0x36, 0x59,
	0x3f, 0xe9, 0xad, 0x4a, 0xde, 0x4f, 0x40, 0xbe, 0x8a, 0xa4, 0x6f, 0x23, 0xb0, 0xc7, 0xb7, 0x8b,
	0x3b, 0x66, 0xf1, 0xb6, 0xa5, 0xd7, 0x63, 0x68, 0xcb, 0xdb, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff,
	0x75, 0xfa, 0x87, 0xf8, 0x1f, 0x23, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SubmitClient is the client API for Submit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SubmitClient interface {
	SubmitJobs(ctx context.Context, in *JobSubmitRequest, opts ...grpc.CallOption) (*JobSubmitResponse, error)
	CancelJobs(ctx context.Context, in *JobCancelRequest, opts ...grpc.CallOption) (*CancellationResult, error)
	CancelJobSet(ctx context.Context, in *JobSetCancelRequest, opts ...grpc.CallOption) (*types.Empty, error)
	ReprioritizeJobs(ctx context.Context, in *JobReprioritizeRequest, opts ...grpc.CallOption) (*JobReprioritizeResponse, error)
	CreateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*types.Empty, error)
	CreateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueCreateResponse, error)
	UpdateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*types.Empty, error)
	UpdateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueUpdateResponse, error)
	DeleteQueue(ctx context.Context, in *QueueDeleteRequest, opts ...grpc.CallOption) (*types.Empty, error)
	GetQueue(ctx context.Context, in *QueueGetRequest, opts ...grpc.CallOption) (*Queue, error)
	GetQueues(ctx context.Context, in *StreamingQueueGetRequest, opts ...grpc.CallOption) (Submit_GetQueuesClient, error)
	Health(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type submitClient struct {
	cc *grpc.ClientConn
}

func NewSubmitClient(cc *grpc.ClientConn) SubmitClient {
	return &submitClient{cc}
}

func (c *submitClient) SubmitJobs(ctx context.Context, in *JobSubmitRequest, opts ...grpc.CallOption) (*JobSubmitResponse, error) {
	out := new(JobSubmitResponse)
	err := c.cc.Invoke(ctx, "/api.Submit/SubmitJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) CancelJobs(ctx context.Context, in *JobCancelRequest, opts ...grpc.CallOption) (*CancellationResult, error) {
	out := new(CancellationResult)
	err := c.cc.Invoke(ctx, "/api.Submit/CancelJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) CancelJobSet(ctx context.Context, in *JobSetCancelRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/api.Submit/CancelJobSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) ReprioritizeJobs(ctx context.Context, in *JobReprioritizeRequest, opts ...grpc.CallOption) (*JobReprioritizeResponse, error) {
	out := new(JobReprioritizeResponse)
	err := c.cc.Invoke(ctx, "/api.Submit/ReprioritizeJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) CreateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/api.Submit/CreateQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) CreateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueCreateResponse, error) {
	out := new(BatchQueueCreateResponse)
	err := c.cc.Invoke(ctx, "/api.Submit/CreateQueues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) UpdateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/api.Submit/UpdateQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) UpdateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueUpdateResponse, error) {
	out := new(BatchQueueUpdateResponse)
	err := c.cc.Invoke(ctx, "/api.Submit/UpdateQueues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) DeleteQueue(ctx context.Context, in *QueueDeleteRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/api.Submit/DeleteQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) GetQueue(ctx context.Context, in *QueueGetRequest, opts ...grpc.CallOption) (*Queue, error) {
	out := new(Queue)
	err := c.cc.Invoke(ctx, "/api.Submit/GetQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) GetQueues(ctx context.Context, in *StreamingQueueGetRequest, opts ...grpc.CallOption) (Submit_GetQueuesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Submit_serviceDesc.Streams[0], "/api.Submit/GetQueues", opts...)
	if err != nil {
		return nil, err
	}
	x := &submitGetQueuesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Submit_GetQueuesClient interface {
	Recv() (*StreamingQueueMessage, error)
	grpc.ClientStream
}

type submitGetQueuesClient struct {
	grpc.ClientStream
}

func (x *submitGetQueuesClient) Recv() (*StreamingQueueMessage, error) {
	m := new(StreamingQueueMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *submitClient) Health(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, "/api.Submit/Health", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubmitServer is the server API for Submit service.
type SubmitServer interface {
	SubmitJobs(context.Context, *JobSubmitRequest) (*JobSubmitResponse, error)
	CancelJobs(context.Context, *JobCancelRequest) (*CancellationResult, error)
	CancelJobSet(context.Context, *JobSetCancelRequest) (*types.Empty, error)
	ReprioritizeJobs(context.Context, *JobReprioritizeRequest) (*JobReprioritizeResponse, error)
	CreateQueue(context.Context, *Queue) (*types.Empty, error)
	CreateQueues(context.Context, *QueueList) (*BatchQueueCreateResponse, error)
	UpdateQueue(context.Context, *Queue) (*types.Empty, error)
	UpdateQueues(context.Context, *QueueList) (*BatchQueueUpdateResponse, error)
	DeleteQueue(context.Context, *QueueDeleteRequest) (*types.Empty, error)
	GetQueue(context.Context, *QueueGetRequest) (*Queue, error)
	GetQueues(*StreamingQueueGetRequest, Submit_GetQueuesServer) error
	Health(context.Context, *types.Empty) (*HealthCheckResponse, error)
}

// UnimplementedSubmitServer can be embedded to have forward compatible implementations.
type UnimplementedSubmitServer struct {
}

func (*UnimplementedSubmitServer) SubmitJobs(ctx context.Context, req *JobSubmitRequest) (*JobSubmitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitJobs not implemented")
}
func (*UnimplementedSubmitServer) CancelJobs(ctx context.Context, req *JobCancelRequest) (*CancellationResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJobs not implemented")
}
func (*UnimplementedSubmitServer) CancelJobSet(ctx context.Context, req *JobSetCancelRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJobSet not implemented")
}
func (*UnimplementedSubmitServer) ReprioritizeJobs(ctx context.Context, req *JobReprioritizeRequest) (*JobReprioritizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReprioritizeJobs not implemented")
}
func (*UnimplementedSubmitServer) CreateQueue(ctx context.Context, req *Queue) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQueue not implemented")
}
func (*UnimplementedSubmitServer) CreateQueues(ctx context.Context, req *QueueList) (*BatchQueueCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQueues not implemented")
}
func (*UnimplementedSubmitServer) UpdateQueue(ctx context.Context, req *Queue) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQueue not implemented")
}
func (*UnimplementedSubmitServer) UpdateQueues(ctx context.Context, req *QueueList) (*BatchQueueUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQueues not implemented")
}
func (*UnimplementedSubmitServer) DeleteQueue(ctx context.Context, req *QueueDeleteRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQueue not implemented")
}
func (*UnimplementedSubmitServer) GetQueue(ctx context.Context, req *QueueGetRequest) (*Queue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueue not implemented")
}
func (*UnimplementedSubmitServer) GetQueues(req *StreamingQueueGetRequest, srv Submit_GetQueuesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetQueues not implemented")
}
func (*UnimplementedSubmitServer) Health(ctx context.Context, req *types.Empty) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}

func RegisterSubmitServer(s *grpc.Server, srv SubmitServer) {
	s.RegisterService(&_Submit_serviceDesc, srv)
}

func _Submit_SubmitJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSubmitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).SubmitJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/SubmitJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).SubmitJobs(ctx, req.(*JobSubmitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_CancelJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).CancelJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/CancelJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).CancelJobs(ctx, req.(*JobCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_CancelJobSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSetCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).CancelJobSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/CancelJobSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).CancelJobSet(ctx, req.(*JobSetCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_ReprioritizeJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobReprioritizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).ReprioritizeJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/ReprioritizeJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).ReprioritizeJobs(ctx, req.(*JobReprioritizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_CreateQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Queue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).CreateQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/CreateQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).CreateQueue(ctx, req.(*Queue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_CreateQueues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).CreateQueues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/CreateQueues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).CreateQueues(ctx, req.(*QueueList))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_UpdateQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Queue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).UpdateQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/UpdateQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).UpdateQueue(ctx, req.(*Queue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_UpdateQueues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).UpdateQueues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/UpdateQueues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).UpdateQueues(ctx, req.(*QueueList))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_DeleteQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).DeleteQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/DeleteQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).DeleteQueue(ctx, req.(*QueueDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_GetQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).GetQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/GetQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).GetQueue(ctx, req.(*QueueGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_GetQueues_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamingQueueGetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubmitServer).GetQueues(m, &submitGetQueuesServer{stream})
}

type Submit_GetQueuesServer interface {
	Send(*StreamingQueueMessage) error
	grpc.ServerStream
}

type submitGetQueuesServer struct {
	grpc.ServerStream
}

func (x *submitGetQueuesServer) Send(m *StreamingQueueMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _Submit_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Submit/Health",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).Health(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Submit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Submit",
	HandlerType: (*SubmitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitJobs",
			Handler:    _Submit_SubmitJobs_Handler,
		},
		{
			MethodName: "CancelJobs",
			Handler:    _Submit_CancelJobs_Handler,
		},
		{
			MethodName: "CancelJobSet",
			Handler:    _Submit_CancelJobSet_Handler,
		},
		{
			MethodName: "ReprioritizeJobs",
			Handler:    _Submit_ReprioritizeJobs_Handler,
		},
		{
			MethodName: "CreateQueue",
			Handler:    _Submit_CreateQueue_Handler,
		},
		{
			MethodName: "CreateQueues",
			Handler:    _Submit_CreateQueues_Handler,
		},
		{
			MethodName: "UpdateQueue",
			Handler:    _Submit_UpdateQueue_Handler,
		},
		{
			MethodName: "UpdateQueues",
			Handler:    _Submit_UpdateQueues_Handler,
		},
		{
			MethodName: "DeleteQueue",
			Handler:    _Submit_DeleteQueue_Handler,
		},
		{
			MethodName: "GetQueue",
			Handler:    _Submit_GetQueue_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _Submit_Health_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetQueues",
			Handler:       _Submit_GetQueues_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/api/submit.proto",
}

func (m *JobSubmitRequestItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSubmitRequestItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSubmitRequestItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QueueTtlSeconds != 0 {
		i = encodeVarintSubmit(dAtA, i, uint64(m.QueueTtlSeconds))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Scheduler) > 0 {
		i -= len(m.Scheduler)
		copy(dAtA[i:], m.Scheduler)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Scheduler)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Services[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Ingress) > 0 {
		for iNdEx := len(m.Ingress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ingress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PodSpecs) > 0 {
		for iNdEx := len(m.PodSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PodSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RequiredNodeLabels) > 0 {
		for k := range m.RequiredNodeLabels {
			v := m.RequiredNodeLabels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSubmit(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSubmit(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSubmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSubmit(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSubmit(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSubmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSubmit(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSubmit(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSubmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PodSpec != nil {
		{
			size, err := m.PodSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Priority != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Priority))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *IngressConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngressConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseClusterIP {
		i--
		if m.UseClusterIP {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.CertName) > 0 {
		i -= len(m.CertName)
		copy(dAtA[i:], m.CertName)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.CertName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TlsEnabled {
		i--
		if m.TlsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSubmit(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSubmit(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSubmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Ports) > 0 {
		dAtA3 := make([]byte, len(m.Ports)*10)
		var j2 int
		for _, num := range m.Ports {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintSubmit(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintSubmit(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServiceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		dAtA5 := make([]byte, len(m.Ports)*10)
		var j4 int
		for _, num := range m.Ports {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintSubmit(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintSubmit(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *JobSubmitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSubmitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSubmitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobRequestItems) > 0 {
		for iNdEx := len(m.JobRequestItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JobRequestItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.JobSetId) > 0 {
		i -= len(m.JobSetId)
		copy(dAtA[i:], m.JobSetId)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.JobSetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobCancelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobCancelRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobCancelRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.JobIds) > 0 {
		for iNdEx := len(m.JobIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.JobIds[iNdEx])
			copy(dAtA[i:], m.JobIds[iNdEx])
			i = encodeVarintSubmit(dAtA, i, uint64(len(m.JobIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobSetId) > 0 {
		i -= len(m.JobSetId)
		copy(dAtA[i:], m.JobSetId)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.JobSetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobSetCancelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSetCancelRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSetCancelRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobSetId) > 0 {
		i -= len(m.JobSetId)
		copy(dAtA[i:], m.JobSetId)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.JobSetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobSetFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSetFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSetFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.States) > 0 {
		dAtA8 := make([]byte, len(m.States)*10)
		var j7 int
		for _, num := range m.States {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintSubmit(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Job) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QueueTtlSeconds != 0 {
		i = encodeVarintSubmit(dAtA, i, uint64(m.QueueTtlSeconds))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	{
		size, err := m.SchedulingResourceRequirements.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSubmit(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	if len(m.Scheduler) > 0 {
		i -= len(m.Scheduler)
		copy(dAtA[i:], m.Scheduler)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Scheduler)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.CompressedQueueOwnershipUserGroups) > 0 {
		i -= len(m.CompressedQueueOwnershipUserGroups)
		copy(dAtA[i:], m.CompressedQueueOwnershipUserGroups)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.CompressedQueueOwnershipUserGroups)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.K8SService) > 0 {
		for iNdEx := len(m.K8SService) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.K8SService[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.K8SIngress) > 0 {
		for iNdEx := len(m.K8SIngress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.K8SIngress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.Services) > 0 {
		for iNdEx := len(m.Services) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Services[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.QueueOwnershipUserGroups) > 0 {
		for iNdEx := len(m.QueueOwnershipUserGroups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QueueOwnershipUserGroups[iNdEx])
			copy(dAtA[i:], m.QueueOwnershipUserGroups[iNdEx])
			i = encodeVarintSubmit(dAtA, i, uint64(len(m.QueueOwnershipUserGroups[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.Ingress) > 0 {
		for iNdEx := len(m.Ingress) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ingress[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.PodSpecs) > 0 {
		for iNdEx := len(m.PodSpecs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PodSpecs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.RequiredNodeLabels) > 0 {
		for k := range m.RequiredNodeLabels {
			v := m.RequiredNodeLabels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSubmit(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSubmit(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSubmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSubmit(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSubmit(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSubmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSubmit(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSubmit(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSubmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x3a
	}
	n10, err10 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Created):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintSubmit(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x32
	if m.PodSpec != nil {
		{
			size, err := m.PodSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Priority != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Priority))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobSetId) > 0 {
		i -= len(m.JobSetId)
		copy(dAtA[i:], m.JobSetId)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.JobSetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobReprioritizeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobReprioritizeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobReprioritizeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewPriority != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.NewPriority))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobSetId) > 0 {
		i -= len(m.JobSetId)
		copy(dAtA[i:], m.JobSetId)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.JobSetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobIds) > 0 {
		for iNdEx := len(m.JobIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.JobIds[iNdEx])
			copy(dAtA[i:], m.JobIds[iNdEx])
			i = encodeVarintSubmit(dAtA, i, uint64(len(m.JobIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobReprioritizeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobReprioritizeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobReprioritizeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReprioritizationResults) > 0 {
		for k := range m.ReprioritizationResults {
			v := m.ReprioritizationResults[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSubmit(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSubmit(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSubmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobSubmitResponseItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSubmitResponseItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSubmitResponseItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobSubmitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSubmitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSubmitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobResponseItems) > 0 {
		for iNdEx := len(m.JobResponseItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JobResponseItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Queue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Queue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Queue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for iNdEx := len(m.Permissions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Permissions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ResourceLimits) > 0 {
		for k := range m.ResourceLimits {
			v := m.ResourceLimits[k]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSubmit(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSubmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.GroupOwners) > 0 {
		for iNdEx := len(m.GroupOwners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GroupOwners[iNdEx])
			copy(dAtA[i:], m.GroupOwners[iNdEx])
			i = encodeVarintSubmit(dAtA, i, uint64(len(m.GroupOwners[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UserOwners) > 0 {
		for iNdEx := len(m.UserOwners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UserOwners[iNdEx])
			copy(dAtA[i:], m.UserOwners[iNdEx])
			i = encodeVarintSubmit(dAtA, i, uint64(len(m.UserOwners[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.PriorityFactor != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PriorityFactor))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Queue_Permissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Queue_Permissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Queue_Permissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Verbs) > 0 {
		for iNdEx := len(m.Verbs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Verbs[iNdEx])
			copy(dAtA[i:], m.Verbs[iNdEx])
			i = encodeVarintSubmit(dAtA, i, uint64(len(m.Verbs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Subjects) > 0 {
		for iNdEx := len(m.Subjects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subjects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Queue_Permissions_Subject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Queue_Permissions_Subject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Queue_Permissions_Subject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueueList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Queues) > 0 {
		for iNdEx := len(m.Queues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Queues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CancellationResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancellationResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancellationResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CancelledIds) > 0 {
		for iNdEx := len(m.CancelledIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CancelledIds[iNdEx])
			copy(dAtA[i:], m.CancelledIds[iNdEx])
			i = encodeVarintSubmit(dAtA, i, uint64(len(m.CancelledIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueueGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamingQueueGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamingQueueGetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamingQueueGetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Num != 0 {
		i = encodeVarintSubmit(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueueDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueDeleteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobSetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSetInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeasedJobs != 0 {
		i = encodeVarintSubmit(dAtA, i, uint64(m.LeasedJobs))
		i--
		dAtA[i] = 0x18
	}
	if m.QueuedJobs != 0 {
		i = encodeVarintSubmit(dAtA, i, uint64(m.QueuedJobs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueueUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueUpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.Queue != nil {
		{
			size, err := m.Queue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchQueueUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchQueueUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchQueueUpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailedQueues) > 0 {
		for iNdEx := len(m.FailedQueues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FailedQueues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueueCreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueCreateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueCreateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintSubmit(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.Queue != nil {
		{
			size, err := m.Queue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchQueueCreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchQueueCreateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchQueueCreateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailedQueues) > 0 {
		for iNdEx := len(m.FailedQueues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FailedQueues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSubmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EndMarker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndMarker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EndMarker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *StreamingQueueMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamingQueueMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamingQueueMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StreamingQueueMessage_Queue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamingQueueMessage_Queue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Queue != nil {
		{
			size, err := m.Queue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StreamingQueueMessage_End) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamingQueueMessage_End) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSubmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func encodeVarintSubmit(dAtA []byte, offset int, v uint64) int {
	offset -= sovSubmit(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *JobSubmitRequestItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 9
	}
	if m.PodSpec != nil {
		l = m.PodSpec.Size()
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSubmit(uint64(len(k))) + 1 + len(v) + sovSubmit(uint64(len(v)))
			n += mapEntrySize + 1 + sovSubmit(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSubmit(uint64(len(k))) + 1 + len(v) + sovSubmit(uint64(len(v)))
			n += mapEntrySize + 1 + sovSubmit(uint64(mapEntrySize))
		}
	}
	if len(m.RequiredNodeLabels) > 0 {
		for k, v := range m.RequiredNodeLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSubmit(uint64(len(k))) + 1 + len(v) + sovSubmit(uint64(len(v)))
			n += mapEntrySize + 1 + sovSubmit(uint64(mapEntrySize))
		}
	}
	if len(m.PodSpecs) > 0 {
		for _, e := range m.PodSpecs {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	l = len(m.Scheduler)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if m.QueueTtlSeconds != 0 {
		n += 1 + sovSubmit(uint64(m.QueueTtlSeconds))
	}
	return n
}

func (m *IngressConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSubmit(uint64(m.Type))
	}
	if len(m.Ports) > 0 {
		l = 0
		for _, e := range m.Ports {
			l += sovSubmit(uint64(e))
		}
		n += 1 + sovSubmit(uint64(l)) + l
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSubmit(uint64(len(k))) + 1 + len(v) + sovSubmit(uint64(len(v)))
			n += mapEntrySize + 1 + sovSubmit(uint64(mapEntrySize))
		}
	}
	if m.TlsEnabled {
		n += 2
	}
	l = len(m.CertName)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if m.UseClusterIP {
		n += 2
	}
	return n
}

func (m *ServiceConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSubmit(uint64(m.Type))
	}
	if len(m.Ports) > 0 {
		l = 0
		for _, e := range m.Ports {
			l += sovSubmit(uint64(e))
		}
		n += 1 + sovSubmit(uint64(l)) + l
	}
	return n
}

func (m *JobSubmitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.JobSetId)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if len(m.JobRequestItems) > 0 {
		for _, e := range m.JobRequestItems {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	return n
}

func (m *JobCancelRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.JobSetId)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if len(m.JobIds) > 0 {
		for _, s := range m.JobIds {
			l = len(s)
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	return n
}

func (m *JobSetCancelRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobSetId)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	return n
}

func (m *JobSetFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.States) > 0 {
		l = 0
		for _, e := range m.States {
			l += sovSubmit(uint64(e))
		}
		n += 1 + sovSubmit(uint64(l)) + l
	}
	return n
}

func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.JobSetId)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if m.Priority != 0 {
		n += 9
	}
	if m.PodSpec != nil {
		l = m.PodSpec.Size()
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovSubmit(uint64(l))
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSubmit(uint64(len(k))) + 1 + len(v) + sovSubmit(uint64(len(v)))
			n += mapEntrySize + 1 + sovSubmit(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSubmit(uint64(len(k))) + 1 + len(v) + sovSubmit(uint64(len(v)))
			n += mapEntrySize + 1 + sovSubmit(uint64(mapEntrySize))
		}
	}
	if len(m.RequiredNodeLabels) > 0 {
		for k, v := range m.RequiredNodeLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSubmit(uint64(len(k))) + 1 + len(v) + sovSubmit(uint64(len(v)))
			n += mapEntrySize + 1 + sovSubmit(uint64(mapEntrySize))
		}
	}
	if len(m.PodSpecs) > 0 {
		for _, e := range m.PodSpecs {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	if len(m.QueueOwnershipUserGroups) > 0 {
		for _, s := range m.QueueOwnershipUserGroups {
			l = len(s)
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 2 + l + sovSubmit(uint64(l))
		}
	}
	if len(m.K8SIngress) > 0 {
		for _, e := range m.K8SIngress {
			l = e.Size()
			n += 2 + l + sovSubmit(uint64(l))
		}
	}
	if len(m.K8SService) > 0 {
		for _, e := range m.K8SService {
			l = e.Size()
			n += 2 + l + sovSubmit(uint64(l))
		}
	}
	l = len(m.CompressedQueueOwnershipUserGroups)
	if l > 0 {
		n += 2 + l + sovSubmit(uint64(l))
	}
	l = len(m.Scheduler)
	if l > 0 {
		n += 2 + l + sovSubmit(uint64(l))
	}
	l = m.SchedulingResourceRequirements.Size()
	n += 2 + l + sovSubmit(uint64(l))
	if m.QueueTtlSeconds != 0 {
		n += 2 + sovSubmit(uint64(m.QueueTtlSeconds))
	}
	return n
}

func (m *JobReprioritizeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobIds) > 0 {
		for _, s := range m.JobIds {
			l = len(s)
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	l = len(m.JobSetId)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if m.NewPriority != 0 {
		n += 9
	}
	return n
}

func (m *JobReprioritizeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ReprioritizationResults) > 0 {
		for k, v := range m.ReprioritizationResults {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSubmit(uint64(len(k))) + 1 + len(v) + sovSubmit(uint64(len(v)))
			n += mapEntrySize + 1 + sovSubmit(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *JobSubmitResponseItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	return n
}

func (m *JobSubmitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobResponseItems) > 0 {
		for _, e := range m.JobResponseItems {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	return n
}

func (m *Queue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if m.PriorityFactor != 0 {
		n += 9
	}
	if len(m.UserOwners) > 0 {
		for _, s := range m.UserOwners {
			l = len(s)
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	if len(m.GroupOwners) > 0 {
		for _, s := range m.GroupOwners {
			l = len(s)
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	if len(m.ResourceLimits) > 0 {
		for k, v := range m.ResourceLimits {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSubmit(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovSubmit(uint64(mapEntrySize))
		}
	}
	if len(m.Permissions) > 0 {
		for _, e := range m.Permissions {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	return n
}

func (m *Queue_Permissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Subjects) > 0 {
		for _, e := range m.Subjects {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	if len(m.Verbs) > 0 {
		for _, s := range m.Verbs {
			l = len(s)
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	return n
}

func (m *Queue_Permissions_Subject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	return n
}

func (m *QueueList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Queues) > 0 {
		for _, e := range m.Queues {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	return n
}

func (m *CancellationResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CancelledIds) > 0 {
		for _, s := range m.CancelledIds {
			l = len(s)
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	return n
}

func (m *QueueGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	return n
}

func (m *StreamingQueueGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Num != 0 {
		n += 1 + sovSubmit(uint64(m.Num))
	}
	return n
}

func (m *QueueDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	return n
}

func (m *JobSetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	if m.QueuedJobs != 0 {
		n += 1 + sovSubmit(uint64(m.QueuedJobs))
	}
	if m.LeasedJobs != 0 {
		n += 1 + sovSubmit(uint64(m.LeasedJobs))
	}
	return n
}

func (m *QueueUpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Queue != nil {
		l = m.Queue.Size()
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	return n
}

func (m *BatchQueueUpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FailedQueues) > 0 {
		for _, e := range m.FailedQueues {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	return n
}

func (m *QueueCreateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Queue != nil {
		l = m.Queue.Size()
		n += 1 + l + sovSubmit(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovSubmit(uint64(l))
	}
	return n
}

func (m *BatchQueueCreateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FailedQueues) > 0 {
		for _, e := range m.FailedQueues {
			l = e.Size()
			n += 1 + l + sovSubmit(uint64(l))
		}
	}
	return n
}

func (m *EndMarker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *StreamingQueueMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *StreamingQueueMessage_Queue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Queue != nil {
		l = m.Queue.Size()
		n += 1 + l + sovSubmit(uint64(l))
	}
	return n
}
func (m *StreamingQueueMessage_End) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovSubmit(uint64(l))
	}
	return n
}

func sovSubmit(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSubmit(x uint64) (n int) {
	return sovSubmit(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *JobSubmitRequestItem) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPodSpecs := "[]*PodSpec{"
	for _, f := range this.PodSpecs {
		repeatedStringForPodSpecs += strings.Replace(fmt.Sprintf("%v", f), "PodSpec", "v1.PodSpec", 1) + ","
	}
	repeatedStringForPodSpecs += "}"
	repeatedStringForIngress := "[]*IngressConfig{"
	for _, f := range this.Ingress {
		repeatedStringForIngress += strings.Replace(f.String(), "IngressConfig", "IngressConfig", 1) + ","
	}
	repeatedStringForIngress += "}"
	repeatedStringForServices := "[]*ServiceConfig{"
	for _, f := range this.Services {
		repeatedStringForServices += strings.Replace(f.String(), "ServiceConfig", "ServiceConfig", 1) + ","
	}
	repeatedStringForServices += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	keysForRequiredNodeLabels := make([]string, 0, len(this.RequiredNodeLabels))
	for k, _ := range this.RequiredNodeLabels {
		keysForRequiredNodeLabels = append(keysForRequiredNodeLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRequiredNodeLabels)
	mapStringForRequiredNodeLabels := "map[string]string{"
	for _, k := range keysForRequiredNodeLabels {
		mapStringForRequiredNodeLabels += fmt.Sprintf("%v: %v,", k, this.RequiredNodeLabels[k])
	}
	mapStringForRequiredNodeLabels += "}"
	s := strings.Join([]string{`&JobSubmitRequestItem{`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`PodSpec:` + strings.Replace(fmt.Sprintf("%v", this.PodSpec), "PodSpec", "v1.PodSpec", 1) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`RequiredNodeLabels:` + mapStringForRequiredNodeLabels + `,`,
		`PodSpecs:` + repeatedStringForPodSpecs + `,`,
		`ClientId:` + fmt.Sprintf("%v", this.ClientId) + `,`,
		`Ingress:` + repeatedStringForIngress + `,`,
		`Services:` + repeatedStringForServices + `,`,
		`Scheduler:` + fmt.Sprintf("%v", this.Scheduler) + `,`,
		`QueueTtlSeconds:` + fmt.Sprintf("%v", this.QueueTtlSeconds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IngressConfig) String() string {
	if this == nil {
		return "nil"
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&IngressConfig{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`TlsEnabled:` + fmt.Sprintf("%v", this.TlsEnabled) + `,`,
		`CertName:` + fmt.Sprintf("%v", this.CertName) + `,`,
		`UseClusterIP:` + fmt.Sprintf("%v", this.UseClusterIP) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceConfig{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobSubmitRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForJobRequestItems := "[]*JobSubmitRequestItem{"
	for _, f := range this.JobRequestItems {
		repeatedStringForJobRequestItems += strings.Replace(f.String(), "JobSubmitRequestItem", "JobSubmitRequestItem", 1) + ","
	}
	repeatedStringForJobRequestItems += "}"
	s := strings.Join([]string{`&JobSubmitRequest{`,
		`Queue:` + fmt.Sprintf("%v", this.Queue) + `,`,
		`JobSetId:` + fmt.Sprintf("%v", this.JobSetId) + `,`,
		`JobRequestItems:` + repeatedStringForJobRequestItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobCancelRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JobCancelRequest{`,
		`JobId:` + fmt.Sprintf("%v", this.JobId) + `,`,
		`JobSetId:` + fmt.Sprintf("%v", this.JobSetId) + `,`,
		`Queue:` + fmt.Sprintf("%v", this.Queue) + `,`,
		`JobIds:` + fmt.Sprintf("%v", this.JobIds) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobSetCancelRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JobSetCancelRequest{`,
		`JobSetId:` + fmt.Sprintf("%v", this.JobSetId) + `,`,
		`Queue:` + fmt.Sprintf("%v", this.Queue) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "JobSetFilter", "JobSetFilter", 1) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobSetFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JobSetFilter{`,
		`States:` + fmt.Sprintf("%v", this.States) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Job) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPodSpecs := "[]*PodSpec{"
	for _, f := range this.PodSpecs {
		repeatedStringForPodSpecs += strings.Replace(fmt.Sprintf("%v", f), "PodSpec", "v1.PodSpec", 1) + ","
	}
	repeatedStringForPodSpecs += "}"
	repeatedStringForIngress := "[]*IngressConfig{"
	for _, f := range this.Ingress {
		repeatedStringForIngress += strings.Replace(f.String(), "IngressConfig", "IngressConfig", 1) + ","
	}
	repeatedStringForIngress += "}"
	repeatedStringForServices := "[]*ServiceConfig{"
	for _, f := range this.Services {
		repeatedStringForServices += strings.Replace(f.String(), "ServiceConfig", "ServiceConfig", 1) + ","
	}
	repeatedStringForServices += "}"
	repeatedStringForK8SIngress := "[]*Ingress{"
	for _, f := range this.K8SIngress {
		repeatedStringForK8SIngress += strings.Replace(fmt.Sprintf("%v", f), "Ingress", "v11.Ingress", 1) + ","
	}
	repeatedStringForK8SIngress += "}"
	repeatedStringForK8SService := "[]*Service{"
	for _, f := range this.K8SService {
		repeatedStringForK8SService += strings.Replace(fmt.Sprintf("%v", f), "Service", "v1.Service", 1) + ","
	}
	repeatedStringForK8SService += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	keysForRequiredNodeLabels := make([]string, 0, len(this.RequiredNodeLabels))
	for k, _ := range this.RequiredNodeLabels {
		keysForRequiredNodeLabels = append(keysForRequiredNodeLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForRequiredNodeLabels)
	mapStringForRequiredNodeLabels := "map[string]string{"
	for _, k := range keysForRequiredNodeLabels {
		mapStringForRequiredNodeLabels += fmt.Sprintf("%v: %v,", k, this.RequiredNodeLabels[k])
	}
	mapStringForRequiredNodeLabels += "}"
	s := strings.Join([]string{`&Job{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`JobSetId:` + fmt.Sprintf("%v", this.JobSetId) + `,`,
		`Queue:` + fmt.Sprintf("%v", this.Queue) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`PodSpec:` + strings.Replace(fmt.Sprintf("%v", this.PodSpec), "PodSpec", "v1.PodSpec", 1) + `,`,
		`Created:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Created), "Timestamp", "types.Timestamp", 1), `&`, ``, 1) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Owner:` + fmt.Sprintf("%v", this.Owner) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`RequiredNodeLabels:` + mapStringForRequiredNodeLabels + `,`,
		`PodSpecs:` + repeatedStringForPodSpecs + `,`,
		`ClientId:` + fmt.Sprintf("%v", this.ClientId) + `,`,
		`Ingress:` + repeatedStringForIngress + `,`,
		`QueueOwnershipUserGroups:` + fmt.Sprintf("%v", this.QueueOwnershipUserGroups) + `,`,
		`Services:` + repeatedStringForServices + `,`,
		`K8SIngress:` + repeatedStringForK8SIngress + `,`,
		`K8SService:` + repeatedStringForK8SService + `,`,
		`CompressedQueueOwnershipUserGroups:` + fmt.Sprintf("%v", this.CompressedQueueOwnershipUserGroups) + `,`,
		`Scheduler:` + fmt.Sprintf("%v", this.Scheduler) + `,`,
		`SchedulingResourceRequirements:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.SchedulingResourceRequirements), "ResourceRequirements", "v1.ResourceRequirements", 1), `&`, ``, 1) + `,`,
		`QueueTtlSeconds:` + fmt.Sprintf("%v", this.QueueTtlSeconds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobReprioritizeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JobReprioritizeRequest{`,
		`JobIds:` + fmt.Sprintf("%v", this.JobIds) + `,`,
		`JobSetId:` + fmt.Sprintf("%v", this.JobSetId) + `,`,
		`Queue:` + fmt.Sprintf("%v", this.Queue) + `,`,
		`NewPriority:` + fmt.Sprintf("%v", this.NewPriority) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobReprioritizeResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForReprioritizationResults := make([]string, 0, len(this.ReprioritizationResults))
	for k, _ := range this.ReprioritizationResults {
		keysForReprioritizationResults = append(keysForReprioritizationResults, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForReprioritizationResults)
	mapStringForReprioritizationResults := "map[string]string{"
	for _, k := range keysForReprioritizationResults {
		mapStringForReprioritizationResults += fmt.Sprintf("%v: %v,", k, this.ReprioritizationResults[k])
	}
	mapStringForReprioritizationResults += "}"
	s := strings.Join([]string{`&JobReprioritizeResponse{`,
		`ReprioritizationResults:` + mapStringForReprioritizationResults + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobSubmitResponseItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JobSubmitResponseItem{`,
		`JobId:` + fmt.Sprintf("%v", this.JobId) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobSubmitResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForJobResponseItems := "[]*JobSubmitResponseItem{"
	for _, f := range this.JobResponseItems {
		repeatedStringForJobResponseItems += strings.Replace(f.String(), "JobSubmitResponseItem", "JobSubmitResponseItem", 1) + ","
	}
	repeatedStringForJobResponseItems += "}"
	s := strings.Join([]string{`&JobSubmitResponse{`,
		`JobResponseItems:` + repeatedStringForJobResponseItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *Queue) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPermissions := "[]*Queue_Permissions{"
	for _, f := range this.Permissions {
		repeatedStringForPermissions += strings.Replace(fmt.Sprintf("%v", f), "Queue_Permissions", "Queue_Permissions", 1) + ","
	}
	repeatedStringForPermissions += "}"
	keysForResourceLimits := make([]string, 0, len(this.ResourceLimits))
	for k, _ := range this.ResourceLimits {
		keysForResourceLimits = append(keysForResourceLimits, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForResourceLimits)
	mapStringForResourceLimits := "map[string]float64{"
	for _, k := range keysForResourceLimits {
		mapStringForResourceLimits += fmt.Sprintf("%v: %v,", k, this.ResourceLimits[k])
	}
	mapStringForResourceLimits += "}"
	s := strings.Join([]string{`&Queue{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`PriorityFactor:` + fmt.Sprintf("%v", this.PriorityFactor) + `,`,
		`UserOwners:` + fmt.Sprintf("%v", this.UserOwners) + `,`,
		`GroupOwners:` + fmt.Sprintf("%v", this.GroupOwners) + `,`,
		`ResourceLimits:` + mapStringForResourceLimits + `,`,
		`Permissions:` + repeatedStringForPermissions + `,`,
		`}`,
	}, "")
	return s
}
func (this *Queue_Permissions) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubjects := "[]*Queue_Permissions_Subject{"
	for _, f := range this.Subjects {
		repeatedStringForSubjects += strings.Replace(fmt.Sprintf("%v", f), "Queue_Permissions_Subject", "Queue_Permissions_Subject", 1) + ","
	}
	repeatedStringForSubjects += "}"
	s := strings.Join([]string{`&Queue_Permissions{`,
		`Subjects:` + repeatedStringForSubjects + `,`,
		`Verbs:` + fmt.Sprintf("%v", this.Verbs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Queue_Permissions_Subject) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Queue_Permissions_Subject{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForQueues := "[]*Queue{"
	for _, f := range this.Queues {
		repeatedStringForQueues += strings.Replace(f.String(), "Queue", "Queue", 1) + ","
	}
	repeatedStringForQueues += "}"
	s := strings.Join([]string{`&QueueList{`,
		`Queues:` + repeatedStringForQueues + `,`,
		`}`,
	}, "")
	return s
}
func (this *CancellationResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CancellationResult{`,
		`CancelledIds:` + fmt.Sprintf("%v", this.CancelledIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueGetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueGetRequest{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamingQueueGetRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamingQueueGetRequest{`,
		`Num:` + fmt.Sprintf("%v", this.Num) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueDeleteRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueDeleteRequest{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JobSetInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JobSetInfo{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`QueuedJobs:` + fmt.Sprintf("%v", this.QueuedJobs) + `,`,
		`LeasedJobs:` + fmt.Sprintf("%v", this.LeasedJobs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueUpdateResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueUpdateResponse{`,
		`Queue:` + strings.Replace(this.Queue.String(), "Queue", "Queue", 1) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BatchQueueUpdateResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFailedQueues := "[]*QueueUpdateResponse{"
	for _, f := range this.FailedQueues {
		repeatedStringForFailedQueues += strings.Replace(f.String(), "QueueUpdateResponse", "QueueUpdateResponse", 1) + ","
	}
	repeatedStringForFailedQueues += "}"
	s := strings.Join([]string{`&BatchQueueUpdateResponse{`,
		`FailedQueues:` + repeatedStringForFailedQueues + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueCreateResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueCreateResponse{`,
		`Queue:` + strings.Replace(this.Queue.String(), "Queue", "Queue", 1) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BatchQueueCreateResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFailedQueues := "[]*QueueCreateResponse{"
	for _, f := range this.FailedQueues {
		repeatedStringForFailedQueues += strings.Replace(f.String(), "QueueCreateResponse", "QueueCreateResponse", 1) + ","
	}
	repeatedStringForFailedQueues += "}"
	s := strings.Join([]string{`&BatchQueueCreateResponse{`,
		`FailedQueues:` + repeatedStringForFailedQueues + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndMarker) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndMarker{`,
		`}`,
	}, "")
	return s
}
func (this *StreamingQueueMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamingQueueMessage{`,
		`Event:` + fmt.Sprintf("%v", this.Event) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamingQueueMessage_Queue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamingQueueMessage_Queue{`,
		`Queue:` + strings.Replace(fmt.Sprintf("%v", this.Queue), "Queue", "Queue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamingQueueMessage_End) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamingQueueMessage_End{`,
		`End:` + strings.Replace(fmt.Sprintf("%v", this.End), "EndMarker", "EndMarker", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSubmit(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *JobSubmitRequestItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSubmitRequestItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSubmitRequestItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Priority = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodSpec == nil {
				m.PodSpec = &v1.PodSpec{}
			}
			if err := m.PodSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSubmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSubmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSubmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSubmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredNodeLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequiredNodeLabels == nil {
				m.RequiredNodeLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSubmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSubmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequiredNodeLabels[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodSpecs = append(m.PodSpecs, &v1.PodSpec{})
			if err := m.PodSpecs[len(m.PodSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &IngressConfig{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &ServiceConfig{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheduler = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueTtlSeconds", wireType)
			}
			m.QueueTtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueTtlSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= IngressType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ports = append(m.Ports, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSubmit
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSubmit
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ports) == 0 {
					m.Ports = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ports = append(m.Ports, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSubmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSubmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TlsEnabled = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseClusterIP", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseClusterIP = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ServiceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ports = append(m.Ports, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSubmit
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSubmit
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ports) == 0 {
					m.Ports = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ports = append(m.Ports, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSubmitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSubmitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSubmitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRequestItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobRequestItems = append(m.JobRequestItems, &JobSubmitRequestItem{})
			if err := m.JobRequestItems[len(m.JobRequestItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobCancelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobCancelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobCancelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobIds = append(m.JobIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSetCancelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSetCancelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSetCancelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &JobSetFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSetFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSetFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSetFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v JobState
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= JobState(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.States = append(m.States, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSubmit
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSubmit
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.States) == 0 {
					m.States = make([]JobState, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v JobState
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= JobState(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.States = append(m.States, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Priority = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodSpec == nil {
				m.PodSpec = &v1.PodSpec{}
			}
			if err := m.PodSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSubmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSubmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSubmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSubmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredNodeLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequiredNodeLabels == nil {
				m.RequiredNodeLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSubmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSubmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RequiredNodeLabels[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpecs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodSpecs = append(m.PodSpecs, &v1.PodSpec{})
			if err := m.PodSpecs[len(m.PodSpecs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &IngressConfig{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueOwnershipUserGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueOwnershipUserGroups = append(m.QueueOwnershipUserGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &ServiceConfig{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SIngress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K8SIngress = append(m.K8SIngress, &v11.Ingress{})
			if err := m.K8SIngress[len(m.K8SIngress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SService", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K8SService = append(m.K8SService, &v1.Service{})
			if err := m.K8SService[len(m.K8SService)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressedQueueOwnershipUserGroups", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompressedQueueOwnershipUserGroups = append(m.CompressedQueueOwnershipUserGroups[:0], dAtA[iNdEx:postIndex]...)
			if m.CompressedQueueOwnershipUserGroups == nil {
				m.CompressedQueueOwnershipUserGroups = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheduler = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingResourceRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SchedulingResourceRequirements.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueTtlSeconds", wireType)
			}
			m.QueueTtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueTtlSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobReprioritizeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobReprioritizeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobReprioritizeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobIds = append(m.JobIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPriority", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.NewPriority = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobReprioritizeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobReprioritizeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobReprioritizeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReprioritizationResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReprioritizationResults == nil {
				m.ReprioritizationResults = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSubmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSubmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReprioritizationResults[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSubmitResponseItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSubmitResponseItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSubmitResponseItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSubmitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSubmitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSubmitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobResponseItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobResponseItems = append(m.JobResponseItems, &JobSubmitResponseItem{})
			if err := m.JobResponseItems[len(m.JobResponseItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Queue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Queue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Queue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityFactor", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PriorityFactor = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserOwners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserOwners = append(m.UserOwners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupOwners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupOwners = append(m.GroupOwners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSubmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSubmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSubmit
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSubmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSubmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResourceLimits[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permissions = append(m.Permissions, &Queue_Permissions{})
			if err := m.Permissions[len(m.Permissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Queue_Permissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Permissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Permissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subjects = append(m.Subjects, &Queue_Permissions_Subject{})
			if err := m.Subjects[len(m.Subjects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Verbs = append(m.Verbs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Queue_Permissions_Subject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queues = append(m.Queues, &Queue{})
			if err := m.Queues[len(m.Queues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancellationResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancellationResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancellationResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelledIds = append(m.CancelledIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamingQueueGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamingQueueGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamingQueueGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueuedJobs", wireType)
			}
			m.QueuedJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueuedJobs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasedJobs", wireType)
			}
			m.LeasedJobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeasedJobs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Queue == nil {
				m.Queue = &Queue{}
			}
			if err := m.Queue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchQueueUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchQueueUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchQueueUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedQueues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedQueues = append(m.FailedQueues, &QueueUpdateResponse{})
			if err := m.FailedQueues[len(m.FailedQueues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueCreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueCreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueCreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Queue == nil {
				m.Queue = &Queue{}
			}
			if err := m.Queue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchQueueCreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchQueueCreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchQueueCreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedQueues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedQueues = append(m.FailedQueues, &QueueCreateResponse{})
			if err := m.FailedQueues[len(m.FailedQueues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndMarker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndMarker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndMarker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamingQueueMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamingQueueMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamingQueueMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Queue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StreamingQueueMessage_Queue{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSubmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSubmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndMarker{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StreamingQueueMessage_End{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSubmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSubmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSubmit(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSubmit
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSubmit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSubmit
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSubmit
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSubmit
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSubmit        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSubmit          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSubmit = fmt.Errorf("proto: unexpected end of group")
)
