// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/api/testspec.proto

package api

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Action type for jobs in this spec.
type TestSpec_ActionType int32

const (
	TestSpec_ACTION_NONE    TestSpec_ActionType = 0
	TestSpec_ACTION_CANCEL  TestSpec_ActionType = 1
	TestSpec_ACTION_PREEMPT TestSpec_ActionType = 2
)

var TestSpec_ActionType_name = map[int32]string{
	0: "ACTION_NONE",
	1: "ACTION_CANCEL",
	2: "ACTION_PREEMPT",
}

var TestSpec_ActionType_value = map[string]int32{
	"ACTION_NONE":    0,
	"ACTION_CANCEL":  1,
	"ACTION_PREEMPT": 2,
}

func (x TestSpec_ActionType) String() string {
	return proto.EnumName(TestSpec_ActionType_name, int32(x))
}

func (TestSpec_ActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38d601305b414287, []int{0, 0}
}

// Selection method for the action.
type TestSpec_SelectionType int32

const (
	TestSpec_SELECTION_NO     TestSpec_SelectionType = 0
	TestSpec_SELECTION_BY_ID  TestSpec_SelectionType = 1
	TestSpec_SELECTION_BY_SET TestSpec_SelectionType = 2
	TestSpec_SELECTION_BY_IDS TestSpec_SelectionType = 3
)

var TestSpec_SelectionType_name = map[int32]string{
	0: "SELECTION_NO",
	1: "SELECTION_BY_ID",
	2: "SELECTION_BY_SET",
	3: "SELECTION_BY_IDS",
}

var TestSpec_SelectionType_value = map[string]int32{
	"SELECTION_NO":     0,
	"SELECTION_BY_ID":  1,
	"SELECTION_BY_SET": 2,
	"SELECTION_BY_IDS": 3,
}

func (x TestSpec_SelectionType) String() string {
	return proto.EnumName(TestSpec_SelectionType_name, int32(x))
}

func (TestSpec_SelectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38d601305b414287, []int{0, 1}
}

// Defines a test case for the Armada test suite.
// Defined as a proto message to enable unmarshalling oneof fields.
type TestSpec struct {
	// Jobs to submit.
	// The n jobs herein are copied BatchSize times to produce n*BatchSize jobs.
	// A batch of n*BatchSize such jobs are submitted in each API call.
	// NumBatches such batches are submitted in total.
	Jobs []*JobSubmitRequestItem `protobuf:"bytes,1,rep,name=jobs,proto3" json:"jobs,omitempty"`
	// Events expected in response to submitting each job.
	ExpectedEvents []*EventMessage `protobuf:"bytes,2,rep,name=expected_events,json=expectedEvents,proto3" json:"expectedEvents,omitempty"`
	// Queue to submit jobs to.
	Queue string `protobuf:"bytes,3,opt,name=queue,proto3" json:"queue,omitempty"`
	// Job set to submit jobs to.
	JobSetId string `protobuf:"bytes,4,opt,name=job_set_id,json=jobSetId,proto3" json:"jobSetId,omitempty"`
	// Number of batches of jobs to submit.
	// If 0, will submit forever.
	NumBatches uint32 `protobuf:"varint,5,opt,name=num_batches,json=numBatches,proto3" json:"numBatches,omitempty"`
	// Number of copies of the provided jobs to submit per batch.
	BatchSize uint32 `protobuf:"varint,6,opt,name=batch_size,json=batchSize,proto3" json:"batchSize,omitempty"`
	// Time between batches.
	// If 0, jobs are submitted as quickly as possible.
	Interval *types.Duration `protobuf:"bytes,7,opt,name=interval,proto3" json:"interval,omitempty"`
	// Number of seconds to wait for jobs to finish.
	Timeout   *types.Duration        `protobuf:"bytes,8,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Action    TestSpec_ActionType    `protobuf:"varint,9,opt,name=action,proto3,enum=api.TestSpec_ActionType" json:"action,omitempty"`
	Selection TestSpec_SelectionType `protobuf:"varint,17,opt,name=selection,proto3,enum=api.TestSpec_SelectionType" json:"selection,omitempty"`
	// Reason for preempting jobs (if preemption is configured).
	PreemptReason string `protobuf:"bytes,16,opt,name=preempt_reason,json=preemptReason,proto3" json:"preemptReason,omitempty"`
	// Test name. Defaults to the filename if not provided.
	Name string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	// Randomize clientId if not provided
	RandomClientId bool `protobuf:"varint,11,opt,name=random_client_id,json=randomClientId,proto3" json:"randomClientId,omitempty"`
	// Toggle should testsuite scrape Armada Job (pod) logs
	GetLogs bool `protobuf:"varint,12,opt,name=get_logs,json=getLogs,proto3" json:"getLogs,omitempty"`
	// Value of the environment label set on exported Prometheus metrics.
	Environment string `protobuf:"bytes,13,opt,name=environment,proto3" json:"environment,omitempty"`
	// Value of the target label set on exported Prometheus metrics.
	Target string `protobuf:"bytes,14,opt,name=target,proto3" json:"target,omitempty"`
}

func (m *TestSpec) Reset()         { *m = TestSpec{} }
func (m *TestSpec) String() string { return proto.CompactTextString(m) }
func (*TestSpec) ProtoMessage()    {}
func (*TestSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d601305b414287, []int{0}
}
func (m *TestSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSpec.Merge(m, src)
}
func (m *TestSpec) XXX_Size() int {
	return m.Size()
}
func (m *TestSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TestSpec proto.InternalMessageInfo

func (m *TestSpec) GetJobs() []*JobSubmitRequestItem {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *TestSpec) GetExpectedEvents() []*EventMessage {
	if m != nil {
		return m.ExpectedEvents
	}
	return nil
}

func (m *TestSpec) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *TestSpec) GetJobSetId() string {
	if m != nil {
		return m.JobSetId
	}
	return ""
}

func (m *TestSpec) GetNumBatches() uint32 {
	if m != nil {
		return m.NumBatches
	}
	return 0
}

func (m *TestSpec) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *TestSpec) GetInterval() *types.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *TestSpec) GetTimeout() *types.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *TestSpec) GetAction() TestSpec_ActionType {
	if m != nil {
		return m.Action
	}
	return TestSpec_ACTION_NONE
}

func (m *TestSpec) GetSelection() TestSpec_SelectionType {
	if m != nil {
		return m.Selection
	}
	return TestSpec_SELECTION_NO
}

func (m *TestSpec) GetPreemptReason() string {
	if m != nil {
		return m.PreemptReason
	}
	return ""
}

func (m *TestSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TestSpec) GetRandomClientId() bool {
	if m != nil {
		return m.RandomClientId
	}
	return false
}

func (m *TestSpec) GetGetLogs() bool {
	if m != nil {
		return m.GetLogs
	}
	return false
}

func (m *TestSpec) GetEnvironment() string {
	if m != nil {
		return m.Environment
	}
	return ""
}

func (m *TestSpec) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func init() {
	proto.RegisterEnum("api.TestSpec_ActionType", TestSpec_ActionType_name, TestSpec_ActionType_value)
	proto.RegisterEnum("api.TestSpec_SelectionType", TestSpec_SelectionType_name, TestSpec_SelectionType_value)
	proto.RegisterType((*TestSpec)(nil), "api.TestSpec")
}

func init() { proto.RegisterFile("pkg/api/testspec.proto", fileDescriptor_38d601305b414287) }

var fileDescriptor_38d601305b414287 = []byte{
	// 758 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0xc1, 0x6e, 0xe2, 0x46,
	0x1c, 0xc6, 0x31, 0x64, 0x09, 0x0c, 0x0b, 0x98, 0x81, 0xdd, 0x9d, 0xdd, 0xad, 0x30, 0xca, 0xa1,
	0xa5, 0xd2, 0xca, 0x54, 0xdb, 0xaa, 0x52, 0xd5, 0x13, 0x06, 0xaf, 0xc4, 0x2a, 0x21, 0x11, 0xe6,
	0x90, 0xf6, 0x62, 0xd9, 0xe6, 0x5f, 0xc7, 0x14, 0x7b, 0x1c, 0x7b, 0x1c, 0x35, 0x79, 0x8a, 0x3e,
	0x47, 0xa5, 0xbe, 0x47, 0x8f, 0x39, 0xf6, 0x64, 0x55, 0xc9, 0xcd, 0x4f, 0x51, 0x31, 0xb6, 0x93,
	0x41, 0x3d, 0xf4, 0x38, 0xbf, 0xef, 0xff, 0x7d, 0xd8, 0xf3, 0xfd, 0x31, 0x7a, 0x1d, 0xfe, 0xea,
	0x4e, 0xac, 0xd0, 0x9b, 0x30, 0x88, 0x59, 0x1c, 0x82, 0xa3, 0x86, 0x11, 0x65, 0x14, 0xd7, 0xac,
	0xd0, 0x7b, 0x37, 0x74, 0x29, 0x75, 0x77, 0x30, 0xe1, 0xc8, 0x4e, 0x7e, 0x99, 0x6c, 0x92, 0xc8,
	0x62, 0x1e, 0x0d, 0xf2, 0xa1, 0x77, 0x83, 0xd2, 0x1c, 0x27, 0xb6, 0xef, 0xb1, 0x82, 0xf6, 0x4b,
	0x0a, 0x37, 0x10, 0x14, 0xf0, 0xe4, 0xcf, 0x26, 0x6a, 0xac, 0x21, 0x66, 0x46, 0x08, 0x0e, 0x9e,
	0xa2, 0xa3, 0x2d, 0xb5, 0x63, 0x22, 0x8d, 0x6a, 0xe3, 0xd6, 0xc7, 0xb7, 0xaa, 0x15, 0x7a, 0xea,
	0x67, 0x6a, 0x1b, 0x3c, 0x65, 0x05, 0xd7, 0x09, 0xc4, 0x6c, 0xc1, 0xc0, 0xd7, 0x70, 0x96, 0x2a,
	0x9d, 0xfd, 0xe8, 0x07, 0xea, 0x7b, 0x0c, 0xfc, 0x90, 0xdd, 0xae, 0xb8, 0x15, 0x5f, 0xa2, 0x2e,
	0xfc, 0x16, 0x82, 0xc3, 0x60, 0x63, 0xf2, 0xdf, 0x89, 0x49, 0x95, 0xa7, 0xf5, 0x78, 0x9a, 0xbe,
	0x47, 0x67, 0x10, 0xc7, 0x96, 0x0b, 0xda, 0x17, 0x59, 0xaa, 0x90, 0x72, 0x9a, 0x2b, 0x62, 0x5e,
	0xe7, 0x50, 0xc1, 0x5f, 0xa3, 0x17, 0xd7, 0x09, 0x24, 0x40, 0x6a, 0x23, 0x69, 0xdc, 0xd4, 0xfa,
	0x59, 0xaa, 0x74, 0x39, 0x10, 0x3c, 0xf9, 0x04, 0xfe, 0x0e, 0xa1, 0x2d, 0xb5, 0xcd, 0x18, 0x98,
	0xe9, 0x6d, 0xc8, 0x11, 0x9f, 0x7f, 0x9d, 0xa5, 0x0a, 0xde, 0x52, 0xdb, 0x00, 0xb6, 0xd8, 0x08,
	0x96, 0x46, 0xc9, 0xf0, 0x0f, 0xa8, 0x15, 0x24, 0xbe, 0x69, 0x5b, 0xcc, 0xb9, 0x82, 0x98, 0xbc,
	0x18, 0x49, 0xe3, 0xb6, 0x46, 0xb2, 0x54, 0x19, 0x04, 0x89, 0xaf, 0xe5, 0x54, 0x30, 0xa2, 0x67,
	0x8a, 0xbf, 0x47, 0x88, 0xdb, 0xcc, 0xd8, 0xbb, 0x03, 0x52, 0xe7, 0xce, 0x37, 0x59, 0xaa, 0xf4,
	0x39, 0x35, 0xbc, 0x3b, 0xf1, 0x21, 0x9b, 0x4f, 0x10, 0x9f, 0xa1, 0x86, 0x17, 0x30, 0x88, 0x6e,
	0xac, 0x1d, 0x39, 0x1e, 0x49, 0xfc, 0xd2, 0xf3, 0x6e, 0xd5, 0xb2, 0x5b, 0x75, 0x5e, 0x74, 0x9b,
	0xbf, 0x41, 0x39, 0x2e, 0xbe, 0x41, 0xc9, 0xf0, 0x67, 0x74, 0xcc, 0x3c, 0x1f, 0x68, 0xc2, 0x48,
	0xe3, 0xff, 0xd2, 0x5e, 0x65, 0xa9, 0xd2, 0x2b, 0xa6, 0x85, 0xb0, 0x32, 0x00, 0x7f, 0x42, 0x75,
	0xcb, 0xd9, 0x4f, 0x92, 0xe6, 0x48, 0x1a, 0x77, 0x3e, 0x12, 0xde, 0x5f, 0xb9, 0x2a, 0xea, 0x94,
	0x6b, 0xeb, 0xdb, 0x10, 0xb4, 0x41, 0x96, 0x2a, 0x72, 0x3e, 0x2b, 0x04, 0x15, 0x6e, 0xbc, 0x42,
	0xcd, 0x18, 0x76, 0x90, 0x47, 0xf5, 0x78, 0xd4, 0xfb, 0xc3, 0x28, 0xa3, 0x94, 0x79, 0x1a, 0xbf,
	0xb6, 0x27, 0x87, 0x78, 0x6d, 0x4f, 0x10, 0x6b, 0xa8, 0x13, 0x46, 0xb0, 0xc7, 0x66, 0x04, 0x56,
	0x4c, 0x03, 0x22, 0xf3, 0x8e, 0xdf, 0x67, 0xa9, 0xf2, 0xa6, 0x50, 0x56, 0x5c, 0x10, 0xfc, 0xed,
	0x03, 0x01, 0x7f, 0x89, 0x8e, 0x02, 0xcb, 0x07, 0x82, 0xb8, 0x93, 0x2f, 0xf4, 0xfe, 0x2c, 0x2e,
	0xf4, 0xfe, 0x8c, 0x3f, 0x21, 0x39, 0xb2, 0x82, 0x0d, 0xf5, 0x4d, 0x67, 0xe7, 0x41, 0xc0, 0x37,
	0xaa, 0x35, 0x92, 0xc6, 0x8d, 0x7c, 0x7d, 0x73, 0x6d, 0xc6, 0xa5, 0x83, 0xbd, 0xea, 0x1c, 0x2a,
	0xf8, 0x1b, 0xd4, 0x70, 0x81, 0x99, 0x3b, 0xea, 0xc6, 0xe4, 0x25, 0xf7, 0xf3, 0x06, 0x5c, 0x60,
	0xa7, 0xd4, 0x15, 0xf7, 0xea, 0xb8, 0x40, 0xf8, 0x47, 0xd4, 0x82, 0xe0, 0xc6, 0x8b, 0x68, 0xe0,
	0x43, 0xc0, 0x48, 0x9b, 0x3f, 0xe8, 0xdb, 0x2c, 0x55, 0x5e, 0x09, 0x58, 0x30, 0x8a, 0xd3, 0xf8,
	0x03, 0xaa, 0x33, 0x2b, 0x72, 0x81, 0x91, 0x0e, 0xf7, 0xf1, 0x92, 0x72, 0x22, 0x96, 0x94, 0x93,
	0x93, 0x39, 0x42, 0xcf, 0x85, 0xe2, 0x2e, 0x6a, 0x4d, 0x67, 0xeb, 0xc5, 0xf9, 0xd2, 0x5c, 0x9e,
	0x2f, 0x75, 0xb9, 0x82, 0x7b, 0xa8, 0x5d, 0x80, 0xd9, 0x74, 0x39, 0xd3, 0x4f, 0x65, 0x09, 0x63,
	0xd4, 0x29, 0xd0, 0xc5, 0x4a, 0xd7, 0xcf, 0x2e, 0xd6, 0x72, 0xf5, 0xc4, 0x46, 0xed, 0x83, 0x2e,
	0xb1, 0x8c, 0x5e, 0x1a, 0xfa, 0xa9, 0x5e, 0x66, 0xc9, 0x15, 0xdc, 0x47, 0xdd, 0x67, 0xa2, 0xfd,
	0x64, 0x2e, 0xe6, 0xb2, 0x84, 0x07, 0x48, 0x3e, 0x80, 0x86, 0xbe, 0x96, 0xab, 0xff, 0xa1, 0x8b,
	0xb9, 0x21, 0xd7, 0xb4, 0xcb, 0xbf, 0x1e, 0x86, 0xd2, 0xfd, 0xc3, 0x50, 0xfa, 0xe7, 0x61, 0x28,
	0xfd, 0xfe, 0x38, 0xac, 0xdc, 0x3f, 0x0e, 0x2b, 0x7f, 0x3f, 0x0e, 0x2b, 0x3f, 0x7f, 0xe5, 0x7a,
	0xec, 0x2a, 0xb1, 0x55, 0x87, 0xfa, 0x13, 0x2b, 0xf2, 0xad, 0x8d, 0x15, 0x46, 0x74, 0x0b, 0x0e,
	0x2b, 0x4e, 0x93, 0xe2, 0xf3, 0xf7, 0x47, 0x75, 0x30, 0xe5, 0xe0, 0x22, 0x97, 0xd5, 0x05, 0x55,
	0xa7, 0xa1, 0x67, 0xd7, 0xf9, 0x7f, 0xe4, 0xdb, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x35, 0xe3,
	0x4c, 0x4f, 0x7a, 0x05, 0x00, 0x00,
}

func (m *TestSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Selection != 0 {
		i = encodeVarintTestspec(dAtA, i, uint64(m.Selection))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.PreemptReason) > 0 {
		i -= len(m.PreemptReason)
		copy(dAtA[i:], m.PreemptReason)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.PreemptReason)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Environment) > 0 {
		i -= len(m.Environment)
		copy(dAtA[i:], m.Environment)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.Environment)))
		i--
		dAtA[i] = 0x6a
	}
	if m.GetLogs {
		i--
		if m.GetLogs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.RandomClientId {
		i--
		if m.RandomClientId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if m.Action != 0 {
		i = encodeVarintTestspec(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x48
	}
	if m.Timeout != nil {
		{
			size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestspec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Interval != nil {
		{
			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestspec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BatchSize != 0 {
		i = encodeVarintTestspec(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x30
	}
	if m.NumBatches != 0 {
		i = encodeVarintTestspec(dAtA, i, uint64(m.NumBatches))
		i--
		dAtA[i] = 0x28
	}
	if len(m.JobSetId) > 0 {
		i -= len(m.JobSetId)
		copy(dAtA[i:], m.JobSetId)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.JobSetId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExpectedEvents) > 0 {
		for iNdEx := len(m.ExpectedEvents) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExpectedEvents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestspec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Jobs) > 0 {
		for iNdEx := len(m.Jobs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Jobs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestspec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTestspec(dAtA []byte, offset int, v uint64) int {
	offset -= sovTestspec(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TestSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovTestspec(uint64(l))
		}
	}
	if len(m.ExpectedEvents) > 0 {
		for _, e := range m.ExpectedEvents {
			l = e.Size()
			n += 1 + l + sovTestspec(uint64(l))
		}
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovTestspec(uint64(l))
	}
	l = len(m.JobSetId)
	if l > 0 {
		n += 1 + l + sovTestspec(uint64(l))
	}
	if m.NumBatches != 0 {
		n += 1 + sovTestspec(uint64(m.NumBatches))
	}
	if m.BatchSize != 0 {
		n += 1 + sovTestspec(uint64(m.BatchSize))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovTestspec(uint64(l))
	}
	if m.Timeout != nil {
		l = m.Timeout.Size()
		n += 1 + l + sovTestspec(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovTestspec(uint64(m.Action))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTestspec(uint64(l))
	}
	if m.RandomClientId {
		n += 2
	}
	if m.GetLogs {
		n += 2
	}
	l = len(m.Environment)
	if l > 0 {
		n += 1 + l + sovTestspec(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovTestspec(uint64(l))
	}
	l = len(m.PreemptReason)
	if l > 0 {
		n += 2 + l + sovTestspec(uint64(l))
	}
	if m.Selection != 0 {
		n += 2 + sovTestspec(uint64(m.Selection))
	}
	return n
}

func sovTestspec(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTestspec(x uint64) (n int) {
	return sovTestspec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TestSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestspec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, &JobSubmitRequestItem{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedEvents = append(m.ExpectedEvents, &EventMessage{})
			if err := m.ExpectedEvents[len(m.ExpectedEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBatches", wireType)
			}
			m.NumBatches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBatches |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &types.Duration{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = &types.Duration{}
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= TestSpec_ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomClientId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandomClientId = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetLogs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetLogs = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreemptReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreemptReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			m.Selection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Selection |= TestSpec_SelectionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTestspec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestspec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTestspec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTestspec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTestspec
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTestspec
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTestspec
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTestspec        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTestspec          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTestspec = fmt.Errorf("proto: unexpected end of group")
)
