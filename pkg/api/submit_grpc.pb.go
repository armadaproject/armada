// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: pkg/api/submit.proto

package api

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	QueueService_CreateQueue_FullMethodName    = "/api.QueueService/CreateQueue"
	QueueService_CreateQueues_FullMethodName   = "/api.QueueService/CreateQueues"
	QueueService_UpdateQueue_FullMethodName    = "/api.QueueService/UpdateQueue"
	QueueService_UpdateQueues_FullMethodName   = "/api.QueueService/UpdateQueues"
	QueueService_DeleteQueue_FullMethodName    = "/api.QueueService/DeleteQueue"
	QueueService_GetQueue_FullMethodName       = "/api.QueueService/GetQueue"
	QueueService_GetQueues_FullMethodName      = "/api.QueueService/GetQueues"
	QueueService_CordonQueue_FullMethodName    = "/api.QueueService/CordonQueue"
	QueueService_UncordonQueue_FullMethodName  = "/api.QueueService/UncordonQueue"
	QueueService_PreemptOnQueue_FullMethodName = "/api.QueueService/PreemptOnQueue"
	QueueService_CancelOnQueue_FullMethodName  = "/api.QueueService/CancelOnQueue"
)

// QueueServiceClient is the client API for QueueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueueServiceClient interface {
	CreateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueCreateResponse, error)
	UpdateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueUpdateResponse, error)
	DeleteQueue(ctx context.Context, in *QueueDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetQueue(ctx context.Context, in *QueueGetRequest, opts ...grpc.CallOption) (*Queue, error)
	GetQueues(ctx context.Context, in *StreamingQueueGetRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingQueueMessage], error)
	CordonQueue(ctx context.Context, in *QueueCordonRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UncordonQueue(ctx context.Context, in *QueueUncordonRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PreemptOnQueue(ctx context.Context, in *QueuePreemptRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CancelOnQueue(ctx context.Context, in *QueueCancelRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type queueServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQueueServiceClient(cc grpc.ClientConnInterface) QueueServiceClient {
	return &queueServiceClient{cc}
}

func (c *queueServiceClient) CreateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, QueueService_CreateQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) CreateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchQueueCreateResponse)
	err := c.cc.Invoke(ctx, QueueService_CreateQueues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) UpdateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, QueueService_UpdateQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) UpdateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchQueueUpdateResponse)
	err := c.cc.Invoke(ctx, QueueService_UpdateQueues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) DeleteQueue(ctx context.Context, in *QueueDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, QueueService_DeleteQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetQueue(ctx context.Context, in *QueueGetRequest, opts ...grpc.CallOption) (*Queue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Queue)
	err := c.cc.Invoke(ctx, QueueService_GetQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) GetQueues(ctx context.Context, in *StreamingQueueGetRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingQueueMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &QueueService_ServiceDesc.Streams[0], QueueService_GetQueues_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamingQueueGetRequest, StreamingQueueMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type QueueService_GetQueuesClient = grpc.ServerStreamingClient[StreamingQueueMessage]

func (c *queueServiceClient) CordonQueue(ctx context.Context, in *QueueCordonRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, QueueService_CordonQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) UncordonQueue(ctx context.Context, in *QueueUncordonRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, QueueService_UncordonQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) PreemptOnQueue(ctx context.Context, in *QueuePreemptRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, QueueService_PreemptOnQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queueServiceClient) CancelOnQueue(ctx context.Context, in *QueueCancelRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, QueueService_CancelOnQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueueServiceServer is the server API for QueueService service.
// All implementations must embed UnimplementedQueueServiceServer
// for forward compatibility.
type QueueServiceServer interface {
	CreateQueue(context.Context, *Queue) (*emptypb.Empty, error)
	CreateQueues(context.Context, *QueueList) (*BatchQueueCreateResponse, error)
	UpdateQueue(context.Context, *Queue) (*emptypb.Empty, error)
	UpdateQueues(context.Context, *QueueList) (*BatchQueueUpdateResponse, error)
	DeleteQueue(context.Context, *QueueDeleteRequest) (*emptypb.Empty, error)
	GetQueue(context.Context, *QueueGetRequest) (*Queue, error)
	GetQueues(*StreamingQueueGetRequest, grpc.ServerStreamingServer[StreamingQueueMessage]) error
	CordonQueue(context.Context, *QueueCordonRequest) (*emptypb.Empty, error)
	UncordonQueue(context.Context, *QueueUncordonRequest) (*emptypb.Empty, error)
	PreemptOnQueue(context.Context, *QueuePreemptRequest) (*emptypb.Empty, error)
	CancelOnQueue(context.Context, *QueueCancelRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedQueueServiceServer()
}

// UnimplementedQueueServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQueueServiceServer struct{}

func (UnimplementedQueueServiceServer) CreateQueue(context.Context, *Queue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQueue not implemented")
}
func (UnimplementedQueueServiceServer) CreateQueues(context.Context, *QueueList) (*BatchQueueCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQueues not implemented")
}
func (UnimplementedQueueServiceServer) UpdateQueue(context.Context, *Queue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQueue not implemented")
}
func (UnimplementedQueueServiceServer) UpdateQueues(context.Context, *QueueList) (*BatchQueueUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQueues not implemented")
}
func (UnimplementedQueueServiceServer) DeleteQueue(context.Context, *QueueDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQueue not implemented")
}
func (UnimplementedQueueServiceServer) GetQueue(context.Context, *QueueGetRequest) (*Queue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueue not implemented")
}
func (UnimplementedQueueServiceServer) GetQueues(*StreamingQueueGetRequest, grpc.ServerStreamingServer[StreamingQueueMessage]) error {
	return status.Errorf(codes.Unimplemented, "method GetQueues not implemented")
}
func (UnimplementedQueueServiceServer) CordonQueue(context.Context, *QueueCordonRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CordonQueue not implemented")
}
func (UnimplementedQueueServiceServer) UncordonQueue(context.Context, *QueueUncordonRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UncordonQueue not implemented")
}
func (UnimplementedQueueServiceServer) PreemptOnQueue(context.Context, *QueuePreemptRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreemptOnQueue not implemented")
}
func (UnimplementedQueueServiceServer) CancelOnQueue(context.Context, *QueueCancelRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOnQueue not implemented")
}
func (UnimplementedQueueServiceServer) mustEmbedUnimplementedQueueServiceServer() {}
func (UnimplementedQueueServiceServer) testEmbeddedByValue()                      {}

// UnsafeQueueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueueServiceServer will
// result in compilation errors.
type UnsafeQueueServiceServer interface {
	mustEmbedUnimplementedQueueServiceServer()
}

func RegisterQueueServiceServer(s grpc.ServiceRegistrar, srv QueueServiceServer) {
	// If the following call pancis, it indicates UnimplementedQueueServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&QueueService_ServiceDesc, srv)
}

func _QueueService_CreateQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Queue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).CreateQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_CreateQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).CreateQueue(ctx, req.(*Queue))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_CreateQueues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).CreateQueues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_CreateQueues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).CreateQueues(ctx, req.(*QueueList))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_UpdateQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Queue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).UpdateQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_UpdateQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).UpdateQueue(ctx, req.(*Queue))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_UpdateQueues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).UpdateQueues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_UpdateQueues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).UpdateQueues(ctx, req.(*QueueList))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_DeleteQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).DeleteQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_DeleteQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).DeleteQueue(ctx, req.(*QueueDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).GetQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_GetQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).GetQueue(ctx, req.(*QueueGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_GetQueues_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamingQueueGetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueueServiceServer).GetQueues(m, &grpc.GenericServerStream[StreamingQueueGetRequest, StreamingQueueMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type QueueService_GetQueuesServer = grpc.ServerStreamingServer[StreamingQueueMessage]

func _QueueService_CordonQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueCordonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).CordonQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_CordonQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).CordonQueue(ctx, req.(*QueueCordonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_UncordonQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueUncordonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).UncordonQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_UncordonQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).UncordonQueue(ctx, req.(*QueueUncordonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_PreemptOnQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueuePreemptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).PreemptOnQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_PreemptOnQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).PreemptOnQueue(ctx, req.(*QueuePreemptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QueueService_CancelOnQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueueServiceServer).CancelOnQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QueueService_CancelOnQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueueServiceServer).CancelOnQueue(ctx, req.(*QueueCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// QueueService_ServiceDesc is the grpc.ServiceDesc for QueueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QueueService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.QueueService",
	HandlerType: (*QueueServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateQueue",
			Handler:    _QueueService_CreateQueue_Handler,
		},
		{
			MethodName: "CreateQueues",
			Handler:    _QueueService_CreateQueues_Handler,
		},
		{
			MethodName: "UpdateQueue",
			Handler:    _QueueService_UpdateQueue_Handler,
		},
		{
			MethodName: "UpdateQueues",
			Handler:    _QueueService_UpdateQueues_Handler,
		},
		{
			MethodName: "DeleteQueue",
			Handler:    _QueueService_DeleteQueue_Handler,
		},
		{
			MethodName: "GetQueue",
			Handler:    _QueueService_GetQueue_Handler,
		},
		{
			MethodName: "CordonQueue",
			Handler:    _QueueService_CordonQueue_Handler,
		},
		{
			MethodName: "UncordonQueue",
			Handler:    _QueueService_UncordonQueue_Handler,
		},
		{
			MethodName: "PreemptOnQueue",
			Handler:    _QueueService_PreemptOnQueue_Handler,
		},
		{
			MethodName: "CancelOnQueue",
			Handler:    _QueueService_CancelOnQueue_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetQueues",
			Handler:       _QueueService_GetQueues_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/api/submit.proto",
}

const (
	Submit_SubmitJobs_FullMethodName       = "/api.Submit/SubmitJobs"
	Submit_CancelJobs_FullMethodName       = "/api.Submit/CancelJobs"
	Submit_CancelJobSet_FullMethodName     = "/api.Submit/CancelJobSet"
	Submit_ReprioritizeJobs_FullMethodName = "/api.Submit/ReprioritizeJobs"
	Submit_PreemptJobs_FullMethodName      = "/api.Submit/PreemptJobs"
	Submit_CreateQueue_FullMethodName      = "/api.Submit/CreateQueue"
	Submit_CreateQueues_FullMethodName     = "/api.Submit/CreateQueues"
	Submit_UpdateQueue_FullMethodName      = "/api.Submit/UpdateQueue"
	Submit_UpdateQueues_FullMethodName     = "/api.Submit/UpdateQueues"
	Submit_DeleteQueue_FullMethodName      = "/api.Submit/DeleteQueue"
	Submit_GetQueue_FullMethodName         = "/api.Submit/GetQueue"
	Submit_GetQueues_FullMethodName        = "/api.Submit/GetQueues"
	Submit_Health_FullMethodName           = "/api.Submit/Health"
)

// SubmitClient is the client API for Submit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SubmitClient interface {
	SubmitJobs(ctx context.Context, in *JobSubmitRequest, opts ...grpc.CallOption) (*JobSubmitResponse, error)
	CancelJobs(ctx context.Context, in *JobCancelRequest, opts ...grpc.CallOption) (*CancellationResult, error)
	CancelJobSet(ctx context.Context, in *JobSetCancelRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ReprioritizeJobs(ctx context.Context, in *JobReprioritizeRequest, opts ...grpc.CallOption) (*JobReprioritizeResponse, error)
	PreemptJobs(ctx context.Context, in *JobPreemptRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueCreateResponse, error)
	UpdateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueUpdateResponse, error)
	DeleteQueue(ctx context.Context, in *QueueDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetQueue(ctx context.Context, in *QueueGetRequest, opts ...grpc.CallOption) (*Queue, error)
	GetQueues(ctx context.Context, in *StreamingQueueGetRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingQueueMessage], error)
	Health(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type submitClient struct {
	cc grpc.ClientConnInterface
}

func NewSubmitClient(cc grpc.ClientConnInterface) SubmitClient {
	return &submitClient{cc}
}

func (c *submitClient) SubmitJobs(ctx context.Context, in *JobSubmitRequest, opts ...grpc.CallOption) (*JobSubmitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JobSubmitResponse)
	err := c.cc.Invoke(ctx, Submit_SubmitJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) CancelJobs(ctx context.Context, in *JobCancelRequest, opts ...grpc.CallOption) (*CancellationResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancellationResult)
	err := c.cc.Invoke(ctx, Submit_CancelJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) CancelJobSet(ctx context.Context, in *JobSetCancelRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Submit_CancelJobSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) ReprioritizeJobs(ctx context.Context, in *JobReprioritizeRequest, opts ...grpc.CallOption) (*JobReprioritizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JobReprioritizeResponse)
	err := c.cc.Invoke(ctx, Submit_ReprioritizeJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) PreemptJobs(ctx context.Context, in *JobPreemptRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Submit_PreemptJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) CreateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Submit_CreateQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) CreateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueCreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchQueueCreateResponse)
	err := c.cc.Invoke(ctx, Submit_CreateQueues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) UpdateQueue(ctx context.Context, in *Queue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Submit_UpdateQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) UpdateQueues(ctx context.Context, in *QueueList, opts ...grpc.CallOption) (*BatchQueueUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchQueueUpdateResponse)
	err := c.cc.Invoke(ctx, Submit_UpdateQueues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) DeleteQueue(ctx context.Context, in *QueueDeleteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Submit_DeleteQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) GetQueue(ctx context.Context, in *QueueGetRequest, opts ...grpc.CallOption) (*Queue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Queue)
	err := c.cc.Invoke(ctx, Submit_GetQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *submitClient) GetQueues(ctx context.Context, in *StreamingQueueGetRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamingQueueMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Submit_ServiceDesc.Streams[0], Submit_GetQueues_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamingQueueGetRequest, StreamingQueueMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Submit_GetQueuesClient = grpc.ServerStreamingClient[StreamingQueueMessage]

func (c *submitClient) Health(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, Submit_Health_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubmitServer is the server API for Submit service.
// All implementations must embed UnimplementedSubmitServer
// for forward compatibility.
type SubmitServer interface {
	SubmitJobs(context.Context, *JobSubmitRequest) (*JobSubmitResponse, error)
	CancelJobs(context.Context, *JobCancelRequest) (*CancellationResult, error)
	CancelJobSet(context.Context, *JobSetCancelRequest) (*emptypb.Empty, error)
	ReprioritizeJobs(context.Context, *JobReprioritizeRequest) (*JobReprioritizeResponse, error)
	PreemptJobs(context.Context, *JobPreemptRequest) (*emptypb.Empty, error)
	CreateQueue(context.Context, *Queue) (*emptypb.Empty, error)
	CreateQueues(context.Context, *QueueList) (*BatchQueueCreateResponse, error)
	UpdateQueue(context.Context, *Queue) (*emptypb.Empty, error)
	UpdateQueues(context.Context, *QueueList) (*BatchQueueUpdateResponse, error)
	DeleteQueue(context.Context, *QueueDeleteRequest) (*emptypb.Empty, error)
	GetQueue(context.Context, *QueueGetRequest) (*Queue, error)
	GetQueues(*StreamingQueueGetRequest, grpc.ServerStreamingServer[StreamingQueueMessage]) error
	Health(context.Context, *emptypb.Empty) (*HealthCheckResponse, error)
	mustEmbedUnimplementedSubmitServer()
}

// UnimplementedSubmitServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSubmitServer struct{}

func (UnimplementedSubmitServer) SubmitJobs(context.Context, *JobSubmitRequest) (*JobSubmitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitJobs not implemented")
}
func (UnimplementedSubmitServer) CancelJobs(context.Context, *JobCancelRequest) (*CancellationResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJobs not implemented")
}
func (UnimplementedSubmitServer) CancelJobSet(context.Context, *JobSetCancelRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJobSet not implemented")
}
func (UnimplementedSubmitServer) ReprioritizeJobs(context.Context, *JobReprioritizeRequest) (*JobReprioritizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReprioritizeJobs not implemented")
}
func (UnimplementedSubmitServer) PreemptJobs(context.Context, *JobPreemptRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreemptJobs not implemented")
}
func (UnimplementedSubmitServer) CreateQueue(context.Context, *Queue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQueue not implemented")
}
func (UnimplementedSubmitServer) CreateQueues(context.Context, *QueueList) (*BatchQueueCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQueues not implemented")
}
func (UnimplementedSubmitServer) UpdateQueue(context.Context, *Queue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQueue not implemented")
}
func (UnimplementedSubmitServer) UpdateQueues(context.Context, *QueueList) (*BatchQueueUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQueues not implemented")
}
func (UnimplementedSubmitServer) DeleteQueue(context.Context, *QueueDeleteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQueue not implemented")
}
func (UnimplementedSubmitServer) GetQueue(context.Context, *QueueGetRequest) (*Queue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueue not implemented")
}
func (UnimplementedSubmitServer) GetQueues(*StreamingQueueGetRequest, grpc.ServerStreamingServer[StreamingQueueMessage]) error {
	return status.Errorf(codes.Unimplemented, "method GetQueues not implemented")
}
func (UnimplementedSubmitServer) Health(context.Context, *emptypb.Empty) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedSubmitServer) mustEmbedUnimplementedSubmitServer() {}
func (UnimplementedSubmitServer) testEmbeddedByValue()                {}

// UnsafeSubmitServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubmitServer will
// result in compilation errors.
type UnsafeSubmitServer interface {
	mustEmbedUnimplementedSubmitServer()
}

func RegisterSubmitServer(s grpc.ServiceRegistrar, srv SubmitServer) {
	// If the following call pancis, it indicates UnimplementedSubmitServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Submit_ServiceDesc, srv)
}

func _Submit_SubmitJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSubmitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).SubmitJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_SubmitJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).SubmitJobs(ctx, req.(*JobSubmitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_CancelJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).CancelJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_CancelJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).CancelJobs(ctx, req.(*JobCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_CancelJobSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobSetCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).CancelJobSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_CancelJobSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).CancelJobSet(ctx, req.(*JobSetCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_ReprioritizeJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobReprioritizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).ReprioritizeJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_ReprioritizeJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).ReprioritizeJobs(ctx, req.(*JobReprioritizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_PreemptJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobPreemptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).PreemptJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_PreemptJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).PreemptJobs(ctx, req.(*JobPreemptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_CreateQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Queue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).CreateQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_CreateQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).CreateQueue(ctx, req.(*Queue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_CreateQueues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).CreateQueues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_CreateQueues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).CreateQueues(ctx, req.(*QueueList))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_UpdateQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Queue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).UpdateQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_UpdateQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).UpdateQueue(ctx, req.(*Queue))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_UpdateQueues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).UpdateQueues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_UpdateQueues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).UpdateQueues(ctx, req.(*QueueList))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_DeleteQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).DeleteQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_DeleteQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).DeleteQueue(ctx, req.(*QueueDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_GetQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).GetQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_GetQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).GetQueue(ctx, req.(*QueueGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Submit_GetQueues_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamingQueueGetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubmitServer).GetQueues(m, &grpc.GenericServerStream[StreamingQueueGetRequest, StreamingQueueMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Submit_GetQueuesServer = grpc.ServerStreamingServer[StreamingQueueMessage]

func _Submit_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubmitServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Submit_Health_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubmitServer).Health(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Submit_ServiceDesc is the grpc.ServiceDesc for Submit service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Submit_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Submit",
	HandlerType: (*SubmitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SubmitJobs",
			Handler:    _Submit_SubmitJobs_Handler,
		},
		{
			MethodName: "CancelJobs",
			Handler:    _Submit_CancelJobs_Handler,
		},
		{
			MethodName: "CancelJobSet",
			Handler:    _Submit_CancelJobSet_Handler,
		},
		{
			MethodName: "ReprioritizeJobs",
			Handler:    _Submit_ReprioritizeJobs_Handler,
		},
		{
			MethodName: "PreemptJobs",
			Handler:    _Submit_PreemptJobs_Handler,
		},
		{
			MethodName: "CreateQueue",
			Handler:    _Submit_CreateQueue_Handler,
		},
		{
			MethodName: "CreateQueues",
			Handler:    _Submit_CreateQueues_Handler,
		},
		{
			MethodName: "UpdateQueue",
			Handler:    _Submit_UpdateQueue_Handler,
		},
		{
			MethodName: "UpdateQueues",
			Handler:    _Submit_UpdateQueues_Handler,
		},
		{
			MethodName: "DeleteQueue",
			Handler:    _Submit_DeleteQueue_Handler,
		},
		{
			MethodName: "GetQueue",
			Handler:    _Submit_GetQueue_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _Submit_Health_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetQueues",
			Handler:       _Submit_GetQueues_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/api/submit.proto",
}
