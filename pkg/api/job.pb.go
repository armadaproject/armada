// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/api/job.proto

package api

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type JobRunState int32

const (
	JobRunState_RUN_STATE_UNKNOWN         JobRunState = 0
	JobRunState_RUN_STATE_LEASED          JobRunState = 1
	JobRunState_RUN_STATE_PENDING         JobRunState = 2
	JobRunState_RUN_STATE_RUNNING         JobRunState = 3
	JobRunState_RUN_STATE_SUCCEEDED       JobRunState = 4
	JobRunState_RUN_STATE_FAILED          JobRunState = 5
	JobRunState_RUN_STATE_PREEMPTED       JobRunState = 6
	JobRunState_RUN_STATE_CANCELLED       JobRunState = 7
	JobRunState_RUN_STATE_LEASE_EXPIRED   JobRunState = 8
	JobRunState_RUNS_STATE_LEASE_RETURNED JobRunState = 9
)

var JobRunState_name = map[int32]string{
	0: "RUN_STATE_UNKNOWN",
	1: "RUN_STATE_LEASED",
	2: "RUN_STATE_PENDING",
	3: "RUN_STATE_RUNNING",
	4: "RUN_STATE_SUCCEEDED",
	5: "RUN_STATE_FAILED",
	6: "RUN_STATE_PREEMPTED",
	7: "RUN_STATE_CANCELLED",
	8: "RUN_STATE_LEASE_EXPIRED",
	9: "RUNS_STATE_LEASE_RETURNED",
}

var JobRunState_value = map[string]int32{
	"RUN_STATE_UNKNOWN":         0,
	"RUN_STATE_LEASED":          1,
	"RUN_STATE_PENDING":         2,
	"RUN_STATE_RUNNING":         3,
	"RUN_STATE_SUCCEEDED":       4,
	"RUN_STATE_FAILED":          5,
	"RUN_STATE_PREEMPTED":       6,
	"RUN_STATE_CANCELLED":       7,
	"RUN_STATE_LEASE_EXPIRED":   8,
	"RUNS_STATE_LEASE_RETURNED": 9,
}

func (x JobRunState) String() string {
	return proto.EnumName(JobRunState_name, int32(x))
}

func (JobRunState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e45f6b75bfad87a4, []int{0}
}

type JobRunDetails struct {
	RunId      string           `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"runId,omitempty"`
	JobId      string           `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	State      JobRunState      `protobuf:"varint,3,opt,name=state,proto3,enum=api.JobRunState" json:"state,omitempty"`
	Cluster    string           `protobuf:"bytes,4,opt,name=cluster,proto3" json:"cluster,omitempty"`
	Node       string           `protobuf:"bytes,5,opt,name=node,proto3" json:"node,omitempty"`
	LeasedTs   *types.Timestamp `protobuf:"bytes,7,opt,name=leased_ts,json=leasedTs,proto3" json:"leasedTs,omitempty"`
	PendingTs  *types.Timestamp `protobuf:"bytes,8,opt,name=pending_ts,json=pendingTs,proto3" json:"pendingTs,omitempty"`
	StartedTs  *types.Timestamp `protobuf:"bytes,9,opt,name=started_ts,json=startedTs,proto3" json:"startedTs,omitempty"`
	FinishedTs *types.Timestamp `protobuf:"bytes,10,opt,name=finished_ts,json=finishedTs,proto3" json:"finishedTs,omitempty"`
}

func (m *JobRunDetails) Reset()         { *m = JobRunDetails{} }
func (m *JobRunDetails) String() string { return proto.CompactTextString(m) }
func (*JobRunDetails) ProtoMessage()    {}
func (*JobRunDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_e45f6b75bfad87a4, []int{0}
}
func (m *JobRunDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunDetails.Merge(m, src)
}
func (m *JobRunDetails) XXX_Size() int {
	return m.Size()
}
func (m *JobRunDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunDetails.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunDetails proto.InternalMessageInfo

func (m *JobRunDetails) GetRunId() string {
	if m != nil {
		return m.RunId
	}
	return ""
}

func (m *JobRunDetails) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobRunDetails) GetState() JobRunState {
	if m != nil {
		return m.State
	}
	return JobRunState_RUN_STATE_UNKNOWN
}

func (m *JobRunDetails) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *JobRunDetails) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *JobRunDetails) GetLeasedTs() *types.Timestamp {
	if m != nil {
		return m.LeasedTs
	}
	return nil
}

func (m *JobRunDetails) GetPendingTs() *types.Timestamp {
	if m != nil {
		return m.PendingTs
	}
	return nil
}

func (m *JobRunDetails) GetStartedTs() *types.Timestamp {
	if m != nil {
		return m.StartedTs
	}
	return nil
}

func (m *JobRunDetails) GetFinishedTs() *types.Timestamp {
	if m != nil {
		return m.FinishedTs
	}
	return nil
}

type JobDetails struct {
	JobId            string           `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	Queue            string           `protobuf:"bytes,2,opt,name=queue,proto3" json:"queue,omitempty"`
	Jobset           string           `protobuf:"bytes,3,opt,name=jobset,proto3" json:"jobset,omitempty"`
	Namespace        string           `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	State            JobState         `protobuf:"varint,5,opt,name=state,proto3,enum=api.JobState" json:"state,omitempty"`
	SubmittedTs      *types.Timestamp `protobuf:"bytes,6,opt,name=submitted_ts,json=submittedTs,proto3" json:"submittedTs,omitempty"`
	CancelTs         *types.Timestamp `protobuf:"bytes,7,opt,name=cancel_ts,json=cancelTs,proto3" json:"cancelTs,omitempty"`
	CancelReason     string           `protobuf:"bytes,8,opt,name=cancel_reason,json=cancelReason,proto3" json:"cancelReason,omitempty"`
	LastTransitionTs *types.Timestamp `protobuf:"bytes,9,opt,name=last_transition_ts,json=lastTransitionTs,proto3" json:"lastTransitionTs,omitempty"`
	LatestRunId      string           `protobuf:"bytes,10,opt,name=latest_run_id,json=latestRunId,proto3" json:"latestRunId,omitempty"`
	JobSpec          *Job             `protobuf:"bytes,11,opt,name=job_spec,json=jobSpec,proto3" json:"jobSpec,omitempty"`
	JobRuns          []*JobRunDetails `protobuf:"bytes,12,rep,name=job_runs,json=jobRuns,proto3" json:"jobRuns,omitempty"`
}

func (m *JobDetails) Reset()         { *m = JobDetails{} }
func (m *JobDetails) String() string { return proto.CompactTextString(m) }
func (*JobDetails) ProtoMessage()    {}
func (*JobDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_e45f6b75bfad87a4, []int{1}
}
func (m *JobDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobDetails.Merge(m, src)
}
func (m *JobDetails) XXX_Size() int {
	return m.Size()
}
func (m *JobDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_JobDetails.DiscardUnknown(m)
}

var xxx_messageInfo_JobDetails proto.InternalMessageInfo

func (m *JobDetails) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobDetails) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *JobDetails) GetJobset() string {
	if m != nil {
		return m.Jobset
	}
	return ""
}

func (m *JobDetails) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *JobDetails) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_QUEUED
}

func (m *JobDetails) GetSubmittedTs() *types.Timestamp {
	if m != nil {
		return m.SubmittedTs
	}
	return nil
}

func (m *JobDetails) GetCancelTs() *types.Timestamp {
	if m != nil {
		return m.CancelTs
	}
	return nil
}

func (m *JobDetails) GetCancelReason() string {
	if m != nil {
		return m.CancelReason
	}
	return ""
}

func (m *JobDetails) GetLastTransitionTs() *types.Timestamp {
	if m != nil {
		return m.LastTransitionTs
	}
	return nil
}

func (m *JobDetails) GetLatestRunId() string {
	if m != nil {
		return m.LatestRunId
	}
	return ""
}

func (m *JobDetails) GetJobSpec() *Job {
	if m != nil {
		return m.JobSpec
	}
	return nil
}

func (m *JobDetails) GetJobRuns() []*JobRunDetails {
	if m != nil {
		return m.JobRuns
	}
	return nil
}

type JobDetailsRequest struct {
	JobIds        []string `protobuf:"bytes,1,rep,name=job_ids,json=jobIds,proto3" json:"jobIds,omitempty"`
	ExpandJobSpec bool     `protobuf:"varint,2,opt,name=expand_job_spec,json=expandJobSpec,proto3" json:"expandJobSpec,omitempty"`
	ExpandJobRun  bool     `protobuf:"varint,3,opt,name=expand_job_run,json=expandJobRun,proto3" json:"expandJobRun,omitempty"`
}

func (m *JobDetailsRequest) Reset()         { *m = JobDetailsRequest{} }
func (m *JobDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*JobDetailsRequest) ProtoMessage()    {}
func (*JobDetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e45f6b75bfad87a4, []int{2}
}
func (m *JobDetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobDetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobDetailsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobDetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobDetailsRequest.Merge(m, src)
}
func (m *JobDetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobDetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobDetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobDetailsRequest proto.InternalMessageInfo

func (m *JobDetailsRequest) GetJobIds() []string {
	if m != nil {
		return m.JobIds
	}
	return nil
}

func (m *JobDetailsRequest) GetExpandJobSpec() bool {
	if m != nil {
		return m.ExpandJobSpec
	}
	return false
}

func (m *JobDetailsRequest) GetExpandJobRun() bool {
	if m != nil {
		return m.ExpandJobRun
	}
	return false
}

type JobDetailsResponse struct {
	JobDetails map[string]*JobDetails `protobuf:"bytes,1,rep,name=job_details,json=jobDetails,proto3" json:"jobDetails,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *JobDetailsResponse) Reset()         { *m = JobDetailsResponse{} }
func (m *JobDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*JobDetailsResponse) ProtoMessage()    {}
func (*JobDetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e45f6b75bfad87a4, []int{3}
}
func (m *JobDetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobDetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobDetailsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobDetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobDetailsResponse.Merge(m, src)
}
func (m *JobDetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobDetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobDetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobDetailsResponse proto.InternalMessageInfo

func (m *JobDetailsResponse) GetJobDetails() map[string]*JobDetails {
	if m != nil {
		return m.JobDetails
	}
	return nil
}

type JobRunDetailsResponse struct {
	JobRunDetails map[string]*JobRunDetails `protobuf:"bytes,1,rep,name=job_run_details,json=jobRunDetails,proto3" json:"jobRunDetails,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *JobRunDetailsResponse) Reset()         { *m = JobRunDetailsResponse{} }
func (m *JobRunDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*JobRunDetailsResponse) ProtoMessage()    {}
func (*JobRunDetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e45f6b75bfad87a4, []int{4}
}
func (m *JobRunDetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunDetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunDetailsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunDetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunDetailsResponse.Merge(m, src)
}
func (m *JobRunDetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobRunDetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunDetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunDetailsResponse proto.InternalMessageInfo

func (m *JobRunDetailsResponse) GetJobRunDetails() map[string]*JobRunDetails {
	if m != nil {
		return m.JobRunDetails
	}
	return nil
}

type JobRunDetailsRequest struct {
	RunIds []string `protobuf:"bytes,1,rep,name=run_ids,json=runIds,proto3" json:"runIds,omitempty"`
}

func (m *JobRunDetailsRequest) Reset()         { *m = JobRunDetailsRequest{} }
func (m *JobRunDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*JobRunDetailsRequest) ProtoMessage()    {}
func (*JobRunDetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e45f6b75bfad87a4, []int{5}
}
func (m *JobRunDetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunDetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunDetailsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunDetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunDetailsRequest.Merge(m, src)
}
func (m *JobRunDetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobRunDetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunDetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunDetailsRequest proto.InternalMessageInfo

func (m *JobRunDetailsRequest) GetRunIds() []string {
	if m != nil {
		return m.RunIds
	}
	return nil
}

type JobStatusRequest struct {
	JobIds []string `protobuf:"bytes,1,rep,name=job_ids,json=jobIds,proto3" json:"jobIds,omitempty"`
}

func (m *JobStatusRequest) Reset()         { *m = JobStatusRequest{} }
func (m *JobStatusRequest) String() string { return proto.CompactTextString(m) }
func (*JobStatusRequest) ProtoMessage()    {}
func (*JobStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e45f6b75bfad87a4, []int{6}
}
func (m *JobStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobStatusRequest.Merge(m, src)
}
func (m *JobStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobStatusRequest proto.InternalMessageInfo

func (m *JobStatusRequest) GetJobIds() []string {
	if m != nil {
		return m.JobIds
	}
	return nil
}

type JobStatusResponse struct {
	JobStates map[string]JobState `protobuf:"bytes,1,rep,name=job_states,json=jobStates,proto3" json:"jobStates,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=api.JobState"`
}

func (m *JobStatusResponse) Reset()         { *m = JobStatusResponse{} }
func (m *JobStatusResponse) String() string { return proto.CompactTextString(m) }
func (*JobStatusResponse) ProtoMessage()    {}
func (*JobStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e45f6b75bfad87a4, []int{7}
}
func (m *JobStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobStatusResponse.Merge(m, src)
}
func (m *JobStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobStatusResponse proto.InternalMessageInfo

func (m *JobStatusResponse) GetJobStates() map[string]JobState {
	if m != nil {
		return m.JobStates
	}
	return nil
}

func init() {
	proto.RegisterEnum("api.JobRunState", JobRunState_name, JobRunState_value)
	proto.RegisterType((*JobRunDetails)(nil), "api.JobRunDetails")
	proto.RegisterType((*JobDetails)(nil), "api.JobDetails")
	proto.RegisterType((*JobDetailsRequest)(nil), "api.JobDetailsRequest")
	proto.RegisterType((*JobDetailsResponse)(nil), "api.JobDetailsResponse")
	proto.RegisterMapType((map[string]*JobDetails)(nil), "api.JobDetailsResponse.JobDetailsEntry")
	proto.RegisterType((*JobRunDetailsResponse)(nil), "api.JobRunDetailsResponse")
	proto.RegisterMapType((map[string]*JobRunDetails)(nil), "api.JobRunDetailsResponse.JobRunDetailsEntry")
	proto.RegisterType((*JobRunDetailsRequest)(nil), "api.JobRunDetailsRequest")
	proto.RegisterType((*JobStatusRequest)(nil), "api.JobStatusRequest")
	proto.RegisterType((*JobStatusResponse)(nil), "api.JobStatusResponse")
	proto.RegisterMapType((map[string]JobState)(nil), "api.JobStatusResponse.JobStatesEntry")
}

func init() { proto.RegisterFile("pkg/api/job.proto", fileDescriptor_e45f6b75bfad87a4) }

var fileDescriptor_e45f6b75bfad87a4 = []byte{
	// 1241 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x41, 0x6f, 0xe3, 0x44,
	0x14, 0xae, 0x93, 0xa6, 0x4d, 0x26, 0x9b, 0xc6, 0x9d, 0xa6, 0x6d, 0x9a, 0x85, 0xb8, 0x0a, 0x82,
	0x2d, 0xab, 0xdd, 0x44, 0x04, 0x21, 0xad, 0x8a, 0x56, 0x90, 0x34, 0x66, 0x95, 0xb2, 0x64, 0x2b,
	0x27, 0x11, 0x2b, 0x04, 0x8a, 0xec, 0x64, 0xb6, 0xeb, 0x6c, 0x62, 0x7b, 0x3d, 0xe3, 0x15, 0x95,
	0x38, 0x21, 0x71, 0xe0, 0x86, 0xc4, 0x89, 0x1f, 0xc0, 0x7f, 0x81, 0x03, 0xd2, 0x4a, 0x5c, 0x38,
	0x59, 0xa8, 0x45, 0x42, 0xf2, 0x89, 0x9f, 0x80, 0x3c, 0x63, 0x3b, 0x63, 0xb7, 0x55, 0x0a, 0xc7,
	0x7c, 0xef, 0xbd, 0xcf, 0x33, 0xef, 0x7d, 0xef, 0xb3, 0x03, 0x36, 0xad, 0x17, 0xa7, 0x0d, 0xd5,
	0xd2, 0x1b, 0x53, 0x53, 0xab, 0x5b, 0xb6, 0x49, 0x4c, 0x98, 0x56, 0x2d, 0xbd, 0x52, 0x0a, 0x71,
	0xec, 0x68, 0x73, 0x9d, 0xb0, 0x50, 0x45, 0x3a, 0x35, 0xcd, 0xd3, 0x19, 0x6a, 0xd0, 0x5f, 0x9a,
	0xf3, 0xac, 0x41, 0xf4, 0x39, 0xc2, 0x44, 0x9d, 0x5b, 0x41, 0xc2, 0x1b, 0x41, 0x82, 0x5f, 0xa9,
	0x1a, 0x86, 0x49, 0x54, 0xa2, 0x9b, 0x06, 0x66, 0xd1, 0xda, 0x6f, 0xab, 0xa0, 0x70, 0x6c, 0x6a,
	0x8a, 0x63, 0x74, 0x10, 0x51, 0xf5, 0x19, 0x86, 0x77, 0xc1, 0x9a, 0xed, 0x18, 0x23, 0x7d, 0x52,
	0x16, 0xf6, 0x85, 0x83, 0x5c, 0x7b, 0xcb, 0x73, 0xa5, 0xa2, 0xed, 0x18, 0xdd, 0xc9, 0x3d, 0x73,
	0xae, 0x13, 0x34, 0xb7, 0xc8, 0x99, 0x92, 0xa1, 0x80, 0x9f, 0x3b, 0x35, 0x35, 0x3f, 0x37, 0xb5,
	0xc8, 0x9d, 0x9a, 0x5a, 0x3c, 0x97, 0x02, 0xf0, 0x43, 0x90, 0xc1, 0x44, 0x25, 0xa8, 0x9c, 0xde,
	0x17, 0x0e, 0x36, 0x9a, 0x62, 0x5d, 0xb5, 0xf4, 0x3a, 0x7b, 0x74, 0xdf, 0xc7, 0x59, 0x31, 0x4d,
	0xe1, 0x8b, 0x29, 0x00, 0x1b, 0x60, 0x7d, 0x3c, 0x73, 0x30, 0x41, 0x76, 0x79, 0x95, 0x3e, 0x69,
	0xdb, 0x73, 0xa5, 0xcd, 0x00, 0xe2, 0xd2, 0xc3, 0x2c, 0xf8, 0x0e, 0x58, 0x35, 0xcc, 0x09, 0x2a,
	0x67, 0x68, 0x36, 0xf4, 0x5c, 0x69, 0xc3, 0xff, 0xcd, 0xa5, 0xd2, 0x38, 0x7c, 0x02, 0x72, 0x33,
	0xa4, 0x62, 0x34, 0x19, 0x11, 0x5c, 0x5e, 0xdf, 0x17, 0x0e, 0xf2, 0xcd, 0x4a, 0x9d, 0x75, 0xac,
	0x1e, 0xb6, 0xb4, 0x3e, 0x08, 0x5b, 0xda, 0xde, 0xf1, 0x5c, 0x09, 0xb2, 0x82, 0x01, 0xe6, 0xc8,
	0xb2, 0x21, 0x06, 0x15, 0x00, 0x2c, 0x64, 0x4c, 0x74, 0xe3, 0xd4, 0x67, 0xcc, 0x2e, 0x65, 0xdc,
	0xf5, 0x5c, 0x69, 0x2b, 0xa8, 0x88, 0x51, 0xe6, 0x22, 0xd0, 0xe7, 0xc4, 0x44, 0xb5, 0x09, 0x3b,
	0x65, 0xee, 0x66, 0x9c, 0x41, 0x45, 0x9c, 0x33, 0x02, 0xe1, 0x10, 0xe4, 0x9f, 0xe9, 0x86, 0x8e,
	0x9f, 0x33, 0x52, 0xb0, 0x94, 0xb4, 0xec, 0xb9, 0x52, 0x29, 0x2c, 0x89, 0xb1, 0x82, 0x05, 0x5a,
	0xfb, 0x69, 0x0d, 0x80, 0x63, 0x53, 0xe3, 0xc4, 0x14, 0x08, 0x44, 0x58, 0x2a, 0x90, 0x77, 0x41,
	0xe6, 0xa5, 0x83, 0x1c, 0xc4, 0x6b, 0x89, 0x02, 0x7c, 0x2a, 0x05, 0xe0, 0x3d, 0x4a, 0x8b, 0x11,
	0xa1, 0x62, 0xca, 0xb5, 0x4b, 0x9e, 0x2b, 0x89, 0x0c, 0xe1, 0x92, 0x83, 0x1c, 0xf8, 0x01, 0xc8,
	0x19, 0xea, 0x1c, 0x61, 0x4b, 0x1d, 0xa3, 0x40, 0x3e, 0xb4, 0x43, 0x11, 0xc8, 0x77, 0x28, 0x02,
	0xe1, 0x83, 0x50, 0xb0, 0x19, 0x2a, 0xd8, 0x42, 0x28, 0xd8, 0xe5, 0x6a, 0x7d, 0x0a, 0x6e, 0xb1,
	0x1d, 0x0d, 0x26, 0xb6, 0xb6, 0xb4, 0xb9, 0x7b, 0x9e, 0x2b, 0x6d, 0x47, 0x35, 0xb1, 0xee, 0xe6,
	0x39, 0xd8, 0x97, 0xeb, 0x58, 0x35, 0xc6, 0x68, 0xf6, 0x1f, 0xe4, 0xca, 0x0a, 0xe2, 0x72, 0x0d,
	0x31, 0xf8, 0x11, 0x28, 0x04, 0x84, 0x36, 0x52, 0xb1, 0x69, 0x50, 0xc5, 0xe6, 0xda, 0x15, 0xcf,
	0x95, 0x76, 0x58, 0x40, 0xa1, 0x38, 0x57, 0x7c, 0x8b, 0xc7, 0xe1, 0x73, 0x00, 0x67, 0x2a, 0x26,
	0x23, 0x62, 0xab, 0x06, 0xd6, 0x7d, 0x6b, 0xb9, 0x99, 0x46, 0xab, 0x9e, 0x2b, 0x55, 0xfc, 0xca,
	0x41, 0x54, 0x18, 0x3b, 0xa2, 0x98, 0x8c, 0xc1, 0x87, 0xa0, 0x30, 0x53, 0x09, 0xc2, 0x64, 0x14,
	0xf8, 0x13, 0xa0, 0x47, 0xa5, 0xad, 0x63, 0x01, 0x25, 0xe1, 0x52, 0x79, 0x0e, 0x86, 0x87, 0x20,
	0xeb, 0x4b, 0x11, 0x5b, 0x68, 0x5c, 0xce, 0xd3, 0xe3, 0x65, 0xc3, 0x89, 0x32, 0x37, 0x99, 0x9a,
	0x5a, 0xdf, 0x42, 0x63, 0xde, 0x4d, 0x02, 0x08, 0x76, 0x58, 0xad, 0xed, 0x18, 0xb8, 0x7c, 0x6b,
	0x3f, 0x7d, 0x90, 0x6f, 0x42, 0xce, 0xbe, 0x02, 0xb1, 0x47, 0x2c, 0x8a, 0x63, 0xe0, 0x04, 0x8b,
	0x0f, 0xd5, 0x7e, 0x15, 0xc0, 0xe6, 0x62, 0x37, 0x14, 0xf4, 0xd2, 0x41, 0x98, 0xc0, 0xfb, 0x60,
	0x9d, 0xad, 0x08, 0x2e, 0x0b, 0xfb, 0x69, 0x4e, 0xcc, 0xdd, 0x09, 0x4e, 0x88, 0xb9, 0x3b, 0xc1,
	0xf0, 0x08, 0x14, 0xd1, 0xd7, 0x96, 0x6a, 0x4c, 0x46, 0xd1, 0x6d, 0xfc, 0x7d, 0xc9, 0xb6, 0x6f,
	0x7b, 0xae, 0xb4, 0xcb, 0x42, 0xc7, 0x97, 0x6e, 0x52, 0x88, 0x05, 0xe0, 0xc7, 0x60, 0x83, 0x23,
	0xb1, 0x1d, 0x83, 0xee, 0x51, 0x96, 0x8d, 0x3d, 0x4a, 0x55, 0x9c, 0xd8, 0xd8, 0x79, 0xbc, 0xf6,
	0x8f, 0x00, 0x20, 0x7f, 0x17, 0x6c, 0x99, 0x06, 0x46, 0x50, 0x03, 0x79, 0x9f, 0x71, 0xc2, 0x60,
	0x7a, 0xa1, 0x7c, 0xf3, 0x4e, 0xd8, 0xab, 0x44, 0x36, 0x07, 0xc9, 0x06, 0xb1, 0xcf, 0x98, 0xc5,
	0x4c, 0x23, 0x90, 0xb7, 0x98, 0x05, 0x5a, 0x79, 0x05, 0x8a, 0x89, 0x42, 0xf8, 0x16, 0x48, 0xbf,
	0x40, 0x67, 0x81, 0xc7, 0x6c, 0x7a, 0xae, 0x54, 0x78, 0x81, 0xce, 0xb8, 0x72, 0x3f, 0x0a, 0x0f,
	0x41, 0xe6, 0x95, 0x3a, 0x0b, 0xfc, 0x25, 0xdf, 0x2c, 0x26, 0x4e, 0xc5, 0x36, 0x9a, 0x66, 0xf0,
	0x1b, 0x4d, 0x81, 0xc3, 0xd4, 0x03, 0xa1, 0xf6, 0x7d, 0x0a, 0x6c, 0xc7, 0x06, 0x1e, 0xdd, 0xda,
	0x06, 0xc5, 0xa0, 0x8f, 0x89, 0x9b, 0xdf, 0xbf, 0xac, 0x12, 0xfe, 0xf2, 0x0b, 0x94, 0xdd, 0x9f,
	0x8e, 0x70, 0xca, 0xe3, 0xfc, 0x08, 0x63, 0x81, 0xca, 0x37, 0xb4, 0xff, 0x09, 0x86, 0x9b, 0x35,
	0xe2, 0x61, 0xbc, 0x11, 0x57, 0x49, 0x79, 0x59, 0x2f, 0x64, 0x50, 0x4a, 0xdc, 0x2a, 0x12, 0x33,
	0x5b, 0xce, 0x98, 0x98, 0xe9, 0xc7, 0x42, 0x4c, 0xcc, 0x0c, 0xa9, 0xb5, 0x80, 0x18, 0x18, 0xaa,
	0xf3, 0x3f, 0xf7, 0xa1, 0xf6, 0x37, 0x5b, 0xaa, 0x90, 0x23, 0x98, 0xc8, 0x57, 0x00, 0xd0, 0xf5,
	0xf0, 0xed, 0x38, 0x1c, 0xc6, 0xdb, 0xbc, 0x81, 0x3b, 0xb1, 0x41, 0x50, 0x4b, 0x0f, 0x86, 0x40,
	0x5f, 0x0d, 0xd3, 0x10, 0xe3, 0x5f, 0x0d, 0x11, 0x58, 0xc1, 0x60, 0x23, 0x5e, 0x75, 0xb3, 0xc6,
	0x3f, 0xe0, 0x1b, 0x7f, 0xf5, 0x1b, 0xe5, 0xfa, 0x9e, 0xdf, 0xfd, 0x2e, 0x05, 0xf2, 0xdc, 0xf7,
	0x12, 0xdc, 0x06, 0x9b, 0xca, 0xb0, 0x37, 0xea, 0x0f, 0x5a, 0x03, 0x79, 0x34, 0xec, 0x7d, 0xda,
	0x7b, 0xf2, 0x79, 0x4f, 0x5c, 0x81, 0x25, 0x20, 0x2e, 0xe0, 0xc7, 0x72, 0xab, 0x2f, 0x77, 0x44,
	0x21, 0x9e, 0x7c, 0x22, 0xf7, 0x3a, 0xdd, 0xde, 0x23, 0x31, 0x15, 0x87, 0x95, 0x61, 0xaf, 0xe7,
	0xc3, 0x69, 0xb8, 0x0b, 0xb6, 0x16, 0x70, 0x7f, 0x78, 0x74, 0x24, 0xcb, 0x1d, 0xb9, 0x23, 0xae,
	0xc6, 0xc9, 0x3f, 0x69, 0x75, 0x1f, 0xcb, 0x1d, 0x31, 0x13, 0x4f, 0x3f, 0x51, 0x64, 0xf9, 0xb3,
	0x93, 0x81, 0xdc, 0x11, 0xd7, 0xe2, 0x81, 0xa3, 0x56, 0xef, 0x48, 0x7e, 0xec, 0x57, 0xac, 0xc3,
	0xdb, 0x60, 0x37, 0x71, 0xc8, 0x91, 0xfc, 0xf4, 0xa4, 0xab, 0xc8, 0x1d, 0x31, 0x0b, 0xdf, 0x04,
	0x7b, 0xca, 0xb0, 0xd7, 0x8f, 0x45, 0x15, 0x79, 0x30, 0x54, 0x7a, 0x72, 0x47, 0xcc, 0x35, 0x7f,
	0x4e, 0x81, 0xd5, 0x63, 0x53, 0xc3, 0xfe, 0x6b, 0xf6, 0x11, 0x22, 0xd1, 0x40, 0xe1, 0x76, 0x72,
	0xc0, 0x54, 0x50, 0x95, 0x9d, 0xab, 0xe7, 0x5e, 0xdb, 0xfb, 0xf6, 0xf7, 0xbf, 0x7e, 0x4c, 0x6d,
	0xd5, 0x36, 0x1a, 0xaf, 0xde, 0xf3, 0xbf, 0xb5, 0x1b, 0x98, 0xc6, 0x0f, 0x85, 0xbb, 0xf0, 0x4b,
	0x50, 0x60, 0xcc, 0xe1, 0x77, 0xcc, 0xce, 0x25, 0x0b, 0x63, 0xdc, 0xbb, 0xd7, 0x58, 0x5b, 0xad,
	0x42, 0xc9, 0x4b, 0xb5, 0x62, 0x48, 0x1e, 0x18, 0x83, 0xcf, 0x8e, 0x80, 0xc8, 0xd8, 0xb9, 0xaf,
	0xee, 0xbd, 0xab, 0x9c, 0x82, 0x3d, 0xa3, 0x72, 0xbd, 0x89, 0xc4, 0x1f, 0x63, 0x3b, 0x06, 0xf7,
	0x98, 0x76, 0xeb, 0x97, 0xf3, 0xaa, 0xf0, 0xfa, 0xbc, 0x2a, 0xfc, 0x79, 0x5e, 0x15, 0x7e, 0xb8,
	0xa8, 0xae, 0xbc, 0xbe, 0xa8, 0xae, 0xfc, 0x71, 0x51, 0x5d, 0xf9, 0xe2, 0xce, 0xa9, 0x4e, 0x9e,
	0x3b, 0x5a, 0x7d, 0x6c, 0xce, 0x1b, 0xaa, 0x3d, 0x57, 0x27, 0xaa, 0x65, 0x9b, 0x53, 0x34, 0x26,
	0xc1, 0xaf, 0x46, 0xf0, 0x4f, 0x43, 0x5b, 0xa3, 0x2f, 0xee, 0xf7, 0xff, 0x0d, 0x00, 0x00, 0xff,
	0xff, 0x8f, 0x5d, 0xde, 0x96, 0x93, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// JobsClient is the client API for Jobs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type JobsClient interface {
	GetJobStatus(ctx context.Context, in *JobStatusRequest, opts ...grpc.CallOption) (*JobStatusResponse, error)
	GetJobDetails(ctx context.Context, in *JobDetailsRequest, opts ...grpc.CallOption) (*JobDetailsResponse, error)
	GetJobRunDetails(ctx context.Context, in *JobRunDetailsRequest, opts ...grpc.CallOption) (*JobRunDetailsResponse, error)
}

type jobsClient struct {
	cc *grpc.ClientConn
}

func NewJobsClient(cc *grpc.ClientConn) JobsClient {
	return &jobsClient{cc}
}

func (c *jobsClient) GetJobStatus(ctx context.Context, in *JobStatusRequest, opts ...grpc.CallOption) (*JobStatusResponse, error) {
	out := new(JobStatusResponse)
	err := c.cc.Invoke(ctx, "/api.Jobs/GetJobStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobsClient) GetJobDetails(ctx context.Context, in *JobDetailsRequest, opts ...grpc.CallOption) (*JobDetailsResponse, error) {
	out := new(JobDetailsResponse)
	err := c.cc.Invoke(ctx, "/api.Jobs/GetJobDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobsClient) GetJobRunDetails(ctx context.Context, in *JobRunDetailsRequest, opts ...grpc.CallOption) (*JobRunDetailsResponse, error) {
	out := new(JobRunDetailsResponse)
	err := c.cc.Invoke(ctx, "/api.Jobs/GetJobRunDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobsServer is the server API for Jobs service.
type JobsServer interface {
	GetJobStatus(context.Context, *JobStatusRequest) (*JobStatusResponse, error)
	GetJobDetails(context.Context, *JobDetailsRequest) (*JobDetailsResponse, error)
	GetJobRunDetails(context.Context, *JobRunDetailsRequest) (*JobRunDetailsResponse, error)
}

// UnimplementedJobsServer can be embedded to have forward compatible implementations.
type UnimplementedJobsServer struct {
}

func (*UnimplementedJobsServer) GetJobStatus(ctx context.Context, req *JobStatusRequest) (*JobStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobStatus not implemented")
}
func (*UnimplementedJobsServer) GetJobDetails(ctx context.Context, req *JobDetailsRequest) (*JobDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobDetails not implemented")
}
func (*UnimplementedJobsServer) GetJobRunDetails(ctx context.Context, req *JobRunDetailsRequest) (*JobRunDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobRunDetails not implemented")
}

func RegisterJobsServer(s *grpc.Server, srv JobsServer) {
	s.RegisterService(&_Jobs_serviceDesc, srv)
}

func _Jobs_GetJobStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServer).GetJobStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Jobs/GetJobStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServer).GetJobStatus(ctx, req.(*JobStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jobs_GetJobDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServer).GetJobDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Jobs/GetJobDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServer).GetJobDetails(ctx, req.(*JobDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Jobs_GetJobRunDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRunDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServer).GetJobRunDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Jobs/GetJobRunDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServer).GetJobRunDetails(ctx, req.(*JobRunDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Jobs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Jobs",
	HandlerType: (*JobsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetJobStatus",
			Handler:    _Jobs_GetJobStatus_Handler,
		},
		{
			MethodName: "GetJobDetails",
			Handler:    _Jobs_GetJobDetails_Handler,
		},
		{
			MethodName: "GetJobRunDetails",
			Handler:    _Jobs_GetJobRunDetails_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/api/job.proto",
}

func (m *JobRunDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FinishedTs != nil {
		{
			size, err := m.FinishedTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.StartedTs != nil {
		{
			size, err := m.StartedTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.PendingTs != nil {
		{
			size, err := m.PendingTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LeasedTs != nil {
		{
			size, err := m.LeasedTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintJob(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Cluster) > 0 {
		i -= len(m.Cluster)
		copy(dAtA[i:], m.Cluster)
		i = encodeVarintJob(dAtA, i, uint64(len(m.Cluster)))
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintJob(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintJob(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RunId) > 0 {
		i -= len(m.RunId)
		copy(dAtA[i:], m.RunId)
		i = encodeVarintJob(dAtA, i, uint64(len(m.RunId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobRuns) > 0 {
		for iNdEx := len(m.JobRuns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JobRuns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintJob(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.JobSpec != nil {
		{
			size, err := m.JobSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.LatestRunId) > 0 {
		i -= len(m.LatestRunId)
		copy(dAtA[i:], m.LatestRunId)
		i = encodeVarintJob(dAtA, i, uint64(len(m.LatestRunId)))
		i--
		dAtA[i] = 0x52
	}
	if m.LastTransitionTs != nil {
		{
			size, err := m.LastTransitionTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.CancelReason) > 0 {
		i -= len(m.CancelReason)
		copy(dAtA[i:], m.CancelReason)
		i = encodeVarintJob(dAtA, i, uint64(len(m.CancelReason)))
		i--
		dAtA[i] = 0x42
	}
	if m.CancelTs != nil {
		{
			size, err := m.CancelTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SubmittedTs != nil {
		{
			size, err := m.SubmittedTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintJob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.State != 0 {
		i = encodeVarintJob(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintJob(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Jobset) > 0 {
		i -= len(m.Jobset)
		copy(dAtA[i:], m.Jobset)
		i = encodeVarintJob(dAtA, i, uint64(len(m.Jobset)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintJob(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintJob(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobDetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobDetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobDetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpandJobRun {
		i--
		if m.ExpandJobRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ExpandJobSpec {
		i--
		if m.ExpandJobSpec {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.JobIds) > 0 {
		for iNdEx := len(m.JobIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.JobIds[iNdEx])
			copy(dAtA[i:], m.JobIds[iNdEx])
			i = encodeVarintJob(dAtA, i, uint64(len(m.JobIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobDetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobDetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobDetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobDetails) > 0 {
		for k := range m.JobDetails {
			v := m.JobDetails[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintJob(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintJob(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintJob(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobRunDetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunDetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunDetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobRunDetails) > 0 {
		for k := range m.JobRunDetails {
			v := m.JobRunDetails[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintJob(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintJob(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintJob(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobRunDetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunDetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunDetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RunIds) > 0 {
		for iNdEx := len(m.RunIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RunIds[iNdEx])
			copy(dAtA[i:], m.RunIds[iNdEx])
			i = encodeVarintJob(dAtA, i, uint64(len(m.RunIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobIds) > 0 {
		for iNdEx := len(m.JobIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.JobIds[iNdEx])
			copy(dAtA[i:], m.JobIds[iNdEx])
			i = encodeVarintJob(dAtA, i, uint64(len(m.JobIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobStates) > 0 {
		for k := range m.JobStates {
			v := m.JobStates[k]
			baseI := i
			i = encodeVarintJob(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintJob(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintJob(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintJob(dAtA []byte, offset int, v uint64) int {
	offset -= sovJob(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *JobRunDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RunId)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovJob(uint64(m.State))
	}
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	if m.LeasedTs != nil {
		l = m.LeasedTs.Size()
		n += 1 + l + sovJob(uint64(l))
	}
	if m.PendingTs != nil {
		l = m.PendingTs.Size()
		n += 1 + l + sovJob(uint64(l))
	}
	if m.StartedTs != nil {
		l = m.StartedTs.Size()
		n += 1 + l + sovJob(uint64(l))
	}
	if m.FinishedTs != nil {
		l = m.FinishedTs.Size()
		n += 1 + l + sovJob(uint64(l))
	}
	return n
}

func (m *JobDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.Jobset)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovJob(uint64(m.State))
	}
	if m.SubmittedTs != nil {
		l = m.SubmittedTs.Size()
		n += 1 + l + sovJob(uint64(l))
	}
	if m.CancelTs != nil {
		l = m.CancelTs.Size()
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.CancelReason)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	if m.LastTransitionTs != nil {
		l = m.LastTransitionTs.Size()
		n += 1 + l + sovJob(uint64(l))
	}
	l = len(m.LatestRunId)
	if l > 0 {
		n += 1 + l + sovJob(uint64(l))
	}
	if m.JobSpec != nil {
		l = m.JobSpec.Size()
		n += 1 + l + sovJob(uint64(l))
	}
	if len(m.JobRuns) > 0 {
		for _, e := range m.JobRuns {
			l = e.Size()
			n += 1 + l + sovJob(uint64(l))
		}
	}
	return n
}

func (m *JobDetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobIds) > 0 {
		for _, s := range m.JobIds {
			l = len(s)
			n += 1 + l + sovJob(uint64(l))
		}
	}
	if m.ExpandJobSpec {
		n += 2
	}
	if m.ExpandJobRun {
		n += 2
	}
	return n
}

func (m *JobDetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobDetails) > 0 {
		for k, v := range m.JobDetails {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovJob(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovJob(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovJob(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *JobRunDetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobRunDetails) > 0 {
		for k, v := range m.JobRunDetails {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovJob(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovJob(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovJob(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *JobRunDetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RunIds) > 0 {
		for _, s := range m.RunIds {
			l = len(s)
			n += 1 + l + sovJob(uint64(l))
		}
	}
	return n
}

func (m *JobStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobIds) > 0 {
		for _, s := range m.JobIds {
			l = len(s)
			n += 1 + l + sovJob(uint64(l))
		}
	}
	return n
}

func (m *JobStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.JobStates) > 0 {
		for k, v := range m.JobStates {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovJob(uint64(len(k))) + 1 + sovJob(uint64(v))
			n += mapEntrySize + 1 + sovJob(uint64(mapEntrySize))
		}
	}
	return n
}

func sovJob(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozJob(x uint64) (n int) {
	return sovJob(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *JobRunDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= JobRunState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeasedTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeasedTs == nil {
				m.LeasedTs = &types.Timestamp{}
			}
			if err := m.LeasedTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PendingTs == nil {
				m.PendingTs = &types.Timestamp{}
			}
			if err := m.PendingTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedTs == nil {
				m.StartedTs = &types.Timestamp{}
			}
			if err := m.StartedTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinishedTs == nil {
				m.FinishedTs = &types.Timestamp{}
			}
			if err := m.FinishedTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubmittedTs == nil {
				m.SubmittedTs = &types.Timestamp{}
			}
			if err := m.SubmittedTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CancelTs == nil {
				m.CancelTs = &types.Timestamp{}
			}
			if err := m.CancelTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CancelReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastTransitionTs == nil {
				m.LastTransitionTs = &types.Timestamp{}
			}
			if err := m.LastTransitionTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestRunId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestRunId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobSpec == nil {
				m.JobSpec = &Job{}
			}
			if err := m.JobSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRuns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobRuns = append(m.JobRuns, &JobRunDetails{})
			if err := m.JobRuns[len(m.JobRuns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobDetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobIds = append(m.JobIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandJobSpec", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpandJobSpec = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandJobRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpandJobRun = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobDetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobDetails == nil {
				m.JobDetails = make(map[string]*JobDetails)
			}
			var mapkey string
			var mapvalue *JobDetails
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJob
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJob
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthJob
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJob
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthJob
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &JobDetails{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJob(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthJob
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JobDetails[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunDetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobRunDetails == nil {
				m.JobRunDetails = make(map[string]*JobRunDetails)
			}
			var mapkey string
			var mapvalue *JobRunDetails
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJob
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJob
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthJob
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthJob
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthJob
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &JobRunDetails{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJob(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthJob
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JobRunDetails[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunDetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RunIds = append(m.RunIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobIds = append(m.JobIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthJob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthJob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobStates == nil {
				m.JobStates = make(map[string]JobState)
			}
			var mapkey string
			var mapvalue JobState
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowJob
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthJob
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthJob
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowJob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= JobState(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipJob(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthJob
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JobStates[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthJob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipJob(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowJob
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthJob
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupJob
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthJob
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthJob        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowJob          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupJob = fmt.Errorf("proto: unexpected end of group")
)
