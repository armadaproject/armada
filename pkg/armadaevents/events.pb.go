// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/armadaevents/events.proto

package armadaevents

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	v11 "k8s.io/api/core/v1"
	v1 "k8s.io/api/networking/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"

	schedulerobjects "github.com/armadaproject/armada/internal/scheduler/schedulerobjects"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type JobState int32

const (
	JobState_QUEUED  JobState = 0
	JobState_PENDING JobState = 1
	JobState_RUNNING JobState = 2
)

var JobState_name = map[int32]string{
	0: "QUEUED",
	1: "PENDING",
	2: "RUNNING",
}

var JobState_value = map[string]int32{
	"QUEUED":  0,
	"PENDING": 1,
	"RUNNING": 2,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}

func (JobState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{0}
}

// Reason reported by Kubernetes.
type KubernetesReason int32

const (
	KubernetesReason_AppError         KubernetesReason = 0
	KubernetesReason_Evicted          KubernetesReason = 1
	KubernetesReason_OOM              KubernetesReason = 2
	KubernetesReason_DeadlineExceeded KubernetesReason = 3
)

var KubernetesReason_name = map[int32]string{
	0: "AppError",
	1: "Evicted",
	2: "OOM",
	3: "DeadlineExceeded",
}

var KubernetesReason_value = map[string]int32{
	"AppError":         0,
	"Evicted":          1,
	"OOM":              2,
	"DeadlineExceeded": 3,
}

func (x KubernetesReason) String() string {
	return proto.EnumName(KubernetesReason_name, int32(x))
}

func (KubernetesReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{1}
}

// Message representing a sequence of state transitions.
// This is the only message type that should ever be published to the log.
type EventSequence struct {
	// The system is namespaced by queue, and all events are associated with a job set.
	// Hence, these are included with every message.
	Queue string `protobuf:"bytes,1,opt,name=queue,proto3" json:"queue,omitempty"`
	// Each job set has a unique name.
	JobSetName string `protobuf:"bytes,2,opt,name=job_set_name,json=jobSetName,proto3" json:"jobSetName,omitempty"`
	// Id of the user submitting the message. Is passed on to Kubernetes.
	// Leave empty for messages generated by Armada itself.
	UserId string `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"userId,omitempty"`
	// List of groups the user is member of. Is passed on to Kubernetes.
	Groups []string `protobuf:"bytes,4,rep,name=groups,proto3" json:"groups,omitempty"`
	// For efficiency, we bundle several events (i.e., state transitions) in a single log message.
	Events []*EventSequence_Event `protobuf:"bytes,5,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *EventSequence) Reset()         { *m = EventSequence{} }
func (m *EventSequence) String() string { return proto.CompactTextString(m) }
func (*EventSequence) ProtoMessage()    {}
func (*EventSequence) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{0}
}
func (m *EventSequence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSequence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSequence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSequence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSequence.Merge(m, src)
}
func (m *EventSequence) XXX_Size() int {
	return m.Size()
}
func (m *EventSequence) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSequence.DiscardUnknown(m)
}

var xxx_messageInfo_EventSequence proto.InternalMessageInfo

func (m *EventSequence) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *EventSequence) GetJobSetName() string {
	if m != nil {
		return m.JobSetName
	}
	return ""
}

func (m *EventSequence) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *EventSequence) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *EventSequence) GetEvents() []*EventSequence_Event {
	if m != nil {
		return m.Events
	}
	return nil
}

// List of possible events, i.e., state transitions.
type EventSequence_Event struct {
	Created *time.Time `protobuf:"bytes,18,opt,name=created,proto3,stdtime" json:"created,omitempty"`
	// Types that are valid to be assigned to Event:
	//	*EventSequence_Event_SubmitJob
	//	*EventSequence_Event_ReprioritiseJob
	//	*EventSequence_Event_ReprioritiseJobSet
	//	*EventSequence_Event_ReprioritisedJob
	//	*EventSequence_Event_CancelJob
	//	*EventSequence_Event_CancelJobSet
	//	*EventSequence_Event_CancelledJob
	//	*EventSequence_Event_JobSucceeded
	//	*EventSequence_Event_JobErrors
	//	*EventSequence_Event_JobRunLeased
	//	*EventSequence_Event_JobRunAssigned
	//	*EventSequence_Event_JobRunRunning
	//	*EventSequence_Event_JobRunSucceeded
	//	*EventSequence_Event_JobRunErrors
	//	*EventSequence_Event_JobDuplicateDetected
	//	*EventSequence_Event_StandaloneIngressInfo
	//	*EventSequence_Event_ResourceUtilisation
	//	*EventSequence_Event_JobRunPreempted
	//	*EventSequence_Event_PartitionMarker
	//	*EventSequence_Event_JobRunPreemptionRequested
	//	*EventSequence_Event_JobRequeued
	Event isEventSequence_Event_Event `protobuf_oneof:"event"`
}

func (m *EventSequence_Event) Reset()         { *m = EventSequence_Event{} }
func (m *EventSequence_Event) String() string { return proto.CompactTextString(m) }
func (*EventSequence_Event) ProtoMessage()    {}
func (*EventSequence_Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{0, 0}
}
func (m *EventSequence_Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSequence_Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSequence_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSequence_Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSequence_Event.Merge(m, src)
}
func (m *EventSequence_Event) XXX_Size() int {
	return m.Size()
}
func (m *EventSequence_Event) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSequence_Event.DiscardUnknown(m)
}

var xxx_messageInfo_EventSequence_Event proto.InternalMessageInfo

type isEventSequence_Event_Event interface {
	isEventSequence_Event_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EventSequence_Event_SubmitJob struct {
	SubmitJob *SubmitJob `protobuf:"bytes,1,opt,name=submitJob,proto3,oneof" json:"submitJob,omitempty"`
}
type EventSequence_Event_ReprioritiseJob struct {
	ReprioritiseJob *ReprioritiseJob `protobuf:"bytes,2,opt,name=reprioritiseJob,proto3,oneof" json:"reprioritiseJob,omitempty"`
}
type EventSequence_Event_ReprioritiseJobSet struct {
	ReprioritiseJobSet *ReprioritiseJobSet `protobuf:"bytes,3,opt,name=reprioritiseJobSet,proto3,oneof" json:"reprioritiseJobSet,omitempty"`
}
type EventSequence_Event_ReprioritisedJob struct {
	ReprioritisedJob *ReprioritisedJob `protobuf:"bytes,4,opt,name=reprioritisedJob,proto3,oneof" json:"reprioritisedJob,omitempty"`
}
type EventSequence_Event_CancelJob struct {
	CancelJob *CancelJob `protobuf:"bytes,5,opt,name=cancelJob,proto3,oneof" json:"cancelJob,omitempty"`
}
type EventSequence_Event_CancelJobSet struct {
	CancelJobSet *CancelJobSet `protobuf:"bytes,6,opt,name=cancelJobSet,proto3,oneof" json:"cancelJobSet,omitempty"`
}
type EventSequence_Event_CancelledJob struct {
	CancelledJob *CancelledJob `protobuf:"bytes,7,opt,name=cancelledJob,proto3,oneof" json:"cancelledJob,omitempty"`
}
type EventSequence_Event_JobSucceeded struct {
	JobSucceeded *JobSucceeded `protobuf:"bytes,8,opt,name=jobSucceeded,proto3,oneof" json:"jobSucceeded,omitempty"`
}
type EventSequence_Event_JobErrors struct {
	JobErrors *JobErrors `protobuf:"bytes,9,opt,name=jobErrors,proto3,oneof" json:"jobErrors,omitempty"`
}
type EventSequence_Event_JobRunLeased struct {
	JobRunLeased *JobRunLeased `protobuf:"bytes,10,opt,name=jobRunLeased,proto3,oneof" json:"jobRunLeased,omitempty"`
}
type EventSequence_Event_JobRunAssigned struct {
	JobRunAssigned *JobRunAssigned `protobuf:"bytes,11,opt,name=jobRunAssigned,proto3,oneof" json:"jobRunAssigned,omitempty"`
}
type EventSequence_Event_JobRunRunning struct {
	JobRunRunning *JobRunRunning `protobuf:"bytes,12,opt,name=jobRunRunning,proto3,oneof" json:"jobRunRunning,omitempty"`
}
type EventSequence_Event_JobRunSucceeded struct {
	JobRunSucceeded *JobRunSucceeded `protobuf:"bytes,13,opt,name=jobRunSucceeded,proto3,oneof" json:"jobRunSucceeded,omitempty"`
}
type EventSequence_Event_JobRunErrors struct {
	JobRunErrors *JobRunErrors `protobuf:"bytes,14,opt,name=jobRunErrors,proto3,oneof" json:"jobRunErrors,omitempty"`
}
type EventSequence_Event_JobDuplicateDetected struct {
	JobDuplicateDetected *JobDuplicateDetected `protobuf:"bytes,15,opt,name=jobDuplicateDetected,proto3,oneof" json:"jobDuplicateDetected,omitempty"`
}
type EventSequence_Event_StandaloneIngressInfo struct {
	StandaloneIngressInfo *StandaloneIngressInfo `protobuf:"bytes,16,opt,name=standaloneIngressInfo,proto3,oneof" json:"standaloneIngressInfo,omitempty"`
}
type EventSequence_Event_ResourceUtilisation struct {
	ResourceUtilisation *ResourceUtilisation `protobuf:"bytes,17,opt,name=resourceUtilisation,proto3,oneof" json:"resourceUtilisation,omitempty"`
}
type EventSequence_Event_JobRunPreempted struct {
	JobRunPreempted *JobRunPreempted `protobuf:"bytes,19,opt,name=jobRunPreempted,proto3,oneof" json:"jobRunPreempted,omitempty"`
}
type EventSequence_Event_PartitionMarker struct {
	PartitionMarker *PartitionMarker `protobuf:"bytes,20,opt,name=partitionMarker,proto3,oneof" json:"partitionMarker,omitempty"`
}
type EventSequence_Event_JobRunPreemptionRequested struct {
	JobRunPreemptionRequested *JobRunPreemptionRequested `protobuf:"bytes,21,opt,name=jobRunPreemptionRequested,proto3,oneof" json:"jobRunPreemptionRequested,omitempty"`
}
type EventSequence_Event_JobRequeued struct {
	JobRequeued *JobRequeued `protobuf:"bytes,22,opt,name=jobRequeued,proto3,oneof" json:"jobRequeued,omitempty"`
}

func (*EventSequence_Event_SubmitJob) isEventSequence_Event_Event()                 {}
func (*EventSequence_Event_ReprioritiseJob) isEventSequence_Event_Event()           {}
func (*EventSequence_Event_ReprioritiseJobSet) isEventSequence_Event_Event()        {}
func (*EventSequence_Event_ReprioritisedJob) isEventSequence_Event_Event()          {}
func (*EventSequence_Event_CancelJob) isEventSequence_Event_Event()                 {}
func (*EventSequence_Event_CancelJobSet) isEventSequence_Event_Event()              {}
func (*EventSequence_Event_CancelledJob) isEventSequence_Event_Event()              {}
func (*EventSequence_Event_JobSucceeded) isEventSequence_Event_Event()              {}
func (*EventSequence_Event_JobErrors) isEventSequence_Event_Event()                 {}
func (*EventSequence_Event_JobRunLeased) isEventSequence_Event_Event()              {}
func (*EventSequence_Event_JobRunAssigned) isEventSequence_Event_Event()            {}
func (*EventSequence_Event_JobRunRunning) isEventSequence_Event_Event()             {}
func (*EventSequence_Event_JobRunSucceeded) isEventSequence_Event_Event()           {}
func (*EventSequence_Event_JobRunErrors) isEventSequence_Event_Event()              {}
func (*EventSequence_Event_JobDuplicateDetected) isEventSequence_Event_Event()      {}
func (*EventSequence_Event_StandaloneIngressInfo) isEventSequence_Event_Event()     {}
func (*EventSequence_Event_ResourceUtilisation) isEventSequence_Event_Event()       {}
func (*EventSequence_Event_JobRunPreempted) isEventSequence_Event_Event()           {}
func (*EventSequence_Event_PartitionMarker) isEventSequence_Event_Event()           {}
func (*EventSequence_Event_JobRunPreemptionRequested) isEventSequence_Event_Event() {}
func (*EventSequence_Event_JobRequeued) isEventSequence_Event_Event()               {}

func (m *EventSequence_Event) GetEvent() isEventSequence_Event_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *EventSequence_Event) GetCreated() *time.Time {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *EventSequence_Event) GetSubmitJob() *SubmitJob {
	if x, ok := m.GetEvent().(*EventSequence_Event_SubmitJob); ok {
		return x.SubmitJob
	}
	return nil
}

func (m *EventSequence_Event) GetReprioritiseJob() *ReprioritiseJob {
	if x, ok := m.GetEvent().(*EventSequence_Event_ReprioritiseJob); ok {
		return x.ReprioritiseJob
	}
	return nil
}

func (m *EventSequence_Event) GetReprioritiseJobSet() *ReprioritiseJobSet {
	if x, ok := m.GetEvent().(*EventSequence_Event_ReprioritiseJobSet); ok {
		return x.ReprioritiseJobSet
	}
	return nil
}

func (m *EventSequence_Event) GetReprioritisedJob() *ReprioritisedJob {
	if x, ok := m.GetEvent().(*EventSequence_Event_ReprioritisedJob); ok {
		return x.ReprioritisedJob
	}
	return nil
}

func (m *EventSequence_Event) GetCancelJob() *CancelJob {
	if x, ok := m.GetEvent().(*EventSequence_Event_CancelJob); ok {
		return x.CancelJob
	}
	return nil
}

func (m *EventSequence_Event) GetCancelJobSet() *CancelJobSet {
	if x, ok := m.GetEvent().(*EventSequence_Event_CancelJobSet); ok {
		return x.CancelJobSet
	}
	return nil
}

func (m *EventSequence_Event) GetCancelledJob() *CancelledJob {
	if x, ok := m.GetEvent().(*EventSequence_Event_CancelledJob); ok {
		return x.CancelledJob
	}
	return nil
}

func (m *EventSequence_Event) GetJobSucceeded() *JobSucceeded {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobSucceeded); ok {
		return x.JobSucceeded
	}
	return nil
}

func (m *EventSequence_Event) GetJobErrors() *JobErrors {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobErrors); ok {
		return x.JobErrors
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunLeased() *JobRunLeased {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunLeased); ok {
		return x.JobRunLeased
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunAssigned() *JobRunAssigned {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunAssigned); ok {
		return x.JobRunAssigned
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunRunning() *JobRunRunning {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunRunning); ok {
		return x.JobRunRunning
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunSucceeded() *JobRunSucceeded {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunSucceeded); ok {
		return x.JobRunSucceeded
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunErrors() *JobRunErrors {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunErrors); ok {
		return x.JobRunErrors
	}
	return nil
}

func (m *EventSequence_Event) GetJobDuplicateDetected() *JobDuplicateDetected {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobDuplicateDetected); ok {
		return x.JobDuplicateDetected
	}
	return nil
}

func (m *EventSequence_Event) GetStandaloneIngressInfo() *StandaloneIngressInfo {
	if x, ok := m.GetEvent().(*EventSequence_Event_StandaloneIngressInfo); ok {
		return x.StandaloneIngressInfo
	}
	return nil
}

func (m *EventSequence_Event) GetResourceUtilisation() *ResourceUtilisation {
	if x, ok := m.GetEvent().(*EventSequence_Event_ResourceUtilisation); ok {
		return x.ResourceUtilisation
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunPreempted() *JobRunPreempted {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunPreempted); ok {
		return x.JobRunPreempted
	}
	return nil
}

func (m *EventSequence_Event) GetPartitionMarker() *PartitionMarker {
	if x, ok := m.GetEvent().(*EventSequence_Event_PartitionMarker); ok {
		return x.PartitionMarker
	}
	return nil
}

func (m *EventSequence_Event) GetJobRunPreemptionRequested() *JobRunPreemptionRequested {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRunPreemptionRequested); ok {
		return x.JobRunPreemptionRequested
	}
	return nil
}

func (m *EventSequence_Event) GetJobRequeued() *JobRequeued {
	if x, ok := m.GetEvent().(*EventSequence_Event_JobRequeued); ok {
		return x.JobRequeued
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EventSequence_Event) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EventSequence_Event_SubmitJob)(nil),
		(*EventSequence_Event_ReprioritiseJob)(nil),
		(*EventSequence_Event_ReprioritiseJobSet)(nil),
		(*EventSequence_Event_ReprioritisedJob)(nil),
		(*EventSequence_Event_CancelJob)(nil),
		(*EventSequence_Event_CancelJobSet)(nil),
		(*EventSequence_Event_CancelledJob)(nil),
		(*EventSequence_Event_JobSucceeded)(nil),
		(*EventSequence_Event_JobErrors)(nil),
		(*EventSequence_Event_JobRunLeased)(nil),
		(*EventSequence_Event_JobRunAssigned)(nil),
		(*EventSequence_Event_JobRunRunning)(nil),
		(*EventSequence_Event_JobRunSucceeded)(nil),
		(*EventSequence_Event_JobRunErrors)(nil),
		(*EventSequence_Event_JobDuplicateDetected)(nil),
		(*EventSequence_Event_StandaloneIngressInfo)(nil),
		(*EventSequence_Event_ResourceUtilisation)(nil),
		(*EventSequence_Event_JobRunPreempted)(nil),
		(*EventSequence_Event_PartitionMarker)(nil),
		(*EventSequence_Event_JobRunPreemptionRequested)(nil),
		(*EventSequence_Event_JobRequeued)(nil),
	}
}

// Resource usage of a particular k8s object created as part of a job.
type ResourceUtilisation struct {
	RunId                 *Uuid                        `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"runId,omitempty"`
	JobId                 *Uuid                        `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	ResourceInfo          *KubernetesResourceInfo      `protobuf:"bytes,3,opt,name=resource_info,json=resourceInfo,proto3" json:"resourceInfo,omitempty"`
	MaxResourcesForPeriod map[string]resource.Quantity `protobuf:"bytes,4,rep,name=max_resources_for_period,json=maxResourcesForPeriod,proto3" json:"maxResourcesForPeriod" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TotalCumulativeUsage  map[string]resource.Quantity `protobuf:"bytes,5,rep,name=total_cumulative_usage,json=totalCumulativeUsage,proto3" json:"totalCumulativeUsage" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ResourceUtilisation) Reset()         { *m = ResourceUtilisation{} }
func (m *ResourceUtilisation) String() string { return proto.CompactTextString(m) }
func (*ResourceUtilisation) ProtoMessage()    {}
func (*ResourceUtilisation) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{1}
}
func (m *ResourceUtilisation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceUtilisation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceUtilisation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceUtilisation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceUtilisation.Merge(m, src)
}
func (m *ResourceUtilisation) XXX_Size() int {
	return m.Size()
}
func (m *ResourceUtilisation) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceUtilisation.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceUtilisation proto.InternalMessageInfo

func (m *ResourceUtilisation) GetRunId() *Uuid {
	if m != nil {
		return m.RunId
	}
	return nil
}

func (m *ResourceUtilisation) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *ResourceUtilisation) GetResourceInfo() *KubernetesResourceInfo {
	if m != nil {
		return m.ResourceInfo
	}
	return nil
}

func (m *ResourceUtilisation) GetMaxResourcesForPeriod() map[string]resource.Quantity {
	if m != nil {
		return m.MaxResourcesForPeriod
	}
	return nil
}

func (m *ResourceUtilisation) GetTotalCumulativeUsage() map[string]resource.Quantity {
	if m != nil {
		return m.TotalCumulativeUsage
	}
	return nil
}

// A UUID, encoded in accordance with section 4.1.2 of RFC 4122
// (technically equivalent to ITU-T Rec. X.667 and ISO/IEC 9834-8).
// As of March 2022, this seems to be the most efficient way to include UUIDs in proto messages; see
// https://github.com/protocolbuffers/protobuf/issues/2224#issuecomment-760635430
type Uuid struct {
	// The high 64 bits of the UUID - MSB -> LSB: time_low (32 bits) | time_mid (16 bits) | time_hi_and_version (16 bits).
	High64 uint64 `protobuf:"fixed64,1,opt,name=high64,proto3" json:"high64,omitempty"`
	// The low 64 bits of the UUID - MSB -> LSB: clock_seq_hi_and_reserved (8 bits) | clock_seq_low (8 bits) | node (48 bits).
	Low64 uint64 `protobuf:"fixed64,2,opt,name=low64,proto3" json:"low64,omitempty"`
}

func (m *Uuid) Reset()         { *m = Uuid{} }
func (m *Uuid) String() string { return proto.CompactTextString(m) }
func (*Uuid) ProtoMessage()    {}
func (*Uuid) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{2}
}
func (m *Uuid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Uuid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Uuid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Uuid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Uuid.Merge(m, src)
}
func (m *Uuid) XXX_Size() int {
	return m.Size()
}
func (m *Uuid) XXX_DiscardUnknown() {
	xxx_messageInfo_Uuid.DiscardUnknown(m)
}

var xxx_messageInfo_Uuid proto.InternalMessageInfo

func (m *Uuid) GetHigh64() uint64 {
	if m != nil {
		return m.High64
	}
	return 0
}

func (m *Uuid) GetLow64() uint64 {
	if m != nil {
		return m.Low64
	}
	return 0
}

// A request to run an Armada job. Each job consists of a set of Kubernetes objects,
// one of which is the main object (typically a pod spec.) and has a priority associated with it.
// When the main object exits, all other objects are cleaned up.
// The priority, together with the queue the job is submitted to, determines the order in which jobs are run.
type SubmitJob struct {
	// Each application may be run multiple times. This id uniquely identifies this job.
	JobId *Uuid `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	// User-provided id used for server-side deduplication.
	// I.e., jobs submitted with the same deduplication_id as an existing job are discarded.
	// TODO: If we can deduplicate at the API endpoint, we don't need this on the log.
	DeduplicationId string `protobuf:"bytes,2,opt,name=deduplication_id,json=deduplicationId,proto3" json:"deduplicationId,omitempty"`
	// Priority of this job. Measured relative to other jobs in the same queue.
	Priority uint32 `protobuf:"varint,3,opt,name=priority,proto3" json:"priority,omitempty"`
	// Shared ObjectMeta for all Kubernetes objects in this job.
	// If provided, the namespace therein is used for all objects that do not explicitly specify another.
	// And the labels and annotations therein are applied to all objects part of the job.
	ObjectMeta *ObjectMeta `protobuf:"bytes,4,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	// Main object that determines when an application has finished.
	MainObject *KubernetesMainObject `protobuf:"bytes,5,opt,name=mainObject,proto3" json:"mainObject,omitempty"`
	// Set of additional Kubernetes objects to create as part of the job.
	Objects []*KubernetesObject `protobuf:"bytes,6,rep,name=objects,proto3" json:"objects,omitempty"`
	// Maximum lifetime of the job in seconds. Zero indicates an infinite lifetime.
	Lifetime uint32 `protobuf:"varint,7,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	// If true, the job is run at most once, i.e., at most one job run will be created for it.
	// If false, the job may be re-leased on failure, which may cause the job to run more than once
	// (e.g., if a job run succeeds but the executor fails before it can report job success).
	AtMostOnce bool `protobuf:"varint,8,opt,name=atMostOnce,proto3" json:"atMostOnce,omitempty"`
	// If true, Armada may preempt the job while running.
	Preemptible bool `protobuf:"varint,9,opt,name=preemptible,proto3" json:"preemptible,omitempty"`
	// If true, Armada may optimistically run several instances of the job concurrently
	// (typically on different clusters).
	// If false, a new job run may only be created once Armada is certain that all existing runs have finished.
	ConcurrencySafe bool `protobuf:"varint,10,opt,name=concurrencySafe,proto3" json:"concurrencySafe,omitempty"`
	// Indicates which scheduler should manage this job.
	// If empty, the default scheduler is used.
	Scheduler string `protobuf:"bytes,11,opt,name=scheduler,proto3" json:"scheduler,omitempty"`
	// Indicates whether job is a duplicate
	IsDuplicate bool `protobuf:"varint,12,opt,name=isDuplicate,proto3" json:"isDuplicate,omitempty"`
	// Queuing TTL for this job in seconds. If this job queues for more than this duration it will be cancelled. Zero indicates an infinite lifetime.
	QueueTtlSeconds int64 `protobuf:"varint,13,opt,name=queue_ttl_seconds,json=queueTtlSeconds,proto3" json:"queueTtlSeconds,omitempty"`
}

func (m *SubmitJob) Reset()         { *m = SubmitJob{} }
func (m *SubmitJob) String() string { return proto.CompactTextString(m) }
func (*SubmitJob) ProtoMessage()    {}
func (*SubmitJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{3}
}
func (m *SubmitJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitJob.Merge(m, src)
}
func (m *SubmitJob) XXX_Size() int {
	return m.Size()
}
func (m *SubmitJob) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitJob.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitJob proto.InternalMessageInfo

func (m *SubmitJob) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *SubmitJob) GetDeduplicationId() string {
	if m != nil {
		return m.DeduplicationId
	}
	return ""
}

func (m *SubmitJob) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *SubmitJob) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *SubmitJob) GetMainObject() *KubernetesMainObject {
	if m != nil {
		return m.MainObject
	}
	return nil
}

func (m *SubmitJob) GetObjects() []*KubernetesObject {
	if m != nil {
		return m.Objects
	}
	return nil
}

func (m *SubmitJob) GetLifetime() uint32 {
	if m != nil {
		return m.Lifetime
	}
	return 0
}

func (m *SubmitJob) GetAtMostOnce() bool {
	if m != nil {
		return m.AtMostOnce
	}
	return false
}

func (m *SubmitJob) GetPreemptible() bool {
	if m != nil {
		return m.Preemptible
	}
	return false
}

func (m *SubmitJob) GetConcurrencySafe() bool {
	if m != nil {
		return m.ConcurrencySafe
	}
	return false
}

func (m *SubmitJob) GetScheduler() string {
	if m != nil {
		return m.Scheduler
	}
	return ""
}

func (m *SubmitJob) GetIsDuplicate() bool {
	if m != nil {
		return m.IsDuplicate
	}
	return false
}

func (m *SubmitJob) GetQueueTtlSeconds() int64 {
	if m != nil {
		return m.QueueTtlSeconds
	}
	return 0
}

// Kubernetes objects that can serve as main objects for an Armada job.
type KubernetesMainObject struct {
	ObjectMeta *ObjectMeta `protobuf:"bytes,1,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	// Types that are valid to be assigned to Object:
	//	*KubernetesMainObject_PodSpec
	Object isKubernetesMainObject_Object `protobuf_oneof:"object"`
}

func (m *KubernetesMainObject) Reset()         { *m = KubernetesMainObject{} }
func (m *KubernetesMainObject) String() string { return proto.CompactTextString(m) }
func (*KubernetesMainObject) ProtoMessage()    {}
func (*KubernetesMainObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{4}
}
func (m *KubernetesMainObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesMainObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesMainObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesMainObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesMainObject.Merge(m, src)
}
func (m *KubernetesMainObject) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesMainObject) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesMainObject.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesMainObject proto.InternalMessageInfo

type isKubernetesMainObject_Object interface {
	isKubernetesMainObject_Object()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KubernetesMainObject_PodSpec struct {
	PodSpec *PodSpecWithAvoidList `protobuf:"bytes,2,opt,name=pod_spec,json=podSpec,proto3,oneof" json:"podSpec,omitempty"`
}

func (*KubernetesMainObject_PodSpec) isKubernetesMainObject_Object() {}

func (m *KubernetesMainObject) GetObject() isKubernetesMainObject_Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *KubernetesMainObject) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *KubernetesMainObject) GetPodSpec() *PodSpecWithAvoidList {
	if x, ok := m.GetObject().(*KubernetesMainObject_PodSpec); ok {
		return x.PodSpec
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KubernetesMainObject) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KubernetesMainObject_PodSpec)(nil),
	}
}

// Kubernetes objects that can be created as part of an Armada.
type KubernetesObject struct {
	ObjectMeta *ObjectMeta `protobuf:"bytes,1,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	// Types that are valid to be assigned to Object:
	//	*KubernetesObject_PodSpec
	//	*KubernetesObject_Ingress
	//	*KubernetesObject_Service
	//	*KubernetesObject_ConfigMap
	Object isKubernetesObject_Object `protobuf_oneof:"object"`
}

func (m *KubernetesObject) Reset()         { *m = KubernetesObject{} }
func (m *KubernetesObject) String() string { return proto.CompactTextString(m) }
func (*KubernetesObject) ProtoMessage()    {}
func (*KubernetesObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{5}
}
func (m *KubernetesObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesObject.Merge(m, src)
}
func (m *KubernetesObject) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesObject) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesObject.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesObject proto.InternalMessageInfo

type isKubernetesObject_Object interface {
	isKubernetesObject_Object()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KubernetesObject_PodSpec struct {
	PodSpec *PodSpecWithAvoidList `protobuf:"bytes,2,opt,name=pod_spec,json=podSpec,proto3,oneof" json:"podSpec,omitempty"`
}
type KubernetesObject_Ingress struct {
	Ingress *v1.IngressSpec `protobuf:"bytes,3,opt,name=ingress,proto3,oneof" json:"ingress,omitempty"`
}
type KubernetesObject_Service struct {
	Service *v11.ServiceSpec `protobuf:"bytes,4,opt,name=service,proto3,oneof" json:"service,omitempty"`
}
type KubernetesObject_ConfigMap struct {
	ConfigMap *v11.ConfigMap `protobuf:"bytes,5,opt,name=configMap,proto3,oneof" json:"configMap,omitempty"`
}

func (*KubernetesObject_PodSpec) isKubernetesObject_Object()   {}
func (*KubernetesObject_Ingress) isKubernetesObject_Object()   {}
func (*KubernetesObject_Service) isKubernetesObject_Object()   {}
func (*KubernetesObject_ConfigMap) isKubernetesObject_Object() {}

func (m *KubernetesObject) GetObject() isKubernetesObject_Object {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *KubernetesObject) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *KubernetesObject) GetPodSpec() *PodSpecWithAvoidList {
	if x, ok := m.GetObject().(*KubernetesObject_PodSpec); ok {
		return x.PodSpec
	}
	return nil
}

func (m *KubernetesObject) GetIngress() *v1.IngressSpec {
	if x, ok := m.GetObject().(*KubernetesObject_Ingress); ok {
		return x.Ingress
	}
	return nil
}

func (m *KubernetesObject) GetService() *v11.ServiceSpec {
	if x, ok := m.GetObject().(*KubernetesObject_Service); ok {
		return x.Service
	}
	return nil
}

func (m *KubernetesObject) GetConfigMap() *v11.ConfigMap {
	if x, ok := m.GetObject().(*KubernetesObject_ConfigMap); ok {
		return x.ConfigMap
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KubernetesObject) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KubernetesObject_PodSpec)(nil),
		(*KubernetesObject_Ingress)(nil),
		(*KubernetesObject_Service)(nil),
		(*KubernetesObject_ConfigMap)(nil),
	}
}

// Auxiliary information needed to instantiate the object in Kubernetes.
// Inspired by the Kubernetes ObjectMeta object; see:
// https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L641
type ObjectMeta struct {
	// Unique id of the executor responsible for the Kubernetes cluster that created the object.
	// Is set by the executor on object creation.
	ExecutorId string `protobuf:"bytes,1,opt,name=executor_id,json=executorId,proto3" json:"executorId,omitempty"`
	Namespace  string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Name       string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Unique id assigned to the object by Kubernetes (typically a 128-bit UUID).
	// Should be left empty on job creation, but should be set, e.g., when in the JobRunRunning message.
	// Stored as a string because Kubernetes doesn't always use UUIDs; see
	// https://github.com/kubernetes/apimachinery/blob/master/pkg/types/uid.go#L19
	KubernetesId string            `protobuf:"bytes,4,opt,name=kubernetes_id,json=kubernetesId,proto3" json:"kubernetesId,omitempty"`
	Annotations  map[string]string `protobuf:"bytes,5,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Labels       map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ObjectMeta) Reset()         { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()    {}
func (*ObjectMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{6}
}
func (m *ObjectMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMeta.Merge(m, src)
}
func (m *ObjectMeta) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMeta proto.InternalMessageInfo

func (m *ObjectMeta) GetExecutorId() string {
	if m != nil {
		return m.ExecutorId
	}
	return ""
}

func (m *ObjectMeta) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectMeta) GetKubernetesId() string {
	if m != nil {
		return m.KubernetesId
	}
	return ""
}

func (m *ObjectMeta) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectMeta) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// Kubernetes pod spec. with a bundled list of pods to avoid scheduling the pod to.
type PodSpecWithAvoidList struct {
	PodSpec *v11.PodSpec `protobuf:"bytes,1,opt,name=pod_spec,json=podSpec,proto3" json:"podSpec,omitempty"`
	// List of nodes to avoid scheduling this pod on.
	// TODO: Could this be done with selectors, taints, etc?
	NodeAvoidlist []string `protobuf:"bytes,2,rep,name=node_avoidlist,json=nodeAvoidlist,proto3" json:"nodeAvoidlist,omitempty"`
}

func (m *PodSpecWithAvoidList) Reset()         { *m = PodSpecWithAvoidList{} }
func (m *PodSpecWithAvoidList) String() string { return proto.CompactTextString(m) }
func (*PodSpecWithAvoidList) ProtoMessage()    {}
func (*PodSpecWithAvoidList) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{7}
}
func (m *PodSpecWithAvoidList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodSpecWithAvoidList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodSpecWithAvoidList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodSpecWithAvoidList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodSpecWithAvoidList.Merge(m, src)
}
func (m *PodSpecWithAvoidList) XXX_Size() int {
	return m.Size()
}
func (m *PodSpecWithAvoidList) XXX_DiscardUnknown() {
	xxx_messageInfo_PodSpecWithAvoidList.DiscardUnknown(m)
}

var xxx_messageInfo_PodSpecWithAvoidList proto.InternalMessageInfo

func (m *PodSpecWithAvoidList) GetPodSpec() *v11.PodSpec {
	if m != nil {
		return m.PodSpec
	}
	return nil
}

func (m *PodSpecWithAvoidList) GetNodeAvoidlist() []string {
	if m != nil {
		return m.NodeAvoidlist
	}
	return nil
}

// Set the priority of a particular job.
type ReprioritiseJob struct {
	JobId    *Uuid  `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	Priority uint32 `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *ReprioritiseJob) Reset()         { *m = ReprioritiseJob{} }
func (m *ReprioritiseJob) String() string { return proto.CompactTextString(m) }
func (*ReprioritiseJob) ProtoMessage()    {}
func (*ReprioritiseJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{8}
}
func (m *ReprioritiseJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReprioritiseJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReprioritiseJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReprioritiseJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReprioritiseJob.Merge(m, src)
}
func (m *ReprioritiseJob) XXX_Size() int {
	return m.Size()
}
func (m *ReprioritiseJob) XXX_DiscardUnknown() {
	xxx_messageInfo_ReprioritiseJob.DiscardUnknown(m)
}

var xxx_messageInfo_ReprioritiseJob proto.InternalMessageInfo

func (m *ReprioritiseJob) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *ReprioritiseJob) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

type JobRequeued struct {
	JobId          *Uuid                               `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	SchedulingInfo *schedulerobjects.JobSchedulingInfo `protobuf:"bytes,2,opt,name=scheduling_info,json=schedulingInfo,proto3" json:"schedulingInfo,omitempty"`
	// Used by the scheduler to maintain a consistent state
	UpdateSequenceNumber int32 `protobuf:"varint,3,opt,name=update_sequence_number,json=updateSequenceNumber,proto3" json:"updateSequenceNumber,omitempty"`
}

func (m *JobRequeued) Reset()         { *m = JobRequeued{} }
func (m *JobRequeued) String() string { return proto.CompactTextString(m) }
func (*JobRequeued) ProtoMessage()    {}
func (*JobRequeued) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{9}
}
func (m *JobRequeued) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRequeued) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRequeued.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRequeued) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRequeued.Merge(m, src)
}
func (m *JobRequeued) XXX_Size() int {
	return m.Size()
}
func (m *JobRequeued) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRequeued.DiscardUnknown(m)
}

var xxx_messageInfo_JobRequeued proto.InternalMessageInfo

func (m *JobRequeued) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *JobRequeued) GetSchedulingInfo() *schedulerobjects.JobSchedulingInfo {
	if m != nil {
		return m.SchedulingInfo
	}
	return nil
}

func (m *JobRequeued) GetUpdateSequenceNumber() int32 {
	if m != nil {
		return m.UpdateSequenceNumber
	}
	return 0
}

// Set the priority of all jobs part of a job set.
// This sets the priority of all jobs in the job set currently in the queued state.
type ReprioritiseJobSet struct {
	Priority uint32 `protobuf:"varint,1,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *ReprioritiseJobSet) Reset()         { *m = ReprioritiseJobSet{} }
func (m *ReprioritiseJobSet) String() string { return proto.CompactTextString(m) }
func (*ReprioritiseJobSet) ProtoMessage()    {}
func (*ReprioritiseJobSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{10}
}
func (m *ReprioritiseJobSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReprioritiseJobSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReprioritiseJobSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReprioritiseJobSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReprioritiseJobSet.Merge(m, src)
}
func (m *ReprioritiseJobSet) XXX_Size() int {
	return m.Size()
}
func (m *ReprioritiseJobSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ReprioritiseJobSet.DiscardUnknown(m)
}

var xxx_messageInfo_ReprioritiseJobSet proto.InternalMessageInfo

func (m *ReprioritiseJobSet) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// Generated by the scheduler in response to ReprioritiseJob and ReprioritiseJobSet.
// One such message is generated per job that was re-prioritised and includes the new priority.
type ReprioritisedJob struct {
	JobId    *Uuid  `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	Priority uint32 `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *ReprioritisedJob) Reset()         { *m = ReprioritisedJob{} }
func (m *ReprioritisedJob) String() string { return proto.CompactTextString(m) }
func (*ReprioritisedJob) ProtoMessage()    {}
func (*ReprioritisedJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{11}
}
func (m *ReprioritisedJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReprioritisedJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReprioritisedJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReprioritisedJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReprioritisedJob.Merge(m, src)
}
func (m *ReprioritisedJob) XXX_Size() int {
	return m.Size()
}
func (m *ReprioritisedJob) XXX_DiscardUnknown() {
	xxx_messageInfo_ReprioritisedJob.DiscardUnknown(m)
}

var xxx_messageInfo_ReprioritisedJob proto.InternalMessageInfo

func (m *ReprioritisedJob) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *ReprioritisedJob) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// A request to cancel a particular job.
// This will cancel all runs (preempting it if running) for the job (i.e., move them to the failed state)
// and then cancel job itself (i.e., move it to the failed state).
type CancelJob struct {
	JobId  *Uuid  `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *CancelJob) Reset()         { *m = CancelJob{} }
func (m *CancelJob) String() string { return proto.CompactTextString(m) }
func (*CancelJob) ProtoMessage()    {}
func (*CancelJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{12}
}
func (m *CancelJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelJob.Merge(m, src)
}
func (m *CancelJob) XXX_Size() int {
	return m.Size()
}
func (m *CancelJob) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelJob.DiscardUnknown(m)
}

var xxx_messageInfo_CancelJob proto.InternalMessageInfo

func (m *CancelJob) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *CancelJob) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// Filter to be used when cancelling job sets
// This allows users to cancel all jobs in a given state for a specific job set
type JobSetFilter struct {
	States []JobState `protobuf:"varint,1,rep,packed,name=states,proto3,enum=armadaevents.JobState" json:"states,omitempty"`
}

func (m *JobSetFilter) Reset()         { *m = JobSetFilter{} }
func (m *JobSetFilter) String() string { return proto.CompactTextString(m) }
func (*JobSetFilter) ProtoMessage()    {}
func (*JobSetFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{13}
}
func (m *JobSetFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSetFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSetFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSetFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSetFilter.Merge(m, src)
}
func (m *JobSetFilter) XXX_Size() int {
	return m.Size()
}
func (m *JobSetFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSetFilter.DiscardUnknown(m)
}

var xxx_messageInfo_JobSetFilter proto.InternalMessageInfo

func (m *JobSetFilter) GetStates() []JobState {
	if m != nil {
		return m.States
	}
	return nil
}

// Request to cancel all jobs in a job set.
// Empty set of states means all states
type CancelJobSet struct {
	States []JobState `protobuf:"varint,1,rep,packed,name=states,proto3,enum=armadaevents.JobState" json:"states,omitempty"`
	Reason string     `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *CancelJobSet) Reset()         { *m = CancelJobSet{} }
func (m *CancelJobSet) String() string { return proto.CompactTextString(m) }
func (*CancelJobSet) ProtoMessage()    {}
func (*CancelJobSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{14}
}
func (m *CancelJobSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelJobSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelJobSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelJobSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelJobSet.Merge(m, src)
}
func (m *CancelJobSet) XXX_Size() int {
	return m.Size()
}
func (m *CancelJobSet) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelJobSet.DiscardUnknown(m)
}

var xxx_messageInfo_CancelJobSet proto.InternalMessageInfo

func (m *CancelJobSet) GetStates() []JobState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *CancelJobSet) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// Generated by the scheduler in response to CancelJob and CancelJobSet.
// One such message is generated per job that was cancelled.
type CancelledJob struct {
	JobId  *Uuid  `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *CancelledJob) Reset()         { *m = CancelledJob{} }
func (m *CancelledJob) String() string { return proto.CompactTextString(m) }
func (*CancelledJob) ProtoMessage()    {}
func (*CancelledJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{15}
}
func (m *CancelledJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelledJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelledJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelledJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelledJob.Merge(m, src)
}
func (m *CancelledJob) XXX_Size() int {
	return m.Size()
}
func (m *CancelledJob) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelledJob.DiscardUnknown(m)
}

var xxx_messageInfo_CancelledJob proto.InternalMessageInfo

func (m *CancelledJob) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *CancelledJob) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type JobSucceeded struct {
	JobId *Uuid `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	// Runtime information, e.g., which node the job is running on, its IP address etc,
	// for each resource created for the job run.
	// TODO: remove this once we have fixed the external api
	ResourceInfos []*KubernetesResourceInfo `protobuf:"bytes,2,rep,name=resourceInfos,proto3" json:"resourceInfos,omitempty"`
}

func (m *JobSucceeded) Reset()         { *m = JobSucceeded{} }
func (m *JobSucceeded) String() string { return proto.CompactTextString(m) }
func (*JobSucceeded) ProtoMessage()    {}
func (*JobSucceeded) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{16}
}
func (m *JobSucceeded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSucceeded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSucceeded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSucceeded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSucceeded.Merge(m, src)
}
func (m *JobSucceeded) XXX_Size() int {
	return m.Size()
}
func (m *JobSucceeded) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSucceeded.DiscardUnknown(m)
}

var xxx_messageInfo_JobSucceeded proto.InternalMessageInfo

func (m *JobSucceeded) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *JobSucceeded) GetResourceInfos() []*KubernetesResourceInfo {
	if m != nil {
		return m.ResourceInfos
	}
	return nil
}

// Indicates that a job has been leased to a cluster by the Armada scheduler.
type JobRunLeased struct {
	RunId *Uuid `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"runId,omitempty"`
	JobId *Uuid `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	// Each cluster is represented by an executor.
	ExecutorId string `protobuf:"bytes,3,opt,name=executor_id,json=executorId,proto3" json:"executorId,omitempty"`
	NodeId     string `protobuf:"bytes,4,opt,name=node_id,json=nodeId,proto3" json:"nodeId,omitempty"`
	// Used by the scheduler to maintain a consistent state
	UpdateSequenceNumber int32 `protobuf:"varint,5,opt,name=update_sequence_number,json=updateSequenceNumber,proto3" json:"updateSequenceNumber,omitempty"`
	// This bool is here because it is the most ergonomic way of distinguishing
	// the case where `scheduled_at_priority` was explicitly set to zero from
	// the case where it was not set at all.
	HasScheduledAtPriority bool `protobuf:"varint,6,opt,name=has_scheduled_at_priority,json=hasScheduledAtPriority,proto3" json:"hasScheduledAtPriority,omitempty"`
	// Priority class priority that this job was scheduled at.
	//
	// This is usually equal to the priority of the job's priority class, except
	// in the case where the job was scheduled as an away job; this field is
	// used to distinguish this case from the case where the job was scheduled
	// as a home job.
	ScheduledAtPriority int32 `protobuf:"varint,7,opt,name=scheduled_at_priority,json=scheduledAtPriority,proto3" json:"scheduledAtPriority,omitempty"`
	// The scheduler uses this field to modify the pod requirements of a job;
	// for example, it may add additional tolerations to runs that are scheduled
	// as away jobs.
	PodRequirementsOverlay *schedulerobjects.PodRequirements `protobuf:"bytes,9,opt,name=pod_requirements_overlay,json=podRequirementsOverlay,proto3" json:"podRequirementsOverlay,omitempty"`
}

func (m *JobRunLeased) Reset()         { *m = JobRunLeased{} }
func (m *JobRunLeased) String() string { return proto.CompactTextString(m) }
func (*JobRunLeased) ProtoMessage()    {}
func (*JobRunLeased) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{17}
}
func (m *JobRunLeased) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunLeased) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunLeased.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunLeased) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunLeased.Merge(m, src)
}
func (m *JobRunLeased) XXX_Size() int {
	return m.Size()
}
func (m *JobRunLeased) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunLeased.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunLeased proto.InternalMessageInfo

func (m *JobRunLeased) GetRunId() *Uuid {
	if m != nil {
		return m.RunId
	}
	return nil
}

func (m *JobRunLeased) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *JobRunLeased) GetExecutorId() string {
	if m != nil {
		return m.ExecutorId
	}
	return ""
}

func (m *JobRunLeased) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *JobRunLeased) GetUpdateSequenceNumber() int32 {
	if m != nil {
		return m.UpdateSequenceNumber
	}
	return 0
}

func (m *JobRunLeased) GetHasScheduledAtPriority() bool {
	if m != nil {
		return m.HasScheduledAtPriority
	}
	return false
}

func (m *JobRunLeased) GetScheduledAtPriority() int32 {
	if m != nil {
		return m.ScheduledAtPriority
	}
	return 0
}

func (m *JobRunLeased) GetPodRequirementsOverlay() *schedulerobjects.PodRequirements {
	if m != nil {
		return m.PodRequirementsOverlay
	}
	return nil
}

// Indicates that a job has been assigned to nodes by Kubernetes.
type JobRunAssigned struct {
	RunId *Uuid `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"runId,omitempty"`
	JobId *Uuid `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	// Runtime information, e.g., which node the job is running on, its IP address etc,
	// for each resource created for the job run.
	// Included here and in JobRunRunning for compatibility with legacy messages.
	ResourceInfos []*KubernetesResourceInfo `protobuf:"bytes,3,rep,name=resourceInfos,proto3" json:"resourceInfos,omitempty"`
}

func (m *JobRunAssigned) Reset()         { *m = JobRunAssigned{} }
func (m *JobRunAssigned) String() string { return proto.CompactTextString(m) }
func (*JobRunAssigned) ProtoMessage()    {}
func (*JobRunAssigned) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{18}
}
func (m *JobRunAssigned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunAssigned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunAssigned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunAssigned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunAssigned.Merge(m, src)
}
func (m *JobRunAssigned) XXX_Size() int {
	return m.Size()
}
func (m *JobRunAssigned) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunAssigned.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunAssigned proto.InternalMessageInfo

func (m *JobRunAssigned) GetRunId() *Uuid {
	if m != nil {
		return m.RunId
	}
	return nil
}

func (m *JobRunAssigned) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *JobRunAssigned) GetResourceInfos() []*KubernetesResourceInfo {
	if m != nil {
		return m.ResourceInfos
	}
	return nil
}

// Indicates that the resources required by the job have been created and that the job is now running.
type JobRunRunning struct {
	RunId *Uuid `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"runId,omitempty"`
	JobId *Uuid `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	// Runtime information, e.g., which node the job is running on, its IP address etc,
	// for each resource created for the job run.
	ResourceInfos []*KubernetesResourceInfo `protobuf:"bytes,3,rep,name=resourceInfos,proto3" json:"resourceInfos,omitempty"`
}

func (m *JobRunRunning) Reset()         { *m = JobRunRunning{} }
func (m *JobRunRunning) String() string { return proto.CompactTextString(m) }
func (*JobRunRunning) ProtoMessage()    {}
func (*JobRunRunning) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{19}
}
func (m *JobRunRunning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunRunning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunRunning.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunRunning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunRunning.Merge(m, src)
}
func (m *JobRunRunning) XXX_Size() int {
	return m.Size()
}
func (m *JobRunRunning) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunRunning.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunRunning proto.InternalMessageInfo

func (m *JobRunRunning) GetRunId() *Uuid {
	if m != nil {
		return m.RunId
	}
	return nil
}

func (m *JobRunRunning) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *JobRunRunning) GetResourceInfos() []*KubernetesResourceInfo {
	if m != nil {
		return m.ResourceInfos
	}
	return nil
}

// Message containing runtime information about some resource created for a job.
type KubernetesResourceInfo struct {
	ObjectMeta *ObjectMeta `protobuf:"bytes,1,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	// Types that are valid to be assigned to Info:
	//	*KubernetesResourceInfo_PodInfo
	//	*KubernetesResourceInfo_IngressInfo
	Info isKubernetesResourceInfo_Info `protobuf_oneof:"info"`
}

func (m *KubernetesResourceInfo) Reset()         { *m = KubernetesResourceInfo{} }
func (m *KubernetesResourceInfo) String() string { return proto.CompactTextString(m) }
func (*KubernetesResourceInfo) ProtoMessage()    {}
func (*KubernetesResourceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{20}
}
func (m *KubernetesResourceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesResourceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesResourceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesResourceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesResourceInfo.Merge(m, src)
}
func (m *KubernetesResourceInfo) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesResourceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesResourceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesResourceInfo proto.InternalMessageInfo

type isKubernetesResourceInfo_Info interface {
	isKubernetesResourceInfo_Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type KubernetesResourceInfo_PodInfo struct {
	PodInfo *PodInfo `protobuf:"bytes,2,opt,name=podInfo,proto3,oneof" json:"podInfo,omitempty"`
}
type KubernetesResourceInfo_IngressInfo struct {
	IngressInfo *IngressInfo `protobuf:"bytes,3,opt,name=ingressInfo,proto3,oneof" json:"ingressInfo,omitempty"`
}

func (*KubernetesResourceInfo_PodInfo) isKubernetesResourceInfo_Info()     {}
func (*KubernetesResourceInfo_IngressInfo) isKubernetesResourceInfo_Info() {}

func (m *KubernetesResourceInfo) GetInfo() isKubernetesResourceInfo_Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *KubernetesResourceInfo) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *KubernetesResourceInfo) GetPodInfo() *PodInfo {
	if x, ok := m.GetInfo().(*KubernetesResourceInfo_PodInfo); ok {
		return x.PodInfo
	}
	return nil
}

func (m *KubernetesResourceInfo) GetIngressInfo() *IngressInfo {
	if x, ok := m.GetInfo().(*KubernetesResourceInfo_IngressInfo); ok {
		return x.IngressInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*KubernetesResourceInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*KubernetesResourceInfo_PodInfo)(nil),
		(*KubernetesResourceInfo_IngressInfo)(nil),
	}
}

// Runtime information of a pod.
type PodInfo struct {
	NodeName  string `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"nodeName,omitempty"`
	PodNumber int32  `protobuf:"varint,2,opt,name=pod_number,json=podNumber,proto3" json:"podNumber,omitempty"`
}

func (m *PodInfo) Reset()         { *m = PodInfo{} }
func (m *PodInfo) String() string { return proto.CompactTextString(m) }
func (*PodInfo) ProtoMessage()    {}
func (*PodInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{21}
}
func (m *PodInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodInfo.Merge(m, src)
}
func (m *PodInfo) XXX_Size() int {
	return m.Size()
}
func (m *PodInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PodInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PodInfo proto.InternalMessageInfo

func (m *PodInfo) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *PodInfo) GetPodNumber() int32 {
	if m != nil {
		return m.PodNumber
	}
	return 0
}

// Runtime information of an ingress.
type IngressInfo struct {
	// TODO: Why a node name?
	NodeName string `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"nodeName,omitempty"`
	// TODO: Why a map?
	IngressAddresses map[int32]string `protobuf:"bytes,2,rep,name=ingress_addresses,json=ingressAddresses,proto3" json:"ingressAddresses,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *IngressInfo) Reset()         { *m = IngressInfo{} }
func (m *IngressInfo) String() string { return proto.CompactTextString(m) }
func (*IngressInfo) ProtoMessage()    {}
func (*IngressInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{22}
}
func (m *IngressInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngressInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngressInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IngressInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngressInfo.Merge(m, src)
}
func (m *IngressInfo) XXX_Size() int {
	return m.Size()
}
func (m *IngressInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IngressInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IngressInfo proto.InternalMessageInfo

func (m *IngressInfo) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *IngressInfo) GetIngressAddresses() map[int32]string {
	if m != nil {
		return m.IngressAddresses
	}
	return nil
}

// For sending details associated with a created ingress.
// Used for compatibility with legacy messages, which send ingress info as its own message.
// Later, this info should be bundled with the JobRunRunning message.
type StandaloneIngressInfo struct {
	RunId *Uuid `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"runId,omitempty"`
	JobId *Uuid `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	// ObjectMeta associated with the ingress.
	ObjectMeta       *ObjectMeta      `protobuf:"bytes,3,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	IngressAddresses map[int32]string `protobuf:"bytes,4,rep,name=ingress_addresses,json=ingressAddresses,proto3" json:"ingressAddresses,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The legacy message bundles info associated with the pod.
	NodeName     string `protobuf:"bytes,5,opt,name=node_name,json=nodeName,proto3" json:"nodeName,omitempty"`
	PodNumber    int32  `protobuf:"varint,6,opt,name=pod_number,json=podNumber,proto3" json:"podNumber,omitempty"`
	PodName      string `protobuf:"bytes,7,opt,name=pod_name,json=podName,proto3" json:"podName,omitempty"`
	PodNamespace string `protobuf:"bytes,8,opt,name=pod_namespace,json=podNamespace,proto3" json:"podNamespace,omitempty"`
}

func (m *StandaloneIngressInfo) Reset()         { *m = StandaloneIngressInfo{} }
func (m *StandaloneIngressInfo) String() string { return proto.CompactTextString(m) }
func (*StandaloneIngressInfo) ProtoMessage()    {}
func (*StandaloneIngressInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{23}
}
func (m *StandaloneIngressInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StandaloneIngressInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StandaloneIngressInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StandaloneIngressInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StandaloneIngressInfo.Merge(m, src)
}
func (m *StandaloneIngressInfo) XXX_Size() int {
	return m.Size()
}
func (m *StandaloneIngressInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StandaloneIngressInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StandaloneIngressInfo proto.InternalMessageInfo

func (m *StandaloneIngressInfo) GetRunId() *Uuid {
	if m != nil {
		return m.RunId
	}
	return nil
}

func (m *StandaloneIngressInfo) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *StandaloneIngressInfo) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *StandaloneIngressInfo) GetIngressAddresses() map[int32]string {
	if m != nil {
		return m.IngressAddresses
	}
	return nil
}

func (m *StandaloneIngressInfo) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *StandaloneIngressInfo) GetPodNumber() int32 {
	if m != nil {
		return m.PodNumber
	}
	return 0
}

func (m *StandaloneIngressInfo) GetPodName() string {
	if m != nil {
		return m.PodName
	}
	return ""
}

func (m *StandaloneIngressInfo) GetPodNamespace() string {
	if m != nil {
		return m.PodNamespace
	}
	return ""
}

// Indicates that the job finished successfully (i.e., in the expected manner).
type JobRunSucceeded struct {
	RunId *Uuid `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"runId,omitempty"`
	JobId *Uuid `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	// Runtime information, e.g., which node the job is running on, its IP address etc,
	// for each resource created for the job run.
	// TODO: remove this once we have fixed the external api
	ResourceInfos []*KubernetesResourceInfo `protobuf:"bytes,3,rep,name=resourceInfos,proto3" json:"resourceInfos,omitempty"`
}

func (m *JobRunSucceeded) Reset()         { *m = JobRunSucceeded{} }
func (m *JobRunSucceeded) String() string { return proto.CompactTextString(m) }
func (*JobRunSucceeded) ProtoMessage()    {}
func (*JobRunSucceeded) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{24}
}
func (m *JobRunSucceeded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunSucceeded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunSucceeded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunSucceeded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunSucceeded.Merge(m, src)
}
func (m *JobRunSucceeded) XXX_Size() int {
	return m.Size()
}
func (m *JobRunSucceeded) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunSucceeded.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunSucceeded proto.InternalMessageInfo

func (m *JobRunSucceeded) GetRunId() *Uuid {
	if m != nil {
		return m.RunId
	}
	return nil
}

func (m *JobRunSucceeded) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *JobRunSucceeded) GetResourceInfos() []*KubernetesResourceInfo {
	if m != nil {
		return m.ResourceInfos
	}
	return nil
}

// Message containing a set of errors associated with a particular job.
// Contains a flag, which if set to true indicates that the job has failed.
// Otherwise, this message represents a set of errors from which the system has recovered.
type JobErrors struct {
	JobId *Uuid `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	// A set of errors that occurred within some context.
	Errors []*Error `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors,omitempty"`
}

func (m *JobErrors) Reset()         { *m = JobErrors{} }
func (m *JobErrors) String() string { return proto.CompactTextString(m) }
func (*JobErrors) ProtoMessage()    {}
func (*JobErrors) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{25}
}
func (m *JobErrors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobErrors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobErrors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobErrors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobErrors.Merge(m, src)
}
func (m *JobErrors) XXX_Size() int {
	return m.Size()
}
func (m *JobErrors) XXX_DiscardUnknown() {
	xxx_messageInfo_JobErrors.DiscardUnknown(m)
}

var xxx_messageInfo_JobErrors proto.InternalMessageInfo

func (m *JobErrors) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *JobErrors) GetErrors() []*Error {
	if m != nil {
		return m.Errors
	}
	return nil
}

// Message containing a set of errors associated with a particular job run.
// Contains a flag, which if set to true indicates that the job run has failed.
// Otherwise, this message represents a set of errors from which the system has recovered.
//
// Because each error may specify a parent error, the set of errors form a tree.
//
// Services may listen for these messages to obtain realtime information about errors associated with jobs.
type JobRunErrors struct {
	RunId *Uuid `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"runId,omitempty"`
	JobId *Uuid `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
	// A set of errors that occurred within some context.
	Errors []*Error `protobuf:"bytes,3,rep,name=errors,proto3" json:"errors,omitempty"`
}

func (m *JobRunErrors) Reset()         { *m = JobRunErrors{} }
func (m *JobRunErrors) String() string { return proto.CompactTextString(m) }
func (*JobRunErrors) ProtoMessage()    {}
func (*JobRunErrors) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{26}
}
func (m *JobRunErrors) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunErrors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunErrors.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunErrors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunErrors.Merge(m, src)
}
func (m *JobRunErrors) XXX_Size() int {
	return m.Size()
}
func (m *JobRunErrors) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunErrors.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunErrors proto.InternalMessageInfo

func (m *JobRunErrors) GetRunId() *Uuid {
	if m != nil {
		return m.RunId
	}
	return nil
}

func (m *JobRunErrors) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *JobRunErrors) GetErrors() []*Error {
	if m != nil {
		return m.Errors
	}
	return nil
}

// Represents a failure that took place in the course of a job run (i.e., an attempt to run a job).
// Each failure is either a resource failure or a system-level failure.
// Resource failures correspond to a problem with a specific Kubernetes resource
// (e.g., if a container terminates with a non-zero exit code).
// System-level failure messages are created by the executor (e.g., a failure by the executor to write to Kubernetes).
//
// This message may only be published to the log as part of a JobRunError message.
// TODO: Check if the container status contained any useful info for non-failed containers.
type Error struct {
	// If true, this error represents an unrecoverable failure and Armada has given up on this job or job run.
	Terminal bool `protobuf:"varint,1,opt,name=terminal,proto3" json:"terminal,omitempty"`
	// Additional information for this particular combination of component and error. May be set to nil.
	//
	// Types that are valid to be assigned to Reason:
	//	*Error_KubernetesError
	//	*Error_ContainerError
	//	*Error_ExecutorError
	//	*Error_PodUnschedulable
	//	*Error_LeaseExpired
	//	*Error_MaxRunsExceeded
	//	*Error_PodError
	//	*Error_PodLeaseReturned
	//	*Error_PodTerminated
	//	*Error_JobRunPreemptedError
	//	*Error_GangJobUnschedulable
	Reason isError_Reason `protobuf_oneof:"reason"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{27}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

type isError_Reason interface {
	isError_Reason()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Error_KubernetesError struct {
	KubernetesError *KubernetesError `protobuf:"bytes,2,opt,name=kubernetesError,proto3,oneof" json:"kubernetesError,omitempty"`
}
type Error_ContainerError struct {
	ContainerError *ContainerError `protobuf:"bytes,3,opt,name=containerError,proto3,oneof" json:"containerError,omitempty"`
}
type Error_ExecutorError struct {
	ExecutorError *ExecutorError `protobuf:"bytes,4,opt,name=executorError,proto3,oneof" json:"executorError,omitempty"`
}
type Error_PodUnschedulable struct {
	PodUnschedulable *PodUnschedulable `protobuf:"bytes,5,opt,name=podUnschedulable,proto3,oneof" json:"podUnschedulable,omitempty"`
}
type Error_LeaseExpired struct {
	LeaseExpired *LeaseExpired `protobuf:"bytes,6,opt,name=leaseExpired,proto3,oneof" json:"leaseExpired,omitempty"`
}
type Error_MaxRunsExceeded struct {
	MaxRunsExceeded *MaxRunsExceeded `protobuf:"bytes,7,opt,name=maxRunsExceeded,proto3,oneof" json:"maxRunsExceeded,omitempty"`
}
type Error_PodError struct {
	PodError *PodError `protobuf:"bytes,8,opt,name=podError,proto3,oneof" json:"podError,omitempty"`
}
type Error_PodLeaseReturned struct {
	PodLeaseReturned *PodLeaseReturned `protobuf:"bytes,9,opt,name=podLeaseReturned,proto3,oneof" json:"podLeaseReturned,omitempty"`
}
type Error_PodTerminated struct {
	PodTerminated *PodTerminated `protobuf:"bytes,10,opt,name=podTerminated,proto3,oneof" json:"podTerminated,omitempty"`
}
type Error_JobRunPreemptedError struct {
	JobRunPreemptedError *JobRunPreemptedError `protobuf:"bytes,11,opt,name=jobRunPreemptedError,proto3,oneof" json:"jobRunPreemptedError,omitempty"`
}
type Error_GangJobUnschedulable struct {
	GangJobUnschedulable *GangJobUnschedulable `protobuf:"bytes,12,opt,name=gangJobUnschedulable,proto3,oneof" json:"gangJobUnschedulable,omitempty"`
}

func (*Error_KubernetesError) isError_Reason()      {}
func (*Error_ContainerError) isError_Reason()       {}
func (*Error_ExecutorError) isError_Reason()        {}
func (*Error_PodUnschedulable) isError_Reason()     {}
func (*Error_LeaseExpired) isError_Reason()         {}
func (*Error_MaxRunsExceeded) isError_Reason()      {}
func (*Error_PodError) isError_Reason()             {}
func (*Error_PodLeaseReturned) isError_Reason()     {}
func (*Error_PodTerminated) isError_Reason()        {}
func (*Error_JobRunPreemptedError) isError_Reason() {}
func (*Error_GangJobUnschedulable) isError_Reason() {}

func (m *Error) GetReason() isError_Reason {
	if m != nil {
		return m.Reason
	}
	return nil
}

func (m *Error) GetTerminal() bool {
	if m != nil {
		return m.Terminal
	}
	return false
}

func (m *Error) GetKubernetesError() *KubernetesError {
	if x, ok := m.GetReason().(*Error_KubernetesError); ok {
		return x.KubernetesError
	}
	return nil
}

func (m *Error) GetContainerError() *ContainerError {
	if x, ok := m.GetReason().(*Error_ContainerError); ok {
		return x.ContainerError
	}
	return nil
}

func (m *Error) GetExecutorError() *ExecutorError {
	if x, ok := m.GetReason().(*Error_ExecutorError); ok {
		return x.ExecutorError
	}
	return nil
}

func (m *Error) GetPodUnschedulable() *PodUnschedulable {
	if x, ok := m.GetReason().(*Error_PodUnschedulable); ok {
		return x.PodUnschedulable
	}
	return nil
}

func (m *Error) GetLeaseExpired() *LeaseExpired {
	if x, ok := m.GetReason().(*Error_LeaseExpired); ok {
		return x.LeaseExpired
	}
	return nil
}

func (m *Error) GetMaxRunsExceeded() *MaxRunsExceeded {
	if x, ok := m.GetReason().(*Error_MaxRunsExceeded); ok {
		return x.MaxRunsExceeded
	}
	return nil
}

func (m *Error) GetPodError() *PodError {
	if x, ok := m.GetReason().(*Error_PodError); ok {
		return x.PodError
	}
	return nil
}

func (m *Error) GetPodLeaseReturned() *PodLeaseReturned {
	if x, ok := m.GetReason().(*Error_PodLeaseReturned); ok {
		return x.PodLeaseReturned
	}
	return nil
}

func (m *Error) GetPodTerminated() *PodTerminated {
	if x, ok := m.GetReason().(*Error_PodTerminated); ok {
		return x.PodTerminated
	}
	return nil
}

func (m *Error) GetJobRunPreemptedError() *JobRunPreemptedError {
	if x, ok := m.GetReason().(*Error_JobRunPreemptedError); ok {
		return x.JobRunPreemptedError
	}
	return nil
}

func (m *Error) GetGangJobUnschedulable() *GangJobUnschedulable {
	if x, ok := m.GetReason().(*Error_GangJobUnschedulable); ok {
		return x.GangJobUnschedulable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Error) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Error_KubernetesError)(nil),
		(*Error_ContainerError)(nil),
		(*Error_ExecutorError)(nil),
		(*Error_PodUnschedulable)(nil),
		(*Error_LeaseExpired)(nil),
		(*Error_MaxRunsExceeded)(nil),
		(*Error_PodError)(nil),
		(*Error_PodLeaseReturned)(nil),
		(*Error_PodTerminated)(nil),
		(*Error_JobRunPreemptedError)(nil),
		(*Error_GangJobUnschedulable)(nil),
	}
}

// Represents an error associated with a particular Kubernetes resource.
type KubernetesError struct {
	// Type of Kubernetes resource (e.g., ingress).
	ResourceType string `protobuf:"bytes,1,opt,name=resourceType,proto3" json:"resourceType,omitempty"`
	// Id assigned to the resource by Kubernetes.
	ResourceId *Uuid `protobuf:"bytes,2,opt,name=resourceId,proto3" json:"resourceId,omitempty"`
}

func (m *KubernetesError) Reset()         { *m = KubernetesError{} }
func (m *KubernetesError) String() string { return proto.CompactTextString(m) }
func (*KubernetesError) ProtoMessage()    {}
func (*KubernetesError) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{28}
}
func (m *KubernetesError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesError.Merge(m, src)
}
func (m *KubernetesError) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesError) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesError.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesError proto.InternalMessageInfo

func (m *KubernetesError) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *KubernetesError) GetResourceId() *Uuid {
	if m != nil {
		return m.ResourceId
	}
	return nil
}

// Indicates one or more of the containers in the pod failed.
type PodError struct {
	// This ObjectMeta identifies the Pod.
	ObjectMeta       *ObjectMeta       `protobuf:"bytes,1,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	Message          string            `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	NodeName         string            `protobuf:"bytes,3,opt,name=node_name,json=nodeName,proto3" json:"nodeName,omitempty"`
	PodNumber        int32             `protobuf:"varint,4,opt,name=pod_number,json=podNumber,proto3" json:"podNumber,omitempty"`
	ContainerErrors  []*ContainerError `protobuf:"bytes,5,rep,name=containerErrors,proto3" json:"containerErrors,omitempty"`
	KubernetesReason KubernetesReason  `protobuf:"varint,6,opt,name=kubernetes_reason,json=kubernetesReason,proto3,enum=armadaevents.KubernetesReason" json:"kubernetesReason,omitempty"`
}

func (m *PodError) Reset()         { *m = PodError{} }
func (m *PodError) String() string { return proto.CompactTextString(m) }
func (*PodError) ProtoMessage()    {}
func (*PodError) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{29}
}
func (m *PodError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodError.Merge(m, src)
}
func (m *PodError) XXX_Size() int {
	return m.Size()
}
func (m *PodError) XXX_DiscardUnknown() {
	xxx_messageInfo_PodError.DiscardUnknown(m)
}

var xxx_messageInfo_PodError proto.InternalMessageInfo

func (m *PodError) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *PodError) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *PodError) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *PodError) GetPodNumber() int32 {
	if m != nil {
		return m.PodNumber
	}
	return 0
}

func (m *PodError) GetContainerErrors() []*ContainerError {
	if m != nil {
		return m.ContainerErrors
	}
	return nil
}

func (m *PodError) GetKubernetesReason() KubernetesReason {
	if m != nil {
		return m.KubernetesReason
	}
	return KubernetesReason_AppError
}

type ContainerError struct {
	// this ObjectMeta identifies the container
	ObjectMeta *ObjectMeta `protobuf:"bytes,1,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	// Exit code of the application running in the container.
	ExitCode int32 `protobuf:"varint,2,opt,name=exit_code,json=exitCode,proto3" json:"exitCode,omitempty"`
	// Corresponds to v1.ContainerStateTerminated.Message
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// Corresponds to v1.ContainerStateTerminated.Reason
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	// Reason reported by Kubernetes.
	KubernetesReason KubernetesReason `protobuf:"varint,9,opt,name=kubernetes_reason,json=kubernetesReason,proto3,enum=armadaevents.KubernetesReason" json:"kubernetesReason,omitempty"`
}

func (m *ContainerError) Reset()         { *m = ContainerError{} }
func (m *ContainerError) String() string { return proto.CompactTextString(m) }
func (*ContainerError) ProtoMessage()    {}
func (*ContainerError) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{30}
}
func (m *ContainerError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerError.Merge(m, src)
}
func (m *ContainerError) XXX_Size() int {
	return m.Size()
}
func (m *ContainerError) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerError.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerError proto.InternalMessageInfo

func (m *ContainerError) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *ContainerError) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *ContainerError) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ContainerError) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ContainerError) GetKubernetesReason() KubernetesReason {
	if m != nil {
		return m.KubernetesReason
	}
	return KubernetesReason_AppError
}

// Indicates that the pod could not be scheduled for some reason.
type PodLeaseReturned struct {
	ObjectMeta   *ObjectMeta `protobuf:"bytes,1,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	Message      string      `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	PodNumber    int32       `protobuf:"varint,3,opt,name=pod_number,json=podNumber,proto3" json:"podNumber,omitempty"`
	RunAttempted bool        `protobuf:"varint,4,opt,name=run_attempted,json=runAttempted,proto3" json:"runAttempted,omitempty"`
}

func (m *PodLeaseReturned) Reset()         { *m = PodLeaseReturned{} }
func (m *PodLeaseReturned) String() string { return proto.CompactTextString(m) }
func (*PodLeaseReturned) ProtoMessage()    {}
func (*PodLeaseReturned) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{31}
}
func (m *PodLeaseReturned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodLeaseReturned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodLeaseReturned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodLeaseReturned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodLeaseReturned.Merge(m, src)
}
func (m *PodLeaseReturned) XXX_Size() int {
	return m.Size()
}
func (m *PodLeaseReturned) XXX_DiscardUnknown() {
	xxx_messageInfo_PodLeaseReturned.DiscardUnknown(m)
}

var xxx_messageInfo_PodLeaseReturned proto.InternalMessageInfo

func (m *PodLeaseReturned) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *PodLeaseReturned) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *PodLeaseReturned) GetPodNumber() int32 {
	if m != nil {
		return m.PodNumber
	}
	return 0
}

func (m *PodLeaseReturned) GetRunAttempted() bool {
	if m != nil {
		return m.RunAttempted
	}
	return false
}

// Indicates that the lease on the job that the pod was part of could not be renewed.
// If this happens, the executor deletes the pod and generates a JobRunError with this message as the reason.
type PodTerminated struct {
	// This ObjectMeta identifies the Pod.
	ObjectMeta *ObjectMeta `protobuf:"bytes,1,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	Message    string      `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	NodeName   string      `protobuf:"bytes,3,opt,name=node_name,json=nodeName,proto3" json:"nodeName,omitempty"`
	PodNumber  int32       `protobuf:"varint,4,opt,name=pod_number,json=podNumber,proto3" json:"podNumber,omitempty"`
}

func (m *PodTerminated) Reset()         { *m = PodTerminated{} }
func (m *PodTerminated) String() string { return proto.CompactTextString(m) }
func (*PodTerminated) ProtoMessage()    {}
func (*PodTerminated) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{32}
}
func (m *PodTerminated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodTerminated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodTerminated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodTerminated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodTerminated.Merge(m, src)
}
func (m *PodTerminated) XXX_Size() int {
	return m.Size()
}
func (m *PodTerminated) XXX_DiscardUnknown() {
	xxx_messageInfo_PodTerminated.DiscardUnknown(m)
}

var xxx_messageInfo_PodTerminated proto.InternalMessageInfo

func (m *PodTerminated) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *PodTerminated) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *PodTerminated) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *PodTerminated) GetPodNumber() int32 {
	if m != nil {
		return m.PodNumber
	}
	return 0
}

type ExecutorError struct {
}

func (m *ExecutorError) Reset()         { *m = ExecutorError{} }
func (m *ExecutorError) String() string { return proto.CompactTextString(m) }
func (*ExecutorError) ProtoMessage()    {}
func (*ExecutorError) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{33}
}
func (m *ExecutorError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutorError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutorError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutorError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutorError.Merge(m, src)
}
func (m *ExecutorError) XXX_Size() int {
	return m.Size()
}
func (m *ExecutorError) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutorError.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutorError proto.InternalMessageInfo

type PodUnschedulable struct {
	// this ObjectMeta identifies the Pod
	ObjectMeta *ObjectMeta `protobuf:"bytes,1,opt,name=objectMeta,proto3" json:"objectMeta,omitempty"`
	Message    string      `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	NodeName   string      `protobuf:"bytes,3,opt,name=node_name,json=nodeName,proto3" json:"nodeName,omitempty"`
	PodNumber  int32       `protobuf:"varint,4,opt,name=pod_number,json=podNumber,proto3" json:"podNumber,omitempty"`
}

func (m *PodUnschedulable) Reset()         { *m = PodUnschedulable{} }
func (m *PodUnschedulable) String() string { return proto.CompactTextString(m) }
func (*PodUnschedulable) ProtoMessage()    {}
func (*PodUnschedulable) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{34}
}
func (m *PodUnschedulable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodUnschedulable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodUnschedulable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodUnschedulable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodUnschedulable.Merge(m, src)
}
func (m *PodUnschedulable) XXX_Size() int {
	return m.Size()
}
func (m *PodUnschedulable) XXX_DiscardUnknown() {
	xxx_messageInfo_PodUnschedulable.DiscardUnknown(m)
}

var xxx_messageInfo_PodUnschedulable proto.InternalMessageInfo

func (m *PodUnschedulable) GetObjectMeta() *ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *PodUnschedulable) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *PodUnschedulable) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *PodUnschedulable) GetPodNumber() int32 {
	if m != nil {
		return m.PodNumber
	}
	return 0
}

type LeaseExpired struct {
}

func (m *LeaseExpired) Reset()         { *m = LeaseExpired{} }
func (m *LeaseExpired) String() string { return proto.CompactTextString(m) }
func (*LeaseExpired) ProtoMessage()    {}
func (*LeaseExpired) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{35}
}
func (m *LeaseExpired) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LeaseExpired) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LeaseExpired.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LeaseExpired) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LeaseExpired.Merge(m, src)
}
func (m *LeaseExpired) XXX_Size() int {
	return m.Size()
}
func (m *LeaseExpired) XXX_DiscardUnknown() {
	xxx_messageInfo_LeaseExpired.DiscardUnknown(m)
}

var xxx_messageInfo_LeaseExpired proto.InternalMessageInfo

type MaxRunsExceeded struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *MaxRunsExceeded) Reset()         { *m = MaxRunsExceeded{} }
func (m *MaxRunsExceeded) String() string { return proto.CompactTextString(m) }
func (*MaxRunsExceeded) ProtoMessage()    {}
func (*MaxRunsExceeded) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{36}
}
func (m *MaxRunsExceeded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxRunsExceeded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxRunsExceeded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxRunsExceeded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxRunsExceeded.Merge(m, src)
}
func (m *MaxRunsExceeded) XXX_Size() int {
	return m.Size()
}
func (m *MaxRunsExceeded) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxRunsExceeded.DiscardUnknown(m)
}

var xxx_messageInfo_MaxRunsExceeded proto.InternalMessageInfo

func (m *MaxRunsExceeded) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type JobRunPreemptedError struct {
}

func (m *JobRunPreemptedError) Reset()         { *m = JobRunPreemptedError{} }
func (m *JobRunPreemptedError) String() string { return proto.CompactTextString(m) }
func (*JobRunPreemptedError) ProtoMessage()    {}
func (*JobRunPreemptedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{37}
}
func (m *JobRunPreemptedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunPreemptedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunPreemptedError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunPreemptedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunPreemptedError.Merge(m, src)
}
func (m *JobRunPreemptedError) XXX_Size() int {
	return m.Size()
}
func (m *JobRunPreemptedError) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunPreemptedError.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunPreemptedError proto.InternalMessageInfo

type GangJobUnschedulable struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *GangJobUnschedulable) Reset()         { *m = GangJobUnschedulable{} }
func (m *GangJobUnschedulable) String() string { return proto.CompactTextString(m) }
func (*GangJobUnschedulable) ProtoMessage()    {}
func (*GangJobUnschedulable) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{38}
}
func (m *GangJobUnschedulable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GangJobUnschedulable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GangJobUnschedulable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GangJobUnschedulable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GangJobUnschedulable.Merge(m, src)
}
func (m *GangJobUnschedulable) XXX_Size() int {
	return m.Size()
}
func (m *GangJobUnschedulable) XXX_DiscardUnknown() {
	xxx_messageInfo_GangJobUnschedulable.DiscardUnknown(m)
}

var xxx_messageInfo_GangJobUnschedulable proto.InternalMessageInfo

func (m *GangJobUnschedulable) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Generated by the scheduler whenever it detects a SubmitJob message that includes a previously used deduplication id
// (i.e., when it detects a duplicate job submission).
type JobDuplicateDetected struct {
	NewJobId *Uuid `protobuf:"bytes,1,opt,name=new_job_id,json=newJobId,proto3" json:"newJobId,omitempty"`
	OldJobId *Uuid `protobuf:"bytes,2,opt,name=old_job_id,json=oldJobId,proto3" json:"oldJobId,omitempty"`
}

func (m *JobDuplicateDetected) Reset()         { *m = JobDuplicateDetected{} }
func (m *JobDuplicateDetected) String() string { return proto.CompactTextString(m) }
func (*JobDuplicateDetected) ProtoMessage()    {}
func (*JobDuplicateDetected) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{39}
}
func (m *JobDuplicateDetected) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobDuplicateDetected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobDuplicateDetected.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobDuplicateDetected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobDuplicateDetected.Merge(m, src)
}
func (m *JobDuplicateDetected) XXX_Size() int {
	return m.Size()
}
func (m *JobDuplicateDetected) XXX_DiscardUnknown() {
	xxx_messageInfo_JobDuplicateDetected.DiscardUnknown(m)
}

var xxx_messageInfo_JobDuplicateDetected proto.InternalMessageInfo

func (m *JobDuplicateDetected) GetNewJobId() *Uuid {
	if m != nil {
		return m.NewJobId
	}
	return nil
}

func (m *JobDuplicateDetected) GetOldJobId() *Uuid {
	if m != nil {
		return m.OldJobId
	}
	return nil
}

// Message to indicate that a JobRun has been preempted.
type JobRunPreempted struct {
	// Uuid of the job that was preempted
	PreemptedJobId *Uuid `protobuf:"bytes,1,opt,name=preempted_job_id,json=preemptedJobId,proto3" json:"preemptedJobId,omitempty"`
	// Uuid of the job run that was preempted.
	PreemptedRunId *Uuid `protobuf:"bytes,2,opt,name=preempted_run_id,json=preemptedRunId,proto3" json:"preemptedRunId,omitempty"`
	// Uuid of the job that caused the preemption.
	PreemptiveJobId *Uuid `protobuf:"bytes,3,opt,name=preemptive_job_id,json=preemptiveJobId,proto3" json:"preemptiveJobId,omitempty"`
	// Uuid of the job run that caused the preemption.
	PreemptiveRunId *Uuid `protobuf:"bytes,4,opt,name=preemptive_run_id,json=preemptiveRunId,proto3" json:"preemptiveRunId,omitempty"`
}

func (m *JobRunPreempted) Reset()         { *m = JobRunPreempted{} }
func (m *JobRunPreempted) String() string { return proto.CompactTextString(m) }
func (*JobRunPreempted) ProtoMessage()    {}
func (*JobRunPreempted) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{40}
}
func (m *JobRunPreempted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunPreempted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunPreempted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunPreempted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunPreempted.Merge(m, src)
}
func (m *JobRunPreempted) XXX_Size() int {
	return m.Size()
}
func (m *JobRunPreempted) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunPreempted.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunPreempted proto.InternalMessageInfo

func (m *JobRunPreempted) GetPreemptedJobId() *Uuid {
	if m != nil {
		return m.PreemptedJobId
	}
	return nil
}

func (m *JobRunPreempted) GetPreemptedRunId() *Uuid {
	if m != nil {
		return m.PreemptedRunId
	}
	return nil
}

func (m *JobRunPreempted) GetPreemptiveJobId() *Uuid {
	if m != nil {
		return m.PreemptiveJobId
	}
	return nil
}

func (m *JobRunPreempted) GetPreemptiveRunId() *Uuid {
	if m != nil {
		return m.PreemptiveRunId
	}
	return nil
}

// Message used internally by Armada to see if messages can be propagated through a pulsar partition
type PartitionMarker struct {
	// group id ties together multiple messages across different partitions
	GroupId *Uuid `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"groupId,omitempty"`
	// The pulsar partition on which this message was sent
	Partition uint32 `protobuf:"varint,2,opt,name=partition,proto3" json:"partition,omitempty"`
}

func (m *PartitionMarker) Reset()         { *m = PartitionMarker{} }
func (m *PartitionMarker) String() string { return proto.CompactTextString(m) }
func (*PartitionMarker) ProtoMessage()    {}
func (*PartitionMarker) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{41}
}
func (m *PartitionMarker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartitionMarker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartitionMarker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartitionMarker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartitionMarker.Merge(m, src)
}
func (m *PartitionMarker) XXX_Size() int {
	return m.Size()
}
func (m *PartitionMarker) XXX_DiscardUnknown() {
	xxx_messageInfo_PartitionMarker.DiscardUnknown(m)
}

var xxx_messageInfo_PartitionMarker proto.InternalMessageInfo

func (m *PartitionMarker) GetGroupId() *Uuid {
	if m != nil {
		return m.GroupId
	}
	return nil
}

func (m *PartitionMarker) GetPartition() uint32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

// Indicates that the scheduler has requested for the job run to be pre-empted.
type JobRunPreemptionRequested struct {
	RunId *Uuid `protobuf:"bytes,1,opt,name=run_id,json=runId,proto3" json:"runId,omitempty"`
	JobId *Uuid `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
}

func (m *JobRunPreemptionRequested) Reset()         { *m = JobRunPreemptionRequested{} }
func (m *JobRunPreemptionRequested) String() string { return proto.CompactTextString(m) }
func (*JobRunPreemptionRequested) ProtoMessage()    {}
func (*JobRunPreemptionRequested) Descriptor() ([]byte, []int) {
	return fileDescriptor_6aab92ca59e015f8, []int{42}
}
func (m *JobRunPreemptionRequested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRunPreemptionRequested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRunPreemptionRequested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobRunPreemptionRequested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRunPreemptionRequested.Merge(m, src)
}
func (m *JobRunPreemptionRequested) XXX_Size() int {
	return m.Size()
}
func (m *JobRunPreemptionRequested) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRunPreemptionRequested.DiscardUnknown(m)
}

var xxx_messageInfo_JobRunPreemptionRequested proto.InternalMessageInfo

func (m *JobRunPreemptionRequested) GetRunId() *Uuid {
	if m != nil {
		return m.RunId
	}
	return nil
}

func (m *JobRunPreemptionRequested) GetJobId() *Uuid {
	if m != nil {
		return m.JobId
	}
	return nil
}

func init() {
	proto.RegisterEnum("armadaevents.JobState", JobState_name, JobState_value)
	proto.RegisterEnum("armadaevents.KubernetesReason", KubernetesReason_name, KubernetesReason_value)
	proto.RegisterType((*EventSequence)(nil), "armadaevents.EventSequence")
	proto.RegisterType((*EventSequence_Event)(nil), "armadaevents.EventSequence.Event")
	proto.RegisterType((*ResourceUtilisation)(nil), "armadaevents.ResourceUtilisation")
	proto.RegisterMapType((map[string]resource.Quantity)(nil), "armadaevents.ResourceUtilisation.MaxResourcesForPeriodEntry")
	proto.RegisterMapType((map[string]resource.Quantity)(nil), "armadaevents.ResourceUtilisation.TotalCumulativeUsageEntry")
	proto.RegisterType((*Uuid)(nil), "armadaevents.Uuid")
	proto.RegisterType((*SubmitJob)(nil), "armadaevents.SubmitJob")
	proto.RegisterType((*KubernetesMainObject)(nil), "armadaevents.KubernetesMainObject")
	proto.RegisterType((*KubernetesObject)(nil), "armadaevents.KubernetesObject")
	proto.RegisterType((*ObjectMeta)(nil), "armadaevents.ObjectMeta")
	proto.RegisterMapType((map[string]string)(nil), "armadaevents.ObjectMeta.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "armadaevents.ObjectMeta.LabelsEntry")
	proto.RegisterType((*PodSpecWithAvoidList)(nil), "armadaevents.PodSpecWithAvoidList")
	proto.RegisterType((*ReprioritiseJob)(nil), "armadaevents.ReprioritiseJob")
	proto.RegisterType((*JobRequeued)(nil), "armadaevents.JobRequeued")
	proto.RegisterType((*ReprioritiseJobSet)(nil), "armadaevents.ReprioritiseJobSet")
	proto.RegisterType((*ReprioritisedJob)(nil), "armadaevents.ReprioritisedJob")
	proto.RegisterType((*CancelJob)(nil), "armadaevents.CancelJob")
	proto.RegisterType((*JobSetFilter)(nil), "armadaevents.JobSetFilter")
	proto.RegisterType((*CancelJobSet)(nil), "armadaevents.CancelJobSet")
	proto.RegisterType((*CancelledJob)(nil), "armadaevents.CancelledJob")
	proto.RegisterType((*JobSucceeded)(nil), "armadaevents.JobSucceeded")
	proto.RegisterType((*JobRunLeased)(nil), "armadaevents.JobRunLeased")
	proto.RegisterType((*JobRunAssigned)(nil), "armadaevents.JobRunAssigned")
	proto.RegisterType((*JobRunRunning)(nil), "armadaevents.JobRunRunning")
	proto.RegisterType((*KubernetesResourceInfo)(nil), "armadaevents.KubernetesResourceInfo")
	proto.RegisterType((*PodInfo)(nil), "armadaevents.PodInfo")
	proto.RegisterType((*IngressInfo)(nil), "armadaevents.IngressInfo")
	proto.RegisterMapType((map[int32]string)(nil), "armadaevents.IngressInfo.IngressAddressesEntry")
	proto.RegisterType((*StandaloneIngressInfo)(nil), "armadaevents.StandaloneIngressInfo")
	proto.RegisterMapType((map[int32]string)(nil), "armadaevents.StandaloneIngressInfo.IngressAddressesEntry")
	proto.RegisterType((*JobRunSucceeded)(nil), "armadaevents.JobRunSucceeded")
	proto.RegisterType((*JobErrors)(nil), "armadaevents.JobErrors")
	proto.RegisterType((*JobRunErrors)(nil), "armadaevents.JobRunErrors")
	proto.RegisterType((*Error)(nil), "armadaevents.Error")
	proto.RegisterType((*KubernetesError)(nil), "armadaevents.KubernetesError")
	proto.RegisterType((*PodError)(nil), "armadaevents.PodError")
	proto.RegisterType((*ContainerError)(nil), "armadaevents.ContainerError")
	proto.RegisterType((*PodLeaseReturned)(nil), "armadaevents.PodLeaseReturned")
	proto.RegisterType((*PodTerminated)(nil), "armadaevents.PodTerminated")
	proto.RegisterType((*ExecutorError)(nil), "armadaevents.ExecutorError")
	proto.RegisterType((*PodUnschedulable)(nil), "armadaevents.PodUnschedulable")
	proto.RegisterType((*LeaseExpired)(nil), "armadaevents.LeaseExpired")
	proto.RegisterType((*MaxRunsExceeded)(nil), "armadaevents.MaxRunsExceeded")
	proto.RegisterType((*JobRunPreemptedError)(nil), "armadaevents.JobRunPreemptedError")
	proto.RegisterType((*GangJobUnschedulable)(nil), "armadaevents.GangJobUnschedulable")
	proto.RegisterType((*JobDuplicateDetected)(nil), "armadaevents.JobDuplicateDetected")
	proto.RegisterType((*JobRunPreempted)(nil), "armadaevents.JobRunPreempted")
	proto.RegisterType((*PartitionMarker)(nil), "armadaevents.PartitionMarker")
	proto.RegisterType((*JobRunPreemptionRequested)(nil), "armadaevents.JobRunPreemptionRequested")
}

func init() { proto.RegisterFile("pkg/armadaevents/events.proto", fileDescriptor_6aab92ca59e015f8) }

var fileDescriptor_6aab92ca59e015f8 = []byte{
	// 3604 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x5b, 0x4b, 0x6c, 0x1b, 0xd7,
	0xb9, 0xf6, 0x90, 0x12, 0x1f, 0x3f, 0xf5, 0xa0, 0x8f, 0x25, 0x85, 0x56, 0x6c, 0x51, 0x1e, 0xe7,
	0xde, 0x38, 0x41, 0x42, 0x26, 0xce, 0x03, 0x79, 0x5c, 0x24, 0x10, 0x6d, 0xc5, 0xb6, 0x62, 0xd9,
	0x0a, 0x65, 0xe5, 0xfa, 0x06, 0xb9, 0x60, 0x86, 0x9c, 0x23, 0x6a, 0xac, 0xe1, 0x0c, 0x33, 0x0f,
	0x59, 0x02, 0xb2, 0xb8, 0xb9, 0xb8, 0x37, 0xdd, 0xa5, 0x06, 0x9a, 0x45, 0x81, 0x2e, 0xd2, 0x6d,
	0x03, 0x74, 0xdd, 0x75, 0x57, 0xcd, 0xa2, 0x28, 0xd2, 0x5d, 0x57, 0x6c, 0x91, 0xa0, 0x8b, 0x72,
	0xd1, 0x75, 0xdb, 0x4d, 0x8b, 0xf3, 0x9a, 0x39, 0x67, 0x38, 0xb4, 0xe5, 0x57, 0x9d, 0xc2, 0x2b,
	0x69, 0xbe, 0xff, 0x39, 0xe7, 0xf1, 0xcf, 0xff, 0xff, 0xe7, 0x10, 0x4e, 0xf6, 0x77, 0xbb, 0x75,
	0xc3, 0xeb, 0x19, 0xa6, 0x81, 0xf7, 0xb0, 0x13, 0xf8, 0x75, 0xf6, 0xa7, 0xd6, 0xf7, 0xdc, 0xc0,
	0x45, 0x53, 0x32, 0x69, 0x51, 0xdf, 0x7d, 0xcd, 0xaf, 0x59, 0x6e, 0xdd, 0xe8, 0x5b, 0xf5, 0x8e,
	0xeb, 0xe1, 0xfa, 0xde, 0x8b, 0xf5, 0x2e, 0x76, 0xb0, 0x67, 0x04, 0xd8, 0x64, 0x12, 0x8b, 0x67,
	0x24, 0x1e, 0x07, 0x07, 0x37, 0x5d, 0x6f, 0xd7, 0x72, 0xba, 0x69, 0x9c, 0xd5, 0xae, 0xeb, 0x76,
	0x6d, 0x5c, 0xa7, 0x4f, 0xed, 0x70, 0xbb, 0x1e, 0x58, 0x3d, 0xec, 0x07, 0x46, 0xaf, 0xcf, 0x19,
	0x5e, 0x8e, 0x55, 0xf5, 0x8c, 0xce, 0x8e, 0xe5, 0x60, 0xef, 0xa0, 0x4e, 0xfd, 0xed, 0x5b, 0x75,
	0x0f, 0xfb, 0x6e, 0xe8, 0x75, 0xf0, 0x88, 0xda, 0xe7, 0xbb, 0x56, 0xb0, 0x13, 0xb6, 0x6b, 0x1d,
	0xb7, 0x57, 0xef, 0xba, 0x5d, 0x37, 0xd6, 0x4f, 0x9e, 0xe8, 0x03, 0xfd, 0x8f, 0xb3, 0xbf, 0x61,
	0x39, 0x01, 0xf6, 0x1c, 0xc3, 0xae, 0xfb, 0x9d, 0x1d, 0x6c, 0x86, 0x36, 0xf6, 0xe2, 0xff, 0xdc,
	0xf6, 0x0d, 0xdc, 0x09, 0xfc, 0x11, 0x80, 0xc9, 0xea, 0xb7, 0xe6, 0x60, 0x7a, 0x95, 0x0c, 0xcd,
	0x26, 0xfe, 0x38, 0xc4, 0x4e, 0x07, 0xa3, 0x67, 0x60, 0xf2, 0xe3, 0x10, 0x87, 0xb8, 0xa2, 0x2d,
	0x6b, 0x67, 0x8a, 0x8d, 0x63, 0xc3, 0x41, 0x75, 0x96, 0x02, 0xcf, 0xb9, 0x3d, 0x2b, 0xc0, 0xbd,
	0x7e, 0x70, 0xd0, 0x64, 0x1c, 0xe8, 0x0d, 0x98, 0xba, 0xe1, 0xb6, 0x5b, 0x3e, 0x0e, 0x5a, 0x8e,
	0xd1, 0xc3, 0x95, 0x0c, 0x95, 0xa8, 0x0c, 0x07, 0xd5, 0xb9, 0x1b, 0x6e, 0x7b, 0x13, 0x07, 0x57,
	0x8c, 0x9e, 0x2c, 0x06, 0x31, 0x8a, 0x9e, 0x87, 0x7c, 0xe8, 0x63, 0xaf, 0x65, 0x99, 0x95, 0x2c,
	0x15, 0x9b, 0x1b, 0x0e, 0xaa, 0x65, 0x02, 0x5d, 0x32, 0x25, 0x91, 0x1c, 0x43, 0xd0, 0x73, 0x90,
	0xeb, 0x7a, 0x6e, 0xd8, 0xf7, 0x2b, 0x13, 0xcb, 0x59, 0xc1, 0xcd, 0x10, 0x99, 0x9b, 0x21, 0xe8,
	0x2a, 0xe4, 0xd8, 0x7c, 0x57, 0x26, 0x97, 0xb3, 0x67, 0x4a, 0x67, 0x4f, 0xd5, 0xe4, 0x45, 0x50,
	0x53, 0x5e, 0x98, 0x3d, 0x31, 0x85, 0x8c, 0x2e, 0x2b, 0xe4, 0xcb, 0xe6, 0x4f, 0x47, 0x61, 0x92,
	0xf2, 0xa1, 0xab, 0x90, 0xef, 0x78, 0x98, 0x4c, 0x56, 0x05, 0x2d, 0x6b, 0x67, 0x4a, 0x67, 0x17,
	0x6b, 0x6c, 0x11, 0xd4, 0xc4, 0x24, 0xd5, 0xae, 0x89, 0x45, 0xd0, 0x38, 0x3e, 0x1c, 0x54, 0x8f,
	0x72, 0xf6, 0x58, 0xeb, 0xad, 0xdf, 0x57, 0xb5, 0xa6, 0xd0, 0x82, 0x36, 0xa0, 0xe8, 0x87, 0xed,
	0x9e, 0x15, 0xac, 0xb9, 0x6d, 0x3a, 0xe6, 0xa5, 0xb3, 0x4f, 0xa8, 0xee, 0x6e, 0x0a, 0x72, 0xe3,
	0x89, 0xe1, 0xa0, 0x7a, 0x2c, 0xe2, 0x8e, 0x35, 0x5e, 0x3c, 0xd2, 0x8c, 0x95, 0xa0, 0x1d, 0x98,
	0xf5, 0x70, 0xdf, 0xb3, 0x5c, 0xcf, 0x0a, 0x2c, 0x1f, 0x13, 0xbd, 0x19, 0xaa, 0xf7, 0xa4, 0xaa,
	0xb7, 0xa9, 0x32, 0x35, 0x4e, 0x0e, 0x07, 0xd5, 0xe3, 0x09, 0x49, 0xc5, 0x46, 0x52, 0x2d, 0x0a,
	0x00, 0x25, 0xa0, 0x4d, 0x1c, 0xd0, 0xf9, 0x2c, 0x9d, 0x5d, 0xbe, 0xad, 0xb1, 0x4d, 0x1c, 0x34,
	0x96, 0x87, 0x83, 0xea, 0x89, 0x51, 0x79, 0xc5, 0x64, 0x8a, 0x7e, 0x64, 0x43, 0x59, 0x46, 0x4d,
	0xf2, 0x82, 0x13, 0xd4, 0xe6, 0xd2, 0x78, 0x9b, 0x84, 0xab, 0xb1, 0x34, 0x1c, 0x54, 0x17, 0x93,
	0xb2, 0x8a, 0xbd, 0x11, 0xcd, 0x64, 0x7e, 0x3a, 0x86, 0xd3, 0xc1, 0x36, 0x31, 0x33, 0x99, 0x36,
	0x3f, 0xe7, 0x04, 0x99, 0xcd, 0x4f, 0xc4, 0xad, 0xce, 0x4f, 0x04, 0xa3, 0x0f, 0x61, 0x2a, 0x7a,
	0x20, 0xe3, 0x95, 0xe3, 0xeb, 0x28, 0x5d, 0x29, 0x19, 0xa9, 0xc5, 0xe1, 0xa0, 0xba, 0x20, 0xcb,
	0x28, 0xaa, 0x15, 0x6d, 0xb1, 0x76, 0x9b, 0x8d, 0x4c, 0x7e, 0xbc, 0x76, 0xc6, 0x21, 0x6b, 0xb7,
	0x47, 0x47, 0x44, 0xd1, 0x46, 0xb4, 0x93, 0x4d, 0x1c, 0x76, 0x3a, 0x18, 0x9b, 0xd8, 0xac, 0x14,
	0xd2, 0xb4, 0xaf, 0x49, 0x1c, 0x4c, 0xbb, 0x2c, 0xa3, 0x6a, 0x97, 0x29, 0x64, 0xac, 0x6f, 0xb8,
	0xed, 0x55, 0xcf, 0x73, 0x3d, 0xbf, 0x52, 0x4c, 0x1b, 0xeb, 0x35, 0x41, 0x66, 0x63, 0x1d, 0x71,
	0xab, 0x63, 0x1d, 0xc1, 0xdc, 0xdf, 0x66, 0xe8, 0x5c, 0xc6, 0x86, 0x8f, 0xcd, 0x0a, 0x8c, 0xf1,
	0x37, 0xe2, 0x88, 0xfc, 0x8d, 0x90, 0x11, 0x7f, 0x23, 0x0a, 0x32, 0x61, 0x86, 0x3d, 0xaf, 0xf8,
	0xbe, 0xd5, 0x75, 0xb0, 0x59, 0x29, 0x51, 0xfd, 0x27, 0xd2, 0xf4, 0x0b, 0x9e, 0xc6, 0x89, 0xe1,
	0xa0, 0x5a, 0x51, 0xe5, 0x14, 0x1b, 0x09, 0x9d, 0xe8, 0x23, 0x98, 0x66, 0x48, 0x33, 0x74, 0x1c,
	0xcb, 0xe9, 0x56, 0xa6, 0xa8, 0x91, 0x27, 0xd3, 0x8c, 0x70, 0x96, 0xc6, 0x93, 0xc3, 0x41, 0xf5,
	0x09, 0x45, 0x4a, 0x31, 0xa1, 0x2a, 0x24, 0x11, 0x83, 0x01, 0xf1, 0xc4, 0x4e, 0xa7, 0x45, 0x8c,
	0x35, 0x95, 0x89, 0x45, 0x8c, 0x84, 0xa4, 0x1a, 0x31, 0x12, 0xc4, 0x78, 0x3e, 0xf8, 0x24, 0xcf,
	0x8c, 0x9f, 0x0f, 0x3e, 0xcf, 0xd2, 0x7c, 0xa4, 0x4c, 0xb5, 0xa2, 0x0d, 0x7d, 0x02, 0xe4, 0xc3,
	0x73, 0x3e, 0xec, 0xdb, 0x56, 0xc7, 0x08, 0xf0, 0x79, 0x1c, 0xe0, 0x0e, 0x89, 0xd4, 0xb3, 0xd4,
	0x8a, 0x3e, 0x62, 0x65, 0x84, 0xb3, 0xa1, 0x0f, 0x07, 0xd5, 0xa5, 0x34, 0x1d, 0x8a, 0xd5, 0x54,
	0x2b, 0xe8, 0x7f, 0x34, 0x98, 0xf7, 0x03, 0xc3, 0x31, 0x0d, 0xdb, 0x75, 0xf0, 0x25, 0xa7, 0xeb,
	0x61, 0xdf, 0xbf, 0xe4, 0x6c, 0xbb, 0x95, 0x32, 0xb5, 0x7f, 0x3a, 0x11, 0xd6, 0xd3, 0x58, 0x1b,
	0xa7, 0x87, 0x83, 0x6a, 0x35, 0x55, 0x8b, 0xe2, 0x41, 0xba, 0x21, 0xb4, 0x0f, 0xc7, 0x44, 0x56,
	0xb1, 0x15, 0x58, 0xb6, 0xe5, 0x1b, 0x81, 0xe5, 0x3a, 0x95, 0xa3, 0xd4, 0xfe, 0xa9, 0x64, 0x74,
	0x1c, 0x61, 0x6c, 0x9c, 0x1a, 0x0e, 0xaa, 0x27, 0x53, 0x34, 0x28, 0xb6, 0xd3, 0x4c, 0xc4, 0x4b,
	0x68, 0xc3, 0xc3, 0x84, 0x11, 0x9b, 0x95, 0x63, 0xe3, 0x97, 0x50, 0xc4, 0x24, 0x2f, 0xa1, 0x08,
	0x4c, 0x5b, 0x42, 0x11, 0x91, 0x58, 0xea, 0x1b, 0x5e, 0x60, 0x11, 0xb3, 0xeb, 0x86, 0xb7, 0x8b,
	0xbd, 0xca, 0x5c, 0x9a, 0xa5, 0x0d, 0x95, 0x89, 0x59, 0x4a, 0x48, 0xaa, 0x96, 0x12, 0x44, 0x74,
	0x4b, 0x03, 0xd5, 0x35, 0xcb, 0x75, 0x9a, 0x24, 0x6d, 0xf0, 0xc9, 0xeb, 0xcd, 0x53, 0xa3, 0x4f,
	0xdf, 0xe6, 0xf5, 0x64, 0xf6, 0xc6, 0xd3, 0xc3, 0x41, 0xf5, 0xf4, 0x58, 0x6d, 0x8a, 0x23, 0xe3,
	0x8d, 0xa2, 0xeb, 0x50, 0x22, 0x44, 0x4c, 0x13, 0x30, 0xb3, 0xb2, 0x40, 0x7d, 0x38, 0x3e, 0xea,
	0x03, 0x67, 0xa0, 0x19, 0xc8, 0xbc, 0x24, 0xa1, 0xd8, 0x91, 0x55, 0x35, 0xf2, 0x30, 0x49, 0xe5,
	0xf5, 0x61, 0x0e, 0x8e, 0xa5, 0xac, 0x0d, 0xf4, 0x16, 0xe4, 0xbc, 0xd0, 0x21, 0x09, 0x1b, 0xcb,
	0x52, 0x90, 0x6a, 0x75, 0x2b, 0xb4, 0x4c, 0x96, 0x2d, 0x7a, 0xa1, 0xa3, 0xe4, 0x70, 0x93, 0x14,
	0x20, 0xf2, 0x24, 0x5b, 0xb4, 0x4c, 0x9e, 0x8d, 0x8c, 0x95, 0xbf, 0xe1, 0xb6, 0x55, 0x79, 0x0a,
	0x20, 0x0c, 0xd3, 0x62, 0xe1, 0xb5, 0x2c, 0xb2, 0xab, 0x58, 0x9e, 0xf1, 0x94, 0xaa, 0xe6, 0xdd,
	0xb0, 0x8d, 0x3d, 0x07, 0x07, 0xd8, 0x17, 0xef, 0x40, 0xb7, 0x15, 0x8d, 0x22, 0x9e, 0x84, 0x48,
	0xfa, 0xa7, 0x64, 0x1c, 0x7d, 0xa1, 0x41, 0xa5, 0x67, 0xec, 0xb7, 0x04, 0xe8, 0xb7, 0xb6, 0x5d,
	0xaf, 0xd5, 0xc7, 0x9e, 0xe5, 0x9a, 0x34, 0xf9, 0x2c, 0x9d, 0xfd, 0x8f, 0x3b, 0x6e, 0xa4, 0xda,
	0xba, 0xb1, 0x2f, 0x60, 0xff, 0x1d, 0xd7, 0xdb, 0xa0, 0xe2, 0xab, 0x4e, 0xe0, 0x1d, 0x34, 0x4e,
	0x7e, 0x3d, 0xa8, 0x1e, 0x21, 0xd3, 0xd2, 0x4b, 0xe3, 0x69, 0xa6, 0xc3, 0xe8, 0x87, 0x1a, 0x2c,
	0x04, 0x6e, 0x60, 0xd8, 0xad, 0x4e, 0xd8, 0x0b, 0x6d, 0x23, 0xb0, 0xf6, 0x70, 0x2b, 0xf4, 0x8d,
	0x2e, 0xe6, 0x39, 0xee, 0x9b, 0x77, 0x76, 0xea, 0x1a, 0x91, 0x3f, 0x17, 0x89, 0x6f, 0x11, 0x69,
	0xe6, 0xd3, 0x09, 0xee, 0xd3, 0x5c, 0x90, 0xc2, 0xd2, 0x4c, 0x45, 0x17, 0x7f, 0xaa, 0xc1, 0xe2,
	0xf8, 0xd7, 0x44, 0xa7, 0x21, 0xbb, 0x8b, 0x0f, 0x78, 0x15, 0x71, 0x74, 0x38, 0xa8, 0x4e, 0xef,
	0xe2, 0x03, 0x69, 0xd4, 0x09, 0x15, 0xfd, 0x17, 0x4c, 0xee, 0x19, 0x76, 0x88, 0xf9, 0x92, 0xa8,
	0xd5, 0x58, 0xbd, 0x54, 0x93, 0xeb, 0xa5, 0x5a, 0x7f, 0xb7, 0x4b, 0x80, 0x9a, 0x98, 0x91, 0xda,
	0x7b, 0xa1, 0xe1, 0x04, 0x56, 0x70, 0xc0, 0x96, 0x0b, 0x55, 0x20, 0x2f, 0x17, 0x0a, 0xbc, 0x91,
	0x79, 0x4d, 0x5b, 0xfc, 0x52, 0x83, 0xe3, 0x63, 0x5f, 0xfa, 0xfb, 0xe0, 0xa1, 0xde, 0x82, 0x09,
	0xb2, 0xf0, 0x49, 0x7d, 0xb3, 0x63, 0x75, 0x77, 0x5e, 0x7d, 0x99, 0xba, 0x93, 0x63, 0xe5, 0x08,
	0x43, 0xe4, 0x72, 0x84, 0x21, 0xa4, 0x46, 0xb3, 0xdd, 0x9b, 0xaf, 0xbe, 0x4c, 0x9d, 0xca, 0x31,
	0x23, 0x14, 0x90, 0x8d, 0x50, 0x40, 0xff, 0x7b, 0x0e, 0x8a, 0x51, 0x01, 0x21, 0xed, 0x41, 0xed,
	0x9e, 0xf6, 0xe0, 0x45, 0x28, 0x9b, 0xd8, 0xe4, 0x5f, 0x3e, 0xcb, 0x75, 0xc4, 0x6e, 0x2e, 0xb2,
	0xe8, 0xaa, 0xd0, 0x14, 0xf9, 0xd9, 0x04, 0x09, 0x9d, 0x85, 0x02, 0x4f, 0xb4, 0x0f, 0xe8, 0x46,
	0x9e, 0x6e, 0x2c, 0x0c, 0x07, 0x55, 0x24, 0x30, 0x49, 0x34, 0xe2, 0x43, 0x4d, 0x00, 0x56, 0xbd,
	0xae, 0xe3, 0xc0, 0xe0, 0x29, 0x7f, 0x45, 0x7d, 0x83, 0xab, 0x11, 0x9d, 0xd5, 0xa1, 0x31, 0xbf,
	0x5c, 0x87, 0xc6, 0x28, 0xfa, 0x10, 0xa0, 0x67, 0x58, 0x0e, 0x93, 0xe3, 0xf9, 0xbd, 0x3e, 0x2e,
	0xa4, 0xac, 0x47, 0x9c, 0x4c, 0x7b, 0x2c, 0x29, 0x6b, 0x8f, 0x51, 0x52, 0x2d, 0xf2, 0x7a, 0xbb,
	0x92, 0xa3, 0xbb, 0x74, 0x69, 0x9c, 0x6a, 0xae, 0x76, 0x9e, 0x54, 0x8c, 0x5c, 0x44, 0xd2, 0x29,
	0xb4, 0x90, 0x61, 0xb3, 0xad, 0x6d, 0x1c, 0x58, 0x3d, 0x4c, 0x33, 0x7b, 0x3e, 0x6c, 0x02, 0x93,
	0x87, 0x4d, 0x60, 0xe8, 0x35, 0x00, 0x23, 0x58, 0x77, 0xfd, 0xe0, 0xaa, 0xd3, 0xc1, 0x34, 0x63,
	0x2f, 0x30, 0xf7, 0x63, 0x54, 0x76, 0x3f, 0x46, 0xd1, 0x9b, 0x50, 0xea, 0xf3, 0x8f, 0x50, 0xdb,
	0xc6, 0x34, 0x23, 0x2f, 0xb0, 0x4f, 0x8a, 0x04, 0x4b, 0xb2, 0x32, 0x37, 0xba, 0x00, 0xb3, 0x1d,
	0xd7, 0xe9, 0x84, 0x9e, 0x87, 0x9d, 0xce, 0xc1, 0xa6, 0xb1, 0x8d, 0x69, 0xf6, 0x5d, 0x60, 0x4b,
	0x25, 0x41, 0x92, 0x97, 0x4a, 0x82, 0x84, 0x5e, 0x81, 0x62, 0xd4, 0xbd, 0xa0, 0x09, 0x76, 0x91,
	0x17, 0xc2, 0x02, 0x94, 0x84, 0x63, 0x4e, 0xe2, 0xbc, 0xe5, 0x47, 0x59, 0x1a, 0x4d, 0x9a, 0xb9,
	0xf3, 0x12, 0x2c, 0x3b, 0x2f, 0xc1, 0xe8, 0x12, 0x1c, 0xa5, 0xdf, 0xc5, 0x56, 0x10, 0xd8, 0x2d,
	0x1f, 0x77, 0x5c, 0xc7, 0xf4, 0x69, 0x4e, 0x9c, 0x65, 0xee, 0x53, 0xe2, 0xb5, 0xc0, 0xde, 0x64,
	0x24, 0xd9, 0xfd, 0x04, 0x49, 0xff, 0xb5, 0x06, 0x73, 0x69, 0x4b, 0x28, 0xb1, 0x9c, 0xb5, 0x07,
	0xb2, 0x9c, 0xdf, 0x87, 0x42, 0xdf, 0x35, 0x5b, 0x7e, 0x1f, 0x77, 0x78, 0xc4, 0x4a, 0x2c, 0xe6,
	0x0d, 0xd7, 0xdc, 0xec, 0xe3, 0xce, 0x7f, 0x5a, 0xc1, 0xce, 0xca, 0x9e, 0x6b, 0x99, 0x97, 0x2d,
	0x9f, 0xaf, 0xba, 0x3e, 0xa3, 0x28, 0x19, 0x42, 0x9e, 0x83, 0x8d, 0x02, 0xe4, 0x98, 0x15, 0xfd,
	0x37, 0x59, 0x28, 0x27, 0x97, 0xed, 0xbf, 0xd2, 0xab, 0xa0, 0xeb, 0x90, 0xb7, 0x58, 0xca, 0xcc,
	0x33, 0x88, 0x7f, 0x93, 0x62, 0x7a, 0x2d, 0x6e, 0xf8, 0xd5, 0xf6, 0x5e, 0xac, 0xf1, 0xdc, 0x9a,
	0x0e, 0x01, 0xd5, 0xcc, 0x25, 0x55, 0xcd, 0x1c, 0x44, 0x4d, 0xc8, 0xfb, 0xd8, 0xdb, 0xb3, 0x3a,
	0x98, 0x07, 0xa7, 0xaa, 0xac, 0xb9, 0xe3, 0x7a, 0x98, 0xe8, 0xdc, 0x64, 0x2c, 0xb1, 0x4e, 0x2e,
	0xa3, 0xea, 0xe4, 0x20, 0x7a, 0x1f, 0x8a, 0x1d, 0xd7, 0xd9, 0xb6, 0xba, 0xeb, 0x46, 0x9f, 0x87,
	0xa7, 0x93, 0x69, 0x5a, 0xcf, 0x09, 0x26, 0xde, 0x84, 0x10, 0x8f, 0x89, 0x26, 0x44, 0xc4, 0x15,
	0x4f, 0xe8, 0x9f, 0x27, 0x00, 0xe2, 0xc9, 0x41, 0xaf, 0x43, 0x09, 0xef, 0xe3, 0x4e, 0x18, 0xb8,
	0x9e, 0xf8, 0x4e, 0xf0, 0x9e, 0x9e, 0x80, 0x95, 0xc0, 0x0e, 0x31, 0x4a, 0x36, 0xaa, 0x63, 0xf4,
	0xb0, 0xdf, 0x37, 0x3a, 0xa2, 0x19, 0x48, 0x9d, 0x89, 0x40, 0x79, 0xa3, 0x46, 0x20, 0xfa, 0x77,
	0x98, 0xa0, 0xed, 0x43, 0xd6, 0x07, 0x44, 0xc3, 0x41, 0x75, 0xc6, 0x51, 0x1b, 0x87, 0x94, 0x8e,
	0xde, 0x86, 0xe9, 0xdd, 0x68, 0xe1, 0x11, 0xdf, 0x26, 0xa8, 0x00, 0x4d, 0xed, 0x62, 0x82, 0xe2,
	0xdd, 0x94, 0x8c, 0xa3, 0x6d, 0x28, 0x19, 0x8e, 0xe3, 0x06, 0xf4, 0x1b, 0x24, 0x7a, 0x83, 0xcf,
	0x8c, 0x5b, 0xa6, 0xb5, 0x95, 0x98, 0x97, 0x65, 0x49, 0x34, 0x78, 0x48, 0x1a, 0xe4, 0xe0, 0x21,
	0xc1, 0xa8, 0x09, 0x39, 0xdb, 0x68, 0x63, 0x5b, 0x04, 0xfd, 0xa7, 0xc6, 0x9a, 0xb8, 0x4c, 0xd9,
	0x98, 0x76, 0xfa, 0xc9, 0x67, 0x72, 0xf2, 0x27, 0x9f, 0x21, 0x8b, 0xdb, 0x50, 0x4e, 0xfa, 0x73,
	0xb8, 0x04, 0xe6, 0x19, 0x39, 0x81, 0x29, 0xde, 0x31, 0x65, 0x32, 0xa0, 0x24, 0x39, 0xf5, 0x30,
	0x4c, 0xe8, 0x3f, 0xd3, 0x60, 0x2e, 0x6d, 0xef, 0xa2, 0x75, 0x69, 0xc7, 0x6b, 0xbc, 0xc7, 0x91,
	0xb2, 0xd4, 0xb9, 0xec, 0x98, 0xad, 0x1e, 0x6f, 0xf4, 0x06, 0xcc, 0x38, 0xae, 0x89, 0x5b, 0x06,
	0x31, 0x60, 0x5b, 0x7e, 0x50, 0xc9, 0xd0, 0xde, 0x31, 0xed, 0x8d, 0x10, 0xca, 0x8a, 0x20, 0x48,
	0xd2, 0xd3, 0x0a, 0x41, 0xff, 0x7f, 0x0d, 0x66, 0x13, 0xad, 0xcb, 0xfb, 0x4e, 0xa2, 0xe4, 0xd4,
	0x27, 0x73, 0xb8, 0xd4, 0x47, 0xff, 0x51, 0x06, 0x4a, 0x52, 0x5d, 0x77, 0xdf, 0x3e, 0xdc, 0x80,
	0x59, 0xfe, 0xa5, 0xb4, 0x9c, 0x2e, 0x2b, 0xa7, 0x32, 0xbc, 0x49, 0x31, 0x72, 0x52, 0xb0, 0xe6,
	0xb6, 0x37, 0x23, 0x5e, 0x5a, 0x4d, 0xd1, 0x0e, 0x96, 0xaf, 0x60, 0x92, 0x89, 0x19, 0x95, 0x82,
	0xae, 0xc3, 0x42, 0xd8, 0x37, 0x8d, 0x00, 0xb7, 0x7c, 0xde, 0x73, 0x6f, 0x39, 0x61, 0xaf, 0x8d,
	0x3d, 0xba, 0xe3, 0x27, 0x59, 0xcf, 0x85, 0x71, 0x88, 0xa6, 0xfc, 0x15, 0x4a, 0x97, 0x74, 0xce,
	0xa5, 0xd1, 0xf5, 0x8b, 0x80, 0x46, 0xfb, 0xca, 0xca, 0xf8, 0x6a, 0x87, 0x1c, 0xdf, 0xcf, 0x34,
	0x28, 0x27, 0xdb, 0xc5, 0x8f, 0x64, 0xa2, 0x0f, 0xa0, 0x18, 0xb5, 0x7e, 0xef, 0xdb, 0x81, 0xe7,
	0x20, 0xe7, 0x61, 0xc3, 0x77, 0x1d, 0xbe, 0x33, 0x69, 0x88, 0x61, 0x88, 0x1c, 0x62, 0x18, 0xa2,
	0x5f, 0x83, 0x29, 0x36, 0x82, 0xef, 0x58, 0x76, 0x80, 0x3d, 0x74, 0x1e, 0x72, 0x7e, 0x60, 0x04,
	0xd8, 0xaf, 0x68, 0xcb, 0xd9, 0x33, 0x33, 0x67, 0x17, 0x46, 0xbb, 0xbc, 0x84, 0xcc, 0xb4, 0x32,
	0x4e, 0x59, 0x2b, 0x43, 0xf4, 0xff, 0xd5, 0x60, 0x4a, 0x6e, 0x66, 0x3f, 0x18, 0xb5, 0x77, 0xf9,
	0x6a, 0x9f, 0x08, 0x1f, 0xec, 0x07, 0x33, 0xb3, 0x77, 0x67, 0xfd, 0x17, 0x1a, 0x1b, 0xd9, 0xa8,
	0x0b, 0x7a, 0xbf, 0xe6, 0xbb, 0x71, 0x2b, 0x84, 0xec, 0x30, 0x9f, 0x06, 0xb6, 0xc3, 0xb6, 0x42,
	0x68, 0xf8, 0x53, 0xc4, 0xe5, 0xf0, 0xa7, 0x10, 0xf4, 0x2f, 0x26, 0xa9, 0xe7, 0x71, 0xc7, 0xfb,
	0x51, 0x37, 0x81, 0x12, 0xd9, 0x49, 0xf6, 0x2e, 0xb2, 0x93, 0xe7, 0x21, 0x4f, 0x3f, 0x07, 0x51,
	0xe2, 0x40, 0x27, 0x8d, 0x40, 0xea, 0x89, 0x23, 0x43, 0x6e, 0x13, 0xb5, 0x26, 0xef, 0x2f, 0x6a,
	0xa1, 0x16, 0x1c, 0xdf, 0x31, 0xfc, 0x96, 0x88, 0xb3, 0x66, 0xcb, 0x08, 0x5a, 0x51, 0x9c, 0xc8,
	0xd1, 0x32, 0xe5, 0xa9, 0xe1, 0xa0, 0xba, 0xbc, 0x63, 0xf8, 0x9b, 0x82, 0x67, 0x25, 0xd8, 0x18,
	0x8d, 0x1a, 0x0b, 0xe9, 0x1c, 0x68, 0x0b, 0xe6, 0xd3, 0x95, 0xe7, 0xa9, 0xe7, 0xb4, 0xc9, 0xeb,
	0xdf, 0x56, 0xf3, 0xb1, 0x14, 0x32, 0xfa, 0x54, 0x83, 0x0a, 0xf9, 0x3e, 0x7b, 0xf8, 0xe3, 0xd0,
	0xf2, 0x70, 0x8f, 0xcc, 0x58, 0xcb, 0xdd, 0xc3, 0x9e, 0x6d, 0x1c, 0xf0, 0xd3, 0x9a, 0x53, 0xa3,
	0x5f, 0x8f, 0x0d, 0xd7, 0x6c, 0x4a, 0x02, 0xec, 0xd5, 0xfa, 0x2a, 0x78, 0x95, 0x29, 0x91, 0x5f,
	0x2d, 0x9d, 0x63, 0x6d, 0xa2, 0x50, 0x28, 0x17, 0xf5, 0xbf, 0x6a, 0x30, 0xa3, 0x1e, 0xaa, 0x3c,
	0xf2, 0x85, 0x39, 0xb2, 0x25, 0xb3, 0x0f, 0x69, 0x4b, 0xfe, 0x45, 0x83, 0x69, 0xe5, 0xac, 0xe7,
	0xf1, 0x79, 0xf5, 0x1f, 0x67, 0x60, 0x21, 0x5d, 0xcd, 0x43, 0x29, 0x40, 0x2f, 0x02, 0x49, 0x25,
	0x2f, 0xc5, 0xb9, 0xd1, 0xfc, 0x48, 0xfd, 0x49, 0x5f, 0x41, 0xe4, 0xa1, 0x23, 0x87, 0x34, 0x42,
	0x1c, 0x5d, 0x87, 0x92, 0x25, 0x1d, 0x07, 0x65, 0xd3, 0xba, 0xf6, 0xf2, 0x21, 0x10, 0xeb, 0x52,
	0x8c, 0x39, 0xfa, 0x91, 0x55, 0x35, 0x72, 0x30, 0x41, 0x92, 0x37, 0x7d, 0x0f, 0xf2, 0xdc, 0x1d,
	0xf4, 0x12, 0x14, 0x69, 0x9c, 0xa3, 0x35, 0x15, 0x4b, 0xdc, 0x69, 0xda, 0x41, 0xc0, 0xc4, 0x85,
	0x8c, 0x82, 0xc0, 0xd0, 0xab, 0x00, 0x64, 0x6b, 0xf3, 0x08, 0x97, 0xa1, 0x71, 0x82, 0xd6, 0x6e,
	0x7d, 0xd7, 0x1c, 0x09, 0x6b, 0xc5, 0x08, 0xd4, 0x7f, 0x9e, 0x81, 0x92, 0x7c, 0x00, 0x75, 0x4f,
	0xc6, 0x3f, 0x01, 0x51, 0x57, 0xb7, 0x0c, 0xd3, 0x24, 0x7f, 0xb1, 0xf8, 0xa4, 0xd5, 0xc7, 0x0e,
	0x92, 0xf8, 0x7f, 0x45, 0x48, 0xb0, 0x2a, 0x8a, 0x1e, 0xf1, 0x5b, 0x09, 0x92, 0x64, 0xb5, 0x9c,
	0xa4, 0x2d, 0xee, 0xc2, 0x7c, 0xaa, 0x2a, 0xb9, 0xf6, 0x99, 0x7c, 0x50, 0xb5, 0xcf, 0x2f, 0x27,
	0x61, 0x3e, 0xf5, 0xe0, 0xef, 0x91, 0xef, 0x62, 0x75, 0x07, 0x65, 0x1f, 0xc8, 0x0e, 0xfa, 0x4c,
	0x4b, 0x9b, 0x59, 0x76, 0x88, 0xf2, 0xfa, 0x21, 0x4e, 0x43, 0x1f, 0xd4, 0x1c, 0xab, 0xcb, 0x72,
	0xf2, 0x9e, 0xf6, 0x44, 0xee, 0xb0, 0x7b, 0x02, 0xbd, 0xc0, 0xca, 0x58, 0x6a, 0x2b, 0x4f, 0x6d,
	0x89, 0x08, 0x91, 0x30, 0x95, 0xe7, 0x10, 0x7a, 0x1b, 0xa6, 0x85, 0x04, 0x6b, 0x9e, 0x14, 0xe2,
	0xce, 0x06, 0xe7, 0x49, 0xf6, 0x4f, 0xa6, 0x64, 0xfc, 0x9f, 0xbb, 0x86, 0xff, 0xa6, 0xc1, 0x6c,
	0xe2, 0x26, 0xc0, 0xe3, 0xf3, 0x0d, 0xfa, 0x5c, 0x83, 0x62, 0x74, 0x09, 0xe5, 0xbe, 0x13, 0xf9,
	0x15, 0xc8, 0x61, 0x76, 0x11, 0x82, 0x85, 0xbb, 0x63, 0x89, 0x8b, 0x6a, 0x84, 0xc6, 0xaf, 0xa6,
	0x25, 0xee, 0x3e, 0x34, 0xb9, 0xa0, 0xfe, 0x5b, 0x4d, 0xa4, 0xe8, 0xb1, 0x4f, 0x8f, 0x74, 0x2a,
	0xe2, 0x77, 0xca, 0xde, 0xeb, 0x3b, 0xfd, 0xaa, 0x08, 0x93, 0x94, 0x8f, 0x94, 0xd0, 0x01, 0xf6,
	0x7a, 0x96, 0x63, 0xd8, 0xf4, 0x75, 0x0a, 0x6c, 0xdf, 0x0a, 0x4c, 0xde, 0xb7, 0x02, 0x43, 0x3b,
	0x30, 0x1b, 0xb7, 0xfd, 0xa8, 0x9a, 0xf4, 0xfb, 0x6f, 0xef, 0xaa, 0x4c, 0xac, 0xb1, 0x9f, 0x90,
	0x54, 0x2f, 0x08, 0x24, 0x88, 0xc8, 0x84, 0x99, 0x8e, 0xeb, 0x04, 0x86, 0xe5, 0x60, 0x8f, 0x19,
	0xca, 0xa6, 0xdd, 0xff, 0x39, 0xa7, 0xf0, 0xb0, 0xee, 0x89, 0x2a, 0xa7, 0xde, 0xff, 0x51, 0x69,
	0xe8, 0x23, 0x98, 0x16, 0x65, 0x0c, 0x33, 0x32, 0x91, 0x76, 0xff, 0x67, 0x55, 0x66, 0x61, 0x4b,
	0x5a, 0x91, 0x52, 0xef, 0xff, 0x28, 0x24, 0x64, 0x43, 0xb9, 0xef, 0x9a, 0x5b, 0x0e, 0x4f, 0xde,
	0x8d, 0xb6, 0x8d, 0x79, 0xaf, 0x79, 0x69, 0x24, 0xe5, 0x51, 0xb8, 0x58, 0x28, 0x4e, 0xca, 0xaa,
	0x37, 0xea, 0x92, 0x54, 0xf4, 0x21, 0x4c, 0xd9, 0xa4, 0x9a, 0x5c, 0xdd, 0xef, 0x5b, 0x1e, 0x36,
	0xd3, 0xef, 0xbf, 0x5d, 0x96, 0x38, 0x58, 0x20, 0x94, 0x65, 0xd4, 0x3b, 0x40, 0x32, 0x85, 0xcc,
	0x7e, 0xcf, 0xd8, 0x6f, 0x86, 0x8e, 0xbf, 0xba, 0xcf, 0xef, 0x32, 0xe5, 0xd3, 0x66, 0x7f, 0x5d,
	0x65, 0x62, 0xb3, 0x9f, 0x90, 0x54, 0x67, 0x3f, 0x41, 0x44, 0x97, 0x69, 0x9c, 0x67, 0x53, 0xc2,
	0xee, 0xc1, 0x2d, 0x8c, 0x8c, 0x16, 0x9b, 0x0d, 0xd6, 0xf6, 0xe1, 0x4f, 0x8a, 0xd2, 0x48, 0x03,
	0x9f, 0x03, 0xfa, 0xda, 0x4d, 0x1c, 0x84, 0x9e, 0x83, 0x4d, 0x5e, 0x54, 0x8d, 0xce, 0x81, 0xc2,
	0x15, 0xcd, 0x81, 0x82, 0x8e, 0xcc, 0x81, 0x42, 0x25, 0x6b, 0xaa, 0xef, 0x9a, 0xd7, 0xd8, 0x96,
	0x09, 0xa2, 0x8b, 0x71, 0x4f, 0x8e, 0x98, 0x8a, 0x59, 0xd8, 0x9a, 0x52, 0xa4, 0xd4, 0x35, 0xa5,
	0x90, 0xf8, 0x5d, 0x2c, 0xf9, 0xe6, 0x0e, 0x1b, 0xa9, 0xd2, 0x98, 0xbb, 0x58, 0x23, 0x9c, 0xd1,
	0x5d, 0xac, 0x11, 0xca, 0xc8, 0x5d, 0xac, 0x11, 0x0e, 0x62, 0xbd, 0x6b, 0x38, 0xdd, 0x35, 0xb7,
	0xad, 0xae, 0xea, 0xa9, 0x34, 0xeb, 0x17, 0x52, 0x38, 0x99, 0xf5, 0x34, 0x1d, 0xaa, 0xf5, 0x34,
	0x8e, 0x46, 0x41, 0xb4, 0x87, 0xf4, 0x2f, 0x35, 0x98, 0x4d, 0xc4, 0x19, 0xf4, 0x16, 0x44, 0x37,
	0x4e, 0xae, 0x1d, 0xf4, 0x45, 0x9a, 0xac, 0xdc, 0x50, 0x21, 0x78, 0xda, 0x0d, 0x15, 0x82, 0xa3,
	0xcb, 0x00, 0xd1, 0x37, 0xe9, 0x76, 0x41, 0x9a, 0xe6, 0x68, 0x31, 0xa7, 0x9c, 0xa3, 0xc5, 0xa8,
	0xfe, 0x4d, 0x16, 0x0a, 0x62, 0xa1, 0x3e, 0x94, 0x32, 0xaa, 0x0e, 0xf9, 0x1e, 0xf6, 0xe9, 0x4d,
	0x95, 0x4c, 0x9c, 0x0d, 0x71, 0x48, 0xce, 0x86, 0x38, 0xa4, 0x26, 0x6b, 0xd9, 0x7b, 0x4a, 0xd6,
	0x26, 0x0e, 0x9d, 0xac, 0x61, 0x7a, 0x4a, 0x2d, 0x85, 0x5b, 0x71, 0x2e, 0x74, 0xfb, 0x18, 0x2e,
	0xce, 0xb0, 0x65, 0xc1, 0xc4, 0x19, 0xb6, 0x4c, 0x42, 0xbb, 0x70, 0x54, 0x3a, 0xbb, 0xe2, 0xbd,
	0x43, 0x12, 0xf8, 0x66, 0xc6, 0x5f, 0x09, 0x68, 0x52, 0x2e, 0xb6, 0xbd, 0x77, 0x13, 0xa8, 0x9c,
	0xed, 0x26, 0x69, 0xfa, 0x1f, 0x33, 0x30, 0xa3, 0xfa, 0xfb, 0x50, 0x26, 0xf6, 0x25, 0x28, 0xe2,
	0x7d, 0x2b, 0x68, 0x75, 0x5c, 0x13, 0xf3, 0x92, 0x91, 0xce, 0x13, 0x01, 0xcf, 0xb9, 0xa6, 0x32,
	0x4f, 0x02, 0x93, 0x57, 0x43, 0xf6, 0x50, 0xab, 0x21, 0x6e, 0xb5, 0x4e, 0xdc, 0xb9, 0xd5, 0x9a,
	0x3e, 0xce, 0xc5, 0x87, 0x34, 0xce, 0xb7, 0x32, 0x50, 0x4e, 0x46, 0xe3, 0xef, 0xc7, 0x16, 0x52,
	0x77, 0x43, 0xf6, 0xd0, 0xbb, 0xe1, 0x6d, 0x98, 0x26, 0xb9, 0xa3, 0x11, 0x04, 0xfc, 0x0e, 0xe7,
	0x04, 0xcd, 0xb9, 0x58, 0x6c, 0x0a, 0x9d, 0x15, 0x81, 0x2b, 0xb1, 0x49, 0xc2, 0xf5, 0x4f, 0x33,
	0x30, 0xad, 0x7c, 0x35, 0x1e, 0xbf, 0x90, 0xa2, 0xcf, 0xc2, 0xb4, 0x92, 0x8c, 0xe9, 0xff, 0xc7,
	0xd6, 0x89, 0x9a, 0x05, 0x3d, 0x7e, 0xe3, 0x32, 0x03, 0x53, 0x72, 0x56, 0xa7, 0x37, 0x60, 0x36,
	0x91, 0x84, 0xc9, 0x2f, 0xa0, 0x1d, 0xe6, 0x05, 0xf4, 0x05, 0x98, 0x4b, 0xcb, 0x1d, 0xf4, 0x0b,
	0x30, 0x97, 0xf6, 0x55, 0xbf, 0x7b, 0x03, 0x5f, 0x69, 0xd4, 0xc2, 0xe8, 0x6d, 0xef, 0x8b, 0x00,
	0x0e, 0xbe, 0xd9, 0xba, 0x63, 0xf9, 0xc7, 0xc6, 0x13, 0xdf, 0x5c, 0x4b, 0x54, 0x4b, 0x05, 0x81,
	0x11, 0x4d, 0xae, 0x6d, 0xb6, 0xee, 0x58, 0x74, 0x51, 0x4d, 0xae, 0x6d, 0x8e, 0x68, 0x12, 0x98,
	0xfe, 0x83, 0xac, 0xa8, 0xcc, 0xe3, 0xeb, 0xd2, 0x1f, 0x40, 0xb9, 0x2f, 0x1e, 0xee, 0xec, 0x2d,
	0xad, 0x4d, 0x22, 0xfe, 0xa4, 0xa5, 0x19, 0x95, 0xa2, 0xea, 0xe6, 0x45, 0x67, 0xe6, 0x90, 0xba,
	0x9b, 0x89, 0xea, 0x73, 0x46, 0xa5, 0xa0, 0xff, 0x86, 0xa3, 0xe2, 0x36, 0xd9, 0x1e, 0x16, 0x8e,
	0x67, 0xc7, 0x2a, 0x67, 0xb7, 0xbb, 0x23, 0x81, 0xa4, 0xe7, 0xb3, 0x09, 0x52, 0x42, 0x3d, 0xf7,
	0x7d, 0xe2, 0xb0, 0xea, 0x93, 0xce, 0xcf, 0x26, 0x48, 0xfa, 0xe7, 0x1a, 0xcc, 0x26, 0x2e, 0xa0,
	0xa3, 0xf3, 0x50, 0xa0, 0xbf, 0x4f, 0xbb, 0xfd, 0x0c, 0xd0, 0x05, 0x49, 0xf9, 0x14, 0x0b, 0x79,
	0x0e, 0xa1, 0x57, 0xa0, 0x18, 0xdd, 0x53, 0xe7, 0xa7, 0xca, 0x6c, 0xf3, 0x09, 0x50, 0xd9, 0x7c,
	0x02, 0xd4, 0x7f, 0xa2, 0xc1, 0xf1, 0xb1, 0x97, 0xd3, 0x1f, 0x75, 0xcf, 0xe0, 0xd9, 0x17, 0xa0,
	0x20, 0xce, 0x7d, 0x11, 0x40, 0xee, 0xbd, 0xad, 0xd5, 0xad, 0xd5, 0xf3, 0xe5, 0x23, 0xa8, 0x04,
	0xf9, 0x8d, 0xd5, 0x2b, 0xe7, 0x2f, 0x5d, 0xb9, 0x50, 0xd6, 0xc8, 0x43, 0x73, 0xeb, 0xca, 0x15,
	0xf2, 0x90, 0x79, 0xf6, 0xb2, 0x7c, 0x0b, 0x8d, 0x7d, 0x8f, 0xd1, 0x14, 0x14, 0x56, 0xfa, 0x7d,
	0x1a, 0x00, 0x98, 0xec, 0xea, 0x9e, 0x45, 0xf6, 0x6a, 0x59, 0x43, 0x79, 0xc8, 0x5e, 0xbd, 0xba,
	0x5e, 0xce, 0xa0, 0x39, 0x28, 0x9f, 0xc7, 0x86, 0x69, 0x5b, 0x0e, 0x16, 0x51, 0xa7, 0x9c, 0x6d,
	0xdc, 0xf8, 0xfa, 0xdb, 0x25, 0xed, 0x9b, 0x6f, 0x97, 0xb4, 0x3f, 0x7c, 0xbb, 0xa4, 0xdd, 0xfa,
	0x6e, 0xe9, 0xc8, 0x37, 0xdf, 0x2d, 0x1d, 0xf9, 0xdd, 0x77, 0x4b, 0x47, 0x3e, 0x78, 0x41, 0xfa,
	0x2d, 0x26, 0x7b, 0xa7, 0xbe, 0xe7, 0x92, 0x80, 0xcb, 0x9f, 0xea, 0xc9, 0x5f, 0x9f, 0x7e, 0x95,
	0x39, 0xb9, 0x42, 0x1f, 0x37, 0x18, 0x5f, 0xed, 0x92, 0x5b, 0x63, 0x00, 0xfd, 0x01, 0xa1, 0xdf,
	0xce, 0xd1, 0x1f, 0x0a, 0xbe, 0xf4, 0x8f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xdf, 0x71, 0x86, 0xa5,
	0xb8, 0x3a, 0x00, 0x00,
}

func (m *EventSequence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSequence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Groups) > 0 {
		for iNdEx := len(m.Groups) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Groups[iNdEx])
			copy(dAtA[i:], m.Groups[iNdEx])
			i = encodeVarintEvents(dAtA, i, uint64(len(m.Groups[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobSetName) > 0 {
		i -= len(m.JobSetName)
		copy(dAtA[i:], m.JobSetName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.JobSetName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSequence_Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSequence_Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Created != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.Created):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintEvents(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}

func (m *EventSequence_Event_SubmitJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_SubmitJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubmitJob != nil {
		{
			size, err := m.SubmitJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_ReprioritiseJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_ReprioritiseJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReprioritiseJob != nil {
		{
			size, err := m.ReprioritiseJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_ReprioritiseJobSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_ReprioritiseJobSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReprioritiseJobSet != nil {
		{
			size, err := m.ReprioritiseJobSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_ReprioritisedJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_ReprioritisedJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReprioritisedJob != nil {
		{
			size, err := m.ReprioritisedJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_CancelJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_CancelJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelJob != nil {
		{
			size, err := m.CancelJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_CancelJobSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_CancelJobSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelJobSet != nil {
		{
			size, err := m.CancelJobSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_CancelledJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_CancelledJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CancelledJob != nil {
		{
			size, err := m.CancelledJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobSucceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobSucceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobSucceeded != nil {
		{
			size, err := m.JobSucceeded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobErrors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobErrors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobErrors != nil {
		{
			size, err := m.JobErrors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunLeased) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunLeased) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunLeased != nil {
		{
			size, err := m.JobRunLeased.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunAssigned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunAssigned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunAssigned != nil {
		{
			size, err := m.JobRunAssigned.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunRunning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunRunning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunRunning != nil {
		{
			size, err := m.JobRunRunning.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunSucceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunSucceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunSucceeded != nil {
		{
			size, err := m.JobRunSucceeded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunErrors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunErrors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunErrors != nil {
		{
			size, err := m.JobRunErrors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobDuplicateDetected) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobDuplicateDetected) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobDuplicateDetected != nil {
		{
			size, err := m.JobDuplicateDetected.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_StandaloneIngressInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_StandaloneIngressInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StandaloneIngressInfo != nil {
		{
			size, err := m.StandaloneIngressInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_ResourceUtilisation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_ResourceUtilisation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ResourceUtilisation != nil {
		{
			size, err := m.ResourceUtilisation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunPreempted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunPreempted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunPreempted != nil {
		{
			size, err := m.JobRunPreempted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_PartitionMarker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_PartitionMarker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PartitionMarker != nil {
		{
			size, err := m.PartitionMarker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRunPreemptionRequested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRunPreemptionRequested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunPreemptionRequested != nil {
		{
			size, err := m.JobRunPreemptionRequested.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *EventSequence_Event_JobRequeued) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSequence_Event_JobRequeued) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRequeued != nil {
		{
			size, err := m.JobRequeued.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ResourceUtilisation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceUtilisation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceUtilisation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalCumulativeUsage) > 0 {
		for k := range m.TotalCumulativeUsage {
			v := m.TotalCumulativeUsage[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEvents(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEvents(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MaxResourcesForPeriod) > 0 {
		for k := range m.MaxResourcesForPeriod {
			v := m.MaxResourcesForPeriod[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEvents(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEvents(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ResourceInfo != nil {
		{
			size, err := m.ResourceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RunId != nil {
		{
			size, err := m.RunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Uuid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Uuid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Uuid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Low64 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Low64))
		i--
		dAtA[i] = 0x11
	}
	if m.High64 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.High64))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *SubmitJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubmitJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QueueTtlSeconds != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.QueueTtlSeconds))
		i--
		dAtA[i] = 0x68
	}
	if m.IsDuplicate {
		i--
		if m.IsDuplicate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.Scheduler) > 0 {
		i -= len(m.Scheduler)
		copy(dAtA[i:], m.Scheduler)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Scheduler)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ConcurrencySafe {
		i--
		if m.ConcurrencySafe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Preemptible {
		i--
		if m.Preemptible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.AtMostOnce {
		i--
		if m.AtMostOnce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Lifetime != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Lifetime))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Objects) > 0 {
		for iNdEx := len(m.Objects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Objects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.MainObject != nil {
		{
			size, err := m.MainObject.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Priority != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DeduplicationId) > 0 {
		i -= len(m.DeduplicationId)
		copy(dAtA[i:], m.DeduplicationId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DeduplicationId)))
		i--
		dAtA[i] = 0x12
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesMainObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesMainObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesMainObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Object != nil {
		{
			size := m.Object.Size()
			i -= size
			if _, err := m.Object.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesMainObject_PodSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesMainObject_PodSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodSpec != nil {
		{
			size, err := m.PodSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *KubernetesObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Object != nil {
		{
			size := m.Object.Size()
			i -= size
			if _, err := m.Object.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesObject_PodSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesObject_PodSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodSpec != nil {
		{
			size, err := m.PodSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *KubernetesObject_Ingress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesObject_Ingress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ingress != nil {
		{
			size, err := m.Ingress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *KubernetesObject_Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesObject_Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *KubernetesObject_ConfigMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesObject_ConfigMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConfigMap != nil {
		{
			size, err := m.ConfigMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ObjectMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintEvents(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEvents(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEvents(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintEvents(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEvents(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEvents(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.KubernetesId) > 0 {
		i -= len(m.KubernetesId)
		copy(dAtA[i:], m.KubernetesId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.KubernetesId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ExecutorId) > 0 {
		i -= len(m.ExecutorId)
		copy(dAtA[i:], m.ExecutorId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExecutorId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodSpecWithAvoidList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodSpecWithAvoidList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSpecWithAvoidList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeAvoidlist) > 0 {
		for iNdEx := len(m.NodeAvoidlist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NodeAvoidlist[iNdEx])
			copy(dAtA[i:], m.NodeAvoidlist[iNdEx])
			i = encodeVarintEvents(dAtA, i, uint64(len(m.NodeAvoidlist[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PodSpec != nil {
		{
			size, err := m.PodSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReprioritiseJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReprioritiseJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReprioritiseJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x10
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRequeued) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRequeued) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRequeued) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateSequenceNumber != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.UpdateSequenceNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.SchedulingInfo != nil {
		{
			size, err := m.SchedulingInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReprioritiseJobSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReprioritiseJobSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReprioritiseJobSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReprioritisedJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReprioritisedJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReprioritisedJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x10
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobSetFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSetFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSetFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.States) > 0 {
		dAtA45 := make([]byte, len(m.States)*10)
		var j44 int
		for _, num := range m.States {
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintEvents(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelJobSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelJobSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelJobSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.States) > 0 {
		dAtA47 := make([]byte, len(m.States)*10)
		var j46 int
		for _, num := range m.States {
			for num >= 1<<7 {
				dAtA47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			dAtA47[j46] = uint8(num)
			j46++
		}
		i -= j46
		copy(dAtA[i:], dAtA47[:j46])
		i = encodeVarintEvents(dAtA, i, uint64(j46))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelledJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelledJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelledJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobSucceeded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSucceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSucceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceInfos) > 0 {
		for iNdEx := len(m.ResourceInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunLeased) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunLeased) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunLeased) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PodRequirementsOverlay != nil {
		{
			size, err := m.PodRequirementsOverlay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ScheduledAtPriority != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ScheduledAtPriority))
		i--
		dAtA[i] = 0x38
	}
	if m.HasScheduledAtPriority {
		i--
		if m.HasScheduledAtPriority {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.UpdateSequenceNumber != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.UpdateSequenceNumber))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExecutorId) > 0 {
		i -= len(m.ExecutorId)
		copy(dAtA[i:], m.ExecutorId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ExecutorId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RunId != nil {
		{
			size, err := m.RunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunAssigned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunAssigned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunAssigned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceInfos) > 0 {
		for iNdEx := len(m.ResourceInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RunId != nil {
		{
			size, err := m.RunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunRunning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunRunning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunRunning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceInfos) > 0 {
		for iNdEx := len(m.ResourceInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RunId != nil {
		{
			size, err := m.RunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesResourceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesResourceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesResourceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size := m.Info.Size()
			i -= size
			if _, err := m.Info.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesResourceInfo_PodInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesResourceInfo_PodInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodInfo != nil {
		{
			size, err := m.PodInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *KubernetesResourceInfo_IngressInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesResourceInfo_IngressInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IngressInfo != nil {
		{
			size, err := m.IngressInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PodInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PodNumber != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PodNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IngressInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IngressInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IngressAddresses) > 0 {
		for k := range m.IngressAddresses {
			v := m.IngressAddresses[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintEvents(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintEvents(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintEvents(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StandaloneIngressInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StandaloneIngressInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StandaloneIngressInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PodNamespace) > 0 {
		i -= len(m.PodNamespace)
		copy(dAtA[i:], m.PodNamespace)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PodNamespace)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PodName) > 0 {
		i -= len(m.PodName)
		copy(dAtA[i:], m.PodName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PodName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.PodNumber != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PodNumber))
		i--
		dAtA[i] = 0x30
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IngressAddresses) > 0 {
		for k := range m.IngressAddresses {
			v := m.IngressAddresses[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintEvents(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintEvents(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintEvents(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RunId != nil {
		{
			size, err := m.RunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunSucceeded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunSucceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunSucceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceInfos) > 0 {
		for iNdEx := len(m.ResourceInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RunId != nil {
		{
			size, err := m.RunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobErrors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobErrors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobErrors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Errors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunErrors) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunErrors) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunErrors) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Errors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RunId != nil {
		{
			size, err := m.RunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reason != nil {
		{
			size := m.Reason.Size()
			i -= size
			if _, err := m.Reason.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Terminal {
		i--
		if m.Terminal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Error_KubernetesError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_KubernetesError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KubernetesError != nil {
		{
			size, err := m.KubernetesError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Error_ContainerError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_ContainerError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ContainerError != nil {
		{
			size, err := m.ContainerError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Error_ExecutorError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_ExecutorError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExecutorError != nil {
		{
			size, err := m.ExecutorError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Error_PodUnschedulable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_PodUnschedulable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodUnschedulable != nil {
		{
			size, err := m.PodUnschedulable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Error_LeaseExpired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_LeaseExpired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LeaseExpired != nil {
		{
			size, err := m.LeaseExpired.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Error_MaxRunsExceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_MaxRunsExceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MaxRunsExceeded != nil {
		{
			size, err := m.MaxRunsExceeded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Error_PodError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_PodError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodError != nil {
		{
			size, err := m.PodError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Error_PodLeaseReturned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_PodLeaseReturned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodLeaseReturned != nil {
		{
			size, err := m.PodLeaseReturned.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Error_PodTerminated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_PodTerminated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodTerminated != nil {
		{
			size, err := m.PodTerminated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Error_JobRunPreemptedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_JobRunPreemptedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JobRunPreemptedError != nil {
		{
			size, err := m.JobRunPreemptedError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Error_GangJobUnschedulable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error_GangJobUnschedulable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GangJobUnschedulable != nil {
		{
			size, err := m.GangJobUnschedulable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *KubernetesError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceId != nil {
		{
			size, err := m.ResourceId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KubernetesReason != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.KubernetesReason))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ContainerErrors) > 0 {
		for iNdEx := len(m.ContainerErrors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ContainerErrors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PodNumber != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PodNumber))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KubernetesReason != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.KubernetesReason))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExitCode != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExitCode))
		i--
		dAtA[i] = 0x10
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodLeaseReturned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodLeaseReturned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodLeaseReturned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RunAttempted {
		i--
		if m.RunAttempted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PodNumber != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PodNumber))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodTerminated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodTerminated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodTerminated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PodNumber != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PodNumber))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutorError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutorError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *PodUnschedulable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodUnschedulable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodUnschedulable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PodNumber != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PodNumber))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.ObjectMeta != nil {
		{
			size, err := m.ObjectMeta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LeaseExpired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseExpired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LeaseExpired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MaxRunsExceeded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxRunsExceeded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxRunsExceeded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunPreemptedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunPreemptedError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunPreemptedError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GangJobUnschedulable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GangJobUnschedulable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GangJobUnschedulable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobDuplicateDetected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobDuplicateDetected) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobDuplicateDetected) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OldJobId != nil {
		{
			size, err := m.OldJobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewJobId != nil {
		{
			size, err := m.NewJobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunPreempted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunPreempted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunPreempted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreemptiveRunId != nil {
		{
			size, err := m.PreemptiveRunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PreemptiveJobId != nil {
		{
			size, err := m.PreemptiveJobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PreemptedRunId != nil {
		{
			size, err := m.PreemptedRunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PreemptedJobId != nil {
		{
			size, err := m.PreemptedJobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PartitionMarker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartitionMarker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartitionMarker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Partition != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Partition))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != nil {
		{
			size, err := m.GroupId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobRunPreemptionRequested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRunPreemptionRequested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobRunPreemptionRequested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JobId != nil {
		{
			size, err := m.JobId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.RunId != nil {
		{
			size, err := m.RunId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventSequence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.JobSetName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Groups) > 0 {
		for _, s := range m.Groups {
			l = len(s)
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *EventSequence_Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	if m.Created != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.Created)
		n += 2 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSequence_Event_SubmitJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubmitJob != nil {
		l = m.SubmitJob.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_ReprioritiseJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReprioritiseJob != nil {
		l = m.ReprioritiseJob.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_ReprioritiseJobSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReprioritiseJobSet != nil {
		l = m.ReprioritiseJobSet.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_ReprioritisedJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReprioritisedJob != nil {
		l = m.ReprioritisedJob.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_CancelJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelJob != nil {
		l = m.CancelJob.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_CancelJobSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelJobSet != nil {
		l = m.CancelJobSet.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_CancelledJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CancelledJob != nil {
		l = m.CancelledJob.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobSucceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobSucceeded != nil {
		l = m.JobSucceeded.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobErrors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobErrors != nil {
		l = m.JobErrors.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunLeased) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunLeased != nil {
		l = m.JobRunLeased.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunAssigned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunAssigned != nil {
		l = m.JobRunAssigned.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunRunning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunRunning != nil {
		l = m.JobRunRunning.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunSucceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunSucceeded != nil {
		l = m.JobRunSucceeded.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunErrors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunErrors != nil {
		l = m.JobRunErrors.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobDuplicateDetected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobDuplicateDetected != nil {
		l = m.JobDuplicateDetected.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_StandaloneIngressInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StandaloneIngressInfo != nil {
		l = m.StandaloneIngressInfo.Size()
		n += 2 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_ResourceUtilisation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceUtilisation != nil {
		l = m.ResourceUtilisation.Size()
		n += 2 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunPreempted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunPreempted != nil {
		l = m.JobRunPreempted.Size()
		n += 2 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_PartitionMarker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionMarker != nil {
		l = m.PartitionMarker.Size()
		n += 2 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRunPreemptionRequested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunPreemptionRequested != nil {
		l = m.JobRunPreemptionRequested.Size()
		n += 2 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *EventSequence_Event_JobRequeued) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRequeued != nil {
		l = m.JobRequeued.Size()
		n += 2 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *ResourceUtilisation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunId != nil {
		l = m.RunId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ResourceInfo != nil {
		l = m.ResourceInfo.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.MaxResourcesForPeriod) > 0 {
		for k, v := range m.MaxResourcesForPeriod {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovEvents(uint64(len(k))) + 1 + l + sovEvents(uint64(l))
			n += mapEntrySize + 1 + sovEvents(uint64(mapEntrySize))
		}
	}
	if len(m.TotalCumulativeUsage) > 0 {
		for k, v := range m.TotalCumulativeUsage {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovEvents(uint64(len(k))) + 1 + l + sovEvents(uint64(l))
			n += mapEntrySize + 1 + sovEvents(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Uuid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.High64 != 0 {
		n += 9
	}
	if m.Low64 != 0 {
		n += 9
	}
	return n
}

func (m *SubmitJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DeduplicationId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovEvents(uint64(m.Priority))
	}
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MainObject != nil {
		l = m.MainObject.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Objects) > 0 {
		for _, e := range m.Objects {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if m.Lifetime != 0 {
		n += 1 + sovEvents(uint64(m.Lifetime))
	}
	if m.AtMostOnce {
		n += 2
	}
	if m.Preemptible {
		n += 2
	}
	if m.ConcurrencySafe {
		n += 2
	}
	l = len(m.Scheduler)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.IsDuplicate {
		n += 2
	}
	if m.QueueTtlSeconds != 0 {
		n += 1 + sovEvents(uint64(m.QueueTtlSeconds))
	}
	return n
}

func (m *KubernetesMainObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Object != nil {
		n += m.Object.Size()
	}
	return n
}

func (m *KubernetesMainObject_PodSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodSpec != nil {
		l = m.PodSpec.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *KubernetesObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Object != nil {
		n += m.Object.Size()
	}
	return n
}

func (m *KubernetesObject_PodSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodSpec != nil {
		l = m.PodSpec.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *KubernetesObject_Ingress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ingress != nil {
		l = m.Ingress.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *KubernetesObject_Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *KubernetesObject_ConfigMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigMap != nil {
		l = m.ConfigMap.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *ObjectMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExecutorId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.KubernetesId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEvents(uint64(len(k))) + 1 + len(v) + sovEvents(uint64(len(v)))
			n += mapEntrySize + 1 + sovEvents(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEvents(uint64(len(k))) + 1 + len(v) + sovEvents(uint64(len(v)))
			n += mapEntrySize + 1 + sovEvents(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PodSpecWithAvoidList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodSpec != nil {
		l = m.PodSpec.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.NodeAvoidlist) > 0 {
		for _, s := range m.NodeAvoidlist {
			l = len(s)
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *ReprioritiseJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovEvents(uint64(m.Priority))
	}
	return n
}

func (m *JobRequeued) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.SchedulingInfo != nil {
		l = m.SchedulingInfo.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.UpdateSequenceNumber != 0 {
		n += 1 + sovEvents(uint64(m.UpdateSequenceNumber))
	}
	return n
}

func (m *ReprioritiseJobSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Priority != 0 {
		n += 1 + sovEvents(uint64(m.Priority))
	}
	return n
}

func (m *ReprioritisedJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovEvents(uint64(m.Priority))
	}
	return n
}

func (m *CancelJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobSetFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.States) > 0 {
		l = 0
		for _, e := range m.States {
			l += sovEvents(uint64(e))
		}
		n += 1 + sovEvents(uint64(l)) + l
	}
	return n
}

func (m *CancelJobSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.States) > 0 {
		l = 0
		for _, e := range m.States {
			l += sovEvents(uint64(e))
		}
		n += 1 + sovEvents(uint64(l)) + l
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *CancelledJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobSucceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.ResourceInfos) > 0 {
		for _, e := range m.ResourceInfos {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *JobRunLeased) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunId != nil {
		l = m.RunId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ExecutorId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.UpdateSequenceNumber != 0 {
		n += 1 + sovEvents(uint64(m.UpdateSequenceNumber))
	}
	if m.HasScheduledAtPriority {
		n += 2
	}
	if m.ScheduledAtPriority != 0 {
		n += 1 + sovEvents(uint64(m.ScheduledAtPriority))
	}
	if m.PodRequirementsOverlay != nil {
		l = m.PodRequirementsOverlay.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobRunAssigned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunId != nil {
		l = m.RunId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.ResourceInfos) > 0 {
		for _, e := range m.ResourceInfos {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *JobRunRunning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunId != nil {
		l = m.RunId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.ResourceInfos) > 0 {
		for _, e := range m.ResourceInfos {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *KubernetesResourceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Info != nil {
		n += m.Info.Size()
	}
	return n
}

func (m *KubernetesResourceInfo_PodInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodInfo != nil {
		l = m.PodInfo.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *KubernetesResourceInfo_IngressInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IngressInfo != nil {
		l = m.IngressInfo.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *PodInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.PodNumber != 0 {
		n += 1 + sovEvents(uint64(m.PodNumber))
	}
	return n
}

func (m *IngressInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.IngressAddresses) > 0 {
		for k, v := range m.IngressAddresses {
			_ = k
			_ = v
			mapEntrySize := 1 + sovEvents(uint64(k)) + 1 + len(v) + sovEvents(uint64(len(v)))
			n += mapEntrySize + 1 + sovEvents(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *StandaloneIngressInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunId != nil {
		l = m.RunId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.IngressAddresses) > 0 {
		for k, v := range m.IngressAddresses {
			_ = k
			_ = v
			mapEntrySize := 1 + sovEvents(uint64(k)) + 1 + len(v) + sovEvents(uint64(len(v)))
			n += mapEntrySize + 1 + sovEvents(uint64(mapEntrySize))
		}
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.PodNumber != 0 {
		n += 1 + sovEvents(uint64(m.PodNumber))
	}
	l = len(m.PodName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.PodNamespace)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobRunSucceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunId != nil {
		l = m.RunId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.ResourceInfos) > 0 {
		for _, e := range m.ResourceInfos {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *JobErrors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *JobRunErrors) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunId != nil {
		l = m.RunId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Terminal {
		n += 2
	}
	if m.Reason != nil {
		n += m.Reason.Size()
	}
	return n
}

func (m *Error_KubernetesError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KubernetesError != nil {
		l = m.KubernetesError.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *Error_ContainerError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerError != nil {
		l = m.ContainerError.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *Error_ExecutorError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecutorError != nil {
		l = m.ExecutorError.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *Error_PodUnschedulable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodUnschedulable != nil {
		l = m.PodUnschedulable.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *Error_LeaseExpired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeaseExpired != nil {
		l = m.LeaseExpired.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *Error_MaxRunsExceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRunsExceeded != nil {
		l = m.MaxRunsExceeded.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *Error_PodError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodError != nil {
		l = m.PodError.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *Error_PodLeaseReturned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodLeaseReturned != nil {
		l = m.PodLeaseReturned.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *Error_PodTerminated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodTerminated != nil {
		l = m.PodTerminated.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *Error_JobRunPreemptedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobRunPreemptedError != nil {
		l = m.JobRunPreemptedError.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *Error_GangJobUnschedulable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GangJobUnschedulable != nil {
		l = m.GangJobUnschedulable.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *KubernetesError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ResourceId != nil {
		l = m.ResourceId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *PodError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.PodNumber != 0 {
		n += 1 + sovEvents(uint64(m.PodNumber))
	}
	if len(m.ContainerErrors) > 0 {
		for _, e := range m.ContainerErrors {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if m.KubernetesReason != 0 {
		n += 1 + sovEvents(uint64(m.KubernetesReason))
	}
	return n
}

func (m *ContainerError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ExitCode != 0 {
		n += 1 + sovEvents(uint64(m.ExitCode))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.KubernetesReason != 0 {
		n += 1 + sovEvents(uint64(m.KubernetesReason))
	}
	return n
}

func (m *PodLeaseReturned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.PodNumber != 0 {
		n += 1 + sovEvents(uint64(m.PodNumber))
	}
	if m.RunAttempted {
		n += 2
	}
	return n
}

func (m *PodTerminated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.PodNumber != 0 {
		n += 1 + sovEvents(uint64(m.PodNumber))
	}
	return n
}

func (m *ExecutorError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PodUnschedulable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.PodNumber != 0 {
		n += 1 + sovEvents(uint64(m.PodNumber))
	}
	return n
}

func (m *LeaseExpired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MaxRunsExceeded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobRunPreemptedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GangJobUnschedulable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobDuplicateDetected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewJobId != nil {
		l = m.NewJobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.OldJobId != nil {
		l = m.OldJobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *JobRunPreempted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreemptedJobId != nil {
		l = m.PreemptedJobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.PreemptedRunId != nil {
		l = m.PreemptedRunId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.PreemptiveJobId != nil {
		l = m.PreemptiveJobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.PreemptiveRunId != nil {
		l = m.PreemptiveRunId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *PartitionMarker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != nil {
		l = m.GroupId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovEvents(uint64(m.Partition))
	}
	return n
}

func (m *JobRunPreemptionRequested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunId != nil {
		l = m.RunId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.JobId != nil {
		l = m.JobId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventSequence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSequence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSequence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &EventSequence_Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSequence_Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SubmitJob{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_SubmitJob{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReprioritiseJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReprioritiseJob{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_ReprioritiseJob{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReprioritiseJobSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReprioritiseJobSet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_ReprioritiseJobSet{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReprioritisedJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReprioritisedJob{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_ReprioritisedJob{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CancelJob{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_CancelJob{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelJobSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CancelJobSet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_CancelJobSet{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CancelledJob{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_CancelledJob{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSucceeded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobSucceeded{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobSucceeded{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobErrors{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobErrors{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunLeased", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunLeased{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunLeased{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunAssigned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunAssigned{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunAssigned{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunRunning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunRunning{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunRunning{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunSucceeded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunSucceeded{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunSucceeded{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunErrors{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunErrors{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobDuplicateDetected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobDuplicateDetected{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobDuplicateDetected{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandaloneIngressInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StandaloneIngressInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_StandaloneIngressInfo{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUtilisation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ResourceUtilisation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_ResourceUtilisation{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunPreempted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunPreempted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunPreempted{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionMarker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PartitionMarker{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_PartitionMarker{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunPreemptionRequested", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunPreemptionRequested{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRunPreemptionRequested{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRequeued", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRequeued{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &EventSequence_Event_JobRequeued{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceUtilisation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceUtilisation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceUtilisation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunId == nil {
				m.RunId = &Uuid{}
			}
			if err := m.RunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceInfo == nil {
				m.ResourceInfo = &KubernetesResourceInfo{}
			}
			if err := m.ResourceInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResourcesForPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxResourcesForPeriod == nil {
				m.MaxResourcesForPeriod = make(map[string]resource.Quantity)
			}
			var mapkey string
			mapvalue := &resource.Quantity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthEvents
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthEvents
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEvents(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEvents
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MaxResourcesForPeriod[mapkey] = *mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCumulativeUsage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalCumulativeUsage == nil {
				m.TotalCumulativeUsage = make(map[string]resource.Quantity)
			}
			var mapkey string
			mapvalue := &resource.Quantity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthEvents
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthEvents
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEvents(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEvents
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TotalCumulativeUsage[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Uuid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Uuid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Uuid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field High64", wireType)
			}
			m.High64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.High64 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low64", wireType)
			}
			m.Low64 = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Low64 = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeduplicationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeduplicationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MainObject == nil {
				m.MainObject = &KubernetesMainObject{}
			}
			if err := m.MainObject.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objects = append(m.Objects, &KubernetesObject{})
			if err := m.Objects[len(m.Objects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			m.Lifetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lifetime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtMostOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AtMostOnce = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preemptible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Preemptible = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcurrencySafe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConcurrencySafe = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheduler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheduler = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDuplicate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDuplicate = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueTtlSeconds", wireType)
			}
			m.QueueTtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueTtlSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesMainObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesMainObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesMainObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSpecWithAvoidList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Object = &KubernetesMainObject_PodSpec{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSpecWithAvoidList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Object = &KubernetesObject_PodSpec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1.IngressSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Object = &KubernetesObject_Ingress{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v11.ServiceSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Object = &KubernetesObject_Service{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v11.ConfigMap{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Object = &KubernetesObject_ConfigMap{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEvents(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEvents
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEvents(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEvents
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodSpecWithAvoidList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodSpecWithAvoidList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodSpecWithAvoidList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodSpec == nil {
				m.PodSpec = &v11.PodSpec{}
			}
			if err := m.PodSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAvoidlist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAvoidlist = append(m.NodeAvoidlist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReprioritiseJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReprioritiseJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReprioritiseJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRequeued) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRequeued: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRequeued: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchedulingInfo == nil {
				m.SchedulingInfo = &schedulerobjects.JobSchedulingInfo{}
			}
			if err := m.SchedulingInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateSequenceNumber", wireType)
			}
			m.UpdateSequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateSequenceNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReprioritiseJobSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReprioritiseJobSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReprioritiseJobSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReprioritisedJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReprioritisedJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReprioritisedJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSetFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSetFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSetFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v JobState
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= JobState(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.States = append(m.States, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEvents
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthEvents
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.States) == 0 {
					m.States = make([]JobState, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v JobState
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= JobState(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.States = append(m.States, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelJobSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelJobSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelJobSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v JobState
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= JobState(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.States = append(m.States, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEvents
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthEvents
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.States) == 0 {
					m.States = make([]JobState, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v JobState
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= JobState(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.States = append(m.States, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelledJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelledJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelledJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSucceeded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSucceeded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSucceeded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceInfos = append(m.ResourceInfos, &KubernetesResourceInfo{})
			if err := m.ResourceInfos[len(m.ResourceInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunLeased) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunLeased: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunLeased: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunId == nil {
				m.RunId = &Uuid{}
			}
			if err := m.RunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateSequenceNumber", wireType)
			}
			m.UpdateSequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateSequenceNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasScheduledAtPriority", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasScheduledAtPriority = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduledAtPriority", wireType)
			}
			m.ScheduledAtPriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScheduledAtPriority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodRequirementsOverlay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PodRequirementsOverlay == nil {
				m.PodRequirementsOverlay = &schedulerobjects.PodRequirements{}
			}
			if err := m.PodRequirementsOverlay.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunAssigned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunAssigned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunAssigned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunId == nil {
				m.RunId = &Uuid{}
			}
			if err := m.RunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceInfos = append(m.ResourceInfos, &KubernetesResourceInfo{})
			if err := m.ResourceInfos[len(m.ResourceInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunRunning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunRunning: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunRunning: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunId == nil {
				m.RunId = &Uuid{}
			}
			if err := m.RunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceInfos = append(m.ResourceInfos, &KubernetesResourceInfo{})
			if err := m.ResourceInfos[len(m.ResourceInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesResourceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesResourceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesResourceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Info = &KubernetesResourceInfo_PodInfo{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IngressInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Info = &KubernetesResourceInfo_IngressInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNumber", wireType)
			}
			m.PodNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PodNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IngressAddresses == nil {
				m.IngressAddresses = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEvents(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEvents
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.IngressAddresses[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StandaloneIngressInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StandaloneIngressInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StandaloneIngressInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunId == nil {
				m.RunId = &Uuid{}
			}
			if err := m.RunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IngressAddresses == nil {
				m.IngressAddresses = make(map[int32]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEvents
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEvents
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEvents
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEvents(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEvents
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.IngressAddresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNumber", wireType)
			}
			m.PodNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PodNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunSucceeded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunSucceeded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunSucceeded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunId == nil {
				m.RunId = &Uuid{}
			}
			if err := m.RunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceInfos = append(m.ResourceInfos, &KubernetesResourceInfo{})
			if err := m.ResourceInfos[len(m.ResourceInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobErrors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobErrors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobErrors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &Error{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunErrors) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunErrors: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunErrors: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunId == nil {
				m.RunId = &Uuid{}
			}
			if err := m.RunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &Error{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminal = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KubernetesError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_KubernetesError{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ContainerError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_ContainerError{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExecutorError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_ExecutorError{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUnschedulable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodUnschedulable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_PodUnschedulable{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseExpired", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LeaseExpired{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_LeaseExpired{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRunsExceeded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MaxRunsExceeded{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_MaxRunsExceeded{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_PodError{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodLeaseReturned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodLeaseReturned{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_PodLeaseReturned{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodTerminated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodTerminated{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_PodTerminated{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobRunPreemptedError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JobRunPreemptedError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_JobRunPreemptedError{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GangJobUnschedulable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GangJobUnschedulable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reason = &Error_GangJobUnschedulable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceId == nil {
				m.ResourceId = &Uuid{}
			}
			if err := m.ResourceId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNumber", wireType)
			}
			m.PodNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PodNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerErrors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerErrors = append(m.ContainerErrors, &ContainerError{})
			if err := m.ContainerErrors[len(m.ContainerErrors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesReason", wireType)
			}
			m.KubernetesReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KubernetesReason |= KubernetesReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesReason", wireType)
			}
			m.KubernetesReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KubernetesReason |= KubernetesReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodLeaseReturned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodLeaseReturned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodLeaseReturned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNumber", wireType)
			}
			m.PodNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PodNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAttempted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RunAttempted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodTerminated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodTerminated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodTerminated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNumber", wireType)
			}
			m.PodNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PodNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutorError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodUnschedulable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodUnschedulable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodUnschedulable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodNumber", wireType)
			}
			m.PodNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PodNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseExpired) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseExpired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseExpired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxRunsExceeded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxRunsExceeded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxRunsExceeded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunPreemptedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunPreemptedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunPreemptedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GangJobUnschedulable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GangJobUnschedulable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GangJobUnschedulable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobDuplicateDetected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobDuplicateDetected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobDuplicateDetected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewJobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewJobId == nil {
				m.NewJobId = &Uuid{}
			}
			if err := m.NewJobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldJobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldJobId == nil {
				m.OldJobId = &Uuid{}
			}
			if err := m.OldJobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunPreempted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunPreempted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunPreempted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreemptedJobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreemptedJobId == nil {
				m.PreemptedJobId = &Uuid{}
			}
			if err := m.PreemptedJobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreemptedRunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreemptedRunId == nil {
				m.PreemptedRunId = &Uuid{}
			}
			if err := m.PreemptedRunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreemptiveJobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreemptiveJobId == nil {
				m.PreemptiveJobId = &Uuid{}
			}
			if err := m.PreemptiveJobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreemptiveRunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreemptiveRunId == nil {
				m.PreemptiveRunId = &Uuid{}
			}
			if err := m.PreemptiveRunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartitionMarker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartitionMarker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartitionMarker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupId == nil {
				m.GroupId = &Uuid{}
			}
			if err := m.GroupId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Partition |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRunPreemptionRequested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRunPreemptionRequested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRunPreemptionRequested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunId == nil {
				m.RunId = &Uuid{}
			}
			if err := m.RunId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobId == nil {
				m.JobId = &Uuid{}
			}
			if err := m.JobId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
