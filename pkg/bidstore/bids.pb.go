// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/bidstore/bids.proto

package bidstore

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	resource "k8s.io/apimachinery/pkg/api/resource"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PricingPhase represents different phases of the job's lifecycle which have
// different bids.
type PricingPhase int32

const (
	// Default value when phase is not specified
	PricingPhase_PRICING_PHASE_UNSPECIFIED PricingPhase = 0
	// Resource is waiting to be scheduled
	PricingPhase_PRICING_PHASE_QUEUEING PricingPhase = 1
	// Resource has been scheduled and so is running
	PricingPhase_PRICING_PHASE_RUNNING PricingPhase = 2
)

var PricingPhase_name = map[int32]string{
	0: "PRICING_PHASE_UNSPECIFIED",
	1: "PRICING_PHASE_QUEUEING",
	2: "PRICING_PHASE_RUNNING",
}

var PricingPhase_value = map[string]int32{
	"PRICING_PHASE_UNSPECIFIED": 0,
	"PRICING_PHASE_QUEUEING":    1,
	"PRICING_PHASE_RUNNING":     2,
}

func (x PricingPhase) String() string {
	return proto.EnumName(PricingPhase_name, int32(x))
}

func (PricingPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{0}
}

// PriceBand represents different pricing tiers to which users label their jobs
// and set bid prices.
type PriceBand int32

const (
	// Default value when price band is not specified
	PriceBand_PRICE_BAND_UNSPECIFIED PriceBand = 0
	// Standard price bands (not necessarily ordered)
	PriceBand_PRICE_BAND_A PriceBand = 1
	PriceBand_PRICE_BAND_B PriceBand = 2
	PriceBand_PRICE_BAND_C PriceBand = 3
	PriceBand_PRICE_BAND_D PriceBand = 4
	PriceBand_PRICE_BAND_E PriceBand = 5
	PriceBand_PRICE_BAND_F PriceBand = 6
	PriceBand_PRICE_BAND_G PriceBand = 7
	PriceBand_PRICE_BAND_H PriceBand = 8
)

var PriceBand_name = map[int32]string{
	0: "PRICE_BAND_UNSPECIFIED",
	1: "PRICE_BAND_A",
	2: "PRICE_BAND_B",
	3: "PRICE_BAND_C",
	4: "PRICE_BAND_D",
	5: "PRICE_BAND_E",
	6: "PRICE_BAND_F",
	7: "PRICE_BAND_G",
	8: "PRICE_BAND_H",
}

var PriceBand_value = map[string]int32{
	"PRICE_BAND_UNSPECIFIED": 0,
	"PRICE_BAND_A":           1,
	"PRICE_BAND_B":           2,
	"PRICE_BAND_C":           3,
	"PRICE_BAND_D":           4,
	"PRICE_BAND_E":           5,
	"PRICE_BAND_F":           6,
	"PRICE_BAND_G":           7,
	"PRICE_BAND_H":           8,
}

func (x PriceBand) String() string {
	return proto.EnumName(PriceBand_name, int32(x))
}

func (PriceBand) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{1}
}

// Bid represents the bid price for a resouce unit-hour with a timestamp.
type Bid struct {
	// The bid price in beans
	Amount float64 `protobuf:"fixed64,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// Timestamp when this bid was last updated
	LastUpdated *types.Timestamp `protobuf:"bytes,2,opt,name=last_updated,json=lastUpdated,proto3" json:"lastUpdated,omitempty"`
}

func (m *Bid) Reset()         { *m = Bid{} }
func (m *Bid) String() string { return proto.CompactTextString(m) }
func (*Bid) ProtoMessage()    {}
func (*Bid) Descriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{0}
}
func (m *Bid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bid.Merge(m, src)
}
func (m *Bid) XXX_Size() int {
	return m.Size()
}
func (m *Bid) XXX_DiscardUnknown() {
	xxx_messageInfo_Bid.DiscardUnknown(m)
}

var xxx_messageInfo_Bid proto.InternalMessageInfo

func (m *Bid) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Bid) GetLastUpdated() *types.Timestamp {
	if m != nil {
		return m.LastUpdated
	}
	return nil
}

// PricingPhaseBid associates a bid with a specific pricing phase.
type PricingPhaseBid struct {
	// The pricing phase this bid applies to
	PricingPhase PricingPhase `protobuf:"varint,1,opt,name=pricing_phase,json=pricingPhase,proto3,enum=api.PricingPhase" json:"pricingPhase,omitempty"`
	// The bid
	Bid *Bid `protobuf:"bytes,2,opt,name=bid,proto3" json:"bid,omitempty"`
}

func (m *PricingPhaseBid) Reset()         { *m = PricingPhaseBid{} }
func (m *PricingPhaseBid) String() string { return proto.CompactTextString(m) }
func (*PricingPhaseBid) ProtoMessage()    {}
func (*PricingPhaseBid) Descriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{1}
}
func (m *PricingPhaseBid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PricingPhaseBid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PricingPhaseBid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PricingPhaseBid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PricingPhaseBid.Merge(m, src)
}
func (m *PricingPhaseBid) XXX_Size() int {
	return m.Size()
}
func (m *PricingPhaseBid) XXX_DiscardUnknown() {
	xxx_messageInfo_PricingPhaseBid.DiscardUnknown(m)
}

var xxx_messageInfo_PricingPhaseBid proto.InternalMessageInfo

func (m *PricingPhaseBid) GetPricingPhase() PricingPhase {
	if m != nil {
		return m.PricingPhase
	}
	return PricingPhase_PRICING_PHASE_UNSPECIFIED
}

func (m *PricingPhaseBid) GetBid() *Bid {
	if m != nil {
		return m.Bid
	}
	return nil
}

// PriceBandBids contains all a queue's bids for a pool, for different pricing
// phases within a price band.
type PriceBandBids struct {
	// List of bids for different pricing phases - a list instead of a map because
	// we cannot use an enum value as a map key
	PricingPhaseBids []*PricingPhaseBid `protobuf:"bytes,1,rep,name=pricing_phase_bids,json=pricingPhaseBids,proto3" json:"pricingPhaseBids,omitempty"`
}

func (m *PriceBandBids) Reset()         { *m = PriceBandBids{} }
func (m *PriceBandBids) String() string { return proto.CompactTextString(m) }
func (*PriceBandBids) ProtoMessage()    {}
func (*PriceBandBids) Descriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{2}
}
func (m *PriceBandBids) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceBandBids) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceBandBids.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceBandBids) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceBandBids.Merge(m, src)
}
func (m *PriceBandBids) XXX_Size() int {
	return m.Size()
}
func (m *PriceBandBids) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceBandBids.DiscardUnknown(m)
}

var xxx_messageInfo_PriceBandBids proto.InternalMessageInfo

func (m *PriceBandBids) GetPricingPhaseBids() []*PricingPhaseBid {
	if m != nil {
		return m.PricingPhaseBids
	}
	return nil
}

// PriceBandBid associates bids with a specific price band.
type PriceBandBid struct {
	// The price band these bids apply to
	PriceBand PriceBand `protobuf:"varint,1,opt,name=price_band,json=priceBand,proto3,enum=api.PriceBand" json:"priceBand,omitempty"`
	// The bids for this price band
	PriceBandBids *PriceBandBids `protobuf:"bytes,2,opt,name=price_band_bids,json=priceBandBids,proto3" json:"priceBandBids,omitempty"`
}

func (m *PriceBandBid) Reset()         { *m = PriceBandBid{} }
func (m *PriceBandBid) String() string { return proto.CompactTextString(m) }
func (*PriceBandBid) ProtoMessage()    {}
func (*PriceBandBid) Descriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{3}
}
func (m *PriceBandBid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceBandBid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceBandBid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceBandBid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceBandBid.Merge(m, src)
}
func (m *PriceBandBid) XXX_Size() int {
	return m.Size()
}
func (m *PriceBandBid) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceBandBid.DiscardUnknown(m)
}

var xxx_messageInfo_PriceBandBid proto.InternalMessageInfo

func (m *PriceBandBid) GetPriceBand() PriceBand {
	if m != nil {
		return m.PriceBand
	}
	return PriceBand_PRICE_BAND_UNSPECIFIED
}

func (m *PriceBandBid) GetPriceBandBids() *PriceBandBids {
	if m != nil {
		return m.PriceBandBids
	}
	return nil
}

// PoolBids contains all a queue's bids for different price bands within a
// resource pool.
type PoolBids struct {
	// List of bids for different price bands - a list instead of a map because we
	// cannot use an enum value as a map key
	PriceBandBids []*PriceBandBid `protobuf:"bytes,1,rep,name=price_band_bids,json=priceBandBids,proto3" json:"priceBandBids,omitempty"`
	// Fallback bid for the pool for the queue when a job is not labelled with a
	// valid price band
	FallbackBids *PriceBandBids `protobuf:"bytes,2,opt,name=fallback_bids,json=fallbackBids,proto3" json:"fallbackBids,omitempty"`
}

func (m *PoolBids) Reset()         { *m = PoolBids{} }
func (m *PoolBids) String() string { return proto.CompactTextString(m) }
func (*PoolBids) ProtoMessage()    {}
func (*PoolBids) Descriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{4}
}
func (m *PoolBids) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolBids) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolBids.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolBids) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolBids.Merge(m, src)
}
func (m *PoolBids) XXX_Size() int {
	return m.Size()
}
func (m *PoolBids) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolBids.DiscardUnknown(m)
}

var xxx_messageInfo_PoolBids proto.InternalMessageInfo

func (m *PoolBids) GetPriceBandBids() []*PriceBandBid {
	if m != nil {
		return m.PriceBandBids
	}
	return nil
}

func (m *PoolBids) GetFallbackBids() *PriceBandBids {
	if m != nil {
		return m.FallbackBids
	}
	return nil
}

// QueueBids contains all bids for different resource pools within a queue.
type QueueBids struct {
	// Mapping of bids for each resource pool
	PoolBids map[string]*PoolBids `protobuf:"bytes,1,rep,name=pool_bids,json=poolBids,proto3" json:"poolBids,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *QueueBids) Reset()         { *m = QueueBids{} }
func (m *QueueBids) String() string { return proto.CompactTextString(m) }
func (*QueueBids) ProtoMessage()    {}
func (*QueueBids) Descriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{5}
}
func (m *QueueBids) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueBids) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueBids.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueBids) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueBids.Merge(m, src)
}
func (m *QueueBids) XXX_Size() int {
	return m.Size()
}
func (m *QueueBids) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueBids.DiscardUnknown(m)
}

var xxx_messageInfo_QueueBids proto.InternalMessageInfo

func (m *QueueBids) GetPoolBids() map[string]*PoolBids {
	if m != nil {
		return m.PoolBids
	}
	return nil
}

// ResourceShape is a map of Kubernetes resource type to quantity
type ResourceShape struct {
	// Map of resource type (k8s.io.core.v1.ResourceName and "nvidia.com/gpu") to
	// quantity
	Resources map[string]*resource.Quantity `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ResourceShape) Reset()         { *m = ResourceShape{} }
func (m *ResourceShape) String() string { return proto.CompactTextString(m) }
func (*ResourceShape) ProtoMessage()    {}
func (*ResourceShape) Descriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{6}
}
func (m *ResourceShape) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceShape) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceShape.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceShape) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceShape.Merge(m, src)
}
func (m *ResourceShape) XXX_Size() int {
	return m.Size()
}
func (m *ResourceShape) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceShape.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceShape proto.InternalMessageInfo

func (m *ResourceShape) GetResources() map[string]*resource.Quantity {
	if m != nil {
		return m.Resources
	}
	return nil
}

// RetrieveBidsResponse contains the retrieved bids for all requested queues,
// as well as resource unit shapes for each pool.
type RetrieveBidsResponse struct {
	// Map of queue names to their respective bids
	QueueBids map[string]*QueueBids `protobuf:"bytes,1,rep,name=queue_bids,json=queueBids,proto3" json:"queueBids,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Map of pool name to resource unit shape for that pool
	PoolResourceUnits map[string]*ResourceShape `protobuf:"bytes,2,rep,name=pool_resource_units,json=poolResourceUnits,proto3" json:"poolResourceUnits,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RetrieveBidsResponse) Reset()         { *m = RetrieveBidsResponse{} }
func (m *RetrieveBidsResponse) String() string { return proto.CompactTextString(m) }
func (*RetrieveBidsResponse) ProtoMessage()    {}
func (*RetrieveBidsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{7}
}
func (m *RetrieveBidsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetrieveBidsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetrieveBidsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetrieveBidsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetrieveBidsResponse.Merge(m, src)
}
func (m *RetrieveBidsResponse) XXX_Size() int {
	return m.Size()
}
func (m *RetrieveBidsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RetrieveBidsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RetrieveBidsResponse proto.InternalMessageInfo

func (m *RetrieveBidsResponse) GetQueueBids() map[string]*QueueBids {
	if m != nil {
		return m.QueueBids
	}
	return nil
}

func (m *RetrieveBidsResponse) GetPoolResourceUnits() map[string]*ResourceShape {
	if m != nil {
		return m.PoolResourceUnits
	}
	return nil
}

// RetrieveBidsRequest specifies which queues to retrieve bids for.
type RetrieveBidsRequest struct {
	// List of queue names to retrieve bids for
	Queues []string `protobuf:"bytes,1,rep,name=queues,proto3" json:"queues,omitempty"`
}

func (m *RetrieveBidsRequest) Reset()         { *m = RetrieveBidsRequest{} }
func (m *RetrieveBidsRequest) String() string { return proto.CompactTextString(m) }
func (*RetrieveBidsRequest) ProtoMessage()    {}
func (*RetrieveBidsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_67ba02f973552bc2, []int{8}
}
func (m *RetrieveBidsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetrieveBidsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RetrieveBidsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RetrieveBidsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetrieveBidsRequest.Merge(m, src)
}
func (m *RetrieveBidsRequest) XXX_Size() int {
	return m.Size()
}
func (m *RetrieveBidsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RetrieveBidsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RetrieveBidsRequest proto.InternalMessageInfo

func (m *RetrieveBidsRequest) GetQueues() []string {
	if m != nil {
		return m.Queues
	}
	return nil
}

func init() {
	proto.RegisterEnum("api.PricingPhase", PricingPhase_name, PricingPhase_value)
	proto.RegisterEnum("api.PriceBand", PriceBand_name, PriceBand_value)
	proto.RegisterType((*Bid)(nil), "api.Bid")
	proto.RegisterType((*PricingPhaseBid)(nil), "api.PricingPhaseBid")
	proto.RegisterType((*PriceBandBids)(nil), "api.PriceBandBids")
	proto.RegisterType((*PriceBandBid)(nil), "api.PriceBandBid")
	proto.RegisterType((*PoolBids)(nil), "api.PoolBids")
	proto.RegisterType((*QueueBids)(nil), "api.QueueBids")
	proto.RegisterMapType((map[string]*PoolBids)(nil), "api.QueueBids.PoolBidsEntry")
	proto.RegisterType((*ResourceShape)(nil), "api.ResourceShape")
	proto.RegisterMapType((map[string]*resource.Quantity)(nil), "api.ResourceShape.ResourcesEntry")
	proto.RegisterType((*RetrieveBidsResponse)(nil), "api.RetrieveBidsResponse")
	proto.RegisterMapType((map[string]*ResourceShape)(nil), "api.RetrieveBidsResponse.PoolResourceUnitsEntry")
	proto.RegisterMapType((map[string]*QueueBids)(nil), "api.RetrieveBidsResponse.QueueBidsEntry")
	proto.RegisterType((*RetrieveBidsRequest)(nil), "api.RetrieveBidsRequest")
}

func init() { proto.RegisterFile("pkg/bidstore/bids.proto", fileDescriptor_67ba02f973552bc2) }

var fileDescriptor_67ba02f973552bc2 = []byte{
	// 948 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x3d, 0x6f, 0xdb, 0x46,
	0x18, 0xf6, 0x49, 0x4d, 0x6a, 0xbd, 0x96, 0x64, 0xfa, 0xe4, 0xf8, 0x83, 0x69, 0x45, 0x57, 0x05,
	0x0a, 0x23, 0x48, 0xa9, 0xc2, 0xed, 0xe0, 0x16, 0xe8, 0x60, 0xca, 0xb2, 0xa3, 0x45, 0x90, 0xa5,
	0xaa, 0x4d, 0xb3, 0xa8, 0x94, 0x78, 0x91, 0x0f, 0x92, 0xc8, 0x33, 0x3f, 0x0c, 0x68, 0x4b, 0x7f,
	0x40, 0x81, 0x0e, 0xf9, 0x1f, 0x1d, 0xf3, 0x17, 0x3a, 0x06, 0x9d, 0x3a, 0x11, 0x85, 0xbd, 0x71,
	0xef, 0x5e, 0xf0, 0x4e, 0x54, 0x8e, 0x54, 0x02, 0xbb, 0x1b, 0xf9, 0xbc, 0x1f, 0xcf, 0xf3, 0x7e,
	0xf0, 0x8e, 0xb0, 0xcb, 0x26, 0xe3, 0xfa, 0x90, 0x5a, 0x9e, 0xef, 0xb8, 0x84, 0x3f, 0xe8, 0xcc,
	0x75, 0x7c, 0x07, 0xe7, 0x4d, 0x46, 0x55, 0x6d, 0xec, 0x38, 0xe3, 0x29, 0xa9, 0x73, 0x68, 0x18,
	0xbc, 0xac, 0xfb, 0x74, 0x46, 0x3c, 0xdf, 0x9c, 0x31, 0xe1, 0xa5, 0x7e, 0x33, 0x39, 0xf6, 0x74,
	0xea, 0xd4, 0x4d, 0x46, 0x67, 0xe6, 0xe8, 0x92, 0xda, 0xc4, 0x9d, 0xd7, 0xe3, 0x94, 0x26, 0xa3,
	0x75, 0x97, 0x78, 0x4e, 0xe0, 0x8e, 0x48, 0x7d, 0x4c, 0x6c, 0xe2, 0x9a, 0x3e, 0xb1, 0x44, 0x54,
	0xed, 0x37, 0x04, 0x79, 0x83, 0x5a, 0xf8, 0x29, 0x3c, 0x34, 0x67, 0x4e, 0x60, 0xfb, 0x7b, 0xe8,
	0x00, 0x1d, 0x22, 0x63, 0x3b, 0x0a, 0x35, 0x45, 0x20, 0x4f, 0x9d, 0x19, 0xf5, 0xc9, 0x8c, 0xf9,
	0xf3, 0xee, 0xc2, 0x07, 0x3f, 0x87, 0xe2, 0xd4, 0xf4, 0xfc, 0x41, 0xc0, 0xac, 0x38, 0xd7, 0x5e,
	0xee, 0x00, 0x1d, 0x6e, 0x1c, 0xa9, 0xba, 0xd0, 0xa8, 0x27, 0x1a, 0xf5, 0x1f, 0x12, 0x8d, 0xc6,
	0x7e, 0x14, 0x6a, 0x8f, 0xe2, 0x98, 0xbe, 0x08, 0x91, 0x92, 0x6e, 0x48, 0x70, 0xed, 0x35, 0x82,
	0xcd, 0x8e, 0x4b, 0x47, 0xd4, 0x1e, 0x77, 0x2e, 0x4d, 0x8f, 0xc4, 0xda, 0xba, 0x50, 0x62, 0x02,
	0x1a, 0xb0, 0x18, 0xe3, 0x12, 0xcb, 0x47, 0x5b, 0xba, 0xc9, 0xa8, 0x9e, 0x72, 0x56, 0xa3, 0x50,
	0xdb, 0x61, 0x12, 0x22, 0xd1, 0x14, 0x65, 0x1c, 0x7f, 0x09, 0xf9, 0x21, 0x4d, 0x84, 0xaf, 0xf3,
	0x4c, 0x06, 0xb5, 0x8c, 0xad, 0x28, 0xd4, 0x4a, 0x43, 0x2a, 0xcb, 0x8b, 0xfd, 0x6a, 0x1e, 0x94,
	0x62, 0x22, 0x62, 0x98, 0xb6, 0x65, 0x50, 0xcb, 0xc3, 0x43, 0xc0, 0x29, 0x4d, 0x83, 0x78, 0x5e,
	0x7b, 0xe8, 0x20, 0x7f, 0xb8, 0x71, 0xb4, 0xbd, 0x2a, 0x8c, 0x5a, 0x46, 0x35, 0x0a, 0x35, 0x95,
	0xa5, 0x41, 0x4f, 0xe2, 0x51, 0xb2, 0xb6, 0xda, 0x1f, 0x08, 0x8a, 0x32, 0x2b, 0x3e, 0x03, 0x88,
	0x9d, 0xc8, 0x60, 0x68, 0xda, 0xd6, 0xa2, 0x0b, 0xe5, 0x25, 0x99, 0x70, 0xdb, 0x8d, 0x42, 0xad,
	0xc2, 0x92, 0x57, 0x29, 0x7f, 0x61, 0x09, 0xe2, 0x9f, 0x60, 0xf3, 0x5d, 0x1e, 0xa1, 0x5c, 0x34,
	0x02, 0x67, 0x92, 0x51, 0xcb, 0x33, 0x1e, 0x47, 0xa1, 0xb6, 0xcb, 0x64, 0x48, 0x4a, 0x5a, 0x4a,
	0x19, 0x6a, 0x6f, 0x10, 0xac, 0x77, 0x1c, 0x67, 0xca, 0x5b, 0xf4, 0xe3, 0x2a, 0x8b, 0xe8, 0xcf,
	0xd6, 0x0a, 0xcb, 0xff, 0x21, 0xc1, 0x3d, 0x28, 0xbd, 0x34, 0xa7, 0xd3, 0xa1, 0x39, 0x9a, 0xdc,
	0xa5, 0x9d, 0xef, 0x43, 0xe2, 0x9c, 0xc9, 0x5a, 0x94, 0xf1, 0xda, 0x5f, 0x08, 0x0a, 0x17, 0x01,
	0x09, 0x78, 0xe7, 0xf1, 0x05, 0x14, 0x98, 0xe3, 0x4c, 0x65, 0xd1, 0x9f, 0xf0, 0xf4, 0x4b, 0x17,
	0x3d, 0x29, 0xb3, 0x69, 0xfb, 0xee, 0xdc, 0xd8, 0x89, 0x42, 0x0d, 0xb3, 0x05, 0x24, 0x91, 0xac,
	0x27, 0x98, 0xea, 0x42, 0x29, 0x15, 0x82, 0x3f, 0x87, 0xfc, 0x84, 0xcc, 0xf9, 0x14, 0x0b, 0x62,
	0xef, 0x26, 0x64, 0x2e, 0xef, 0xdd, 0x84, 0xcc, 0xf1, 0x31, 0x3c, 0xb8, 0x36, 0xa7, 0x01, 0x59,
	0xd4, 0x58, 0x12, 0x35, 0x2e, 0xf2, 0x18, 0x95, 0x28, 0xd4, 0x36, 0xb9, 0x5d, 0x8a, 0x13, 0x01,
	0xdf, 0xe5, 0x8e, 0x51, 0xed, 0x55, 0x0e, 0x4a, 0xdd, 0xc5, 0x97, 0xdf, 0xbb, 0x34, 0x19, 0xc1,
	0xcf, 0xa1, 0x90, 0x1c, 0x05, 0x49, 0x61, 0x9f, 0xf1, 0x9c, 0x29, 0xb7, 0xe5, 0xdb, 0xa2, 0x3a,
	0xbe, 0x53, 0xcb, 0x38, 0x79, 0xa7, 0x96, 0xa0, 0xfa, 0x1a, 0x41, 0x39, 0x1d, 0x76, 0xbf, 0x0a,
	0x7f, 0x4e, 0x57, 0xa8, 0xeb, 0xe2, 0x18, 0xd3, 0xe5, 0x63, 0x4c, 0x67, 0x93, 0x31, 0x57, 0x99,
	0xd0, 0xe9, 0x17, 0x81, 0x69, 0xfb, 0xd4, 0x9f, 0xdf, 0xd9, 0x82, 0x7f, 0xf3, 0xb0, 0xdd, 0x25,
	0xbe, 0x4b, 0xc9, 0x35, 0x9f, 0x5b, 0x97, 0x78, 0xcc, 0xb1, 0x3d, 0x82, 0x7f, 0x01, 0xb8, 0x8a,
	0x87, 0x29, 0xcf, 0xf8, 0x70, 0xd1, 0x8a, 0x55, 0xf7, 0x77, 0x83, 0x97, 0x3a, 0x72, 0x95, 0x60,
	0x72, 0x47, 0x96, 0x20, 0xfe, 0x15, 0x41, 0x85, 0x6f, 0x51, 0xa2, 0x7a, 0x10, 0xd8, 0xd4, 0x8f,
	0xd7, 0x35, 0xe6, 0xfa, 0xea, 0xc3, 0x5c, 0xf1, 0x7c, 0x93, 0x56, 0xf6, 0xe3, 0x10, 0xc1, 0xa9,
	0x45, 0xa1, 0xf6, 0x98, 0x65, 0x6d, 0x12, 0xf7, 0xd6, 0x8a, 0x51, 0xf5, 0xa1, 0x9c, 0x56, 0x7e,
	0xbf, 0xa1, 0x7c, 0x9b, 0x1e, 0x4a, 0x39, 0xbd, 0xfb, 0x77, 0x35, 0x5d, 0x7d, 0x85, 0x60, 0xe7,
	0xfd, 0x45, 0xdc, 0x8f, 0xfe, 0xfb, 0x34, 0x3d, 0x5e, 0xdd, 0xd0, 0x3b, 0xe7, 0xde, 0x80, 0x4a,
	0xba, 0xb7, 0x57, 0x01, 0xf1, 0xfc, 0xf8, 0x9a, 0xe3, 0x03, 0x12, 0x13, 0x2f, 0x88, 0x6b, 0x4e,
	0x20, 0xf2, 0x35, 0x27, 0x90, 0x27, 0x96, 0x38, 0x7f, 0x97, 0x97, 0xc6, 0xa7, 0xb0, 0xdf, 0xe9,
	0xb6, 0x1a, 0xad, 0xf6, 0xf9, 0xa0, 0xf3, 0xec, 0xa4, 0xd7, 0x1c, 0xf4, 0xdb, 0xbd, 0x4e, 0xb3,
	0xd1, 0x3a, 0x6b, 0x35, 0x4f, 0x95, 0x35, 0xac, 0xc2, 0x4e, 0xda, 0x7c, 0xd1, 0x6f, 0xf6, 0x9b,
	0xad, 0xf6, 0xb9, 0x82, 0xf0, 0x3e, 0x3c, 0x4a, 0xdb, 0xba, 0xfd, 0x76, 0x3b, 0x36, 0xe5, 0x9e,
	0xbc, 0x41, 0x50, 0x58, 0x1e, 0x5b, 0x49, 0x92, 0xe6, 0xc0, 0x38, 0x69, 0x9f, 0x66, 0x08, 0x14,
	0x28, 0x4a, 0xb6, 0x13, 0x05, 0x65, 0x10, 0x43, 0xc9, 0x65, 0x90, 0x86, 0x92, 0xcf, 0x20, 0xa7,
	0xca, 0x47, 0x19, 0xa4, 0xa9, 0x3c, 0xc8, 0x20, 0x67, 0xca, 0xc3, 0x0c, 0x72, 0xae, 0x7c, 0x9c,
	0x41, 0x9e, 0x29, 0xeb, 0x47, 0x2f, 0xa0, 0x62, 0x50, 0x2b, 0xe9, 0xb3, 0xdb, 0x23, 0xee, 0x35,
	0x1d, 0x11, 0xdc, 0x80, 0xa2, 0xdc, 0x7b, 0xbc, 0xf7, 0x9e, 0x55, 0xe7, 0xe3, 0x50, 0xf7, 0x3f,
	0xf8, 0x11, 0x18, 0x5f, 0xfc, 0x79, 0x53, 0x45, 0x6f, 0x6f, 0xaa, 0xe8, 0x9f, 0x9b, 0x2a, 0xfa,
	0xfd, 0xb6, 0xba, 0xf6, 0xf6, 0xb6, 0xba, 0xf6, 0xf7, 0x6d, 0x75, 0xed, 0x45, 0x51, 0xfe, 0x4f,
	0x1a, 0x3e, 0xe4, 0x3f, 0x1b, 0x5f, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0x35, 0x6b, 0xf4, 0x29,
	0x3e, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BidRetrieverServiceClient is the client API for BidRetrieverService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BidRetrieverServiceClient interface {
	// RetrieveBids retrieves the current bids for the specified queues across all
	// relevant resource pools, price bands, and pricing phases.
	RetrieveBids(ctx context.Context, in *RetrieveBidsRequest, opts ...grpc.CallOption) (*RetrieveBidsResponse, error)
}

type bidRetrieverServiceClient struct {
	cc *grpc.ClientConn
}

func NewBidRetrieverServiceClient(cc *grpc.ClientConn) BidRetrieverServiceClient {
	return &bidRetrieverServiceClient{cc}
}

func (c *bidRetrieverServiceClient) RetrieveBids(ctx context.Context, in *RetrieveBidsRequest, opts ...grpc.CallOption) (*RetrieveBidsResponse, error) {
	out := new(RetrieveBidsResponse)
	err := c.cc.Invoke(ctx, "/api.BidRetrieverService/RetrieveBids", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BidRetrieverServiceServer is the server API for BidRetrieverService service.
type BidRetrieverServiceServer interface {
	// RetrieveBids retrieves the current bids for the specified queues across all
	// relevant resource pools, price bands, and pricing phases.
	RetrieveBids(context.Context, *RetrieveBidsRequest) (*RetrieveBidsResponse, error)
}

// UnimplementedBidRetrieverServiceServer can be embedded to have forward compatible implementations.
type UnimplementedBidRetrieverServiceServer struct {
}

func (*UnimplementedBidRetrieverServiceServer) RetrieveBids(ctx context.Context, req *RetrieveBidsRequest) (*RetrieveBidsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrieveBids not implemented")
}

func RegisterBidRetrieverServiceServer(s *grpc.Server, srv BidRetrieverServiceServer) {
	s.RegisterService(&_BidRetrieverService_serviceDesc, srv)
}

func _BidRetrieverService_RetrieveBids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetrieveBidsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BidRetrieverServiceServer).RetrieveBids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BidRetrieverService/RetrieveBids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BidRetrieverServiceServer).RetrieveBids(ctx, req.(*RetrieveBidsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BidRetrieverService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.BidRetrieverService",
	HandlerType: (*BidRetrieverServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RetrieveBids",
			Handler:    _BidRetrieverService_RetrieveBids_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pkg/bidstore/bids.proto",
}

func (m *Bid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUpdated != nil {
		{
			size, err := m.LastUpdated.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBids(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Amount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *PricingPhaseBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PricingPhaseBid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PricingPhaseBid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bid != nil {
		{
			size, err := m.Bid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBids(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PricingPhase != 0 {
		i = encodeVarintBids(dAtA, i, uint64(m.PricingPhase))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PriceBandBids) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceBandBids) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceBandBids) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PricingPhaseBids) > 0 {
		for iNdEx := len(m.PricingPhaseBids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PricingPhaseBids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBids(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PriceBandBid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceBandBid) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceBandBid) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PriceBandBids != nil {
		{
			size, err := m.PriceBandBids.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBids(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PriceBand != 0 {
		i = encodeVarintBids(dAtA, i, uint64(m.PriceBand))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PoolBids) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolBids) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolBids) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FallbackBids != nil {
		{
			size, err := m.FallbackBids.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBids(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.PriceBandBids) > 0 {
		for iNdEx := len(m.PriceBandBids) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PriceBandBids[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBids(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueueBids) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueBids) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueBids) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolBids) > 0 {
		for k := range m.PoolBids {
			v := m.PoolBids[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBids(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBids(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBids(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResourceShape) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceShape) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceShape) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for k := range m.Resources {
			v := m.Resources[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBids(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBids(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBids(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RetrieveBidsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetrieveBidsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetrieveBidsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolResourceUnits) > 0 {
		for k := range m.PoolResourceUnits {
			v := m.PoolResourceUnits[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBids(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBids(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBids(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.QueueBids) > 0 {
		for k := range m.QueueBids {
			v := m.QueueBids[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBids(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBids(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBids(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RetrieveBidsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetrieveBidsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetrieveBidsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Queues) > 0 {
		for iNdEx := len(m.Queues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Queues[iNdEx])
			copy(dAtA[i:], m.Queues[iNdEx])
			i = encodeVarintBids(dAtA, i, uint64(len(m.Queues[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBids(dAtA []byte, offset int, v uint64) int {
	offset -= sovBids(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Bid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != 0 {
		n += 9
	}
	if m.LastUpdated != nil {
		l = m.LastUpdated.Size()
		n += 1 + l + sovBids(uint64(l))
	}
	return n
}

func (m *PricingPhaseBid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PricingPhase != 0 {
		n += 1 + sovBids(uint64(m.PricingPhase))
	}
	if m.Bid != nil {
		l = m.Bid.Size()
		n += 1 + l + sovBids(uint64(l))
	}
	return n
}

func (m *PriceBandBids) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PricingPhaseBids) > 0 {
		for _, e := range m.PricingPhaseBids {
			l = e.Size()
			n += 1 + l + sovBids(uint64(l))
		}
	}
	return n
}

func (m *PriceBandBid) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PriceBand != 0 {
		n += 1 + sovBids(uint64(m.PriceBand))
	}
	if m.PriceBandBids != nil {
		l = m.PriceBandBids.Size()
		n += 1 + l + sovBids(uint64(l))
	}
	return n
}

func (m *PoolBids) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PriceBandBids) > 0 {
		for _, e := range m.PriceBandBids {
			l = e.Size()
			n += 1 + l + sovBids(uint64(l))
		}
	}
	if m.FallbackBids != nil {
		l = m.FallbackBids.Size()
		n += 1 + l + sovBids(uint64(l))
	}
	return n
}

func (m *QueueBids) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PoolBids) > 0 {
		for k, v := range m.PoolBids {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBids(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBids(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBids(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ResourceShape) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for k, v := range m.Resources {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBids(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBids(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBids(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RetrieveBidsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.QueueBids) > 0 {
		for k, v := range m.QueueBids {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBids(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBids(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBids(uint64(mapEntrySize))
		}
	}
	if len(m.PoolResourceUnits) > 0 {
		for k, v := range m.PoolResourceUnits {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBids(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBids(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBids(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RetrieveBidsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Queues) > 0 {
		for _, s := range m.Queues {
			l = len(s)
			n += 1 + l + sovBids(uint64(l))
		}
	}
	return n
}

func sovBids(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBids(x uint64) (n int) {
	return sovBids(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Bid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBids
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdated == nil {
				m.LastUpdated = &types.Timestamp{}
			}
			if err := m.LastUpdated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBids(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBids
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PricingPhaseBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBids
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PricingPhaseBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PricingPhaseBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingPhase", wireType)
			}
			m.PricingPhase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PricingPhase |= PricingPhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bid == nil {
				m.Bid = &Bid{}
			}
			if err := m.Bid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBids(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBids
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceBandBids) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBids
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceBandBids: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceBandBids: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingPhaseBids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricingPhaseBids = append(m.PricingPhaseBids, &PricingPhaseBid{})
			if err := m.PricingPhaseBids[len(m.PricingPhaseBids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBids(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBids
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceBandBid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBids
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceBandBid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceBandBid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceBand", wireType)
			}
			m.PriceBand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceBand |= PriceBand(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceBandBids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PriceBandBids == nil {
				m.PriceBandBids = &PriceBandBids{}
			}
			if err := m.PriceBandBids.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBids(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBids
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolBids) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBids
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolBids: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolBids: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceBandBids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceBandBids = append(m.PriceBandBids, &PriceBandBid{})
			if err := m.PriceBandBids[len(m.PriceBandBids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackBids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FallbackBids == nil {
				m.FallbackBids = &PriceBandBids{}
			}
			if err := m.FallbackBids.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBids(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBids
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueBids) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBids
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueBids: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueBids: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolBids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoolBids == nil {
				m.PoolBids = make(map[string]*PoolBids)
			}
			var mapkey string
			var mapvalue *PoolBids
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBids
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBids
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBids
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBids
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBids
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBids
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBids
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PoolBids{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBids(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBids
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PoolBids[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBids(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBids
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceShape) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBids
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceShape: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceShape: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = make(map[string]*resource.Quantity)
			}
			var mapkey string
			var mapvalue *resource.Quantity
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBids
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBids
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBids
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBids
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBids
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBids
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBids
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBids(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBids
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Resources[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBids(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBids
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetrieveBidsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBids
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetrieveBidsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetrieveBidsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueBids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueueBids == nil {
				m.QueueBids = make(map[string]*QueueBids)
			}
			var mapkey string
			var mapvalue *QueueBids
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBids
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBids
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBids
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBids
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBids
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBids
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBids
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &QueueBids{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBids(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBids
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.QueueBids[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolResourceUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoolResourceUnits == nil {
				m.PoolResourceUnits = make(map[string]*ResourceShape)
			}
			var mapkey string
			var mapvalue *ResourceShape
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBids
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBids
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBids
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBids
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBids
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBids
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBids
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ResourceShape{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBids(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBids
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PoolResourceUnits[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBids(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBids
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetrieveBidsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBids
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetrieveBidsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetrieveBidsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBids
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBids
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBids
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queues = append(m.Queues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBids(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBids
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBids(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBids
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBids
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBids
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBids
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBids
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBids
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBids        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBids          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBids = fmt.Errorf("proto: unexpected end of group")
)
