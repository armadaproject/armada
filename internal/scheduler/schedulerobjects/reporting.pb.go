// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal/scheduler/schedulerobjects/reporting.proto

package schedulerobjects

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MostRecentForQueue struct {
	QueueName string `protobuf:"bytes,1,opt,name=queue_name,json=queueName,proto3" json:"queueName,omitempty"`
}

func (m *MostRecentForQueue) Reset()         { *m = MostRecentForQueue{} }
func (m *MostRecentForQueue) String() string { return proto.CompactTextString(m) }
func (*MostRecentForQueue) ProtoMessage()    {}
func (*MostRecentForQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_131a439a3ff6540b, []int{0}
}
func (m *MostRecentForQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MostRecentForQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MostRecentForQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MostRecentForQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MostRecentForQueue.Merge(m, src)
}
func (m *MostRecentForQueue) XXX_Size() int {
	return m.Size()
}
func (m *MostRecentForQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_MostRecentForQueue.DiscardUnknown(m)
}

var xxx_messageInfo_MostRecentForQueue proto.InternalMessageInfo

func (m *MostRecentForQueue) GetQueueName() string {
	if m != nil {
		return m.QueueName
	}
	return ""
}

type MostRecentForJob struct {
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
}

func (m *MostRecentForJob) Reset()         { *m = MostRecentForJob{} }
func (m *MostRecentForJob) String() string { return proto.CompactTextString(m) }
func (*MostRecentForJob) ProtoMessage()    {}
func (*MostRecentForJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_131a439a3ff6540b, []int{1}
}
func (m *MostRecentForJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MostRecentForJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MostRecentForJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MostRecentForJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MostRecentForJob.Merge(m, src)
}
func (m *MostRecentForJob) XXX_Size() int {
	return m.Size()
}
func (m *MostRecentForJob) XXX_DiscardUnknown() {
	xxx_messageInfo_MostRecentForJob.DiscardUnknown(m)
}

var xxx_messageInfo_MostRecentForJob proto.InternalMessageInfo

func (m *MostRecentForJob) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

type SchedulingReportRequest struct {
	// Types that are valid to be assigned to Filter:
	//
	//	*SchedulingReportRequest_MostRecentForQueue
	//	*SchedulingReportRequest_MostRecentForJob
	Filter    isSchedulingReportRequest_Filter `protobuf_oneof:"filter"`
	Verbosity int32                            `protobuf:"varint,3,opt,name=verbosity,proto3" json:"verbosity,omitempty"`
}

func (m *SchedulingReportRequest) Reset()         { *m = SchedulingReportRequest{} }
func (m *SchedulingReportRequest) String() string { return proto.CompactTextString(m) }
func (*SchedulingReportRequest) ProtoMessage()    {}
func (*SchedulingReportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_131a439a3ff6540b, []int{2}
}
func (m *SchedulingReportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulingReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulingReportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulingReportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulingReportRequest.Merge(m, src)
}
func (m *SchedulingReportRequest) XXX_Size() int {
	return m.Size()
}
func (m *SchedulingReportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulingReportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulingReportRequest proto.InternalMessageInfo

type isSchedulingReportRequest_Filter interface {
	isSchedulingReportRequest_Filter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SchedulingReportRequest_MostRecentForQueue struct {
	MostRecentForQueue *MostRecentForQueue `protobuf:"bytes,1,opt,name=most_recent_for_queue,json=mostRecentForQueue,proto3,oneof" json:"mostRecentForQueue,omitempty"`
}
type SchedulingReportRequest_MostRecentForJob struct {
	MostRecentForJob *MostRecentForJob `protobuf:"bytes,2,opt,name=most_recent_for_job,json=mostRecentForJob,proto3,oneof" json:"mostRecentForJob,omitempty"`
}

func (*SchedulingReportRequest_MostRecentForQueue) isSchedulingReportRequest_Filter() {}
func (*SchedulingReportRequest_MostRecentForJob) isSchedulingReportRequest_Filter()   {}

func (m *SchedulingReportRequest) GetFilter() isSchedulingReportRequest_Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *SchedulingReportRequest) GetMostRecentForQueue() *MostRecentForQueue {
	if x, ok := m.GetFilter().(*SchedulingReportRequest_MostRecentForQueue); ok {
		return x.MostRecentForQueue
	}
	return nil
}

func (m *SchedulingReportRequest) GetMostRecentForJob() *MostRecentForJob {
	if x, ok := m.GetFilter().(*SchedulingReportRequest_MostRecentForJob); ok {
		return x.MostRecentForJob
	}
	return nil
}

func (m *SchedulingReportRequest) GetVerbosity() int32 {
	if m != nil {
		return m.Verbosity
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SchedulingReportRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SchedulingReportRequest_MostRecentForQueue)(nil),
		(*SchedulingReportRequest_MostRecentForJob)(nil),
	}
}

type SchedulingReport struct {
	Report string `protobuf:"bytes,1,opt,name=report,proto3" json:"report,omitempty"`
}

func (m *SchedulingReport) Reset()         { *m = SchedulingReport{} }
func (m *SchedulingReport) String() string { return proto.CompactTextString(m) }
func (*SchedulingReport) ProtoMessage()    {}
func (*SchedulingReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_131a439a3ff6540b, []int{3}
}
func (m *SchedulingReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulingReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulingReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulingReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulingReport.Merge(m, src)
}
func (m *SchedulingReport) XXX_Size() int {
	return m.Size()
}
func (m *SchedulingReport) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulingReport.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulingReport proto.InternalMessageInfo

func (m *SchedulingReport) GetReport() string {
	if m != nil {
		return m.Report
	}
	return ""
}

type QueueReportRequest struct {
	QueueName string `protobuf:"bytes,1,opt,name=queue_name,json=queueName,proto3" json:"queueName,omitempty"`
	Verbosity int32  `protobuf:"varint,2,opt,name=verbosity,proto3" json:"verbosity,omitempty"`
}

func (m *QueueReportRequest) Reset()         { *m = QueueReportRequest{} }
func (m *QueueReportRequest) String() string { return proto.CompactTextString(m) }
func (*QueueReportRequest) ProtoMessage()    {}
func (*QueueReportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_131a439a3ff6540b, []int{4}
}
func (m *QueueReportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueReportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueReportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueReportRequest.Merge(m, src)
}
func (m *QueueReportRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueueReportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueReportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueueReportRequest proto.InternalMessageInfo

func (m *QueueReportRequest) GetQueueName() string {
	if m != nil {
		return m.QueueName
	}
	return ""
}

func (m *QueueReportRequest) GetVerbosity() int32 {
	if m != nil {
		return m.Verbosity
	}
	return 0
}

type QueueReport struct {
	Report string `protobuf:"bytes,1,opt,name=report,proto3" json:"report,omitempty"`
}

func (m *QueueReport) Reset()         { *m = QueueReport{} }
func (m *QueueReport) String() string { return proto.CompactTextString(m) }
func (*QueueReport) ProtoMessage()    {}
func (*QueueReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_131a439a3ff6540b, []int{5}
}
func (m *QueueReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueReport.Merge(m, src)
}
func (m *QueueReport) XXX_Size() int {
	return m.Size()
}
func (m *QueueReport) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueReport.DiscardUnknown(m)
}

var xxx_messageInfo_QueueReport proto.InternalMessageInfo

func (m *QueueReport) GetReport() string {
	if m != nil {
		return m.Report
	}
	return ""
}

type JobReportRequest struct {
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"jobId,omitempty"`
}

func (m *JobReportRequest) Reset()         { *m = JobReportRequest{} }
func (m *JobReportRequest) String() string { return proto.CompactTextString(m) }
func (*JobReportRequest) ProtoMessage()    {}
func (*JobReportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_131a439a3ff6540b, []int{6}
}
func (m *JobReportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobReportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobReportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobReportRequest.Merge(m, src)
}
func (m *JobReportRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobReportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobReportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobReportRequest proto.InternalMessageInfo

func (m *JobReportRequest) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

type JobReport struct {
	Report string `protobuf:"bytes,1,opt,name=report,proto3" json:"report,omitempty"`
}

func (m *JobReport) Reset()         { *m = JobReport{} }
func (m *JobReport) String() string { return proto.CompactTextString(m) }
func (*JobReport) ProtoMessage()    {}
func (*JobReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_131a439a3ff6540b, []int{7}
}
func (m *JobReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobReport.Merge(m, src)
}
func (m *JobReport) XXX_Size() int {
	return m.Size()
}
func (m *JobReport) XXX_DiscardUnknown() {
	xxx_messageInfo_JobReport.DiscardUnknown(m)
}

var xxx_messageInfo_JobReport proto.InternalMessageInfo

func (m *JobReport) GetReport() string {
	if m != nil {
		return m.Report
	}
	return ""
}

func init() {
	proto.RegisterType((*MostRecentForQueue)(nil), "schedulerobjects.MostRecentForQueue")
	proto.RegisterType((*MostRecentForJob)(nil), "schedulerobjects.MostRecentForJob")
	proto.RegisterType((*SchedulingReportRequest)(nil), "schedulerobjects.SchedulingReportRequest")
	proto.RegisterType((*SchedulingReport)(nil), "schedulerobjects.SchedulingReport")
	proto.RegisterType((*QueueReportRequest)(nil), "schedulerobjects.QueueReportRequest")
	proto.RegisterType((*QueueReport)(nil), "schedulerobjects.QueueReport")
	proto.RegisterType((*JobReportRequest)(nil), "schedulerobjects.JobReportRequest")
	proto.RegisterType((*JobReport)(nil), "schedulerobjects.JobReport")
}

func init() {
	proto.RegisterFile("internal/scheduler/schedulerobjects/reporting.proto", fileDescriptor_131a439a3ff6540b)
}

var fileDescriptor_131a439a3ff6540b = []byte{
	// 529 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcf, 0x6a, 0x13, 0x5f,
	0x14, 0xce, 0xe4, 0x47, 0xc3, 0x2f, 0xa7, 0xa2, 0xc3, 0x8d, 0xd2, 0x90, 0xea, 0x24, 0x0c, 0x2e,
	0xaa, 0x94, 0x0c, 0xb4, 0x28, 0x88, 0x50, 0x24, 0x82, 0xd1, 0xe0, 0x1f, 0x9c, 0xe2, 0x46, 0x90,
	0x30, 0x37, 0x39, 0x49, 0x27, 0x64, 0xe6, 0xa4, 0x77, 0xee, 0x08, 0xc5, 0xa5, 0x2f, 0xe0, 0x33,
	0xf8, 0x34, 0x2e, 0x5c, 0x74, 0xe9, 0x2a, 0x48, 0xb2, 0x9b, 0xa7, 0x90, 0xde, 0x49, 0x93, 0xf9,
	0x53, 0xdb, 0xc6, 0xdd, 0xcc, 0x77, 0xcf, 0xfd, 0xce, 0xf9, 0xce, 0x77, 0xce, 0x85, 0x7d, 0xd7,
	0x97, 0x28, 0x7c, 0x67, 0x6c, 0x05, 0xbd, 0x23, 0xec, 0x87, 0x63, 0x14, 0xab, 0x2f, 0xe2, 0x23,
	0xec, 0xc9, 0xc0, 0x12, 0x38, 0x21, 0x21, 0x5d, 0x7f, 0xd8, 0x9c, 0x08, 0x92, 0xc4, 0xf4, 0x6c,
	0x44, 0x6d, 0x7b, 0x48, 0x34, 0x1c, 0xa3, 0xa5, 0xce, 0x79, 0x38, 0xb0, 0xd0, 0x9b, 0xc8, 0x93,
	0x38, 0xdc, 0x7c, 0x0d, 0xec, 0x0d, 0x05, 0xd2, 0xc6, 0x1e, 0xfa, 0xf2, 0x05, 0x89, 0xf7, 0x21,
	0x86, 0xc8, 0x1e, 0x03, 0x1c, 0x9f, 0x7d, 0x74, 0x7d, 0xc7, 0xc3, 0xaa, 0xd6, 0xd0, 0x76, 0xca,
	0xad, 0xad, 0x68, 0x5a, 0xaf, 0x28, 0xf4, 0xad, 0xe3, 0xe1, 0x2e, 0x79, 0xae, 0x54, 0x44, 0x76,
	0x79, 0x09, 0x9a, 0x07, 0xa0, 0xa7, 0xd8, 0x3a, 0xc4, 0xd9, 0x43, 0x28, 0x8d, 0x88, 0x77, 0xdd,
	0xfe, 0x82, 0xa7, 0x12, 0x4d, 0xeb, 0xb7, 0x46, 0xc4, 0x5f, 0xf5, 0x13, 0x1c, 0x1b, 0x0a, 0x30,
	0x7f, 0x16, 0x61, 0xeb, 0x30, 0xae, 0xdf, 0xf5, 0x87, 0xb6, 0x92, 0x66, 0xe3, 0x71, 0x88, 0x81,
	0x64, 0x5f, 0xe0, 0x8e, 0x47, 0x81, 0xec, 0x0a, 0x45, 0xde, 0x1d, 0x90, 0xe8, 0xaa, 0xc4, 0x8a,
	0x76, 0x73, 0xef, 0x7e, 0x33, 0x2b, 0xbc, 0x99, 0x17, 0xd6, 0x6a, 0x44, 0xd3, 0xfa, 0x5d, 0x2f,
	0x87, 0xaf, 0x2a, 0x79, 0x59, 0xb0, 0x59, 0xfe, 0x9c, 0x05, 0x50, 0xc9, 0x26, 0x1f, 0x11, 0xaf,
	0x16, 0x55, 0x6a, 0xf3, 0x8a, 0xd4, 0x1d, 0xe2, 0x2d, 0x23, 0x9a, 0xd6, 0x6b, 0x5e, 0x06, 0x4d,
	0xa5, 0xd5, 0xb3, 0xa7, 0xec, 0x11, 0x94, 0x3f, 0xa3, 0xe0, 0x14, 0xb8, 0xf2, 0xa4, 0xfa, 0x5f,
	0x43, 0xdb, 0xd9, 0x88, 0x4d, 0x58, 0x82, 0x49, 0x13, 0x96, 0x60, 0xeb, 0x7f, 0x28, 0x0d, 0xdc,
	0xb1, 0x44, 0x61, 0x3e, 0x03, 0x3d, 0xdb, 0x4d, 0xb6, 0x0b, 0xa5, 0x78, 0x64, 0x16, 0x76, 0xdc,
	0x8e, 0xa6, 0x75, 0x3d, 0x46, 0x12, 0x74, 0x8b, 0x18, 0xf3, 0xab, 0x06, 0x4c, 0x75, 0x20, 0xed,
	0xc5, 0x3f, 0xce, 0x47, 0x5a, 0x51, 0xf1, 0xba, 0x8a, 0xcc, 0xa7, 0xb0, 0x99, 0x28, 0x62, 0x4d,
	0x09, 0x07, 0xa0, 0x77, 0x88, 0xa7, 0xeb, 0x5f, 0x67, 0x26, 0x9f, 0x40, 0x79, 0x79, 0x7f, 0xbd,
	0xd4, 0x7b, 0xdf, 0x8b, 0xc0, 0x0e, 0xcf, 0x47, 0xc3, 0x3e, 0x5f, 0x54, 0xd6, 0x87, 0x4a, 0x1b,
	0x65, 0xce, 0x99, 0x07, 0xf9, 0x31, 0xfa, 0xcb, 0x2e, 0xd4, 0xcc, 0xab, 0x43, 0xd9, 0x07, 0xb8,
	0xd9, 0x46, 0x99, 0xec, 0xdb, 0x05, 0x2b, 0x92, 0xf7, 0xb6, 0x76, 0xef, 0xd2, 0x28, 0xf6, 0x0e,
	0x6e, 0xb4, 0x51, 0xae, 0x3a, 0x72, 0x41, 0x29, 0xd9, 0x76, 0xd7, 0xb6, 0x2f, 0x89, 0x69, 0x7d,
	0xfa, 0x31, 0x33, 0xb4, 0xd3, 0x99, 0xa1, 0xfd, 0x9e, 0x19, 0xda, 0xb7, 0xb9, 0x51, 0x38, 0x9d,
	0x1b, 0x85, 0x5f, 0x73, 0xa3, 0xf0, 0xf1, 0xf9, 0xd0, 0x95, 0x47, 0x21, 0x6f, 0xf6, 0xc8, 0xb3,
	0x1c, 0xe1, 0x39, 0x7d, 0x67, 0x22, 0xe8, 0xec, 0xfa, 0xe2, 0xcf, 0xba, 0xc6, 0xfb, 0xc8, 0x4b,
	0xea, 0x9d, 0xdb, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0xf1, 0xb4, 0x16, 0xb6, 0x4d, 0x05, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SchedulerReportingClient is the client API for SchedulerReporting service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SchedulerReportingClient interface {
	// Return the most recent scheduling report for each executor.
	GetSchedulingReport(ctx context.Context, in *SchedulingReportRequest, opts ...grpc.CallOption) (*SchedulingReport, error)
	// Return the most recent report scheduling for each executor for the given queue.
	GetQueueReport(ctx context.Context, in *QueueReportRequest, opts ...grpc.CallOption) (*QueueReport, error)
	// Return the most recent scheduling report for each executor for the given job.
	GetJobReport(ctx context.Context, in *JobReportRequest, opts ...grpc.CallOption) (*JobReport, error)
}

type schedulerReportingClient struct {
	cc *grpc.ClientConn
}

func NewSchedulerReportingClient(cc *grpc.ClientConn) SchedulerReportingClient {
	return &schedulerReportingClient{cc}
}

func (c *schedulerReportingClient) GetSchedulingReport(ctx context.Context, in *SchedulingReportRequest, opts ...grpc.CallOption) (*SchedulingReport, error) {
	out := new(SchedulingReport)
	err := c.cc.Invoke(ctx, "/schedulerobjects.SchedulerReporting/GetSchedulingReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerReportingClient) GetQueueReport(ctx context.Context, in *QueueReportRequest, opts ...grpc.CallOption) (*QueueReport, error) {
	out := new(QueueReport)
	err := c.cc.Invoke(ctx, "/schedulerobjects.SchedulerReporting/GetQueueReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerReportingClient) GetJobReport(ctx context.Context, in *JobReportRequest, opts ...grpc.CallOption) (*JobReport, error) {
	out := new(JobReport)
	err := c.cc.Invoke(ctx, "/schedulerobjects.SchedulerReporting/GetJobReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchedulerReportingServer is the server API for SchedulerReporting service.
type SchedulerReportingServer interface {
	// Return the most recent scheduling report for each executor.
	GetSchedulingReport(context.Context, *SchedulingReportRequest) (*SchedulingReport, error)
	// Return the most recent report scheduling for each executor for the given queue.
	GetQueueReport(context.Context, *QueueReportRequest) (*QueueReport, error)
	// Return the most recent scheduling report for each executor for the given job.
	GetJobReport(context.Context, *JobReportRequest) (*JobReport, error)
}

// UnimplementedSchedulerReportingServer can be embedded to have forward compatible implementations.
type UnimplementedSchedulerReportingServer struct {
}

func (*UnimplementedSchedulerReportingServer) GetSchedulingReport(ctx context.Context, req *SchedulingReportRequest) (*SchedulingReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSchedulingReport not implemented")
}
func (*UnimplementedSchedulerReportingServer) GetQueueReport(ctx context.Context, req *QueueReportRequest) (*QueueReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueueReport not implemented")
}
func (*UnimplementedSchedulerReportingServer) GetJobReport(ctx context.Context, req *JobReportRequest) (*JobReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobReport not implemented")
}

func RegisterSchedulerReportingServer(s *grpc.Server, srv SchedulerReportingServer) {
	s.RegisterService(&_SchedulerReporting_serviceDesc, srv)
}

func _SchedulerReporting_GetSchedulingReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SchedulingReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerReportingServer).GetSchedulingReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schedulerobjects.SchedulerReporting/GetSchedulingReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerReportingServer).GetSchedulingReport(ctx, req.(*SchedulingReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerReporting_GetQueueReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerReportingServer).GetQueueReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schedulerobjects.SchedulerReporting/GetQueueReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerReportingServer).GetQueueReport(ctx, req.(*QueueReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchedulerReporting_GetJobReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerReportingServer).GetJobReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/schedulerobjects.SchedulerReporting/GetJobReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerReportingServer).GetJobReport(ctx, req.(*JobReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SchedulerReporting_serviceDesc = grpc.ServiceDesc{
	ServiceName: "schedulerobjects.SchedulerReporting",
	HandlerType: (*SchedulerReportingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSchedulingReport",
			Handler:    _SchedulerReporting_GetSchedulingReport_Handler,
		},
		{
			MethodName: "GetQueueReport",
			Handler:    _SchedulerReporting_GetQueueReport_Handler,
		},
		{
			MethodName: "GetJobReport",
			Handler:    _SchedulerReporting_GetJobReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/scheduler/schedulerobjects/reporting.proto",
}

func (m *MostRecentForQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MostRecentForQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MostRecentForQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueueName) > 0 {
		i -= len(m.QueueName)
		copy(dAtA[i:], m.QueueName)
		i = encodeVarintReporting(dAtA, i, uint64(len(m.QueueName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MostRecentForJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MostRecentForJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MostRecentForJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintReporting(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchedulingReportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulingReportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulingReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Verbosity != 0 {
		i = encodeVarintReporting(dAtA, i, uint64(m.Verbosity))
		i--
		dAtA[i] = 0x18
	}
	if m.Filter != nil {
		{
			size := m.Filter.Size()
			i -= size
			if _, err := m.Filter.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SchedulingReportRequest_MostRecentForQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulingReportRequest_MostRecentForQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MostRecentForQueue != nil {
		{
			size, err := m.MostRecentForQueue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReporting(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SchedulingReportRequest_MostRecentForJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulingReportRequest_MostRecentForJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MostRecentForJob != nil {
		{
			size, err := m.MostRecentForJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintReporting(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SchedulingReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulingReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulingReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Report) > 0 {
		i -= len(m.Report)
		copy(dAtA[i:], m.Report)
		i = encodeVarintReporting(dAtA, i, uint64(len(m.Report)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueueReportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueReportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Verbosity != 0 {
		i = encodeVarintReporting(dAtA, i, uint64(m.Verbosity))
		i--
		dAtA[i] = 0x10
	}
	if len(m.QueueName) > 0 {
		i -= len(m.QueueName)
		copy(dAtA[i:], m.QueueName)
		i = encodeVarintReporting(dAtA, i, uint64(len(m.QueueName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueueReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Report) > 0 {
		i -= len(m.Report)
		copy(dAtA[i:], m.Report)
		i = encodeVarintReporting(dAtA, i, uint64(len(m.Report)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobReportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobReportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintReporting(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Report) > 0 {
		i -= len(m.Report)
		copy(dAtA[i:], m.Report)
		i = encodeVarintReporting(dAtA, i, uint64(len(m.Report)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintReporting(dAtA []byte, offset int, v uint64) int {
	offset -= sovReporting(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MostRecentForQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.QueueName)
	if l > 0 {
		n += 1 + l + sovReporting(uint64(l))
	}
	return n
}

func (m *MostRecentForJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovReporting(uint64(l))
	}
	return n
}

func (m *SchedulingReportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		n += m.Filter.Size()
	}
	if m.Verbosity != 0 {
		n += 1 + sovReporting(uint64(m.Verbosity))
	}
	return n
}

func (m *SchedulingReportRequest_MostRecentForQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MostRecentForQueue != nil {
		l = m.MostRecentForQueue.Size()
		n += 1 + l + sovReporting(uint64(l))
	}
	return n
}
func (m *SchedulingReportRequest_MostRecentForJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MostRecentForJob != nil {
		l = m.MostRecentForJob.Size()
		n += 1 + l + sovReporting(uint64(l))
	}
	return n
}
func (m *SchedulingReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Report)
	if l > 0 {
		n += 1 + l + sovReporting(uint64(l))
	}
	return n
}

func (m *QueueReportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.QueueName)
	if l > 0 {
		n += 1 + l + sovReporting(uint64(l))
	}
	if m.Verbosity != 0 {
		n += 1 + sovReporting(uint64(m.Verbosity))
	}
	return n
}

func (m *QueueReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Report)
	if l > 0 {
		n += 1 + l + sovReporting(uint64(l))
	}
	return n
}

func (m *JobReportRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovReporting(uint64(l))
	}
	return n
}

func (m *JobReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Report)
	if l > 0 {
		n += 1 + l + sovReporting(uint64(l))
	}
	return n
}

func sovReporting(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozReporting(x uint64) (n int) {
	return sovReporting(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MostRecentForQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReporting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MostRecentForQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MostRecentForQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReporting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReporting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReporting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReporting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MostRecentForJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReporting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MostRecentForJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MostRecentForJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReporting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReporting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReporting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReporting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulingReportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReporting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulingReportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulingReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MostRecentForQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReporting
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReporting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MostRecentForQueue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Filter = &SchedulingReportRequest_MostRecentForQueue{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MostRecentForJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthReporting
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthReporting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MostRecentForJob{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Filter = &SchedulingReportRequest_MostRecentForJob{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbosity", wireType)
			}
			m.Verbosity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Verbosity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReporting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReporting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulingReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReporting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulingReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulingReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReporting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReporting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Report = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReporting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReporting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueReportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReporting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueReportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReporting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReporting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbosity", wireType)
			}
			m.Verbosity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Verbosity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipReporting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReporting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReporting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReporting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReporting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Report = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReporting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReporting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobReportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReporting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobReportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReporting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReporting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReporting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReporting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowReporting
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthReporting
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthReporting
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Report = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipReporting(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthReporting
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipReporting(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowReporting
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowReporting
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthReporting
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupReporting
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthReporting
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthReporting        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowReporting          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupReporting = fmt.Errorf("proto: unexpected end of group")
)
