// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal/scheduler/schedulerobjects/schedulerobjects.proto

package schedulerobjects

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	v1 "k8s.io/api/core/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Node represents a node in a worker cluster.
type Node struct {
	// Unique name associated with the node.
	// Only used internally by the scheduler.
	Id string `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// Time at which this node was last updated.
	// Used to garbage collect nodes that have been removed.
	LastSeen time.Time `protobuf:"bytes,2,opt,name=LastSeen,proto3,stdtime" json:"LastSeen"`
	// The node type captures scheduling requirements of the node;
	// it's computed from the taints and labels associated with the node.
	NodeType *NodeType `protobuf:"bytes,3,opt,name=nodeType,proto3" json:"nodeType,omitempty"`
	// We store the NodeType.id here to simplify indexing.
	NodeTypeId string `protobuf:"bytes,4,opt,name=NodeTypeId,proto3" json:"NodeTypeId,omitempty"`
	// Kubernetes taints.
	Taints []v1.Taint `protobuf:"bytes,5,rep,name=taints,proto3" json:"taints"`
	// Kubernetes labels.
	Labels map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Total resources on this node.
	TotalResources ResourceList `protobuf:"bytes,7,opt,name=TotalResources,proto3" json:"TotalResources"`
	// Resources available for jobs of a given priority.
	// E.g., AvailableResources[5]["cpu"] is the amount of CPU available to jobs with priority 5,
	// where available resources = unused resources + resources assigned to lower-priority jobs.
	AvailableByPriorityAndResource map[int32]ResourceList `protobuf:"bytes,8,rep,name=AvailableByPriorityAndResource,proto3" json:"AvailableByPriorityAndResource" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{0}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetLastSeen() time.Time {
	if m != nil {
		return m.LastSeen
	}
	return time.Time{}
}

func (m *Node) GetNodeType() *NodeType {
	if m != nil {
		return m.NodeType
	}
	return nil
}

func (m *Node) GetNodeTypeId() string {
	if m != nil {
		return m.NodeTypeId
	}
	return ""
}

func (m *Node) GetTaints() []v1.Taint {
	if m != nil {
		return m.Taints
	}
	return nil
}

func (m *Node) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Node) GetTotalResources() ResourceList {
	if m != nil {
		return m.TotalResources
	}
	return ResourceList{}
}

func (m *Node) GetAvailableByPriorityAndResource() map[int32]ResourceList {
	if m != nil {
		return m.AvailableByPriorityAndResource
	}
	return nil
}

// NodeType represents a particular combination of taints and labels.
// The scheduler groups nodes by node type. When assigning pods to nodes,
// the scheduler only considers nodes with a NodeType for which the taints and labels match.
type NodeType struct {
	// Unique identifier. Used for map lookup.
	Id string `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
	// Kubernetes taints.
	// To reduce the number of distinct node types,
	// may contain only a subset of the taints of the node the node type is created from.
	Taints []v1.Taint `protobuf:"bytes,2,rep,name=taints,proto3" json:"taints"`
	// Kubernetes labels.
	// To reduce the number of distinct node types,
	// may contain only a subset of the labels of the node the node type is created from.
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Well-known labels not set by this node type.
	// Used to filter out nodes when looking for nodes for a pod
	// that requires at least one well-known label to be set.
	UnsetWellKnownLabels map[string]string `protobuf:"bytes,4,rep,name=unsetWellKnownLabels,proto3" json:"unsetWellKnownLabels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NodeType) Reset()         { *m = NodeType{} }
func (m *NodeType) String() string { return proto.CompactTextString(m) }
func (*NodeType) ProtoMessage()    {}
func (*NodeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{1}
}
func (m *NodeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeType.Merge(m, src)
}
func (m *NodeType) XXX_Size() int {
	return m.Size()
}
func (m *NodeType) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeType.DiscardUnknown(m)
}

var xxx_messageInfo_NodeType proto.InternalMessageInfo

func (m *NodeType) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeType) GetTaints() []v1.Taint {
	if m != nil {
		return m.Taints
	}
	return nil
}

func (m *NodeType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *NodeType) GetUnsetWellKnownLabels() map[string]string {
	if m != nil {
		return m.UnsetWellKnownLabels
	}
	return nil
}

// Captures the resource usage of a particular queue
// in a given cluster.
type QueueClusterResourceUsage struct {
	Created             time.Time              `protobuf:"bytes,1,opt,name=created,proto3,stdtime" json:"created"`
	Queue               string                 `protobuf:"bytes,2,opt,name=queue,proto3" json:"queue,omitempty"`
	ExecutorId          string                 `protobuf:"bytes,3,opt,name=executorId,proto3" json:"executorId,omitempty"`
	ResourcesByPriority map[int32]ResourceList `protobuf:"bytes,4,rep,name=resourcesByPriority,proto3" json:"resourcesByPriority" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *QueueClusterResourceUsage) Reset()         { *m = QueueClusterResourceUsage{} }
func (m *QueueClusterResourceUsage) String() string { return proto.CompactTextString(m) }
func (*QueueClusterResourceUsage) ProtoMessage()    {}
func (*QueueClusterResourceUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{2}
}
func (m *QueueClusterResourceUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueClusterResourceUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueClusterResourceUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueClusterResourceUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueClusterResourceUsage.Merge(m, src)
}
func (m *QueueClusterResourceUsage) XXX_Size() int {
	return m.Size()
}
func (m *QueueClusterResourceUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueClusterResourceUsage.DiscardUnknown(m)
}

var xxx_messageInfo_QueueClusterResourceUsage proto.InternalMessageInfo

func (m *QueueClusterResourceUsage) GetCreated() time.Time {
	if m != nil {
		return m.Created
	}
	return time.Time{}
}

func (m *QueueClusterResourceUsage) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *QueueClusterResourceUsage) GetExecutorId() string {
	if m != nil {
		return m.ExecutorId
	}
	return ""
}

func (m *QueueClusterResourceUsage) GetResourcesByPriority() map[int32]ResourceList {
	if m != nil {
		return m.ResourcesByPriority
	}
	return nil
}

type ResourceList struct {
	Resources map[string]resource.Quantity `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ResourceList) Reset()         { *m = ResourceList{} }
func (m *ResourceList) String() string { return proto.CompactTextString(m) }
func (*ResourceList) ProtoMessage()    {}
func (*ResourceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{3}
}
func (m *ResourceList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceList.Merge(m, src)
}
func (m *ResourceList) XXX_Size() int {
	return m.Size()
}
func (m *ResourceList) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceList.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceList proto.InternalMessageInfo

func (m *ResourceList) GetResources() map[string]resource.Quantity {
	if m != nil {
		return m.Resources
	}
	return nil
}

// Minimal job representation used by the scheduler.
type JobSchedulingInfo struct {
	Lifetime        uint32 `protobuf:"varint,1,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	AtMostOnce      bool   `protobuf:"varint,2,opt,name=atMostOnce,proto3" json:"atMostOnce,omitempty"`
	Preemptible     bool   `protobuf:"varint,3,opt,name=preemptible,proto3" json:"preemptible,omitempty"`
	ConcurrencySafe bool   `protobuf:"varint,4,opt,name=concurrencySafe,proto3" json:"concurrencySafe,omitempty"`
	// Kubernetes objects that make up this job and their respective scheduling requirements.
	ObjectRequirements []*ObjectRequirements `protobuf:"bytes,5,rep,name=objectRequirements,proto3" json:"objectRequirements,omitempty"`
}

func (m *JobSchedulingInfo) Reset()         { *m = JobSchedulingInfo{} }
func (m *JobSchedulingInfo) String() string { return proto.CompactTextString(m) }
func (*JobSchedulingInfo) ProtoMessage()    {}
func (*JobSchedulingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{4}
}
func (m *JobSchedulingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSchedulingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSchedulingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSchedulingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSchedulingInfo.Merge(m, src)
}
func (m *JobSchedulingInfo) XXX_Size() int {
	return m.Size()
}
func (m *JobSchedulingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSchedulingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_JobSchedulingInfo proto.InternalMessageInfo

func (m *JobSchedulingInfo) GetLifetime() uint32 {
	if m != nil {
		return m.Lifetime
	}
	return 0
}

func (m *JobSchedulingInfo) GetAtMostOnce() bool {
	if m != nil {
		return m.AtMostOnce
	}
	return false
}

func (m *JobSchedulingInfo) GetPreemptible() bool {
	if m != nil {
		return m.Preemptible
	}
	return false
}

func (m *JobSchedulingInfo) GetConcurrencySafe() bool {
	if m != nil {
		return m.ConcurrencySafe
	}
	return false
}

func (m *JobSchedulingInfo) GetObjectRequirements() []*ObjectRequirements {
	if m != nil {
		return m.ObjectRequirements
	}
	return nil
}

// Message capturing the scheduling requirements of a particular Kubernetes object.
type ObjectRequirements struct {
	// Types that are valid to be assigned to Requirements:
	//	*ObjectRequirements_PodRequirements
	Requirements isObjectRequirements_Requirements `protobuf_oneof:"requirements"`
}

func (m *ObjectRequirements) Reset()         { *m = ObjectRequirements{} }
func (m *ObjectRequirements) String() string { return proto.CompactTextString(m) }
func (*ObjectRequirements) ProtoMessage()    {}
func (*ObjectRequirements) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{5}
}
func (m *ObjectRequirements) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectRequirements) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectRequirements.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectRequirements) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectRequirements.Merge(m, src)
}
func (m *ObjectRequirements) XXX_Size() int {
	return m.Size()
}
func (m *ObjectRequirements) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectRequirements.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectRequirements proto.InternalMessageInfo

type isObjectRequirements_Requirements interface {
	isObjectRequirements_Requirements()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ObjectRequirements_PodRequirements struct {
	PodRequirements *PodRequirements `protobuf:"bytes,1,opt,name=podRequirements,proto3,oneof" json:"podRequirements,omitempty"`
}

func (*ObjectRequirements_PodRequirements) isObjectRequirements_Requirements() {}

func (m *ObjectRequirements) GetRequirements() isObjectRequirements_Requirements {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *ObjectRequirements) GetPodRequirements() *PodRequirements {
	if x, ok := m.GetRequirements().(*ObjectRequirements_PodRequirements); ok {
		return x.PodRequirements
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ObjectRequirements) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ObjectRequirements_PodRequirements)(nil),
	}
}

// Captures the scheduling requirements of a pod.
type PodRequirements struct {
	// Kubernetes node selector.
	NodeSelector map[string]string `protobuf:"bytes,1,rep,name=nodeSelector,proto3" json:"nodeSelector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Kubernetes scheduling requirements.
	Affinity *v1.Affinity `protobuf:"bytes,2,opt,name=affinity,proto3" json:"affinity,omitempty"`
	// Kubernetes tolerations.
	Tolerations []v1.Toleration `protobuf:"bytes,3,rep,name=tolerations,proto3" json:"tolerations"`
	// Pod priority. Should be mapped from the priority class name of the submitted pod.
	Priority int32 `protobuf:"varint,4,opt,name=priority,proto3" json:"priority,omitempty"`
	// One of Never, PreemptLowerPriority.
	// Defaults to PreemptLowerPriority if unset.
	PreemptionPolicy string `protobuf:"bytes,5,opt,name=preemptionPolicy,proto3" json:"preemptionPolicy,omitempty"`
	// Sum of the resource requirements for all containers that make up this pod.
	ResourceRequirements v1.ResourceRequirements `protobuf:"bytes,6,opt,name=resourceRequirements,proto3" json:"resourceRequirements"`
}

func (m *PodRequirements) Reset()         { *m = PodRequirements{} }
func (m *PodRequirements) String() string { return proto.CompactTextString(m) }
func (*PodRequirements) ProtoMessage()    {}
func (*PodRequirements) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{6}
}
func (m *PodRequirements) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodRequirements) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodRequirements.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodRequirements) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodRequirements.Merge(m, src)
}
func (m *PodRequirements) XXX_Size() int {
	return m.Size()
}
func (m *PodRequirements) XXX_DiscardUnknown() {
	xxx_messageInfo_PodRequirements.DiscardUnknown(m)
}

var xxx_messageInfo_PodRequirements proto.InternalMessageInfo

func (m *PodRequirements) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *PodRequirements) GetAffinity() *v1.Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *PodRequirements) GetTolerations() []v1.Toleration {
	if m != nil {
		return m.Tolerations
	}
	return nil
}

func (m *PodRequirements) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *PodRequirements) GetPreemptionPolicy() string {
	if m != nil {
		return m.PreemptionPolicy
	}
	return ""
}

func (m *PodRequirements) GetResourceRequirements() v1.ResourceRequirements {
	if m != nil {
		return m.ResourceRequirements
	}
	return v1.ResourceRequirements{}
}

func init() {
	proto.RegisterType((*Node)(nil), "schedulerobjects.Node")
	proto.RegisterMapType((map[int32]ResourceList)(nil), "schedulerobjects.Node.AvailableByPriorityAndResourceEntry")
	proto.RegisterMapType((map[string]string)(nil), "schedulerobjects.Node.LabelsEntry")
	proto.RegisterType((*NodeType)(nil), "schedulerobjects.NodeType")
	proto.RegisterMapType((map[string]string)(nil), "schedulerobjects.NodeType.LabelsEntry")
	proto.RegisterMapType((map[string]string)(nil), "schedulerobjects.NodeType.UnsetWellKnownLabelsEntry")
	proto.RegisterType((*QueueClusterResourceUsage)(nil), "schedulerobjects.QueueClusterResourceUsage")
	proto.RegisterMapType((map[int32]ResourceList)(nil), "schedulerobjects.QueueClusterResourceUsage.ResourcesByPriorityEntry")
	proto.RegisterType((*ResourceList)(nil), "schedulerobjects.ResourceList")
	proto.RegisterMapType((map[string]resource.Quantity)(nil), "schedulerobjects.ResourceList.ResourcesEntry")
	proto.RegisterType((*JobSchedulingInfo)(nil), "schedulerobjects.JobSchedulingInfo")
	proto.RegisterType((*ObjectRequirements)(nil), "schedulerobjects.ObjectRequirements")
	proto.RegisterType((*PodRequirements)(nil), "schedulerobjects.PodRequirements")
	proto.RegisterMapType((map[string]string)(nil), "schedulerobjects.PodRequirements.NodeSelectorEntry")
}

func init() {
	proto.RegisterFile("internal/scheduler/schedulerobjects/schedulerobjects.proto", fileDescriptor_97dadc5fbd620721)
}

var fileDescriptor_97dadc5fbd620721 = []byte{
	// 990 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x53, 0xe4, 0x44,
	0x14, 0x26, 0x33, 0xc0, 0x86, 0x07, 0x02, 0xdb, 0x72, 0x08, 0x53, 0x56, 0xc0, 0xd1, 0xb2, 0x28,
	0xab, 0x36, 0x53, 0xbb, 0x4b, 0x29, 0x72, 0x58, 0x05, 0xd7, 0x1f, 0x28, 0xbb, 0x0b, 0x61, 0xb6,
	0xf6, 0x9c, 0x49, 0xde, 0x84, 0x96, 0x4c, 0x77, 0xe8, 0x74, 0xd0, 0xa9, 0xf2, 0xe2, 0xcd, 0xe3,
	0xfe, 0x21, 0xfe, 0x21, 0x7b, 0x73, 0x8f, 0x7a, 0x51, 0x0b, 0xfe, 0x02, 0x4f, 0x5e, 0xad, 0x74,
	0x7e, 0x4c, 0x66, 0x92, 0x81, 0xa5, 0xf4, 0x96, 0x7e, 0xf3, 0x7d, 0xdf, 0x7b, 0xaf, 0xfb, 0xeb,
	0xd7, 0x03, 0xbb, 0x94, 0x49, 0x14, 0xcc, 0x09, 0x3a, 0x91, 0x7b, 0x8a, 0x5e, 0x1c, 0xa0, 0x18,
	0x7d, 0xf1, 0xde, 0x77, 0xe8, 0xca, 0xa8, 0x12, 0xb0, 0x42, 0xc1, 0x25, 0x27, 0xab, 0x93, 0xf1,
	0xd6, 0x86, 0xcf, 0xb9, 0x1f, 0x60, 0x47, 0xfd, 0xde, 0x8b, 0xfb, 0x1d, 0x49, 0x07, 0x18, 0x49,
	0x67, 0x10, 0xa6, 0x94, 0x56, 0xfb, 0x6c, 0x27, 0xb2, 0x28, 0xef, 0x38, 0x21, 0xed, 0xb8, 0x5c,
	0x60, 0xe7, 0xe2, 0x7e, 0xc7, 0x47, 0x86, 0xc2, 0x91, 0xe8, 0x65, 0x98, 0xed, 0x11, 0x66, 0xe0,
	0xb8, 0xa7, 0x94, 0xa1, 0x18, 0x76, 0xc2, 0x33, 0x5f, 0x91, 0x04, 0x46, 0x3c, 0x16, 0x2e, 0x56,
	0x58, 0xf7, 0x7c, 0x2a, 0x4f, 0xe3, 0x9e, 0xe5, 0xf2, 0x41, 0xc7, 0xe7, 0x3e, 0x1f, 0xd5, 0x90,
	0xac, 0xd4, 0x42, 0x7d, 0xa5, 0xf0, 0xf6, 0x2f, 0x73, 0x30, 0xfb, 0x94, 0x7b, 0x48, 0x96, 0xa1,
	0x71, 0xe0, 0x19, 0xda, 0xa6, 0xb6, 0xb5, 0x60, 0x37, 0x0e, 0x3c, 0xf2, 0x19, 0xe8, 0x87, 0x4e,
	0x24, 0x4f, 0x10, 0x99, 0xd1, 0xd8, 0xd4, 0xb6, 0x16, 0x1f, 0xb4, 0xac, 0xb4, 0x2b, 0x2b, 0x57,
	0xb4, 0xba, 0x79, 0x57, 0xfb, 0xfa, 0xab, 0x3f, 0x36, 0x66, 0x5e, 0xfe, 0xb9, 0xa1, 0xd9, 0x05,
	0x8b, 0x7c, 0x04, 0x3a, 0xe3, 0x1e, 0x76, 0x87, 0x21, 0x1a, 0xcd, 0x4c, 0xa1, 0xb2, 0x83, 0x4f,
	0x33, 0x84, 0x5d, 0x60, 0x89, 0x09, 0x90, 0x47, 0x0f, 0x3c, 0x63, 0x56, 0x55, 0x54, 0x8a, 0x90,
	0x8f, 0x61, 0x5e, 0x3a, 0x94, 0xc9, 0xc8, 0x98, 0xdb, 0x6c, 0x6e, 0x2d, 0x3e, 0x58, 0xb7, 0xd2,
	0x8d, 0xb2, 0x9c, 0x90, 0x5a, 0xc9, 0x66, 0x5a, 0x17, 0xf7, 0xad, 0x6e, 0x82, 0xd8, 0x9f, 0x4d,
	0xca, 0xb2, 0x33, 0x38, 0xd9, 0x85, 0xf9, 0xc0, 0xe9, 0x61, 0x10, 0x19, 0xf3, 0x8a, 0xd8, 0xae,
	0x2f, 0xc7, 0x3a, 0x54, 0xa0, 0x2f, 0x98, 0x14, 0x43, 0x3b, 0x63, 0x90, 0x43, 0x58, 0xee, 0x72,
	0xe9, 0x04, 0x76, 0xb6, 0xef, 0x91, 0x71, 0x47, 0xb5, 0x64, 0x56, 0x35, 0x72, 0xc8, 0x21, 0x8d,
	0xf2, 0x0a, 0x26, 0xb8, 0xe4, 0x67, 0x0d, 0xcc, 0xbd, 0x0b, 0x87, 0x06, 0x4e, 0x2f, 0xc0, 0xfd,
	0xe1, 0x91, 0xa0, 0x5c, 0x50, 0x39, 0xdc, 0x63, 0x5e, 0x8e, 0x31, 0x74, 0x55, 0xe2, 0xee, 0x94,
	0x12, 0xaf, 0x27, 0xab, 0xd2, 0xb3, 0xd4, 0x37, 0xe4, 0x69, 0x7d, 0x02, 0x8b, 0xa5, 0x7e, 0xc9,
	0x2a, 0x34, 0xcf, 0x70, 0x98, 0xf9, 0x20, 0xf9, 0x24, 0x6b, 0x30, 0x77, 0xe1, 0x04, 0x31, 0x2a,
	0x17, 0x2c, 0xd8, 0xe9, 0x62, 0xb7, 0xb1, 0xa3, 0xb5, 0xce, 0xe1, 0xbd, 0x37, 0xa8, 0xa3, 0x2c,
	0x39, 0x97, 0x4a, 0x6e, 0x97, 0x25, 0x6f, 0xdc, 0xc3, 0x52, 0xca, 0xf6, 0x4f, 0x4d, 0xd0, 0x73,
	0x2b, 0x54, 0x2c, 0x3b, 0x32, 0x46, 0xe3, 0x76, 0xc6, 0x78, 0x54, 0x18, 0xa3, 0xa9, 0x88, 0x1f,
	0x4c, 0xf7, 0x69, 0xad, 0x39, 0x4e, 0x61, 0x2d, 0x66, 0x11, 0xca, 0x17, 0x18, 0x04, 0xdf, 0x32,
	0xfe, 0x3d, 0x4b, 0x41, 0xc6, 0xac, 0x52, 0xdb, 0xbe, 0x46, 0xed, 0x79, 0x0d, 0x2d, 0xd5, 0xae,
	0x55, 0xfc, 0x2f, 0xa7, 0xf5, 0x15, 0xac, 0x4f, 0xcd, 0x76, 0x1b, 0xa1, 0xf6, 0x3f, 0x0d, 0x58,
	0x3f, 0x8e, 0x31, 0xc6, 0xcf, 0x83, 0x38, 0x92, 0x28, 0xf2, 0xb3, 0x7a, 0x1e, 0x39, 0x3e, 0x92,
	0x47, 0x70, 0xc7, 0x15, 0x98, 0x0c, 0x24, 0xa5, 0xf6, 0xa6, 0x63, 0x23, 0x27, 0x25, 0x79, 0xcf,
	0x13, 0xf1, 0x3c, 0xaf, 0x5a, 0x24, 0x33, 0x01, 0x7f, 0x40, 0x37, 0x96, 0x5c, 0x1c, 0x78, 0x6a,
	0x9a, 0x2c, 0xd8, 0xa5, 0x08, 0xf9, 0x11, 0xde, 0xce, 0x27, 0x62, 0x34, 0xb2, 0x62, 0x76, 0x00,
	0x8f, 0xab, 0x07, 0x30, 0xb5, 0xfe, 0xc2, 0x79, 0x25, 0x99, 0xf2, 0x75, 0xaa, 0x4b, 0xd3, 0xea,
	0x83, 0x31, 0x8d, 0xf6, 0xbf, 0xba, 0xff, 0x57, 0x0d, 0x96, 0xca, 0xbf, 0x91, 0x63, 0x58, 0x28,
	0xea, 0x31, 0x34, 0xd5, 0xec, 0xbd, 0xeb, 0xe5, 0x46, 0xfd, 0x95, 0xbb, 0x1a, 0xa9, 0xb4, 0x02,
	0x58, 0x1e, 0x87, 0xd4, 0x78, 0xe3, 0xf1, 0x78, 0x07, 0x56, 0xe9, 0x9e, 0x15, 0x2f, 0x95, 0x15,
	0x9e, 0xf9, 0xea, 0xe2, 0xe5, 0xd2, 0xd6, 0x71, 0xec, 0x30, 0x49, 0xe5, 0xb0, 0xdc, 0xd1, 0xdf,
	0x1a, 0xdc, 0xfd, 0x86, 0xf7, 0x4e, 0xd2, 0x92, 0x29, 0xf3, 0x0f, 0x58, 0x9f, 0x93, 0x16, 0xe8,
	0x01, 0xed, 0x63, 0xf2, 0x68, 0xaa, 0xb4, 0x6f, 0xd9, 0xc5, 0x3a, 0x71, 0x82, 0x23, 0x9f, 0xf0,
	0x48, 0x3e, 0x63, 0x6e, 0x5a, 0x80, 0x6e, 0x97, 0x22, 0x64, 0x13, 0x16, 0x43, 0x81, 0x38, 0x08,
	0x25, 0xed, 0x05, 0xe9, 0xc3, 0xa3, 0xdb, 0xe5, 0x10, 0xd9, 0x82, 0x15, 0x97, 0x33, 0x37, 0x16,
	0x02, 0x99, 0x3b, 0x3c, 0x71, 0xfa, 0xa8, 0x1e, 0x19, 0xdd, 0x9e, 0x0c, 0x93, 0x2e, 0x90, 0x74,
	0x0f, 0x6d, 0x3c, 0x8f, 0xa9, 0xc0, 0x01, 0x8e, 0x5e, 0x9d, 0xf7, 0xab, 0xfb, 0xfc, 0xac, 0x82,
	0xb5, 0x6b, 0xf8, 0xed, 0x08, 0x48, 0x15, 0x49, 0x9e, 0xc0, 0x4a, 0xc8, 0xbd, 0xb1, 0x44, 0xe9,
	0xfd, 0x79, 0xb7, 0x9a, 0xe8, 0x68, 0x1c, 0xf8, 0xf5, 0x8c, 0x3d, 0xc9, 0xdd, 0x5f, 0x86, 0x25,
	0x51, 0x4e, 0xfa, 0x7b, 0x13, 0x56, 0x26, 0x68, 0xe4, 0x05, 0x2c, 0x25, 0x8f, 0xee, 0x09, 0x06,
	0xe8, 0x4a, 0x2e, 0x32, 0x03, 0x3d, 0xbc, 0x31, 0x9f, 0x1a, 0x5f, 0x39, 0x2b, 0x9d, 0x56, 0x63,
	0x42, 0x64, 0x07, 0x74, 0xa7, 0xdf, 0xa7, 0x2c, 0xb9, 0x82, 0xa9, 0x45, 0xde, 0xa9, 0x1b, 0xc5,
	0x7b, 0x19, 0xc6, 0x2e, 0xd0, 0xe4, 0x4b, 0x58, 0x94, 0x3c, 0x48, 0xfe, 0xd0, 0x50, 0xce, 0xf2,
	0x71, 0x6c, 0xd6, 0xce, 0xf1, 0x02, 0x96, 0x79, 0xb8, 0x4c, 0x4c, 0x1c, 0x14, 0x8e, 0x86, 0x40,
	0x72, 0xf5, 0x8a, 0x35, 0xf9, 0x10, 0x56, 0x73, 0x3b, 0x70, 0x76, 0xc4, 0x03, 0xea, 0x0e, 0x8d,
	0x39, 0x65, 0xee, 0x4a, 0x9c, 0xf4, 0x60, 0x2d, 0xf7, 0xef, 0xd8, 0xd1, 0xcc, 0xab, 0xae, 0xb6,
	0xea, 0x0a, 0xb3, 0x6b, 0xf0, 0x59, 0x89, 0xb5, 0x5a, 0xad, 0x4f, 0xe1, 0x6e, 0x65, 0x43, 0x6f,
	0x33, 0x90, 0xf7, 0x8d, 0x57, 0x97, 0xa6, 0xf6, 0xfa, 0xd2, 0xd4, 0xfe, 0xba, 0x34, 0xb5, 0x97,
	0x57, 0xe6, 0xcc, 0xeb, 0x2b, 0x73, 0xe6, 0xb7, 0x2b, 0x73, 0xa6, 0x37, 0xaf, 0x66, 0xee, 0xc3,
	0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x0c, 0xd4, 0x8e, 0xde, 0x0a, 0x00, 0x00,
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AvailableByPriorityAndResource) > 0 {
		for k := range m.AvailableByPriorityAndResource {
			v := m.AvailableByPriorityAndResource[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	{
		size, err := m.TotalResources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Taints) > 0 {
		for iNdEx := len(m.Taints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Taints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NodeTypeId) > 0 {
		i -= len(m.NodeTypeId)
		copy(dAtA[i:], m.NodeTypeId)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.NodeTypeId)))
		i--
		dAtA[i] = 0x22
	}
	if m.NodeType != nil {
		{
			size, err := m.NodeType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastSeen, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSeen):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintSchedulerobjects(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x12
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnsetWellKnownLabels) > 0 {
		for k := range m.UnsetWellKnownLabels {
			v := m.UnsetWellKnownLabels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Taints) > 0 {
		for iNdEx := len(m.Taints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Taints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueueClusterResourceUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueClusterResourceUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueClusterResourceUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourcesByPriority) > 0 {
		for k := range m.ResourcesByPriority {
			v := m.ResourcesByPriority[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ExecutorId) > 0 {
		i -= len(m.ExecutorId)
		copy(dAtA[i:], m.ExecutorId)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.ExecutorId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x12
	}
	n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Created, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Created):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintSchedulerobjects(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResourceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for k := range m.Resources {
			v := m.Resources[k]
			baseI := i
			{
				size, err := (&v).MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobSchedulingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSchedulingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSchedulingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ObjectRequirements) > 0 {
		for iNdEx := len(m.ObjectRequirements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ObjectRequirements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ConcurrencySafe {
		i--
		if m.ConcurrencySafe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Preemptible {
		i--
		if m.Preemptible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AtMostOnce {
		i--
		if m.AtMostOnce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Lifetime != 0 {
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(m.Lifetime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ObjectRequirements) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRequirements) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRequirements) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Requirements != nil {
		{
			size := m.Requirements.Size()
			i -= size
			if _, err := m.Requirements.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ObjectRequirements_PodRequirements) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRequirements_PodRequirements) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodRequirements != nil {
		{
			size, err := m.PodRequirements.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PodRequirements) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodRequirements) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodRequirements) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ResourceRequirements.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.PreemptionPolicy) > 0 {
		i -= len(m.PreemptionPolicy)
		copy(dAtA[i:], m.PreemptionPolicy)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.PreemptionPolicy)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Priority != 0 {
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Tolerations) > 0 {
		for iNdEx := len(m.Tolerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tolerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Affinity != nil {
		{
			size, err := m.Affinity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeSelector) > 0 {
		for k := range m.NodeSelector {
			v := m.NodeSelector[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintSchedulerobjects(dAtA []byte, offset int, v uint64) int {
	offset -= sovSchedulerobjects(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSeen)
	n += 1 + l + sovSchedulerobjects(uint64(l))
	if m.NodeType != nil {
		l = m.NodeType.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	l = len(m.NodeTypeId)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.Taints) > 0 {
		for _, e := range m.Taints {
			l = e.Size()
			n += 1 + l + sovSchedulerobjects(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchedulerobjects(uint64(len(k))) + 1 + len(v) + sovSchedulerobjects(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	l = m.TotalResources.Size()
	n += 1 + l + sovSchedulerobjects(uint64(l))
	if len(m.AvailableByPriorityAndResource) > 0 {
		for k, v := range m.AvailableByPriorityAndResource {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovSchedulerobjects(uint64(k)) + 1 + l + sovSchedulerobjects(uint64(l))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NodeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.Taints) > 0 {
		for _, e := range m.Taints {
			l = e.Size()
			n += 1 + l + sovSchedulerobjects(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchedulerobjects(uint64(len(k))) + 1 + len(v) + sovSchedulerobjects(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	if len(m.UnsetWellKnownLabels) > 0 {
		for k, v := range m.UnsetWellKnownLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchedulerobjects(uint64(len(k))) + 1 + len(v) + sovSchedulerobjects(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *QueueClusterResourceUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Created)
	n += 1 + l + sovSchedulerobjects(uint64(l))
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	l = len(m.ExecutorId)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.ResourcesByPriority) > 0 {
		for k, v := range m.ResourcesByPriority {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovSchedulerobjects(uint64(k)) + 1 + l + sovSchedulerobjects(uint64(l))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ResourceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for k, v := range m.Resources {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovSchedulerobjects(uint64(len(k))) + 1 + l + sovSchedulerobjects(uint64(l))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *JobSchedulingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lifetime != 0 {
		n += 1 + sovSchedulerobjects(uint64(m.Lifetime))
	}
	if m.AtMostOnce {
		n += 2
	}
	if m.Preemptible {
		n += 2
	}
	if m.ConcurrencySafe {
		n += 2
	}
	if len(m.ObjectRequirements) > 0 {
		for _, e := range m.ObjectRequirements {
			l = e.Size()
			n += 1 + l + sovSchedulerobjects(uint64(l))
		}
	}
	return n
}

func (m *ObjectRequirements) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Requirements != nil {
		n += m.Requirements.Size()
	}
	return n
}

func (m *ObjectRequirements_PodRequirements) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodRequirements != nil {
		l = m.PodRequirements.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	return n
}
func (m *PodRequirements) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchedulerobjects(uint64(len(k))) + 1 + len(v) + sovSchedulerobjects(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	if m.Affinity != nil {
		l = m.Affinity.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.Tolerations) > 0 {
		for _, e := range m.Tolerations {
			l = e.Size()
			n += 1 + l + sovSchedulerobjects(uint64(l))
		}
	}
	if m.Priority != 0 {
		n += 1 + sovSchedulerobjects(uint64(m.Priority))
	}
	l = len(m.PreemptionPolicy)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	l = m.ResourceRequirements.Size()
	n += 1 + l + sovSchedulerobjects(uint64(l))
	return n
}

func sovSchedulerobjects(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSchedulerobjects(x uint64) (n int) {
	return sovSchedulerobjects(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastSeen, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeType == nil {
				m.NodeType = &NodeType{}
			}
			if err := m.NodeType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeTypeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeTypeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Taints = append(m.Taints, v1.Taint{})
			if err := m.Taints[len(m.Taints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableByPriorityAndResource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AvailableByPriorityAndResource == nil {
				m.AvailableByPriorityAndResource = make(map[int32]ResourceList)
			}
			var mapkey int32
			mapvalue := &ResourceList{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ResourceList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AvailableByPriorityAndResource[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Taints = append(m.Taints, v1.Taint{})
			if err := m.Taints[len(m.Taints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsetWellKnownLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnsetWellKnownLabels == nil {
				m.UnsetWellKnownLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UnsetWellKnownLabels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueClusterResourceUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueClusterResourceUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueClusterResourceUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Created, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcesByPriority", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourcesByPriority == nil {
				m.ResourcesByPriority = make(map[int32]ResourceList)
			}
			var mapkey int32
			mapvalue := &ResourceList{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ResourceList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResourcesByPriority[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = make(map[string]resource.Quantity)
			}
			var mapkey string
			mapvalue := &resource.Quantity{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Resources[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSchedulingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSchedulingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSchedulingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			m.Lifetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lifetime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtMostOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AtMostOnce = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preemptible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Preemptible = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcurrencySafe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConcurrencySafe = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectRequirements = append(m.ObjectRequirements, &ObjectRequirements{})
			if err := m.ObjectRequirements[len(m.ObjectRequirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRequirements) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRequirements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRequirements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodRequirements{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Requirements = &ObjectRequirements_PodRequirements{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodRequirements) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodRequirements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodRequirements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Affinity == nil {
				m.Affinity = &v1.Affinity{}
			}
			if err := m.Affinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tolerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tolerations = append(m.Tolerations, v1.Toleration{})
			if err := m.Tolerations[len(m.Tolerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreemptionPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreemptionPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceRequirements.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSchedulerobjects(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSchedulerobjects
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSchedulerobjects
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSchedulerobjects
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSchedulerobjects        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSchedulerobjects          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSchedulerobjects = fmt.Errorf("proto: unexpected end of group")
)
