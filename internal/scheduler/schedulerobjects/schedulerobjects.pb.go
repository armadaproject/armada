// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal/scheduler/schedulerobjects/schedulerobjects.proto

package schedulerobjects

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	v1 "k8s.io/api/core/v1"
	resource "k8s.io/apimachinery/pkg/api/resource"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type JobRunState int32

const (
	JobRunState_UNKNOWN   JobRunState = 0
	JobRunState_PENDING   JobRunState = 1
	JobRunState_RUNNING   JobRunState = 2
	JobRunState_SUCCEEDED JobRunState = 3
	JobRunState_FAILED    JobRunState = 4
)

var JobRunState_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "RUNNING",
	3: "SUCCEEDED",
	4: "FAILED",
}

var JobRunState_value = map[string]int32{
	"UNKNOWN":   0,
	"PENDING":   1,
	"RUNNING":   2,
	"SUCCEEDED": 3,
	"FAILED":    4,
}

func (x JobRunState) String() string {
	return proto.EnumName(JobRunState_name, int32(x))
}

func (JobRunState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{0}
}

// Executor represents an executor running on a worker cluster
type Executor struct {
	// Name of the executor.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Pool that the executor belongs to.
	Pool string `protobuf:"bytes,2,opt,name=pool,proto3" json:"pool,omitempty"`
	// The nodes available for scheduling via this executor.
	Nodes []*Node `protobuf:"bytes,3,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// Last time the executor provided a heartbeat to say it was still accepting job.
	LastUpdateTime *types.Timestamp `protobuf:"bytes,5,opt,name=lastUpdateTime,proto3" json:"lastUpdateTime,omitempty"`
	// Jobs that are owned by the cluster but are not assigned to any node.
	UnassignedJobRuns []string `protobuf:"bytes,9,rep,name=unassigned_job_runs,json=unassignedJobRuns,proto3" json:"unassignedJobRuns,omitempty"`
}

func (m *Executor) Reset()         { *m = Executor{} }
func (m *Executor) String() string { return proto.CompactTextString(m) }
func (*Executor) ProtoMessage()    {}
func (*Executor) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{0}
}
func (m *Executor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Executor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Executor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Executor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Executor.Merge(m, src)
}
func (m *Executor) XXX_Size() int {
	return m.Size()
}
func (m *Executor) XXX_DiscardUnknown() {
	xxx_messageInfo_Executor.DiscardUnknown(m)
}

var xxx_messageInfo_Executor proto.InternalMessageInfo

func (m *Executor) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Executor) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *Executor) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Executor) GetLastUpdateTime() *types.Timestamp {
	if m != nil {
		return m.LastUpdateTime
	}
	return nil
}

func (m *Executor) GetUnassignedJobRuns() []string {
	if m != nil {
		return m.UnassignedJobRuns
	}
	return nil
}

// Node represents a node in a worker cluster.
type Node struct {
	// Id associated with the node. Must be unique across all clusters.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Kubernetes node name. Not guaranteed to be unique across clusters.
	Name string `protobuf:"bytes,12,opt,name=name,proto3" json:"name,omitempty"`
	// Name of the executor to which this node belongs.
	Executor string `protobuf:"bytes,19,opt,name=executor,proto3" json:"executor,omitempty"`
	// Time at which this node was last updated.
	// Used to garbage collect nodes that have been removed.
	LastSeen *types.Timestamp `protobuf:"bytes,2,opt,name=last_seen,json=lastSeen,proto3" json:"lastSeen,omitempty"`
	// Kubernetes taints.
	Taints []*v1.Taint `protobuf:"bytes,5,rep,name=taints,proto3" json:"taints,omitempty"`
	// Kubernetes labels.
	Labels map[string]string `protobuf:"bytes,6,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Total resources on this node.
	TotalResources *ResourceList `protobuf:"bytes,7,opt,name=total_resources,json=totalResources,proto3" json:"totalResources,omitempty"`
	// Ids of the job runs currently assigned to this node and their current state.
	StateByJobRunId map[string]JobRunState `protobuf:"bytes,9,rep,name=state_by_job_run_id,json=stateByJobRunId,proto3" json:"stateByJobRunId,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=schedulerobjects.JobRunState"`
	// Resource allocated to non-Armada pods on this node.
	UnallocatableResources map[int32]*ResourceList `protobuf:"bytes,13,rep,name=unallocatable_resources,json=unallocatableResources,proto3" json:"unallocatableResources,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// If true, no new jobs should be scheduled onto this node, e.g., because the node has been cordoned.
	Unschedulable bool `protobuf:"varint,15,opt,name=unschedulable,proto3" json:"unschedulable,omitempty"`
	// This should only be used for metrics
	// This is the type the node should be reported as. It is simply a label to categorise the group the node belongs to
	ReportingNodeType string `protobuf:"bytes,17,opt,name=reporting_node_type,json=reportingNodeType,proto3" json:"reportingNodeType,omitempty"`
	// The pool that this node belongs to, this is used for scheduling purposes
	Pool                        string               `protobuf:"bytes,18,opt,name=pool,proto3" json:"pool,omitempty"`
	ResourceUsageByQueueAndPool []*PoolQueueResource `protobuf:"bytes,20,rep,name=resource_usage_by_queue_and_pool,json=resourceUsageByQueueAndPool,proto3" json:"resourceUsageByQueueAndPool,omitempty"`
	// The name of the reservation for this node, will be empty if this node is not reserved
	Reservation string `protobuf:"bytes,21,opt,name=reservation,proto3" json:"reservation,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{1}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Node) GetExecutor() string {
	if m != nil {
		return m.Executor
	}
	return ""
}

func (m *Node) GetLastSeen() *types.Timestamp {
	if m != nil {
		return m.LastSeen
	}
	return nil
}

func (m *Node) GetTaints() []*v1.Taint {
	if m != nil {
		return m.Taints
	}
	return nil
}

func (m *Node) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Node) GetTotalResources() *ResourceList {
	if m != nil {
		return m.TotalResources
	}
	return nil
}

func (m *Node) GetStateByJobRunId() map[string]JobRunState {
	if m != nil {
		return m.StateByJobRunId
	}
	return nil
}

func (m *Node) GetUnallocatableResources() map[int32]*ResourceList {
	if m != nil {
		return m.UnallocatableResources
	}
	return nil
}

func (m *Node) GetUnschedulable() bool {
	if m != nil {
		return m.Unschedulable
	}
	return false
}

func (m *Node) GetReportingNodeType() string {
	if m != nil {
		return m.ReportingNodeType
	}
	return ""
}

func (m *Node) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *Node) GetResourceUsageByQueueAndPool() []*PoolQueueResource {
	if m != nil {
		return m.ResourceUsageByQueueAndPool
	}
	return nil
}

func (m *Node) GetReservation() string {
	if m != nil {
		return m.Reservation
	}
	return ""
}

type PoolQueueResource struct {
	Pool      string        `protobuf:"bytes,1,opt,name=pool,proto3" json:"pool,omitempty"`
	Queue     string        `protobuf:"bytes,2,opt,name=queue,proto3" json:"queue,omitempty"`
	Resources *ResourceList `protobuf:"bytes,3,opt,name=resources,proto3" json:"resources,omitempty"`
}

func (m *PoolQueueResource) Reset()         { *m = PoolQueueResource{} }
func (m *PoolQueueResource) String() string { return proto.CompactTextString(m) }
func (*PoolQueueResource) ProtoMessage()    {}
func (*PoolQueueResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{2}
}
func (m *PoolQueueResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolQueueResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolQueueResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolQueueResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolQueueResource.Merge(m, src)
}
func (m *PoolQueueResource) XXX_Size() int {
	return m.Size()
}
func (m *PoolQueueResource) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolQueueResource.DiscardUnknown(m)
}

var xxx_messageInfo_PoolQueueResource proto.InternalMessageInfo

func (m *PoolQueueResource) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *PoolQueueResource) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *PoolQueueResource) GetResources() *ResourceList {
	if m != nil {
		return m.Resources
	}
	return nil
}

type ResourceList struct {
	Resources map[string]*resource.Quantity `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ResourceList) Reset()         { *m = ResourceList{} }
func (m *ResourceList) String() string { return proto.CompactTextString(m) }
func (*ResourceList) ProtoMessage()    {}
func (*ResourceList) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{3}
}
func (m *ResourceList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceList.Merge(m, src)
}
func (m *ResourceList) XXX_Size() int {
	return m.Size()
}
func (m *ResourceList) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceList.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceList proto.InternalMessageInfo

func (m *ResourceList) GetResources() map[string]*resource.Quantity {
	if m != nil {
		return m.Resources
	}
	return nil
}

// Minimal job representation used by the scheduler.
type JobSchedulingInfo struct {
	Lifetime          uint32           `protobuf:"varint,1,opt,name=lifetime,proto3" json:"lifetime,omitempty"`
	AtMostOnce        bool             `protobuf:"varint,2,opt,name=at_most_once,json=atMostOnce,proto3" json:"atMostOnce,omitempty"`
	Preemptible       bool             `protobuf:"varint,3,opt,name=preemptible,proto3" json:"preemptible,omitempty"`
	ConcurrencySafe   bool             `protobuf:"varint,4,opt,name=concurrency_safe,json=concurrencySafe,proto3" json:"concurrencySafe,omitempty"`
	PriorityClassName string           `protobuf:"bytes,6,opt,name=priority_class_name,json=priorityClassName,proto3" json:"priorityClassName,omitempty"`
	SubmitTime        *types.Timestamp `protobuf:"bytes,7,opt,name=submit_time,json=submitTime,proto3" json:"submitTime,omitempty"`
	// In-queue priority. I.e., not the priority class priority.
	Priority uint32 `protobuf:"varint,8,opt,name=priority,proto3" json:"priority,omitempty"`
	// Kubernetes objects that make up this job and their respective scheduling requirements.
	ObjectRequirements []*ObjectRequirements `protobuf:"bytes,5,rep,name=object_requirements,json=objectRequirements,proto3" json:"objectRequirements,omitempty"`
	Version            uint32                `protobuf:"varint,9,opt,name=version,proto3" json:"version,omitempty"`
	// Gang scheduling information
	Gang *Gang `protobuf:"bytes,11,opt,name=gang,proto3" json:"gang,omitempty"`
}

func (m *JobSchedulingInfo) Reset()         { *m = JobSchedulingInfo{} }
func (m *JobSchedulingInfo) String() string { return proto.CompactTextString(m) }
func (*JobSchedulingInfo) ProtoMessage()    {}
func (*JobSchedulingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{4}
}
func (m *JobSchedulingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSchedulingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSchedulingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSchedulingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSchedulingInfo.Merge(m, src)
}
func (m *JobSchedulingInfo) XXX_Size() int {
	return m.Size()
}
func (m *JobSchedulingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSchedulingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_JobSchedulingInfo proto.InternalMessageInfo

func (m *JobSchedulingInfo) GetLifetime() uint32 {
	if m != nil {
		return m.Lifetime
	}
	return 0
}

func (m *JobSchedulingInfo) GetAtMostOnce() bool {
	if m != nil {
		return m.AtMostOnce
	}
	return false
}

func (m *JobSchedulingInfo) GetPreemptible() bool {
	if m != nil {
		return m.Preemptible
	}
	return false
}

func (m *JobSchedulingInfo) GetConcurrencySafe() bool {
	if m != nil {
		return m.ConcurrencySafe
	}
	return false
}

func (m *JobSchedulingInfo) GetPriorityClassName() string {
	if m != nil {
		return m.PriorityClassName
	}
	return ""
}

func (m *JobSchedulingInfo) GetSubmitTime() *types.Timestamp {
	if m != nil {
		return m.SubmitTime
	}
	return nil
}

func (m *JobSchedulingInfo) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *JobSchedulingInfo) GetObjectRequirements() []*ObjectRequirements {
	if m != nil {
		return m.ObjectRequirements
	}
	return nil
}

func (m *JobSchedulingInfo) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *JobSchedulingInfo) GetGang() *Gang {
	if m != nil {
		return m.Gang
	}
	return nil
}

// Gang scheduling configuration (user-provided metadata)
type Gang struct {
	GangId                  string `protobuf:"bytes,1,opt,name=gang_id,json=gangId,proto3" json:"gangId,omitempty"`
	Cardinality             uint32 `protobuf:"varint,2,opt,name=cardinality,proto3" json:"cardinality,omitempty"`
	NodeUniformityLabelName string `protobuf:"bytes,3,opt,name=node_uniformity_label_name,json=nodeUniformityLabelName,proto3" json:"nodeUniformityLabelName,omitempty"`
}

func (m *Gang) Reset()         { *m = Gang{} }
func (m *Gang) String() string { return proto.CompactTextString(m) }
func (*Gang) ProtoMessage()    {}
func (*Gang) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{5}
}
func (m *Gang) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Gang) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Gang.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Gang) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gang.Merge(m, src)
}
func (m *Gang) XXX_Size() int {
	return m.Size()
}
func (m *Gang) XXX_DiscardUnknown() {
	xxx_messageInfo_Gang.DiscardUnknown(m)
}

var xxx_messageInfo_Gang proto.InternalMessageInfo

func (m *Gang) GetGangId() string {
	if m != nil {
		return m.GangId
	}
	return ""
}

func (m *Gang) GetCardinality() uint32 {
	if m != nil {
		return m.Cardinality
	}
	return 0
}

func (m *Gang) GetNodeUniformityLabelName() string {
	if m != nil {
		return m.NodeUniformityLabelName
	}
	return ""
}

// Message capturing the scheduling requirements of a particular Kubernetes object.
type ObjectRequirements struct {
	// Types that are valid to be assigned to Requirements:
	//	*ObjectRequirements_PodRequirements
	Requirements isObjectRequirements_Requirements `protobuf_oneof:"requirements"`
}

func (m *ObjectRequirements) Reset()         { *m = ObjectRequirements{} }
func (m *ObjectRequirements) String() string { return proto.CompactTextString(m) }
func (*ObjectRequirements) ProtoMessage()    {}
func (*ObjectRequirements) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{6}
}
func (m *ObjectRequirements) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectRequirements) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectRequirements.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectRequirements) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectRequirements.Merge(m, src)
}
func (m *ObjectRequirements) XXX_Size() int {
	return m.Size()
}
func (m *ObjectRequirements) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectRequirements.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectRequirements proto.InternalMessageInfo

type isObjectRequirements_Requirements interface {
	isObjectRequirements_Requirements()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ObjectRequirements_PodRequirements struct {
	PodRequirements *PodRequirements `protobuf:"bytes,1,opt,name=podRequirements,proto3,oneof" json:"podRequirements,omitempty"`
}

func (*ObjectRequirements_PodRequirements) isObjectRequirements_Requirements() {}

func (m *ObjectRequirements) GetRequirements() isObjectRequirements_Requirements {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *ObjectRequirements) GetPodRequirements() *PodRequirements {
	if x, ok := m.GetRequirements().(*ObjectRequirements_PodRequirements); ok {
		return x.PodRequirements
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ObjectRequirements) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ObjectRequirements_PodRequirements)(nil),
	}
}

// Captures the scheduling requirements of a pod.
type PodRequirements struct {
	// Kubernetes node selector.
	NodeSelector map[string]string `protobuf:"bytes,1,rep,name=nodeSelector,proto3" json:"nodeSelector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Kubernetes scheduling requirements.
	Affinity *v1.Affinity `protobuf:"bytes,2,opt,name=affinity,proto3" json:"affinity,omitempty"`
	// Kubernetes tolerations.
	Tolerations []*v1.Toleration `protobuf:"bytes,3,rep,name=tolerations,proto3" json:"tolerations,omitempty"`
	// Kubernetes annotations. Included here since we use annotations with special meaning.
	Annotations map[string]string `protobuf:"bytes,7,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// One of Never, PreemptLowerPriority.
	// Defaults to PreemptLowerPriority if unset.
	PreemptionPolicy string `protobuf:"bytes,5,opt,name=preemptionPolicy,proto3" json:"preemptionPolicy,omitempty"`
	// Sum of the resource requirements for all containers that make up this pod.
	ResourceRequirements *v1.ResourceRequirements `protobuf:"bytes,6,opt,name=resourceRequirements,proto3" json:"resourceRequirements,omitempty"`
}

func (m *PodRequirements) Reset()         { *m = PodRequirements{} }
func (m *PodRequirements) String() string { return proto.CompactTextString(m) }
func (*PodRequirements) ProtoMessage()    {}
func (*PodRequirements) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{7}
}
func (m *PodRequirements) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodRequirements) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodRequirements.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodRequirements) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodRequirements.Merge(m, src)
}
func (m *PodRequirements) XXX_Size() int {
	return m.Size()
}
func (m *PodRequirements) XXX_DiscardUnknown() {
	xxx_messageInfo_PodRequirements.DiscardUnknown(m)
}

var xxx_messageInfo_PodRequirements proto.InternalMessageInfo

func (m *PodRequirements) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *PodRequirements) GetAffinity() *v1.Affinity {
	if m != nil {
		return m.Affinity
	}
	return nil
}

func (m *PodRequirements) GetTolerations() []*v1.Toleration {
	if m != nil {
		return m.Tolerations
	}
	return nil
}

func (m *PodRequirements) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *PodRequirements) GetPreemptionPolicy() string {
	if m != nil {
		return m.PreemptionPolicy
	}
	return ""
}

func (m *PodRequirements) GetResourceRequirements() *v1.ResourceRequirements {
	if m != nil {
		return m.ResourceRequirements
	}
	return nil
}

// Scheduler-computed gang placement decisions.
// Used in SchedulingMetadata to inform executor of gang placement.
type GangPlacement struct {
	// The gang ID from the original job submission.
	GangId string `protobuf:"bytes,1,opt,name=gang_id,json=gangId,proto3" json:"gangId,omitempty"`
	// The total number of jobs in the gang.
	Cardinality uint32 `protobuf:"varint,2,opt,name=cardinality,proto3" json:"cardinality,omitempty"`
	// The node label name used for gang uniformity (e.g., "rack").
	// Only set if the gang has node uniformity requirements.
	NodeUniformityLabelName string `protobuf:"bytes,3,opt,name=node_uniformity_label_name,json=nodeUniformityLabelName,proto3" json:"nodeUniformityLabelName,omitempty"`
	// The actual value selected during scheduling (e.g., "rack-1").
	// Only set by the scheduler if the gang has node uniformity requirements.
	NodeUniformityLabelValue string `protobuf:"bytes,4,opt,name=node_uniformity_label_value,json=nodeUniformityLabelValue,proto3" json:"nodeUniformityLabelValue,omitempty"`
}

func (m *GangPlacement) Reset()         { *m = GangPlacement{} }
func (m *GangPlacement) String() string { return proto.CompactTextString(m) }
func (*GangPlacement) ProtoMessage()    {}
func (*GangPlacement) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{8}
}
func (m *GangPlacement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GangPlacement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GangPlacement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GangPlacement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GangPlacement.Merge(m, src)
}
func (m *GangPlacement) XXX_Size() int {
	return m.Size()
}
func (m *GangPlacement) XXX_DiscardUnknown() {
	xxx_messageInfo_GangPlacement.DiscardUnknown(m)
}

var xxx_messageInfo_GangPlacement proto.InternalMessageInfo

func (m *GangPlacement) GetGangId() string {
	if m != nil {
		return m.GangId
	}
	return ""
}

func (m *GangPlacement) GetCardinality() uint32 {
	if m != nil {
		return m.Cardinality
	}
	return 0
}

func (m *GangPlacement) GetNodeUniformityLabelName() string {
	if m != nil {
		return m.NodeUniformityLabelName
	}
	return ""
}

func (m *GangPlacement) GetNodeUniformityLabelValue() string {
	if m != nil {
		return m.NodeUniformityLabelValue
	}
	return ""
}

type ExecutorSettings struct {
	ExecutorId   string           `protobuf:"bytes,1,opt,name=executorId,proto3" json:"executorId,omitempty"`
	Cordoned     bool             `protobuf:"varint,2,opt,name=cordoned,proto3" json:"cordoned,omitempty"`
	CordonReason string           `protobuf:"bytes,3,opt,name=cordonReason,proto3" json:"cordonReason,omitempty"`
	SetByUser    string           `protobuf:"bytes,4,opt,name=setByUser,proto3" json:"setByUser,omitempty"`
	SetAtTime    *types.Timestamp `protobuf:"bytes,5,opt,name=setAtTime,proto3" json:"setAtTime,omitempty"`
}

func (m *ExecutorSettings) Reset()         { *m = ExecutorSettings{} }
func (m *ExecutorSettings) String() string { return proto.CompactTextString(m) }
func (*ExecutorSettings) ProtoMessage()    {}
func (*ExecutorSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_97dadc5fbd620721, []int{9}
}
func (m *ExecutorSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutorSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutorSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutorSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutorSettings.Merge(m, src)
}
func (m *ExecutorSettings) XXX_Size() int {
	return m.Size()
}
func (m *ExecutorSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutorSettings.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutorSettings proto.InternalMessageInfo

func (m *ExecutorSettings) GetExecutorId() string {
	if m != nil {
		return m.ExecutorId
	}
	return ""
}

func (m *ExecutorSettings) GetCordoned() bool {
	if m != nil {
		return m.Cordoned
	}
	return false
}

func (m *ExecutorSettings) GetCordonReason() string {
	if m != nil {
		return m.CordonReason
	}
	return ""
}

func (m *ExecutorSettings) GetSetByUser() string {
	if m != nil {
		return m.SetByUser
	}
	return ""
}

func (m *ExecutorSettings) GetSetAtTime() *types.Timestamp {
	if m != nil {
		return m.SetAtTime
	}
	return nil
}

func init() {
	proto.RegisterEnum("schedulerobjects.JobRunState", JobRunState_name, JobRunState_value)
	proto.RegisterType((*Executor)(nil), "schedulerobjects.Executor")
	proto.RegisterType((*Node)(nil), "schedulerobjects.Node")
	proto.RegisterMapType((map[string]string)(nil), "schedulerobjects.Node.LabelsEntry")
	proto.RegisterMapType((map[string]JobRunState)(nil), "schedulerobjects.Node.StateByJobRunIdEntry")
	proto.RegisterMapType((map[int32]*ResourceList)(nil), "schedulerobjects.Node.UnallocatableResourcesEntry")
	proto.RegisterType((*PoolQueueResource)(nil), "schedulerobjects.PoolQueueResource")
	proto.RegisterType((*ResourceList)(nil), "schedulerobjects.ResourceList")
	proto.RegisterMapType((map[string]*resource.Quantity)(nil), "schedulerobjects.ResourceList.ResourcesEntry")
	proto.RegisterType((*JobSchedulingInfo)(nil), "schedulerobjects.JobSchedulingInfo")
	proto.RegisterType((*Gang)(nil), "schedulerobjects.Gang")
	proto.RegisterType((*ObjectRequirements)(nil), "schedulerobjects.ObjectRequirements")
	proto.RegisterType((*PodRequirements)(nil), "schedulerobjects.PodRequirements")
	proto.RegisterMapType((map[string]string)(nil), "schedulerobjects.PodRequirements.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "schedulerobjects.PodRequirements.NodeSelectorEntry")
	proto.RegisterType((*GangPlacement)(nil), "schedulerobjects.GangPlacement")
	proto.RegisterType((*ExecutorSettings)(nil), "schedulerobjects.ExecutorSettings")
}

func init() {
	proto.RegisterFile("internal/scheduler/schedulerobjects/schedulerobjects.proto", fileDescriptor_97dadc5fbd620721)
}

var fileDescriptor_97dadc5fbd620721 = []byte{
	// 1863 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0x37, 0x65, 0x5a, 0xa6, 0x46, 0xb2, 0x4d, 0x8d, 0x9d, 0x84, 0x91, 0xb3, 0xa2, 0x56, 0xfb,
	0x07, 0x4e, 0xdb, 0xa5, 0xb0, 0xde, 0x16, 0x08, 0x52, 0x60, 0x01, 0x2b, 0x71, 0x13, 0xab, 0xa9,
	0xec, 0xd8, 0x51, 0x8b, 0xb6, 0x28, 0xd8, 0x11, 0x39, 0x52, 0xb8, 0xa6, 0x66, 0xb4, 0xe4, 0xd0,
	0x5d, 0xdd, 0x7a, 0x2d, 0x7a, 0xe9, 0x16, 0xed, 0x27, 0xe8, 0xe7, 0xe8, 0xb5, 0x28, 0x8a, 0x1e,
	0xf6, 0xb4, 0xe8, 0x89, 0x28, 0x92, 0x1b, 0x3f, 0x45, 0x31, 0x43, 0x52, 0x1a, 0xfd, 0x71, 0xec,
	0xcb, 0x5e, 0x7a, 0xb2, 0xe7, 0xf7, 0xde, 0xfb, 0xbd, 0x37, 0x6f, 0x1e, 0xdf, 0xbc, 0x11, 0x78,
	0xec, 0x11, 0x86, 0x03, 0x82, 0xfc, 0x56, 0xe8, 0xbc, 0xc6, 0x6e, 0xe4, 0xe3, 0x60, 0xf6, 0x1f,
	0xed, 0x7f, 0x81, 0x1d, 0x16, 0x2e, 0x01, 0xd6, 0x38, 0xa0, 0x8c, 0x42, 0x7d, 0x11, 0xaf, 0x99,
	0x43, 0x4a, 0x87, 0x3e, 0x6e, 0x09, 0x79, 0x3f, 0x1a, 0xb4, 0x98, 0x37, 0xc2, 0x21, 0x43, 0xa3,
	0x71, 0x6a, 0x52, 0x6b, 0x5e, 0x3e, 0x0a, 0x2d, 0x8f, 0xb6, 0xd0, 0xd8, 0x6b, 0x39, 0x34, 0xc0,
	0xad, 0xab, 0x4f, 0x5b, 0x43, 0x4c, 0x70, 0x80, 0x18, 0x76, 0x33, 0x9d, 0x1f, 0xce, 0x74, 0x46,
	0xc8, 0x79, 0xed, 0x11, 0x1c, 0x4c, 0x5a, 0xe3, 0xcb, 0xa1, 0x30, 0x0a, 0x70, 0x48, 0xa3, 0xc0,
	0xc1, 0x8b, 0x56, 0xcd, 0x37, 0x05, 0xa0, 0x1d, 0x7f, 0x85, 0x9d, 0x88, 0xd1, 0x00, 0x36, 0x40,
	0xc1, 0x73, 0x0d, 0xa5, 0xa1, 0x1c, 0x94, 0xda, 0x7a, 0x12, 0x9b, 0x15, 0xcf, 0xfd, 0x01, 0x1d,
	0x79, 0x0c, 0x8f, 0xc6, 0x6c, 0x72, 0x5e, 0xf0, 0x5c, 0xf8, 0x31, 0x50, 0xc7, 0x94, 0xfa, 0x46,
	0x41, 0xe8, 0xc0, 0x24, 0x36, 0xb7, 0xf9, 0x5a, 0xd2, 0x12, 0x72, 0x78, 0x04, 0x36, 0x08, 0x75,
	0x71, 0x68, 0xac, 0x37, 0xd6, 0x0f, 0xca, 0x87, 0x77, 0xad, 0xa5, 0x5c, 0x74, 0xa9, 0x8b, 0xdb,
	0xbb, 0x49, 0x6c, 0xee, 0x08, 0x45, 0x89, 0x21, 0xb5, 0x84, 0xbf, 0x05, 0xdb, 0x3e, 0x0a, 0x59,
	0x6f, 0xec, 0x22, 0x86, 0x5f, 0x79, 0x23, 0x6c, 0x6c, 0x34, 0x94, 0x83, 0xf2, 0x61, 0xcd, 0x4a,
	0xb3, 0x65, 0xe5, 0xd9, 0xb2, 0x5e, 0xe5, 0xd9, 0x6a, 0x3f, 0x48, 0x62, 0xd3, 0x98, 0xb7, 0x92,
	0x88, 0x17, 0xf8, 0xe0, 0x29, 0xd8, 0x8d, 0x08, 0x0a, 0x43, 0x6f, 0x48, 0xb0, 0x6b, 0x7f, 0x41,
	0xfb, 0x76, 0x10, 0x91, 0xd0, 0x28, 0x35, 0xd6, 0x0f, 0x4a, 0x6d, 0x33, 0x89, 0xcd, 0xfd, 0x99,
	0xb8, 0x43, 0xfb, 0xe7, 0x11, 0x91, 0xc3, 0xac, 0x2e, 0x09, 0x3b, 0xaa, 0xa6, 0xea, 0x1b, 0x1d,
	0x55, 0x2b, 0xea, 0x9b, 0x1d, 0x55, 0xdb, 0xd4, 0xb5, 0x8e, 0xaa, 0x69, 0x7a, 0xa9, 0xf9, 0xb7,
	0x0a, 0x50, 0xf9, 0x7e, 0x6f, 0x97, 0x60, 0x82, 0x46, 0xd8, 0xa8, 0xcc, 0x12, 0xcc, 0xd7, 0x72,
	0x82, 0xf9, 0x1a, 0x1e, 0x02, 0x0d, 0x67, 0xc7, 0x66, 0xec, 0x0a, 0xdd, 0xbb, 0x49, 0x6c, 0xc2,
	0x1c, 0x93, 0xf4, 0xa7, 0x7a, 0xf0, 0x14, 0x94, 0x78, 0x06, 0xec, 0x10, 0x63, 0x22, 0x4e, 0xf0,
	0xdd, 0xc9, 0x14, 0x84, 0xdc, 0xe0, 0x02, 0x63, 0x22, 0x13, 0xe6, 0x18, 0x7c, 0x06, 0x8a, 0x0c,
	0x79, 0x84, 0x85, 0xc6, 0x86, 0x38, 0xe6, 0xfb, 0x56, 0x5a, 0x83, 0x16, 0x1a, 0x7b, 0x16, 0xaf,
	0x53, 0xeb, 0xea, 0x53, 0xeb, 0x15, 0xd7, 0x68, 0xef, 0x25, 0xb1, 0xa9, 0xa7, 0xca, 0x12, 0x55,
	0x66, 0x0e, 0xcf, 0x40, 0xd1, 0x47, 0x7d, 0xec, 0x87, 0x46, 0x51, 0x10, 0x35, 0x57, 0xd7, 0x8b,
	0xf5, 0x42, 0x28, 0x1d, 0x13, 0x16, 0x4c, 0x52, 0xc6, 0xd4, 0x4a, 0x66, 0x4c, 0x11, 0x88, 0xc1,
	0x0e, 0xa3, 0x0c, 0xf9, 0x76, 0x5e, 0xf9, 0xa1, 0xb1, 0x29, 0x76, 0x5c, 0x5f, 0xa6, 0x3e, 0xcf,
	0x54, 0x5e, 0x78, 0x21, 0x4b, 0x4b, 0x48, 0x98, 0xe6, 0xb0, 0x4c, 0xbf, 0x3d, 0x2f, 0x81, 0x5f,
	0x81, 0xdd, 0x90, 0x21, 0x86, 0xed, 0xfe, 0x24, 0x2f, 0x20, 0xdb, 0x73, 0x45, 0x09, 0x95, 0x0f,
	0xbf, 0x7f, 0xcd, 0x2e, 0x2e, 0xb8, 0x45, 0x7b, 0x92, 0x56, 0xcd, 0x89, 0x9b, 0x6e, 0xe7, 0xbd,
	0x24, 0x36, 0xef, 0x87, 0xf3, 0x12, 0xc9, 0xf1, 0xce, 0x82, 0x08, 0x7e, 0xad, 0x80, 0x7b, 0x11,
	0x41, 0xbe, 0x4f, 0x1d, 0xc4, 0x50, 0xdf, 0xc7, 0xd2, 0x4e, 0xb7, 0x84, 0xfb, 0xc3, 0x6b, 0xdc,
	0xf7, 0x64, 0xab, 0xe9, 0x56, 0xd2, 0x28, 0x3e, 0x4c, 0x62, 0xb3, 0x11, 0xad, 0x54, 0x90, 0x82,
	0xb9, 0xbb, 0x5a, 0x03, 0x1e, 0x81, 0xad, 0x88, 0x64, 0x4e, 0xb9, 0xc4, 0xd8, 0x69, 0x28, 0x07,
	0x5a, 0x7b, 0x3f, 0x89, 0xcd, 0x7b, 0x73, 0x02, 0x89, 0x6b, 0xde, 0x82, 0x7f, 0x93, 0x01, 0x1e,
	0xd3, 0x80, 0x79, 0x64, 0x68, 0xf3, 0x46, 0x60, 0xb3, 0xc9, 0x18, 0x1b, 0x55, 0x51, 0xe2, 0xe2,
	0x9b, 0x9c, 0x8a, 0xf9, 0x66, 0x5e, 0x4d, 0xc6, 0x32, 0x59, 0x75, 0x49, 0x38, 0xed, 0x58, 0xf0,
	0x86, 0x8e, 0xf5, 0x57, 0x05, 0x34, 0xf2, 0x0c, 0xda, 0x51, 0x88, 0x86, 0xe2, 0x4c, 0xbf, 0x8c,
	0x70, 0x84, 0x6d, 0x44, 0x5c, 0x5b, 0x90, 0xec, 0x89, 0xc4, 0x7e, 0xb0, 0x9c, 0xd8, 0x33, 0x4a,
	0xfd, 0x97, 0x5c, 0x37, 0x4f, 0x46, 0xfb, 0x61, 0x12, 0x9b, 0x1f, 0xe5, 0x84, 0x3d, 0xce, 0xd7,
	0x9e, 0x08, 0x8d, 0x23, 0xe2, 0x9e, 0xcd, 0x07, 0xb0, 0xff, 0x0e, 0x35, 0xf8, 0x63, 0x50, 0x0e,
	0x70, 0x88, 0x83, 0x2b, 0xc4, 0x3c, 0x4a, 0x8c, 0x3b, 0x62, 0x1b, 0xf7, 0x93, 0xd8, 0xbc, 0x23,
	0xc1, 0x12, 0x99, 0xac, 0x5d, 0x43, 0xa0, 0x2c, 0x7d, 0x32, 0xf0, 0x03, 0xb0, 0x7e, 0x89, 0x27,
	0x59, 0xff, 0xa9, 0x26, 0xb1, 0xb9, 0x75, 0x89, 0x27, 0x92, 0x2d, 0x97, 0xc2, 0x87, 0x60, 0xe3,
	0x0a, 0xf9, 0x11, 0xce, 0x7a, 0xbc, 0x68, 0xd1, 0x02, 0x90, 0x5b, 0xb4, 0x00, 0x1e, 0x17, 0x1e,
	0x29, 0xb5, 0x3f, 0x28, 0x60, 0x6f, 0x55, 0x41, 0xdf, 0xce, 0xd9, 0x73, 0xd9, 0xd9, 0xf6, 0xe1,
	0x7b, 0xcb, 0x99, 0x4d, 0x49, 0x53, 0x0f, 0x37, 0xc5, 0xf2, 0xb5, 0x02, 0xf6, 0xdf, 0x51, 0xdd,
	0x72, 0x48, 0x1b, 0xd7, 0x86, 0x74, 0x22, 0x87, 0x74, 0x73, 0xbf, 0xb8, 0x21, 0xa6, 0x8e, 0xaa,
	0xad, 0xeb, 0xea, 0xf4, 0x66, 0xd0, 0xf4, 0x52, 0x47, 0xd5, 0x80, 0x5e, 0xee, 0xa8, 0x5a, 0x59,
	0xaf, 0x74, 0x54, 0x6d, 0x5b, 0xdf, 0xe9, 0xa8, 0x9a, 0xae, 0x57, 0x9b, 0x7f, 0x57, 0x40, 0x75,
	0xa9, 0x8e, 0xa6, 0xf5, 0xab, 0xdc, 0x50, 0xbf, 0x0f, 0xc1, 0x86, 0x28, 0x56, 0xf9, 0xd8, 0x04,
	0x20, 0x87, 0x25, 0x00, 0xd8, 0x03, 0xa5, 0x59, 0xaf, 0x58, 0xbf, 0xd5, 0x2e, 0xef, 0x25, 0xb1,
	0xb9, 0x1b, 0xac, 0x68, 0x05, 0x33, 0xa6, 0xe6, 0x1f, 0x0b, 0xa0, 0x22, 0x1b, 0x41, 0x57, 0xf6,
	0xa3, 0x88, 0x4f, 0xe7, 0x93, 0x77, 0xfb, 0xb1, 0x16, 0xda, 0xd1, 0x2d, 0xdc, 0xd6, 0xfe, 0xa2,
	0x80, 0xed, 0xeb, 0xcf, 0xf9, 0xfa, 0xd2, 0xfb, 0xe5, 0xfc, 0x39, 0x5b, 0xd2, 0xdd, 0x35, 0x9d,
	0x9f, 0xac, 0xf1, 0xe5, 0x50, 0x5c, 0x66, 0xb9, 0x3b, 0xeb, 0x65, 0x84, 0x08, 0xf3, 0xd8, 0xe4,
	0xa6, 0x73, 0x6f, 0x7e, 0xbb, 0x01, 0xaa, 0x1d, 0xda, 0xbf, 0x48, 0xb7, 0xeb, 0x91, 0xe1, 0x09,
	0x19, 0x50, 0x7e, 0x6d, 0xfb, 0xde, 0x00, 0xf3, 0xf9, 0x4e, 0x84, 0xb7, 0x95, 0xdd, 0xb2, 0x19,
	0x36, 0x77, 0xcb, 0x66, 0x18, 0x7c, 0x0c, 0x2a, 0x88, 0xd9, 0x23, 0x1a, 0x32, 0x9b, 0x12, 0x27,
	0x8d, 0x57, 0x6b, 0x1b, 0x49, 0x6c, 0xee, 0x21, 0xf6, 0x33, 0x1a, 0xb2, 0x53, 0xe2, 0xc8, 0x96,
	0x60, 0x86, 0xf2, 0xee, 0x31, 0x0e, 0x30, 0xc7, 0x3d, 0xde, 0x8f, 0xd7, 0x85, 0xa9, 0xe8, 0x1e,
	0x12, 0x2c, 0x77, 0x0f, 0x09, 0x86, 0xcf, 0x81, 0xee, 0x50, 0xe2, 0x44, 0x41, 0x80, 0x89, 0x33,
	0xb1, 0x43, 0x34, 0xc0, 0x86, 0x2a, 0x18, 0xc4, 0x65, 0x25, 0xc9, 0x2e, 0xd0, 0x40, 0x66, 0xd9,
	0x59, 0x10, 0xf1, 0xae, 0x3e, 0x0e, 0x3c, 0x1a, 0x78, 0x6c, 0x62, 0x3b, 0x3e, 0x0a, 0x43, 0x5b,
	0x0c, 0x39, 0xc5, 0x59, 0x57, 0xcf, 0xc5, 0x4f, 0xb8, 0xb4, 0x3b, 0x3f, 0xf1, 0x54, 0x97, 0x84,
	0xb0, 0x07, 0xca, 0x61, 0xd4, 0x1f, 0x79, 0xcc, 0x16, 0xa9, 0xdc, 0xbc, 0x71, 0x98, 0x11, 0xe9,
	0x4a, 0x4d, 0x16, 0xa6, 0x42, 0x30, 0x43, 0xf9, 0xf1, 0xe4, 0xbe, 0x0c, 0x6d, 0x76, 0x3c, 0x39,
	0x26, 0x1f, 0x4f, 0x8e, 0xc1, 0xdf, 0x81, 0xdd, 0xb4, 0x94, 0xed, 0x00, 0x7f, 0x19, 0x79, 0x01,
	0x1e, 0xe1, 0xd9, 0x44, 0xf4, 0xe1, 0x72, 0xbd, 0x9f, 0x8a, 0xbf, 0xe7, 0x92, 0x6e, 0xbb, 0x91,
	0xc4, 0xe6, 0x03, 0xba, 0x84, 0x4b, 0xee, 0xe0, 0xb2, 0x14, 0xb6, 0xc0, 0xe6, 0x15, 0x0e, 0x42,
	0x7e, 0x2b, 0x94, 0x44, 0xac, 0x77, 0x92, 0xd8, 0xac, 0x66, 0x90, 0x64, 0x9b, 0x6b, 0xc1, 0xcf,
	0x81, 0x3a, 0x44, 0x64, 0x68, 0x94, 0x45, 0xb6, 0x56, 0xcc, 0xe4, 0xcf, 0x10, 0x19, 0xa6, 0x2d,
	0x86, 0xeb, 0xc9, 0x2d, 0x86, 0xaf, 0xd3, 0xc6, 0xd5, 0xfc, 0x56, 0x01, 0x2a, 0x57, 0x84, 0x9f,
	0x80, 0x4d, 0x0e, 0xdb, 0xd3, 0x89, 0x56, 0x4c, 0x64, 0x1c, 0x9a, 0x9b, 0x5c, 0x8a, 0x29, 0xc2,
	0x4b, 0xd1, 0x41, 0x81, 0xeb, 0x11, 0xe4, 0xf3, 0xf4, 0x16, 0x44, 0xc8, 0xa2, 0x14, 0x25, 0x58,
	0x2e, 0x45, 0x09, 0x86, 0x7d, 0x50, 0x13, 0xc3, 0x40, 0x44, 0xbc, 0x01, 0x0d, 0x46, 0xbc, 0x8e,
	0xc4, 0xa0, 0x97, 0xd6, 0xd1, 0xba, 0x70, 0xff, 0x51, 0x12, 0x9b, 0xef, 0x73, 0xad, 0xde, 0x54,
	0x49, 0x5c, 0x7e, 0x0b, 0xd5, 0x74, 0xef, 0x1a, 0x95, 0xe6, 0x9f, 0x15, 0x00, 0x97, 0x0f, 0x07,
	0xfa, 0x60, 0x67, 0x4c, 0x5d, 0x19, 0x12, 0xdb, 0x2d, 0x1f, 0xbe, 0xbf, 0x6a, 0x0c, 0x98, 0x53,
	0x4c, 0xbf, 0x93, 0x05, 0xeb, 0x59, 0x28, 0xcf, 0xd7, 0xce, 0x17, 0xa9, 0xdb, 0xdb, 0xa0, 0x22,
	0x97, 0x51, 0xf3, 0xdf, 0x45, 0xb0, 0xb3, 0xc0, 0x0a, 0x43, 0x50, 0xe1, 0x7b, 0xb8, 0xc0, 0x3e,
	0x76, 0xf8, 0xfc, 0x9f, 0xb6, 0xd6, 0xcf, 0x6e, 0x0c, 0x47, 0x8c, 0x7f, 0xb9, 0x55, 0xda, 0x60,
	0x6b, 0x49, 0x6c, 0xde, 0x95, 0xc9, 0xa4, 0x44, 0xcd, 0x39, 0x81, 0x67, 0x40, 0x43, 0x83, 0x81,
	0x47, 0xf2, 0xb3, 0x2b, 0x1f, 0x3e, 0x58, 0x35, 0xed, 0x1f, 0x65, 0x3a, 0xe9, 0x87, 0x93, 0x5b,
	0xc8, 0x1f, 0x4e, 0x8e, 0xc1, 0x5f, 0x83, 0x32, 0xa3, 0x3e, 0x7f, 0x8d, 0x7a, 0x94, 0xe4, 0x2f,
	0xc5, 0xfa, 0xca, 0x27, 0xc4, 0x54, 0x2d, 0x2d, 0x18, 0xc9, 0x4c, 0x2e, 0x18, 0x09, 0x86, 0x14,
	0x94, 0x11, 0x21, 0x94, 0x65, 0xe4, 0x9b, 0xd7, 0x4d, 0xc4, 0x8b, 0x29, 0x3a, 0x9a, 0x19, 0xa5,
	0x19, 0x12, 0x0e, 0x25, 0x2a, 0xd9, 0xa1, 0x04, 0xc3, 0x0e, 0xd0, 0xf3, 0xde, 0x49, 0xc9, 0x19,
	0xf5, 0x3d, 0x67, 0x22, 0x1e, 0xac, 0xa5, 0x76, 0x3d, 0x89, 0xcd, 0xda, 0xa2, 0x4c, 0xa2, 0x59,
	0xb2, 0x83, 0xbf, 0x57, 0xc0, 0x5e, 0x7e, 0xe3, 0xcc, 0x15, 0x5e, 0x51, 0x24, 0xfe, 0x60, 0x55,
	0x8e, 0xce, 0x57, 0xe8, 0xb7, 0x9b, 0x49, 0x6c, 0xd6, 0x57, 0x31, 0x49, 0xee, 0x57, 0x7a, 0xaa,
	0x0d, 0x41, 0x75, 0xa9, 0x5a, 0xbe, 0x93, 0xf9, 0x71, 0x00, 0xf4, 0xc5, 0x9c, 0x7f, 0x17, 0x7e,
	0xb2, 0x97, 0xf8, 0x3f, 0x0a, 0x60, 0x8b, 0x37, 0xaf, 0x33, 0x1f, 0x39, 0x62, 0xa7, 0xff, 0x6f,
	0x5d, 0x0c, 0x62, 0xb0, 0xbf, 0xda, 0x47, 0x9a, 0x2c, 0x55, 0x38, 0xf9, 0x38, 0x89, 0xcd, 0xe6,
	0x0a, 0x86, 0x9f, 0x2f, 0xe4, 0xcf, 0xb8, 0x4e, 0xa7, 0xf9, 0xaf, 0x02, 0xd0, 0xf3, 0xdf, 0x8d,
	0x2e, 0x30, 0xe3, 0x4f, 0xae, 0x10, 0x3e, 0x02, 0x20, 0xff, 0xb1, 0xe1, 0x24, 0x4f, 0xa7, 0xb8,
	0x78, 0x67, 0xa8, 0x7c, 0xf1, 0xce, 0x50, 0x7e, 0xf1, 0x3a, 0x34, 0x70, 0x29, 0xc1, 0x6e, 0x36,
	0xdf, 0x88, 0xfe, 0x91, 0x63, 0x72, 0xff, 0xc8, 0x31, 0xf8, 0x39, 0xa8, 0xa4, 0xff, 0x9f, 0x63,
	0x14, 0x52, 0x92, 0xe5, 0x4f, 0x74, 0x34, 0x19, 0x97, 0x3b, 0x9a, 0x8c, 0xc3, 0x1f, 0x81, 0x52,
	0x88, 0x59, 0x7b, 0xd2, 0x0b, 0x71, 0x90, 0xe5, 0x45, 0xcc, 0x9b, 0x53, 0x50, 0x9e, 0x37, 0xa7,
	0x20, 0x7c, 0x29, 0xcc, 0x8e, 0xd8, 0x2d, 0x7f, 0x92, 0xca, 0x29, 0x8f, 0x16, 0xe7, 0x8e, 0x19,
	0xcb, 0xf7, 0x4e, 0x41, 0x59, 0x7a, 0xe6, 0xc0, 0x32, 0xd8, 0xec, 0x75, 0x7f, 0xda, 0x3d, 0xfd,
	0x45, 0x57, 0x5f, 0xe3, 0x8b, 0xb3, 0xe3, 0xee, 0xd3, 0x93, 0xee, 0x33, 0x5d, 0xe1, 0x8b, 0xf3,
	0x5e, 0xb7, 0xcb, 0x17, 0x05, 0xb8, 0x05, 0x4a, 0x17, 0xbd, 0x27, 0x4f, 0x8e, 0x8f, 0x9f, 0x1e,
	0x3f, 0xd5, 0xd7, 0x21, 0x00, 0xc5, 0x9f, 0x1c, 0x9d, 0xbc, 0x38, 0x7e, 0xaa, 0xab, 0xed, 0xdf,
	0xfc, 0xf3, 0x4d, 0x5d, 0xf9, 0xe6, 0x4d, 0x5d, 0xf9, 0xef, 0x9b, 0xba, 0xf2, 0xa7, 0xb7, 0xf5,
	0xb5, 0x6f, 0xde, 0xd6, 0xd7, 0xfe, 0xf3, 0xb6, 0xbe, 0xf6, 0xab, 0x27, 0x43, 0x8f, 0xbd, 0x8e,
	0xfa, 0x96, 0x43, 0x47, 0x2d, 0x14, 0x8c, 0x90, 0x8b, 0xc6, 0x01, 0xe5, 0xad, 0x30, 0x5b, 0xb5,
	0x6e, 0xf1, 0xc3, 0x66, 0xbf, 0x28, 0xf6, 0xf9, 0xd9, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe7,
	0x00, 0xf7, 0xa7, 0x06, 0x15, 0x00, 0x00,
}

func (m *Executor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Executor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Executor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnassignedJobRuns) > 0 {
		for iNdEx := len(m.UnassignedJobRuns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UnassignedJobRuns[iNdEx])
			copy(dAtA[i:], m.UnassignedJobRuns[iNdEx])
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.UnassignedJobRuns[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.LastUpdateTime != nil {
		{
			size, err := m.LastUpdateTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Pool) > 0 {
		i -= len(m.Pool)
		copy(dAtA[i:], m.Pool)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Pool)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reservation) > 0 {
		i -= len(m.Reservation)
		copy(dAtA[i:], m.Reservation)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Reservation)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.ResourceUsageByQueueAndPool) > 0 {
		for iNdEx := len(m.ResourceUsageByQueueAndPool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ResourceUsageByQueueAndPool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Executor) > 0 {
		i -= len(m.Executor)
		copy(dAtA[i:], m.Executor)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Executor)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Pool) > 0 {
		i -= len(m.Pool)
		copy(dAtA[i:], m.Pool)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Pool)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.ReportingNodeType) > 0 {
		i -= len(m.ReportingNodeType)
		copy(dAtA[i:], m.ReportingNodeType)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.ReportingNodeType)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Unschedulable {
		i--
		if m.Unschedulable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.UnallocatableResources) > 0 {
		for k := range m.UnallocatableResources {
			v := m.UnallocatableResources[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.StateByJobRunId) > 0 {
		for k := range m.StateByJobRunId {
			v := m.StateByJobRunId[k]
			baseI := i
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.TotalResources != nil {
		{
			size, err := m.TotalResources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Taints) > 0 {
		for iNdEx := len(m.Taints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Taints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.LastSeen != nil {
		{
			size, err := m.LastSeen.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PoolQueueResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolQueueResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolQueueResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Resources != nil {
		{
			size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pool) > 0 {
		i -= len(m.Pool)
		copy(dAtA[i:], m.Pool)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.Pool)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for k := range m.Resources {
			v := m.Resources[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobSchedulingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSchedulingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSchedulingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Gang != nil {
		{
			size, err := m.Gang.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Version != 0 {
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x48
	}
	if m.Priority != 0 {
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x40
	}
	if m.SubmitTime != nil {
		{
			size, err := m.SubmitTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PriorityClassName) > 0 {
		i -= len(m.PriorityClassName)
		copy(dAtA[i:], m.PriorityClassName)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.PriorityClassName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ObjectRequirements) > 0 {
		for iNdEx := len(m.ObjectRequirements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ObjectRequirements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ConcurrencySafe {
		i--
		if m.ConcurrencySafe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Preemptible {
		i--
		if m.Preemptible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AtMostOnce {
		i--
		if m.AtMostOnce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Lifetime != 0 {
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(m.Lifetime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Gang) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gang) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Gang) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeUniformityLabelName) > 0 {
		i -= len(m.NodeUniformityLabelName)
		copy(dAtA[i:], m.NodeUniformityLabelName)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.NodeUniformityLabelName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cardinality != 0 {
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(m.Cardinality))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GangId) > 0 {
		i -= len(m.GangId)
		copy(dAtA[i:], m.GangId)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.GangId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectRequirements) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRequirements) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRequirements) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Requirements != nil {
		{
			size := m.Requirements.Size()
			i -= size
			if _, err := m.Requirements.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ObjectRequirements_PodRequirements) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRequirements_PodRequirements) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PodRequirements != nil {
		{
			size, err := m.PodRequirements.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PodRequirements) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodRequirements) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodRequirements) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ResourceRequirements != nil {
		{
			size, err := m.ResourceRequirements.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.PreemptionPolicy) > 0 {
		i -= len(m.PreemptionPolicy)
		copy(dAtA[i:], m.PreemptionPolicy)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.PreemptionPolicy)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Tolerations) > 0 {
		for iNdEx := len(m.Tolerations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tolerations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Affinity != nil {
		{
			size, err := m.Affinity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeSelector) > 0 {
		for k := range m.NodeSelector {
			v := m.NodeSelector[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GangPlacement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GangPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GangPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeUniformityLabelValue) > 0 {
		i -= len(m.NodeUniformityLabelValue)
		copy(dAtA[i:], m.NodeUniformityLabelValue)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.NodeUniformityLabelValue)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NodeUniformityLabelName) > 0 {
		i -= len(m.NodeUniformityLabelName)
		copy(dAtA[i:], m.NodeUniformityLabelName)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.NodeUniformityLabelName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cardinality != 0 {
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(m.Cardinality))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GangId) > 0 {
		i -= len(m.GangId)
		copy(dAtA[i:], m.GangId)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.GangId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutorSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutorSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutorSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SetAtTime != nil {
		{
			size, err := m.SetAtTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedulerobjects(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SetByUser) > 0 {
		i -= len(m.SetByUser)
		copy(dAtA[i:], m.SetByUser)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.SetByUser)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CordonReason) > 0 {
		i -= len(m.CordonReason)
		copy(dAtA[i:], m.CordonReason)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.CordonReason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cordoned {
		i--
		if m.Cordoned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ExecutorId) > 0 {
		i -= len(m.ExecutorId)
		copy(dAtA[i:], m.ExecutorId)
		i = encodeVarintSchedulerobjects(dAtA, i, uint64(len(m.ExecutorId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSchedulerobjects(dAtA []byte, offset int, v uint64) int {
	offset -= sovSchedulerobjects(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Executor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	l = len(m.Pool)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovSchedulerobjects(uint64(l))
		}
	}
	if m.LastUpdateTime != nil {
		l = m.LastUpdateTime.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.UnassignedJobRuns) > 0 {
		for _, s := range m.UnassignedJobRuns {
			l = len(s)
			n += 1 + l + sovSchedulerobjects(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if m.LastSeen != nil {
		l = m.LastSeen.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.Taints) > 0 {
		for _, e := range m.Taints {
			l = e.Size()
			n += 1 + l + sovSchedulerobjects(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchedulerobjects(uint64(len(k))) + 1 + len(v) + sovSchedulerobjects(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	if m.TotalResources != nil {
		l = m.TotalResources.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.StateByJobRunId) > 0 {
		for k, v := range m.StateByJobRunId {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchedulerobjects(uint64(len(k))) + 1 + sovSchedulerobjects(uint64(v))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.UnallocatableResources) > 0 {
		for k, v := range m.UnallocatableResources {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSchedulerobjects(uint64(l))
			}
			mapEntrySize := 1 + sovSchedulerobjects(uint64(k)) + l
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	if m.Unschedulable {
		n += 2
	}
	l = len(m.ReportingNodeType)
	if l > 0 {
		n += 2 + l + sovSchedulerobjects(uint64(l))
	}
	l = len(m.Pool)
	if l > 0 {
		n += 2 + l + sovSchedulerobjects(uint64(l))
	}
	l = len(m.Executor)
	if l > 0 {
		n += 2 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.ResourceUsageByQueueAndPool) > 0 {
		for _, e := range m.ResourceUsageByQueueAndPool {
			l = e.Size()
			n += 2 + l + sovSchedulerobjects(uint64(l))
		}
	}
	l = len(m.Reservation)
	if l > 0 {
		n += 2 + l + sovSchedulerobjects(uint64(l))
	}
	return n
}

func (m *PoolQueueResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pool)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	return n
}

func (m *ResourceList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for k, v := range m.Resources {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSchedulerobjects(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSchedulerobjects(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *JobSchedulingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lifetime != 0 {
		n += 1 + sovSchedulerobjects(uint64(m.Lifetime))
	}
	if m.AtMostOnce {
		n += 2
	}
	if m.Preemptible {
		n += 2
	}
	if m.ConcurrencySafe {
		n += 2
	}
	if len(m.ObjectRequirements) > 0 {
		for _, e := range m.ObjectRequirements {
			l = e.Size()
			n += 1 + l + sovSchedulerobjects(uint64(l))
		}
	}
	l = len(m.PriorityClassName)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if m.SubmitTime != nil {
		l = m.SubmitTime.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovSchedulerobjects(uint64(m.Priority))
	}
	if m.Version != 0 {
		n += 1 + sovSchedulerobjects(uint64(m.Version))
	}
	if m.Gang != nil {
		l = m.Gang.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	return n
}

func (m *Gang) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GangId)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if m.Cardinality != 0 {
		n += 1 + sovSchedulerobjects(uint64(m.Cardinality))
	}
	l = len(m.NodeUniformityLabelName)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	return n
}

func (m *ObjectRequirements) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Requirements != nil {
		n += m.Requirements.Size()
	}
	return n
}

func (m *ObjectRequirements_PodRequirements) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PodRequirements != nil {
		l = m.PodRequirements.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	return n
}
func (m *PodRequirements) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchedulerobjects(uint64(len(k))) + 1 + len(v) + sovSchedulerobjects(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	if m.Affinity != nil {
		l = m.Affinity.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.Tolerations) > 0 {
		for _, e := range m.Tolerations {
			l = e.Size()
			n += 1 + l + sovSchedulerobjects(uint64(l))
		}
	}
	l = len(m.PreemptionPolicy)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if m.ResourceRequirements != nil {
		l = m.ResourceRequirements.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSchedulerobjects(uint64(len(k))) + 1 + len(v) + sovSchedulerobjects(uint64(len(v)))
			n += mapEntrySize + 1 + sovSchedulerobjects(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GangPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GangId)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if m.Cardinality != 0 {
		n += 1 + sovSchedulerobjects(uint64(m.Cardinality))
	}
	l = len(m.NodeUniformityLabelName)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	l = len(m.NodeUniformityLabelValue)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	return n
}

func (m *ExecutorSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExecutorId)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if m.Cordoned {
		n += 2
	}
	l = len(m.CordonReason)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	l = len(m.SetByUser)
	if l > 0 {
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	if m.SetAtTime != nil {
		l = m.SetAtTime.Size()
		n += 1 + l + sovSchedulerobjects(uint64(l))
	}
	return n
}

func sovSchedulerobjects(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSchedulerobjects(x uint64) (n int) {
	return sovSchedulerobjects(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Executor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Executor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Executor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdateTime == nil {
				m.LastUpdateTime = &types.Timestamp{}
			}
			if err := m.LastUpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnassignedJobRuns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnassignedJobRuns = append(m.UnassignedJobRuns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSeen == nil {
				m.LastSeen = &types.Timestamp{}
			}
			if err := m.LastSeen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Taints = append(m.Taints, &v1.Taint{})
			if err := m.Taints[len(m.Taints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalResources == nil {
				m.TotalResources = &ResourceList{}
			}
			if err := m.TotalResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateByJobRunId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StateByJobRunId == nil {
				m.StateByJobRunId = make(map[string]JobRunState)
			}
			var mapkey string
			var mapvalue JobRunState
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= JobRunState(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.StateByJobRunId[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnallocatableResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnallocatableResources == nil {
				m.UnallocatableResources = make(map[int32]*ResourceList)
			}
			var mapkey int32
			var mapvalue *ResourceList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ResourceList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UnallocatableResources[mapkey] = mapvalue
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unschedulable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unschedulable = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportingNodeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportingNodeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUsageByQueueAndPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceUsageByQueueAndPool = append(m.ResourceUsageByQueueAndPool, &PoolQueueResource{})
			if err := m.ResourceUsageByQueueAndPool[len(m.ResourceUsageByQueueAndPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reservation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reservation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolQueueResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolQueueResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolQueueResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pool = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &ResourceList{}
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = make(map[string]*resource.Quantity)
			}
			var mapkey string
			var mapvalue *resource.Quantity
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Resources[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSchedulingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSchedulingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSchedulingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lifetime", wireType)
			}
			m.Lifetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lifetime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtMostOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AtMostOnce = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preemptible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Preemptible = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcurrencySafe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConcurrencySafe = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectRequirements = append(m.ObjectRequirements, &ObjectRequirements{})
			if err := m.ObjectRequirements[len(m.ObjectRequirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubmitTime == nil {
				m.SubmitTime = &types.Timestamp{}
			}
			if err := m.SubmitTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gang", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gang == nil {
				m.Gang = &Gang{}
			}
			if err := m.Gang.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gang) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gang: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gang: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GangId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GangId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cardinality", wireType)
			}
			m.Cardinality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cardinality |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeUniformityLabelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeUniformityLabelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRequirements) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRequirements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRequirements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodRequirements{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Requirements = &ObjectRequirements_PodRequirements{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodRequirements) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodRequirements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodRequirements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Affinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Affinity == nil {
				m.Affinity = &v1.Affinity{}
			}
			if err := m.Affinity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tolerations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tolerations = append(m.Tolerations, &v1.Toleration{})
			if err := m.Tolerations[len(m.Tolerations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreemptionPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreemptionPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceRequirements == nil {
				m.ResourceRequirements = &v1.ResourceRequirements{}
			}
			if err := m.ResourceRequirements.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchedulerobjects
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchedulerobjects
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSchedulerobjects
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GangPlacement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GangPlacement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GangPlacement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GangId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GangId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cardinality", wireType)
			}
			m.Cardinality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cardinality |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeUniformityLabelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeUniformityLabelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeUniformityLabelValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeUniformityLabelValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutorSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutorSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutorSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cordoned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cordoned = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CordonReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CordonReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetByUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SetByUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetAtTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SetAtTime == nil {
				m.SetAtTime = &types.Timestamp{}
			}
			if err := m.SetAtTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulerobjects(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedulerobjects
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSchedulerobjects(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSchedulerobjects
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchedulerobjects
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSchedulerobjects
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSchedulerobjects
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSchedulerobjects
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSchedulerobjects        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSchedulerobjects          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSchedulerobjects = fmt.Errorf("proto: unexpected end of group")
)
