// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal/scheduler/simulator/simulator.proto

package simulator

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	schedulerobjects "github.com/armadaproject/armada/internal/scheduler/schedulerobjects"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	v1 "k8s.io/api/core/v1"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ClusterSpec struct {
	Name                             string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Pools                            []*Pool            `protobuf:"bytes,2,rep,name=pools,proto3" json:"pools,omitempty"`
	WorkflowManagerDelayDistribution ShiftedExponential `protobuf:"bytes,3,opt,name=workflow_manager_delay_distribution,json=workflowManagerDelayDistribution,proto3" json:"workflowManagerDelayDistribution"`
	PendingDelayDistribution         ShiftedExponential `protobuf:"bytes,4,opt,name=pending_delay_distribution,json=pendingDelayDistribution,proto3" json:"pendingDelayDistribution"`
}

func (m *ClusterSpec) Reset()         { *m = ClusterSpec{} }
func (m *ClusterSpec) String() string { return proto.CompactTextString(m) }
func (*ClusterSpec) ProtoMessage()    {}
func (*ClusterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{0}
}
func (m *ClusterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterSpec.Merge(m, src)
}
func (m *ClusterSpec) XXX_Size() int {
	return m.Size()
}
func (m *ClusterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterSpec proto.InternalMessageInfo

func (m *ClusterSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterSpec) GetPools() []*Pool {
	if m != nil {
		return m.Pools
	}
	return nil
}

func (m *ClusterSpec) GetWorkflowManagerDelayDistribution() ShiftedExponential {
	if m != nil {
		return m.WorkflowManagerDelayDistribution
	}
	return ShiftedExponential{}
}

func (m *ClusterSpec) GetPendingDelayDistribution() ShiftedExponential {
	if m != nil {
		return m.PendingDelayDistribution
	}
	return ShiftedExponential{}
}

type WorkloadSpec struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Random seed used in simulations; use to ensure simulations are reproducible.
	// If not provided, or explicitly set to 0, the current time is used.
	RandomSeed int64    `protobuf:"varint,2,opt,name=random_seed,json=randomSeed,proto3" json:"randomSeed,omitempty"`
	Queues     []*Queue `protobuf:"bytes,3,rep,name=queues,proto3" json:"queues,omitempty"`
}

func (m *WorkloadSpec) Reset()         { *m = WorkloadSpec{} }
func (m *WorkloadSpec) String() string { return proto.CompactTextString(m) }
func (*WorkloadSpec) ProtoMessage()    {}
func (*WorkloadSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{1}
}
func (m *WorkloadSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkloadSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkloadSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkloadSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkloadSpec.Merge(m, src)
}
func (m *WorkloadSpec) XXX_Size() int {
	return m.Size()
}
func (m *WorkloadSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkloadSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WorkloadSpec proto.InternalMessageInfo

func (m *WorkloadSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WorkloadSpec) GetRandomSeed() int64 {
	if m != nil {
		return m.RandomSeed
	}
	return 0
}

func (m *WorkloadSpec) GetQueues() []*Queue {
	if m != nil {
		return m.Queues
	}
	return nil
}

type Pool struct {
	Name          string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ClusterGroups []*ClusterGroup `protobuf:"bytes,2,rep,name=cluster_groups,json=clusterGroups,proto3" json:"clusterGroups,omitempty"`
}

func (m *Pool) Reset()         { *m = Pool{} }
func (m *Pool) String() string { return proto.CompactTextString(m) }
func (*Pool) ProtoMessage()    {}
func (*Pool) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{2}
}
func (m *Pool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pool.Merge(m, src)
}
func (m *Pool) XXX_Size() int {
	return m.Size()
}
func (m *Pool) XXX_DiscardUnknown() {
	xxx_messageInfo_Pool.DiscardUnknown(m)
}

var xxx_messageInfo_Pool proto.InternalMessageInfo

func (m *Pool) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pool) GetClusterGroups() []*ClusterGroup {
	if m != nil {
		return m.ClusterGroups
	}
	return nil
}

type ClusterGroup struct {
	Clusters []*Cluster `protobuf:"bytes,1,rep,name=clusters,proto3" json:"clusters,omitempty"`
}

func (m *ClusterGroup) Reset()         { *m = ClusterGroup{} }
func (m *ClusterGroup) String() string { return proto.CompactTextString(m) }
func (*ClusterGroup) ProtoMessage()    {}
func (*ClusterGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{3}
}
func (m *ClusterGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterGroup.Merge(m, src)
}
func (m *ClusterGroup) XXX_Size() int {
	return m.Size()
}
func (m *ClusterGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterGroup.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterGroup proto.InternalMessageInfo

func (m *ClusterGroup) GetClusters() []*Cluster {
	if m != nil {
		return m.Clusters
	}
	return nil
}

type Cluster struct {
	Name          string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	NodeTemplates []*NodeTemplate `protobuf:"bytes,2,rep,name=node_templates,json=nodeTemplates,proto3" json:"nodeTemplates,omitempty"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{4}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetNodeTemplates() []*NodeTemplate {
	if m != nil {
		return m.NodeTemplates
	}
	return nil
}

type NodeTemplate struct {
	Number         int64                         `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	Taints         []v1.Taint                    `protobuf:"bytes,2,rep,name=taints,proto3" json:"taints"`
	Labels         map[string]string             `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TotalResources schedulerobjects.ResourceList `protobuf:"bytes,4,opt,name=total_resources,json=totalResources,proto3" json:"totalResources"`
}

func (m *NodeTemplate) Reset()         { *m = NodeTemplate{} }
func (m *NodeTemplate) String() string { return proto.CompactTextString(m) }
func (*NodeTemplate) ProtoMessage()    {}
func (*NodeTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{5}
}
func (m *NodeTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTemplate.Merge(m, src)
}
func (m *NodeTemplate) XXX_Size() int {
	return m.Size()
}
func (m *NodeTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTemplate proto.InternalMessageInfo

func (m *NodeTemplate) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *NodeTemplate) GetTaints() []v1.Taint {
	if m != nil {
		return m.Taints
	}
	return nil
}

func (m *NodeTemplate) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *NodeTemplate) GetTotalResources() schedulerobjects.ResourceList {
	if m != nil {
		return m.TotalResources
	}
	return schedulerobjects.ResourceList{}
}

type Queue struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Determines the fair share of the queue.
	Weight       float64        `protobuf:"fixed64,2,opt,name=weight,proto3" json:"weight,omitempty"`
	JobTemplates []*JobTemplate `protobuf:"bytes,3,rep,name=job_templates,json=jobTemplates,proto3" json:"jobTemplates,omitempty"`
}

func (m *Queue) Reset()         { *m = Queue{} }
func (m *Queue) String() string { return proto.CompactTextString(m) }
func (*Queue) ProtoMessage()    {}
func (*Queue) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{6}
}
func (m *Queue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Queue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Queue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Queue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Queue.Merge(m, src)
}
func (m *Queue) XXX_Size() int {
	return m.Size()
}
func (m *Queue) XXX_DiscardUnknown() {
	xxx_messageInfo_Queue.DiscardUnknown(m)
}

var xxx_messageInfo_Queue proto.InternalMessageInfo

func (m *Queue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Queue) GetWeight() float64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Queue) GetJobTemplates() []*JobTemplate {
	if m != nil {
		return m.JobTemplates
	}
	return nil
}

type JobTemplate struct {
	// Number of jobs to create from this template.
	Number int64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// Number of jobs created from this template that have succeeded.
	// Maintained by the simulator.
	NumberSuccessful int64 `protobuf:"varint,2,opt,name=numberSuccessful,proto3" json:"numberSuccessful,omitempty"`
	// Queue to which this template belongs. Populated automatically.
	Queue string `protobuf:"bytes,3,opt,name=queue,proto3" json:"queue,omitempty"`
	// Unique id for this template. An id is generated if empty.
	Id                string `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	JobSet            string `protobuf:"bytes,5,opt,name=job_set,json=jobSet,proto3" json:"jobSet,omitempty"`
	QueuePriority     uint32 `protobuf:"varint,6,opt,name=queue_priority,json=queuePriority,proto3" json:"queuePriority,omitempty"`
	PriorityClassName string `protobuf:"bytes,7,opt,name=priority_class_name,json=priorityClassName,proto3" json:"priorityClassName,omitempty"`
	// Scheduling requirements for the pod embedded in the job.
	Requirements schedulerobjects.PodRequirements `protobuf:"bytes,8,opt,name=requirements,proto3" json:"requirements"`
	// List of template ids that must be completed before this template is submitted.
	Dependencies []string `protobuf:"bytes,9,rep,name=dependencies,proto3" json:"dependencies,omitempty"`
	// Earliest time at which jobs from this template are submitted.
	// Measured from the start of the simulation.
	EarliestSubmitTime time.Duration `protobuf:"bytes,10,opt,name=earliest_submit_time,json=earliestSubmitTime,proto3,stdduration" json:"earliestSubmitTime"`
	// Earliest time job can be submitted from when all its dependencies have completed.
	// This option is meant to model thinking or processing time, where some fixed amount of time
	// needs to be spent between dependencies completing and the next batch of jobs being ready to submit.
	EarliestSubmitTimeFromDependencyCompletion time.Duration `protobuf:"bytes,11,opt,name=earliest_submit_time_from_dependency_completion,json=earliestSubmitTimeFromDependencyCompletion,proto3,stdduration" json:"earliestSubmitTimeFromDependencyCompletion"`
	// Job runtimes are assumed to follow a shifted exponential distribution
	// i.e., to be a fixed constant (runtime_minimum) plus a random amount of time
	// drawn from an exponential distribution with known mean (runtime_tail_mean).
	//
	// The shifted-exponential distribution strikes a good balance between simplicity and accuracy;
	// see https://bora.uib.no/bora-xmlui/bitstream/handle/11250/3014726/drthesis_2022_severinson.pdf?sequence=2
	// for a discussion on the topic.
	RuntimeDistribution ShiftedExponential `protobuf:"bytes,12,opt,name=runtime_distribution,json=runtimeDistribution,proto3" json:"runtimeDistribution"`
	// Each job submitted from this template fails with this probability.
	FailureProbability float64 `protobuf:"fixed64,13,opt,name=failure_probability,json=failureProbability,proto3" json:"failureProbability,omitempty"`
	// Runtime distribution of jobs that fail.
	FailureRuntimeDistribution ShiftedExponential `protobuf:"bytes,14,opt,name=failure_runtime_distribution,json=failureRuntimeDistribution,proto3" json:"failureRuntimeDistribution"`
}

func (m *JobTemplate) Reset()         { *m = JobTemplate{} }
func (m *JobTemplate) String() string { return proto.CompactTextString(m) }
func (*JobTemplate) ProtoMessage()    {}
func (*JobTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{7}
}
func (m *JobTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobTemplate.Merge(m, src)
}
func (m *JobTemplate) XXX_Size() int {
	return m.Size()
}
func (m *JobTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_JobTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_JobTemplate proto.InternalMessageInfo

func (m *JobTemplate) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *JobTemplate) GetNumberSuccessful() int64 {
	if m != nil {
		return m.NumberSuccessful
	}
	return 0
}

func (m *JobTemplate) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *JobTemplate) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *JobTemplate) GetJobSet() string {
	if m != nil {
		return m.JobSet
	}
	return ""
}

func (m *JobTemplate) GetQueuePriority() uint32 {
	if m != nil {
		return m.QueuePriority
	}
	return 0
}

func (m *JobTemplate) GetPriorityClassName() string {
	if m != nil {
		return m.PriorityClassName
	}
	return ""
}

func (m *JobTemplate) GetRequirements() schedulerobjects.PodRequirements {
	if m != nil {
		return m.Requirements
	}
	return schedulerobjects.PodRequirements{}
}

func (m *JobTemplate) GetDependencies() []string {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func (m *JobTemplate) GetEarliestSubmitTime() time.Duration {
	if m != nil {
		return m.EarliestSubmitTime
	}
	return 0
}

func (m *JobTemplate) GetEarliestSubmitTimeFromDependencyCompletion() time.Duration {
	if m != nil {
		return m.EarliestSubmitTimeFromDependencyCompletion
	}
	return 0
}

func (m *JobTemplate) GetRuntimeDistribution() ShiftedExponential {
	if m != nil {
		return m.RuntimeDistribution
	}
	return ShiftedExponential{}
}

func (m *JobTemplate) GetFailureProbability() float64 {
	if m != nil {
		return m.FailureProbability
	}
	return 0
}

func (m *JobTemplate) GetFailureRuntimeDistribution() ShiftedExponential {
	if m != nil {
		return m.FailureRuntimeDistribution
	}
	return ShiftedExponential{}
}

type ShiftedExponential struct {
	Minimum  time.Duration `protobuf:"bytes,1,opt,name=minimum,proto3,stdduration" json:"minimum"`
	TailMean time.Duration `protobuf:"bytes,2,opt,name=tail_mean,json=tailMean,proto3,stdduration" json:"tailMean"`
}

func (m *ShiftedExponential) Reset()         { *m = ShiftedExponential{} }
func (m *ShiftedExponential) String() string { return proto.CompactTextString(m) }
func (*ShiftedExponential) ProtoMessage()    {}
func (*ShiftedExponential) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{8}
}
func (m *ShiftedExponential) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShiftedExponential) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShiftedExponential.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShiftedExponential) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShiftedExponential.Merge(m, src)
}
func (m *ShiftedExponential) XXX_Size() int {
	return m.Size()
}
func (m *ShiftedExponential) XXX_DiscardUnknown() {
	xxx_messageInfo_ShiftedExponential.DiscardUnknown(m)
}

var xxx_messageInfo_ShiftedExponential proto.InternalMessageInfo

func (m *ShiftedExponential) GetMinimum() time.Duration {
	if m != nil {
		return m.Minimum
	}
	return 0
}

func (m *ShiftedExponential) GetTailMean() time.Duration {
	if m != nil {
		return m.TailMean
	}
	return 0
}

func init() {
	proto.RegisterType((*ClusterSpec)(nil), "simulator.ClusterSpec")
	proto.RegisterType((*WorkloadSpec)(nil), "simulator.WorkloadSpec")
	proto.RegisterType((*Pool)(nil), "simulator.Pool")
	proto.RegisterType((*ClusterGroup)(nil), "simulator.ClusterGroup")
	proto.RegisterType((*Cluster)(nil), "simulator.Cluster")
	proto.RegisterType((*NodeTemplate)(nil), "simulator.NodeTemplate")
	proto.RegisterMapType((map[string]string)(nil), "simulator.NodeTemplate.LabelsEntry")
	proto.RegisterType((*Queue)(nil), "simulator.Queue")
	proto.RegisterType((*JobTemplate)(nil), "simulator.JobTemplate")
	proto.RegisterType((*ShiftedExponential)(nil), "simulator.ShiftedExponential")
}

func init() {
	proto.RegisterFile("internal/scheduler/simulator/simulator.proto", fileDescriptor_63baccdfe9127510)
}

var fileDescriptor_63baccdfe9127510 = []byte{
	// 1263 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0x41, 0x6f, 0x13, 0x47,
	0x14, 0xce, 0xc6, 0xc4, 0xc1, 0x63, 0x27, 0xc0, 0x24, 0x0a, 0xc6, 0xb4, 0x5e, 0xd7, 0x48, 0x95,
	0x5b, 0x85, 0xb5, 0xa0, 0x52, 0x45, 0x51, 0x85, 0xd4, 0x25, 0xd0, 0x0a, 0x01, 0x0d, 0x0e, 0x02,
	0xa9, 0x1c, 0x56, 0xb3, 0xbb, 0x2f, 0xce, 0x24, 0xbb, 0x3b, 0x66, 0x76, 0x16, 0xea, 0x43, 0x4f,
	0x3d, 0x55, 0x95, 0xaa, 0x9e, 0x50, 0xef, 0xbd, 0xf6, 0xd2, 0x0b, 0xbf, 0x81, 0x23, 0xc7, 0x9e,
	0xb6, 0x15, 0xdc, 0xf6, 0x57, 0x54, 0x3b, 0x3b, 0xeb, 0x8c, 0xb1, 0x09, 0xc9, 0x29, 0x3b, 0xdf,
	0xf7, 0xde, 0x9b, 0x6f, 0xde, 0xbc, 0xf7, 0x3c, 0x41, 0x9b, 0x34, 0x12, 0xc0, 0x23, 0x12, 0xf4,
	0x63, 0x6f, 0x0f, 0xfc, 0x24, 0x00, 0xde, 0x8f, 0x69, 0x98, 0x04, 0x44, 0x30, 0xed, 0xcb, 0x1a,
	0x71, 0x26, 0x18, 0xae, 0x4d, 0x80, 0x56, 0x7b, 0xc8, 0xd8, 0x30, 0x80, 0xbe, 0x24, 0xdc, 0x64,
	0xb7, 0xef, 0x27, 0x9c, 0x08, 0xca, 0xa2, 0xc2, 0xb4, 0xd5, 0x3d, 0xb8, 0x16, 0x5b, 0x94, 0xf5,
	0xc9, 0x88, 0xf6, 0x3d, 0xc6, 0xa1, 0xff, 0xec, 0x4a, 0x7f, 0x08, 0x11, 0x70, 0x22, 0xc0, 0x57,
	0x36, 0x97, 0x87, 0x54, 0xec, 0x25, 0xae, 0xe5, 0xb1, 0xb0, 0x3f, 0x64, 0x43, 0x76, 0x18, 0x2c,
	0x5f, 0xc9, 0x85, 0xfc, 0x52, 0xe6, 0xd7, 0xe7, 0x69, 0x2d, 0xbf, 0x98, 0xbb, 0x0f, 0x9e, 0x88,
	0x67, 0x80, 0xc2, 0xb7, 0xfb, 0x4b, 0x05, 0xd5, 0x6f, 0x06, 0x49, 0x2c, 0x80, 0xef, 0x8c, 0xc0,
	0xc3, 0x9f, 0xa2, 0x53, 0x11, 0x09, 0xa1, 0x69, 0x74, 0x8c, 0x5e, 0xcd, 0xc6, 0x59, 0x6a, 0xae,
	0xe6, 0xeb, 0x4d, 0x16, 0x52, 0x01, 0xe1, 0x48, 0x8c, 0x07, 0x92, 0xc7, 0xd7, 0xd1, 0xd2, 0x88,
	0xb1, 0x20, 0x6e, 0x2e, 0x76, 0x2a, 0xbd, 0xfa, 0xd5, 0x33, 0xd6, 0x61, 0x4a, 0xb6, 0x19, 0x0b,
	0xec, 0xb5, 0x2c, 0x35, 0xcf, 0x48, 0x0b, 0xcd, 0xb5, 0x70, 0xc1, 0x2f, 0x0c, 0x74, 0xe9, 0x39,
	0xe3, 0x07, 0xbb, 0x01, 0x7b, 0xee, 0x84, 0x24, 0x22, 0x43, 0xe0, 0x8e, 0x0f, 0x01, 0x19, 0x3b,
	0x3e, 0x8d, 0x05, 0xa7, 0x6e, 0x92, 0x27, 0xac, 0x59, 0xe9, 0x18, 0xbd, 0xfa, 0xd5, 0x8f, 0xb5,
	0xd0, 0x3b, 0x7b, 0x74, 0x57, 0x80, 0x7f, 0xeb, 0xc7, 0x11, 0x8b, 0x20, 0x12, 0x94, 0x04, 0x76,
	0xef, 0x55, 0x6a, 0x2e, 0x64, 0xa9, 0xd9, 0x29, 0x23, 0xde, 0x2b, 0x02, 0x6e, 0xe5, 0xf1, 0xb6,
	0xb4, 0x70, 0x83, 0x0f, 0x5a, 0xe0, 0x9f, 0x50, 0x6b, 0x04, 0x91, 0x4f, 0xa3, 0xe1, 0x3c, 0x39,
	0xa7, 0x8e, 0x23, 0xa7, 0xa3, 0xe4, 0x34, 0x55, 0xa0, 0x59, 0x19, 0xef, 0x65, 0xba, 0x7f, 0x1b,
	0xa8, 0xf1, 0x98, 0xf1, 0x83, 0x80, 0x11, 0xff, 0x44, 0x97, 0xf1, 0x15, 0xaa, 0x73, 0x12, 0xf9,
	0x2c, 0x74, 0x62, 0x00, 0xbf, 0xb9, 0xd8, 0x31, 0x7a, 0x15, 0xbb, 0x99, 0xa5, 0xe6, 0x7a, 0x01,
	0xef, 0x00, 0xf8, 0x9a, 0x13, 0x3a, 0x44, 0xf1, 0x0d, 0x54, 0x7d, 0x9a, 0x40, 0x02, 0x71, 0xb3,
	0x22, 0x2f, 0xf2, 0xac, 0x76, 0xbc, 0x07, 0x39, 0x61, 0xaf, 0x67, 0xa9, 0x79, 0xb6, 0xb0, 0xd1,
	0x62, 0x28, 0xaf, 0xee, 0xaf, 0x06, 0x3a, 0x95, 0x5f, 0xf8, 0xb1, 0xb5, 0x3e, 0x41, 0xab, 0x5e,
	0x51, 0x6f, 0xce, 0x90, 0xb3, 0x64, 0x54, 0x56, 0xd0, 0x79, 0x6d, 0x63, 0x55, 0x90, 0xdf, 0xe6,
	0xbc, 0x7d, 0x31, 0x4b, 0xcd, 0xf3, 0x9e, 0x86, 0xe8, 0x32, 0x56, 0xa6, 0x88, 0xee, 0x23, 0xd4,
	0xd0, 0x7d, 0xf1, 0x6d, 0x74, 0x5a, 0x19, 0xc4, 0x4d, 0x43, 0x6e, 0x83, 0x67, 0xb7, 0xb1, 0x37,
	0xb2, 0xd4, 0xc4, 0xa5, 0x9d, 0x16, 0x7c, 0xe2, 0xdb, 0xfd, 0xcd, 0x40, 0xcb, 0xca, 0xfa, 0x24,
	0x07, 0x8d, 0x98, 0x0f, 0x4e, 0x0e, 0x06, 0x44, 0xc0, 0xbc, 0x83, 0xde, 0x67, 0x3e, 0x3c, 0x54,
	0x7c, 0x71, 0xd0, 0x48, 0x43, 0xa6, 0x0e, 0x3a, 0x45, 0x74, 0x5f, 0x54, 0x50, 0x43, 0x77, 0xc6,
	0x9b, 0xa8, 0x1a, 0x25, 0xa1, 0x0b, 0x5c, 0xea, 0xaa, 0x14, 0xb7, 0x56, 0x20, 0xfa, 0xad, 0x15,
	0x08, 0xfe, 0x06, 0x55, 0x05, 0xa1, 0x91, 0x28, 0x35, 0x5d, 0xb0, 0x8a, 0xa9, 0x64, 0x91, 0x11,
	0xb5, 0xf2, 0xa9, 0x64, 0x3d, 0xbb, 0x62, 0x3d, 0xcc, 0x2d, 0xec, 0x55, 0x55, 0xd0, 0xca, 0x61,
	0xa0, 0xfe, 0xe2, 0x07, 0xa8, 0x1a, 0x10, 0x17, 0x82, 0xb2, 0x70, 0x2e, 0xbd, 0xe7, 0x58, 0xd6,
	0x5d, 0x69, 0x75, 0x2b, 0x12, 0x7c, 0x5c, 0xa8, 0x2a, 0xdc, 0x74, 0x55, 0x05, 0x82, 0x1d, 0x74,
	0x46, 0x30, 0x41, 0x02, 0x87, 0x43, 0xcc, 0x12, 0xee, 0x41, 0xac, 0x7a, 0xae, 0x6d, 0xcd, 0x4c,
	0xaf, 0x81, 0x32, 0xb9, 0x4b, 0x63, 0x61, 0x6f, 0x28, 0x8d, 0xab, 0xd2, 0xbd, 0xa4, 0xe2, 0xc1,
	0x3b, 0xeb, 0x16, 0x41, 0x75, 0x4d, 0x0d, 0xbe, 0x84, 0x2a, 0x07, 0x30, 0x56, 0x17, 0x79, 0x2e,
	0x4b, 0xcd, 0x95, 0x03, 0x18, 0x6b, 0xba, 0x72, 0x16, 0x7f, 0x86, 0x96, 0x9e, 0x91, 0x20, 0x01,
	0xd9, 0x55, 0xb5, 0x62, 0xae, 0x49, 0x40, 0x9f, 0x6b, 0x12, 0xb8, 0xbe, 0x78, 0xcd, 0xe8, 0xbe,
	0x34, 0xd0, 0x92, 0xec, 0x9b, 0x63, 0xd7, 0xc9, 0x26, 0xaa, 0x3e, 0x07, 0x3a, 0xdc, 0x13, 0x72,
	0x07, 0xa3, 0xc8, 0x51, 0x81, 0xe8, 0x39, 0x2a, 0x10, 0xfc, 0x18, 0xad, 0xec, 0x33, 0x57, 0x2b,
	0xaa, 0x22, 0xfb, 0x1b, 0x5a, 0xf6, 0xef, 0x30, 0x77, 0x52, 0x53, 0xad, 0x2c, 0x35, 0x37, 0xf6,
	0x0f, 0x01, 0x3d, 0xed, 0x0d, 0x1d, 0xef, 0xfe, 0x59, 0x43, 0x75, 0xcd, 0xf3, 0x84, 0x05, 0x75,
	0x07, 0x29, 0x6e, 0x27, 0xf1, 0x3c, 0x88, 0xe3, 0xdd, 0x24, 0x50, 0x63, 0xa8, 0x9d, 0xa5, 0x66,
	0xeb, 0x5d, 0x4e, 0x8b, 0x30, 0xe3, 0x97, 0x67, 0x5c, 0x0e, 0x17, 0x39, 0xff, 0x55, 0xc6, 0x25,
	0xa0, 0x67, 0x5c, 0x02, 0xb8, 0x83, 0x16, 0xa9, 0x2f, 0x8b, 0xa4, 0x66, 0x9f, 0xcd, 0x52, 0xb3,
	0x41, 0xf5, 0x39, 0xb7, 0x48, 0x7d, 0x7c, 0x19, 0x2d, 0xe7, 0xf9, 0x8a, 0x41, 0x34, 0x97, 0xa4,
	0x99, 0x3c, 0xc7, 0x3e, 0x73, 0x77, 0x60, 0x2a, 0xbd, 0x05, 0x82, 0x6d, 0xb4, 0x2a, 0x23, 0x3b,
	0x23, 0x4e, 0x19, 0xa7, 0x62, 0xdc, 0xac, 0x76, 0x8c, 0xde, 0x4a, 0xd1, 0x9b, 0x92, 0xd9, 0x56,
	0x84, 0xde, 0x9b, 0x53, 0x04, 0xfe, 0x1e, 0xad, 0x95, 0xde, 0x8e, 0x17, 0x90, 0x38, 0x76, 0x64,
	0x1d, 0x2c, 0xcb, 0xed, 0xcd, 0x2c, 0x35, 0x2f, 0x96, 0xf4, 0xcd, 0x9c, 0xbd, 0x3f, 0x5d, 0x14,
	0xe7, 0x66, 0x48, 0xfc, 0x04, 0x35, 0x38, 0x3c, 0x4d, 0x28, 0x87, 0x10, 0xf2, 0x9e, 0x3d, 0x2d,
	0x9b, 0xe2, 0x93, 0xd9, 0xa6, 0xd8, 0x66, 0xfe, 0x40, 0x33, 0xb4, 0xd7, 0x55, 0x5f, 0x4c, 0xb9,
	0x0f, 0xa6, 0x56, 0xf8, 0x06, 0x6a, 0xf8, 0x90, 0xff, 0x24, 0x41, 0xe4, 0x51, 0x88, 0x9b, 0xb5,
	0x4e, 0xa5, 0x57, 0x2b, 0xea, 0x46, 0xc7, 0xf5, 0xba, 0xd1, 0x71, 0x7c, 0x80, 0xd6, 0x81, 0xf0,
	0x80, 0x42, 0x2c, 0x9c, 0x38, 0x71, 0x43, 0x2a, 0x1c, 0x41, 0x43, 0x68, 0x22, 0x29, 0xf2, 0x82,
	0x55, 0x3c, 0x87, 0xac, 0xf2, 0x05, 0x63, 0x6d, 0xa9, 0xe7, 0x90, 0xdd, 0x56, 0xe2, 0x70, 0xe9,
	0xbe, 0x23, 0xbd, 0x1f, 0xd2, 0x10, 0xfe, 0xf8, 0xd7, 0x34, 0x06, 0x73, 0x70, 0xfc, 0xd2, 0x40,
	0xfd, 0x79, 0xbb, 0x39, 0xbb, 0x9c, 0x85, 0xce, 0x44, 0xd7, 0xd8, 0xf1, 0x58, 0x38, 0x0a, 0x40,
	0xfe, 0x6c, 0xd7, 0x3f, 0x24, 0xe4, 0x4b, 0x25, 0xe4, 0xf3, 0xd9, 0x0d, 0x6f, 0x73, 0x16, 0x6e,
	0x4d, 0xa2, 0xde, 0x9c, 0x04, 0x95, 0x02, 0x4f, 0x60, 0x8f, 0x43, 0xb4, 0xce, 0x93, 0x48, 0x4a,
	0x9d, 0x7a, 0x53, 0x34, 0x8e, 0xf3, 0xa6, 0xb8, 0xa8, 0x04, 0xae, 0xa9, 0x10, 0x53, 0xcf, 0x89,
	0x79, 0x20, 0x7e, 0x80, 0xd6, 0x76, 0x09, 0x0d, 0x12, 0x9e, 0x17, 0x32, 0x73, 0x89, 0x4b, 0x83,
	0xbc, 0x96, 0x57, 0xe4, 0x80, 0xe9, 0x64, 0xa9, 0xf9, 0x91, 0xa2, 0xb7, 0x0f, 0x59, 0xed, 0x86,
	0xf1, 0x2c, 0x8b, 0x7f, 0x36, 0x50, 0xe9, 0xe4, 0xcc, 0x3d, 0xca, 0xea, 0x71, 0x8e, 0xd2, 0x55,
	0x47, 0x69, 0xa9, 0x50, 0x83, 0x39, 0x27, 0x3a, 0x82, 0xeb, 0xfe, 0x65, 0x20, 0x3c, 0x1b, 0x16,
	0x7f, 0x87, 0x96, 0x43, 0x1a, 0xd1, 0x30, 0x09, 0xe5, 0xb4, 0x3a, 0xf2, 0xba, 0xd7, 0x94, 0x84,
	0xd2, 0x43, 0xde, 0x65, 0xb9, 0xc0, 0x77, 0x51, 0x4d, 0x10, 0x1a, 0x38, 0x21, 0x90, 0x48, 0x4e,
	0xb0, 0x23, 0x63, 0x95, 0x0d, 0x76, 0x3a, 0xf7, 0xb9, 0x07, 0xa4, 0x28, 0x8c, 0xc9, 0xca, 0x7e,
	0xf4, 0xea, 0x4d, 0xdb, 0x78, 0xfd, 0xa6, 0x6d, 0xfc, 0xf7, 0xa6, 0x6d, 0xfc, 0xfe, 0xb6, 0xbd,
	0xf0, 0xfa, 0x6d, 0x7b, 0xe1, 0x9f, 0xb7, 0xed, 0x85, 0x1f, 0xbe, 0xd6, 0x9e, 0xf8, 0x84, 0x87,
	0xc4, 0x27, 0x23, 0xce, 0xf2, 0x2e, 0x56, 0xab, 0xfe, 0x51, 0xff, 0x7f, 0xb8, 0x55, 0x29, 0xe5,
	0x8b, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x4f, 0xf8, 0x4b, 0x4e, 0xa6, 0x0c, 0x00, 0x00,
}

func (m *ClusterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PendingDelayDistribution.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSimulator(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.WorkflowManagerDelayDistribution.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSimulator(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkloadSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkloadSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Queues) > 0 {
		for iNdEx := len(m.Queues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Queues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.RandomSeed != 0 {
		i = encodeVarintSimulator(dAtA, i, uint64(m.RandomSeed))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClusterGroups) > 0 {
		for iNdEx := len(m.ClusterGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for iNdEx := len(m.Clusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Clusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeTemplates) > 0 {
		for iNdEx := len(m.NodeTemplates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeTemplates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TotalResources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSimulator(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSimulator(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSimulator(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSimulator(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Taints) > 0 {
		for iNdEx := len(m.Taints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Taints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Number != 0 {
		i = encodeVarintSimulator(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Queue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Queue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Queue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobTemplates) > 0 {
		for iNdEx := len(m.JobTemplates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JobTemplates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Weight != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Weight))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.FailureRuntimeDistribution.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSimulator(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	if m.FailureProbability != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FailureProbability))))
		i--
		dAtA[i] = 0x69
	}
	{
		size, err := m.RuntimeDistribution.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSimulator(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	n6, err6 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.EarliestSubmitTimeFromDependencyCompletion, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.EarliestSubmitTimeFromDependencyCompletion):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintSimulator(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x5a
	n7, err7 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.EarliestSubmitTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.EarliestSubmitTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintSimulator(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x52
	if len(m.Dependencies) > 0 {
		for iNdEx := len(m.Dependencies) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dependencies[iNdEx])
			copy(dAtA[i:], m.Dependencies[iNdEx])
			i = encodeVarintSimulator(dAtA, i, uint64(len(m.Dependencies[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.Requirements.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSimulator(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.PriorityClassName) > 0 {
		i -= len(m.PriorityClassName)
		copy(dAtA[i:], m.PriorityClassName)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.PriorityClassName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.QueuePriority != 0 {
		i = encodeVarintSimulator(dAtA, i, uint64(m.QueuePriority))
		i--
		dAtA[i] = 0x30
	}
	if len(m.JobSet) > 0 {
		i -= len(m.JobSet)
		copy(dAtA[i:], m.JobSet)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.JobSet)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NumberSuccessful != 0 {
		i = encodeVarintSimulator(dAtA, i, uint64(m.NumberSuccessful))
		i--
		dAtA[i] = 0x10
	}
	if m.Number != 0 {
		i = encodeVarintSimulator(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShiftedExponential) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShiftedExponential) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShiftedExponential) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n9, err9 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TailMean, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.TailMean):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintSimulator(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x12
	n10, err10 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.Minimum, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.Minimum):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintSimulator(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintSimulator(dAtA []byte, offset int, v uint64) int {
	offset -= sovSimulator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClusterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	l = m.WorkflowManagerDelayDistribution.Size()
	n += 1 + l + sovSimulator(uint64(l))
	l = m.PendingDelayDistribution.Size()
	n += 1 + l + sovSimulator(uint64(l))
	return n
}

func (m *WorkloadSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if m.RandomSeed != 0 {
		n += 1 + sovSimulator(uint64(m.RandomSeed))
	}
	if len(m.Queues) > 0 {
		for _, e := range m.Queues {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *Pool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if len(m.ClusterGroups) > 0 {
		for _, e := range m.ClusterGroups {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *ClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if len(m.NodeTemplates) > 0 {
		for _, e := range m.NodeTemplates {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *NodeTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovSimulator(uint64(m.Number))
	}
	if len(m.Taints) > 0 {
		for _, e := range m.Taints {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSimulator(uint64(len(k))) + 1 + len(v) + sovSimulator(uint64(len(v)))
			n += mapEntrySize + 1 + sovSimulator(uint64(mapEntrySize))
		}
	}
	l = m.TotalResources.Size()
	n += 1 + l + sovSimulator(uint64(l))
	return n
}

func (m *Queue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if m.Weight != 0 {
		n += 9
	}
	if len(m.JobTemplates) > 0 {
		for _, e := range m.JobTemplates {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *JobTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovSimulator(uint64(m.Number))
	}
	if m.NumberSuccessful != 0 {
		n += 1 + sovSimulator(uint64(m.NumberSuccessful))
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	l = len(m.JobSet)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if m.QueuePriority != 0 {
		n += 1 + sovSimulator(uint64(m.QueuePriority))
	}
	l = len(m.PriorityClassName)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	l = m.Requirements.Size()
	n += 1 + l + sovSimulator(uint64(l))
	if len(m.Dependencies) > 0 {
		for _, s := range m.Dependencies {
			l = len(s)
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.EarliestSubmitTime)
	n += 1 + l + sovSimulator(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.EarliestSubmitTimeFromDependencyCompletion)
	n += 1 + l + sovSimulator(uint64(l))
	l = m.RuntimeDistribution.Size()
	n += 1 + l + sovSimulator(uint64(l))
	if m.FailureProbability != 0 {
		n += 9
	}
	l = m.FailureRuntimeDistribution.Size()
	n += 1 + l + sovSimulator(uint64(l))
	return n
}

func (m *ShiftedExponential) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.Minimum)
	n += 1 + l + sovSimulator(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TailMean)
	n += 1 + l + sovSimulator(uint64(l))
	return n
}

func sovSimulator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSimulator(x uint64) (n int) {
	return sovSimulator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClusterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &Pool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowManagerDelayDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WorkflowManagerDelayDistribution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingDelayDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PendingDelayDistribution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSeed", wireType)
			}
			m.RandomSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomSeed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queues = append(m.Queues, &Queue{})
			if err := m.Queues[len(m.Queues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterGroups = append(m.ClusterGroups, &ClusterGroup{})
			if err := m.ClusterGroups[len(m.ClusterGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &Cluster{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeTemplates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeTemplates = append(m.NodeTemplates, &NodeTemplate{})
			if err := m.NodeTemplates[len(m.NodeTemplates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Taints = append(m.Taints, v1.Taint{})
			if err := m.Taints[len(m.Taints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSimulator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSimulator
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSimulator
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSimulator
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSimulator
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSimulator
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSimulator
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSimulator(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSimulator
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Queue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Queue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Queue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Weight = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTemplates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobTemplates = append(m.JobTemplates, &JobTemplate{})
			if err := m.JobTemplates[len(m.JobTemplates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberSuccessful", wireType)
			}
			m.NumberSuccessful = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberSuccessful |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueuePriority", wireType)
			}
			m.QueuePriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueuePriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Requirements.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependencies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependencies = append(m.Dependencies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarliestSubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.EarliestSubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarliestSubmitTimeFromDependencyCompletion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.EarliestSubmitTimeFromDependencyCompletion, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RuntimeDistribution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureProbability", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FailureProbability = float64(math.Float64frombits(v))
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureRuntimeDistribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FailureRuntimeDistribution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShiftedExponential) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShiftedExponential: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShiftedExponential: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minimum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.Minimum, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TailMean", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TailMean, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSimulator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSimulator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSimulator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSimulator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSimulator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSimulator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSimulator = fmt.Errorf("proto: unexpected end of group")
)
