// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal/scheduler/simulator/simulator.proto

package simulator

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	schedulerobjects "github.com/armadaproject/armada/internal/scheduler/schedulerobjects"
	armadaevents "github.com/armadaproject/armada/pkg/armadaevents"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	v1 "k8s.io/api/core/v1"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SimulationResult struct {
	Events           []*armadaevents.EventSequence `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	ClusterSpec      *ClusterSpec                  `protobuf:"bytes,2,opt,name=clusterSpec,proto3" json:"clusterSpec,omitempty"`
	WorkloadSpec     *WorkloadSpec                 `protobuf:"bytes,3,opt,name=workloadSpec,proto3" json:"workloadSpec,omitempty"`
	SchedulingConfig string                        `protobuf:"bytes,4,opt,name=schedulingConfig,proto3" json:"schedulingConfig,omitempty"`
}

func (m *SimulationResult) Reset()         { *m = SimulationResult{} }
func (m *SimulationResult) String() string { return proto.CompactTextString(m) }
func (*SimulationResult) ProtoMessage()    {}
func (*SimulationResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{0}
}
func (m *SimulationResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimulationResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimulationResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimulationResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimulationResult.Merge(m, src)
}
func (m *SimulationResult) XXX_Size() int {
	return m.Size()
}
func (m *SimulationResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SimulationResult.DiscardUnknown(m)
}

var xxx_messageInfo_SimulationResult proto.InternalMessageInfo

func (m *SimulationResult) GetEvents() []*armadaevents.EventSequence {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *SimulationResult) GetClusterSpec() *ClusterSpec {
	if m != nil {
		return m.ClusterSpec
	}
	return nil
}

func (m *SimulationResult) GetWorkloadSpec() *WorkloadSpec {
	if m != nil {
		return m.WorkloadSpec
	}
	return nil
}

func (m *SimulationResult) GetSchedulingConfig() string {
	if m != nil {
		return m.SchedulingConfig
	}
	return ""
}

type ClusterSpec struct {
	Name  string  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Pools []*Pool `protobuf:"bytes,2,rep,name=pools,proto3" json:"pools,omitempty"`
}

func (m *ClusterSpec) Reset()         { *m = ClusterSpec{} }
func (m *ClusterSpec) String() string { return proto.CompactTextString(m) }
func (*ClusterSpec) ProtoMessage()    {}
func (*ClusterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{1}
}
func (m *ClusterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterSpec.Merge(m, src)
}
func (m *ClusterSpec) XXX_Size() int {
	return m.Size()
}
func (m *ClusterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterSpec proto.InternalMessageInfo

func (m *ClusterSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterSpec) GetPools() []*Pool {
	if m != nil {
		return m.Pools
	}
	return nil
}

type WorkloadSpec struct {
	Name       string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	RandomSeed int64    `protobuf:"varint,2,opt,name=random_seed,json=randomSeed,proto3" json:"randomSeed,omitempty"`
	Queues     []*Queue `protobuf:"bytes,3,rep,name=queues,proto3" json:"queues,omitempty"`
}

func (m *WorkloadSpec) Reset()         { *m = WorkloadSpec{} }
func (m *WorkloadSpec) String() string { return proto.CompactTextString(m) }
func (*WorkloadSpec) ProtoMessage()    {}
func (*WorkloadSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{2}
}
func (m *WorkloadSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkloadSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkloadSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkloadSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkloadSpec.Merge(m, src)
}
func (m *WorkloadSpec) XXX_Size() int {
	return m.Size()
}
func (m *WorkloadSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkloadSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WorkloadSpec proto.InternalMessageInfo

func (m *WorkloadSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *WorkloadSpec) GetRandomSeed() int64 {
	if m != nil {
		return m.RandomSeed
	}
	return 0
}

func (m *WorkloadSpec) GetQueues() []*Queue {
	if m != nil {
		return m.Queues
	}
	return nil
}

type Pool struct {
	Name          string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ClusterGroups []*ClusterGroup `protobuf:"bytes,2,rep,name=cluster_groups,json=clusterGroups,proto3" json:"clusterGroups,omitempty"`
}

func (m *Pool) Reset()         { *m = Pool{} }
func (m *Pool) String() string { return proto.CompactTextString(m) }
func (*Pool) ProtoMessage()    {}
func (*Pool) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{3}
}
func (m *Pool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pool.Merge(m, src)
}
func (m *Pool) XXX_Size() int {
	return m.Size()
}
func (m *Pool) XXX_DiscardUnknown() {
	xxx_messageInfo_Pool.DiscardUnknown(m)
}

var xxx_messageInfo_Pool proto.InternalMessageInfo

func (m *Pool) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pool) GetClusterGroups() []*ClusterGroup {
	if m != nil {
		return m.ClusterGroups
	}
	return nil
}

type ClusterGroup struct {
	Clusters []*Cluster `protobuf:"bytes,1,rep,name=clusters,proto3" json:"clusters,omitempty"`
}

func (m *ClusterGroup) Reset()         { *m = ClusterGroup{} }
func (m *ClusterGroup) String() string { return proto.CompactTextString(m) }
func (*ClusterGroup) ProtoMessage()    {}
func (*ClusterGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{4}
}
func (m *ClusterGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterGroup.Merge(m, src)
}
func (m *ClusterGroup) XXX_Size() int {
	return m.Size()
}
func (m *ClusterGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterGroup.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterGroup proto.InternalMessageInfo

func (m *ClusterGroup) GetClusters() []*Cluster {
	if m != nil {
		return m.Clusters
	}
	return nil
}

type Cluster struct {
	Name          string          `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	NodeTemplates []*NodeTemplate `protobuf:"bytes,2,rep,name=node_templates,json=nodeTemplates,proto3" json:"nodeTemplates,omitempty"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{5}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetNodeTemplates() []*NodeTemplate {
	if m != nil {
		return m.NodeTemplates
	}
	return nil
}

type NodeTemplate struct {
	Number         int64                         `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	Taints         []v1.Taint                    `protobuf:"bytes,2,rep,name=taints,proto3" json:"taints"`
	Labels         map[string]string             `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TotalResources schedulerobjects.ResourceList `protobuf:"bytes,4,opt,name=total_resources,json=totalResources,proto3" json:"totalResources"`
}

func (m *NodeTemplate) Reset()         { *m = NodeTemplate{} }
func (m *NodeTemplate) String() string { return proto.CompactTextString(m) }
func (*NodeTemplate) ProtoMessage()    {}
func (*NodeTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{6}
}
func (m *NodeTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTemplate.Merge(m, src)
}
func (m *NodeTemplate) XXX_Size() int {
	return m.Size()
}
func (m *NodeTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTemplate proto.InternalMessageInfo

func (m *NodeTemplate) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *NodeTemplate) GetTaints() []v1.Taint {
	if m != nil {
		return m.Taints
	}
	return nil
}

func (m *NodeTemplate) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *NodeTemplate) GetTotalResources() schedulerobjects.ResourceList {
	if m != nil {
		return m.TotalResources
	}
	return schedulerobjects.ResourceList{}
}

type Queue struct {
	Name         string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Weight       float64        `protobuf:"fixed64,2,opt,name=weight,proto3" json:"weight,omitempty"`
	JobTemplates []*JobTemplate `protobuf:"bytes,3,rep,name=job_templates,json=jobTemplates,proto3" json:"jobTemplates,omitempty"`
}

func (m *Queue) Reset()         { *m = Queue{} }
func (m *Queue) String() string { return proto.CompactTextString(m) }
func (*Queue) ProtoMessage()    {}
func (*Queue) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{7}
}
func (m *Queue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Queue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Queue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Queue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Queue.Merge(m, src)
}
func (m *Queue) XXX_Size() int {
	return m.Size()
}
func (m *Queue) XXX_DiscardUnknown() {
	xxx_messageInfo_Queue.DiscardUnknown(m)
}

var xxx_messageInfo_Queue proto.InternalMessageInfo

func (m *Queue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Queue) GetWeight() float64 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Queue) GetJobTemplates() []*JobTemplate {
	if m != nil {
		return m.JobTemplates
	}
	return nil
}

type JobTemplate struct {
	// Number of jobs to create from this template.
	Number int64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// Number of jobs created from this template that have succeeded.
	// Maintained by the simulator.
	NumberSuccessful int64 `protobuf:"varint,2,opt,name=numberSuccessful,proto3" json:"numberSuccessful,omitempty"`
	// Queue to which this template belongs. Populated automatically.
	Queue string `protobuf:"bytes,3,opt,name=queue,proto3" json:"queue,omitempty"`
	// Unique id for this template. An id is generated if empty.
	Id                string `protobuf:"bytes,4,opt,name=id,proto3" json:"id,omitempty"`
	JobSet            string `protobuf:"bytes,5,opt,name=job_set,json=jobSet,proto3" json:"jobSet,omitempty"`
	QueuePriority     uint32 `protobuf:"varint,6,opt,name=queue_priority,json=queuePriority,proto3" json:"queuePriority,omitempty"`
	PriorityClassName string `protobuf:"bytes,7,opt,name=priority_class_name,json=priorityClassName,proto3" json:"priorityClassName,omitempty"`
	// Scheduling requirements for the pod embedded in the job.
	Requirements schedulerobjects.PodRequirements `protobuf:"bytes,8,opt,name=requirements,proto3" json:"requirements"`
	// List of template ids that must be completed before this template is submitted.
	Dependencies []string `protobuf:"bytes,9,rep,name=dependencies,proto3" json:"dependencies,omitempty"`
	// Earliest time at which jobs from this template are submitted.
	// Measured from the start of the simulation.
	EarliestSubmitTime time.Duration `protobuf:"bytes,10,opt,name=earliest_submit_time,json=earliestSubmitTime,proto3,stdduration" json:"earliestSubmitTime"`
	// Minimum job runtime when sampling from shifted exponential distribution.
	RuntimeMin time.Duration `protobuf:"bytes,11,opt,name=runtime_min,json=runtimeMin,proto3,stdduration" json:"runtimeMin"`
	// Job runtime variance. If zero, runtime is deterministic.
	RuntimeVariance time.Duration `protobuf:"bytes,12,opt,name=runtime_variance,json=runtimeVariance,proto3,stdduration" json:"runtimeVariance"`
	// Earliest time job can be submitted from when all dependencies have completed
	EarliestSubmitTimeFromDependencyCompletion time.Duration `protobuf:"bytes,13,opt,name=earliest_submit_time_from_dependency_completion,json=earliestSubmitTimeFromDependencyCompletion,proto3,stdduration" json:"earliestSubmitTimeFromDependencyCompletion"`
}

func (m *JobTemplate) Reset()         { *m = JobTemplate{} }
func (m *JobTemplate) String() string { return proto.CompactTextString(m) }
func (*JobTemplate) ProtoMessage()    {}
func (*JobTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor_63baccdfe9127510, []int{8}
}
func (m *JobTemplate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobTemplate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobTemplate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobTemplate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobTemplate.Merge(m, src)
}
func (m *JobTemplate) XXX_Size() int {
	return m.Size()
}
func (m *JobTemplate) XXX_DiscardUnknown() {
	xxx_messageInfo_JobTemplate.DiscardUnknown(m)
}

var xxx_messageInfo_JobTemplate proto.InternalMessageInfo

func (m *JobTemplate) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *JobTemplate) GetNumberSuccessful() int64 {
	if m != nil {
		return m.NumberSuccessful
	}
	return 0
}

func (m *JobTemplate) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *JobTemplate) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *JobTemplate) GetJobSet() string {
	if m != nil {
		return m.JobSet
	}
	return ""
}

func (m *JobTemplate) GetQueuePriority() uint32 {
	if m != nil {
		return m.QueuePriority
	}
	return 0
}

func (m *JobTemplate) GetPriorityClassName() string {
	if m != nil {
		return m.PriorityClassName
	}
	return ""
}

func (m *JobTemplate) GetRequirements() schedulerobjects.PodRequirements {
	if m != nil {
		return m.Requirements
	}
	return schedulerobjects.PodRequirements{}
}

func (m *JobTemplate) GetDependencies() []string {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func (m *JobTemplate) GetEarliestSubmitTime() time.Duration {
	if m != nil {
		return m.EarliestSubmitTime
	}
	return 0
}

func (m *JobTemplate) GetRuntimeMin() time.Duration {
	if m != nil {
		return m.RuntimeMin
	}
	return 0
}

func (m *JobTemplate) GetRuntimeVariance() time.Duration {
	if m != nil {
		return m.RuntimeVariance
	}
	return 0
}

func (m *JobTemplate) GetEarliestSubmitTimeFromDependencyCompletion() time.Duration {
	if m != nil {
		return m.EarliestSubmitTimeFromDependencyCompletion
	}
	return 0
}

func init() {
	proto.RegisterType((*SimulationResult)(nil), "simulator.SimulationResult")
	proto.RegisterType((*ClusterSpec)(nil), "simulator.ClusterSpec")
	proto.RegisterType((*WorkloadSpec)(nil), "simulator.WorkloadSpec")
	proto.RegisterType((*Pool)(nil), "simulator.Pool")
	proto.RegisterType((*ClusterGroup)(nil), "simulator.ClusterGroup")
	proto.RegisterType((*Cluster)(nil), "simulator.Cluster")
	proto.RegisterType((*NodeTemplate)(nil), "simulator.NodeTemplate")
	proto.RegisterMapType((map[string]string)(nil), "simulator.NodeTemplate.LabelsEntry")
	proto.RegisterType((*Queue)(nil), "simulator.Queue")
	proto.RegisterType((*JobTemplate)(nil), "simulator.JobTemplate")
}

func init() {
	proto.RegisterFile("internal/scheduler/simulator/simulator.proto", fileDescriptor_63baccdfe9127510)
}

var fileDescriptor_63baccdfe9127510 = []byte{
	// 1217 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x5f, 0x6f, 0xd4, 0x46,
	0x10, 0x8f, 0x73, 0xe4, 0x20, 0x7b, 0x97, 0x3f, 0x2c, 0x69, 0x30, 0x89, 0x7a, 0x4e, 0x0f, 0xa9,
	0x4a, 0xab, 0x60, 0x0b, 0x2a, 0x55, 0x14, 0x55, 0x48, 0x75, 0x80, 0xaa, 0x88, 0x52, 0xb8, 0x43,
	0x20, 0x95, 0x07, 0x6b, 0xcf, 0x9e, 0x1c, 0x9b, 0xd8, 0x5e, 0x67, 0xbd, 0x0e, 0xca, 0x67, 0xa8,
	0x54, 0x55, 0x7d, 0xa8, 0xfa, 0x35, 0xfa, 0xc2, 0x67, 0xe0, 0x91, 0xb7, 0xf6, 0xc9, 0xad, 0xe0,
	0xcd, 0x9f, 0xa2, 0xf2, 0xee, 0x3a, 0xd9, 0xcb, 0xa5, 0x85, 0x3c, 0x9d, 0xf7, 0xf7, 0x9b, 0xf9,
	0x79, 0x66, 0x3c, 0x33, 0xb7, 0x68, 0x8b, 0xa6, 0x02, 0x78, 0x4a, 0x62, 0x2f, 0x0f, 0x5f, 0x40,
	0x54, 0xc4, 0xc0, 0xbd, 0x9c, 0x26, 0x45, 0x4c, 0x04, 0x33, 0x9e, 0xdc, 0x8c, 0x33, 0xc1, 0xf0,
	0xfc, 0x11, 0xb0, 0xd6, 0x1b, 0x33, 0x36, 0x8e, 0xc1, 0x93, 0xc4, 0xa8, 0xd8, 0xf1, 0xa2, 0x82,
	0x13, 0x41, 0x59, 0xaa, 0x4c, 0xd7, 0x9c, 0x93, 0xbc, 0xa0, 0x09, 0xe4, 0x82, 0x24, 0x99, 0x36,
	0xe8, 0xef, 0xdd, 0xcc, 0x5d, 0xca, 0x3c, 0x92, 0x51, 0x2f, 0x64, 0x1c, 0xbc, 0x83, 0xeb, 0xde,
	0x18, 0x52, 0xe0, 0x44, 0x40, 0xa4, 0x6d, 0xae, 0x8d, 0xa9, 0x78, 0x51, 0x8c, 0xdc, 0x90, 0x25,
	0xde, 0x98, 0x8d, 0xd9, 0xb1, 0x5a, 0x7d, 0x92, 0x07, 0xf9, 0xa4, 0xcd, 0x6f, 0x9d, 0x96, 0x4c,
	0xf3, 0xc4, 0x46, 0xbb, 0x10, 0x8a, 0x7c, 0x0a, 0xd0, 0xbe, 0x1f, 0x67, 0x7b, 0x63, 0x8f, 0xf0,
	0x84, 0x44, 0x04, 0x0e, 0x20, 0x15, 0xb9, 0xa7, 0x7e, 0x14, 0xdd, 0xff, 0x73, 0x16, 0x2d, 0x0f,
	0x55, 0xf2, 0x94, 0xa5, 0x03, 0xc8, 0x8b, 0x58, 0xe0, 0xef, 0x50, 0x5b, 0x19, 0xd9, 0xd6, 0x46,
	0x6b, 0xb3, 0x73, 0x63, 0xdd, 0x35, 0x05, 0xdc, 0xbb, 0xf5, 0xcf, 0x10, 0xf6, 0x0b, 0x48, 0x43,
	0xf0, 0x57, 0xaa, 0xd2, 0x59, 0x56, 0xcc, 0x16, 0x4b, 0xa8, 0x80, 0x24, 0x13, 0x87, 0x03, 0x2d,
	0x80, 0x87, 0xa8, 0x13, 0xc6, 0x45, 0x2e, 0x80, 0x0f, 0x33, 0x08, 0xed, 0xd9, 0x0d, 0x6b, 0xb3,
	0x73, 0x63, 0xd5, 0x3d, 0xfe, 0x00, 0xdb, 0xc7, 0xac, 0x7f, 0xa5, 0x2a, 0x9d, 0x8f, 0x0c, 0x73,
	0x43, 0xcf, 0x54, 0xc1, 0xcf, 0x50, 0xf7, 0x25, 0xe3, 0x7b, 0x31, 0x23, 0x91, 0x54, 0x6d, 0x49,
	0xd5, 0xcb, 0x86, 0xea, 0x33, 0x83, 0xf6, 0xd7, 0xaa, 0xd2, 0x59, 0x35, 0x1d, 0x0c, 0xdd, 0x09,
	0x21, 0x7c, 0x1f, 0x2d, 0xeb, 0x32, 0xd2, 0x74, 0xbc, 0xcd, 0xd2, 0x1d, 0x3a, 0xb6, 0xcf, 0x6d,
	0x58, 0x9b, 0xf3, 0x7e, 0xaf, 0x2a, 0x9d, 0xb5, 0x93, 0x9c, 0xa1, 0x33, 0xe5, 0xd7, 0xdf, 0x47,
	0x1d, 0x23, 0x37, 0xfc, 0x29, 0x3a, 0x97, 0x92, 0x04, 0x6c, 0x4b, 0xca, 0xe1, 0xaa, 0x74, 0x16,
	0xeb, 0xb3, 0x21, 0x21, 0x79, 0x7c, 0x0b, 0xcd, 0x65, 0x8c, 0xc5, 0xb9, 0x3d, 0x2b, 0x4b, 0xbf,
	0x64, 0x24, 0xf5, 0x88, 0xb1, 0xd8, 0xbf, 0x54, 0x95, 0xce, 0x92, 0xb4, 0x30, 0x5c, 0x95, 0x4b,
	0xff, 0x0f, 0x0b, 0x75, 0xcd, 0xcc, 0x3f, 0xf8, 0xa5, 0x5f, 0xa1, 0x0e, 0x27, 0x69, 0xc4, 0x92,
	0x20, 0x07, 0x88, 0xe4, 0x57, 0x6a, 0xf9, 0x76, 0x55, 0x3a, 0x2b, 0x0a, 0x1e, 0x02, 0x44, 0x86,
	0x13, 0x3a, 0x46, 0xf1, 0x6d, 0xd4, 0xde, 0x2f, 0xa0, 0x80, 0xdc, 0x6e, 0xc9, 0x80, 0x97, 0x8d,
	0x80, 0x1f, 0xd7, 0x84, 0x6a, 0x10, 0x65, 0x63, 0x36, 0x88, 0x42, 0xfa, 0x3f, 0x59, 0xe8, 0x5c,
	0x9d, 0xd8, 0x07, 0xc7, 0xfa, 0x1c, 0x2d, 0xea, 0x5e, 0x08, 0xc6, 0x9c, 0x15, 0x59, 0x53, 0xa9,
	0xcb, 0xd3, 0x4d, 0xf5, 0x6d, 0xcd, 0xfb, 0xeb, 0x55, 0xe9, 0x5c, 0x0e, 0x0d, 0xc4, 0x0c, 0x63,
	0x61, 0x82, 0xe8, 0x3f, 0x45, 0x5d, 0xd3, 0x17, 0xdf, 0x43, 0x17, 0xb4, 0x41, 0x33, 0x0b, 0x78,
	0xfa, 0x35, 0xfe, 0x6a, 0x55, 0x3a, 0xb8, 0xb1, 0x33, 0xc4, 0x8f, 0x7c, 0xfb, 0x3f, 0x5b, 0xe8,
	0xbc, 0xb6, 0x3e, 0x4b, 0xa2, 0x29, 0x8b, 0x20, 0xa8, 0xc1, 0x98, 0x08, 0x38, 0x2d, 0xd1, 0x87,
	0x2c, 0x82, 0x27, 0x9a, 0x57, 0x89, 0xa6, 0x06, 0x32, 0x91, 0xe8, 0x04, 0xd1, 0xff, 0xad, 0x85,
	0xba, 0xa6, 0x33, 0xde, 0x42, 0xed, 0xb4, 0x48, 0x46, 0xc0, 0x65, 0x5c, 0x2d, 0xf5, 0xd5, 0x14,
	0x62, 0x7e, 0x35, 0x85, 0xe0, 0x6f, 0x50, 0x5b, 0x10, 0x5a, 0x6f, 0x08, 0x15, 0xd3, 0x15, 0x57,
	0x6d, 0x3d, 0x97, 0x64, 0xd4, 0xad, 0xb7, 0x9e, 0x7b, 0x70, 0xdd, 0x7d, 0x52, 0x5b, 0xf8, 0x8b,
	0xaf, 0x4b, 0x67, 0xa6, 0x2a, 0x1d, 0xed, 0x30, 0xd0, 0xbf, 0xf8, 0x31, 0x6a, 0xc7, 0x64, 0x04,
	0x71, 0xd3, 0x38, 0x57, 0xff, 0x23, 0x2d, 0xf7, 0x81, 0xb4, 0xba, 0x9b, 0x0a, 0x7e, 0xa8, 0xa2,
	0x52, 0x6e, 0x66, 0x54, 0x0a, 0xc1, 0x01, 0x5a, 0x12, 0x4c, 0x90, 0x38, 0xe0, 0x90, 0xb3, 0x82,
	0x87, 0x90, 0xcb, 0xe9, 0xed, 0xdc, 0xe8, 0xb9, 0x53, 0xdb, 0x71, 0xa0, 0x4d, 0x1e, 0xd0, 0x5c,
	0xf8, 0xab, 0x3a, 0xc6, 0x45, 0xe9, 0xde, 0x50, 0xf9, 0xe0, 0xc4, 0x79, 0x8d, 0xa0, 0x8e, 0x11,
	0x0d, 0xbe, 0x8a, 0x5a, 0x7b, 0x70, 0xa8, 0x3f, 0xe4, 0xc5, 0xaa, 0x74, 0x16, 0xf6, 0xe0, 0xd0,
	0x88, 0xab, 0x66, 0xf1, 0x67, 0x68, 0xee, 0x80, 0xc4, 0x05, 0xc8, 0xa9, 0x9a, 0x57, 0xf3, 0x2b,
	0x01, 0x73, 0x7e, 0x25, 0x70, 0x6b, 0xf6, 0xa6, 0xd5, 0x7f, 0x65, 0xa1, 0x39, 0x39, 0x37, 0x1f,
	0xdc, 0x27, 0x5b, 0xa8, 0xfd, 0x12, 0xe8, 0xf8, 0x85, 0x90, 0x6f, 0xb0, 0x54, 0x8d, 0x14, 0x62,
	0xd6, 0x48, 0x21, 0xf8, 0x19, 0x5a, 0xd8, 0x65, 0x23, 0xa3, 0xa9, 0x54, 0xf5, 0xcd, 0x95, 0x7c,
	0x9f, 0x8d, 0x8e, 0x7a, 0x4a, 0xee, 0xce, 0xdd, 0x63, 0xc0, 0x2c, 0x7b, 0xd7, 0xc4, 0xfb, 0xbf,
	0x5e, 0x40, 0x1d, 0xc3, 0xf3, 0x8c, 0x0d, 0x75, 0x1f, 0x69, 0x6e, 0x58, 0x84, 0x21, 0xe4, 0xf9,
	0x4e, 0x11, 0xeb, 0x35, 0x24, 0x37, 0xef, 0x49, 0xce, 0xdc, 0xbc, 0x27, 0xb9, 0xba, 0xe2, 0x72,
	0xb9, 0xc8, 0xff, 0x05, 0x5d, 0x71, 0x09, 0x98, 0x15, 0x97, 0x00, 0xde, 0x40, 0xb3, 0x34, 0xd2,
	0x2b, 0x7e, 0xb9, 0x2a, 0x9d, 0x2e, 0x35, 0xf7, 0xdc, 0x2c, 0x8d, 0xf0, 0x35, 0x74, 0xbe, 0xae,
	0x57, 0x0e, 0xc2, 0x9e, 0x93, 0x66, 0x32, 0x8f, 0x5d, 0x36, 0x1a, 0xc2, 0x44, 0x79, 0x15, 0x82,
	0x7d, 0xb4, 0x28, 0x95, 0x83, 0x8c, 0x53, 0xc6, 0xa9, 0x38, 0xb4, 0xdb, 0x1b, 0xd6, 0xe6, 0x82,
	0x9a, 0x4d, 0xc9, 0x3c, 0xd2, 0x84, 0x39, 0x9b, 0x13, 0x04, 0xfe, 0x01, 0x5d, 0x6a, 0xbc, 0x83,
	0x30, 0x26, 0x79, 0x1e, 0xc8, 0x3e, 0x38, 0x2f, 0x5f, 0xef, 0x54, 0xa5, 0xb3, 0xde, 0xd0, 0xdb,
	0x35, 0xfb, 0x70, 0xb2, 0x29, 0x2e, 0x4e, 0x91, 0xf8, 0x39, 0xea, 0x72, 0xd8, 0x2f, 0x28, 0x87,
	0x44, 0xfe, 0xab, 0x5f, 0x90, 0x43, 0xf1, 0xc9, 0xf4, 0x50, 0x3c, 0x62, 0xd1, 0xc0, 0x30, 0xf4,
	0x57, 0xf4, 0x5c, 0x4c, 0xb8, 0x0f, 0x26, 0x4e, 0xf8, 0x36, 0xea, 0x46, 0x90, 0x41, 0x1a, 0x41,
	0x1a, 0x52, 0xc8, 0xed, 0xf9, 0x8d, 0xd6, 0xe6, 0xbc, 0xea, 0x1b, 0x13, 0x37, 0xfb, 0xc6, 0xc4,
	0xf1, 0x1e, 0x5a, 0x01, 0xc2, 0x63, 0x0a, 0xb9, 0x08, 0xf2, 0x62, 0x94, 0x50, 0x11, 0xd4, 0x57,
	0x2a, 0x1b, 0xc9, 0x20, 0xaf, 0xb8, 0xea, 0xbe, 0xe5, 0x36, 0x37, 0x24, 0xf7, 0x8e, 0xbe, 0x8f,
	0xf9, 0x3d, 0x1d, 0x1c, 0x6e, 0xdc, 0x87, 0xd2, 0xfb, 0x09, 0x4d, 0xe0, 0xf7, 0xbf, 0x1d, 0x6b,
	0x70, 0x0a, 0x8e, 0x07, 0xa8, 0xc3, 0x8b, 0xb4, 0xd6, 0x0f, 0x12, 0x9a, 0xda, 0x9d, 0xf7, 0xbd,
	0xa3, 0x59, 0x0c, 0x48, 0x7b, 0x7d, 0x4f, 0x53, 0xa9, 0x6d, 0x9c, 0x31, 0x41, 0xcb, 0x8d, 0xe6,
	0x01, 0xe1, 0x94, 0xa4, 0x21, 0xd8, 0xdd, 0xf7, 0x09, 0xaf, 0x6b, 0xe1, 0x25, 0xed, 0xfa, 0x54,
	0x7b, 0x4a, 0xf5, 0x93, 0x20, 0x7e, 0x65, 0x21, 0xef, 0xb4, 0x22, 0x05, 0x3b, 0x9c, 0x25, 0xc1,
	0x51, 0x39, 0x0f, 0x83, 0x90, 0x25, 0x59, 0x0c, 0xf5, 0x1b, 0xec, 0x85, 0xf7, 0x85, 0xf0, 0xa5,
	0x0e, 0xe1, 0xf3, 0xe9, 0x3a, 0xdd, 0xe3, 0x2c, 0xb9, 0x73, 0xa4, 0xba, 0x7d, 0x24, 0x2a, 0xa3,
	0x3b, 0x83, 0xbd, 0xff, 0xf4, 0xf5, 0xdb, 0x9e, 0xf5, 0xe6, 0x6d, 0xcf, 0xfa, 0xe7, 0x6d, 0xcf,
	0xfa, 0xe5, 0x5d, 0x6f, 0xe6, 0xcd, 0xbb, 0xde, 0xcc, 0x5f, 0xef, 0x7a, 0x33, 0x3f, 0x7e, 0x6d,
	0x5c, 0x81, 0xd5, 0xed, 0x32, 0xe3, 0xac, 0xee, 0x42, 0x7d, 0xf2, 0xfe, 0xef, 0x02, 0x3f, 0x6a,
	0xcb, 0x74, 0xbe, 0xf8, 0x37, 0x00, 0x00, 0xff, 0xff, 0xd0, 0x70, 0xff, 0x6b, 0xe7, 0x0b, 0x00,
	0x00,
}

func (m *SimulationResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimulationResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimulationResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SchedulingConfig) > 0 {
		i -= len(m.SchedulingConfig)
		copy(dAtA[i:], m.SchedulingConfig)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.SchedulingConfig)))
		i--
		dAtA[i] = 0x22
	}
	if m.WorkloadSpec != nil {
		{
			size, err := m.WorkloadSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSimulator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ClusterSpec != nil {
		{
			size, err := m.ClusterSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSimulator(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClusterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkloadSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkloadSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Queues) > 0 {
		for iNdEx := len(m.Queues) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Queues[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.RandomSeed != 0 {
		i = encodeVarintSimulator(dAtA, i, uint64(m.RandomSeed))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClusterGroups) > 0 {
		for iNdEx := len(m.ClusterGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ClusterGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for iNdEx := len(m.Clusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Clusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeTemplates) > 0 {
		for iNdEx := len(m.NodeTemplates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeTemplates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TotalResources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSimulator(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSimulator(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSimulator(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSimulator(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Taints) > 0 {
		for iNdEx := len(m.Taints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Taints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Number != 0 {
		i = encodeVarintSimulator(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Queue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Queue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Queue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobTemplates) > 0 {
		for iNdEx := len(m.JobTemplates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.JobTemplates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSimulator(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Weight != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Weight))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobTemplate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobTemplate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobTemplate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n4, err4 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.EarliestSubmitTimeFromDependencyCompletion, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.EarliestSubmitTimeFromDependencyCompletion):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintSimulator(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x6a
	n5, err5 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.RuntimeVariance, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.RuntimeVariance):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintSimulator(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x62
	n6, err6 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.RuntimeMin, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.RuntimeMin):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintSimulator(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x5a
	n7, err7 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.EarliestSubmitTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.EarliestSubmitTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintSimulator(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x52
	if len(m.Dependencies) > 0 {
		for iNdEx := len(m.Dependencies) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dependencies[iNdEx])
			copy(dAtA[i:], m.Dependencies[iNdEx])
			i = encodeVarintSimulator(dAtA, i, uint64(len(m.Dependencies[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	{
		size, err := m.Requirements.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintSimulator(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.PriorityClassName) > 0 {
		i -= len(m.PriorityClassName)
		copy(dAtA[i:], m.PriorityClassName)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.PriorityClassName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.QueuePriority != 0 {
		i = encodeVarintSimulator(dAtA, i, uint64(m.QueuePriority))
		i--
		dAtA[i] = 0x30
	}
	if len(m.JobSet) > 0 {
		i -= len(m.JobSet)
		copy(dAtA[i:], m.JobSet)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.JobSet)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintSimulator(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NumberSuccessful != 0 {
		i = encodeVarintSimulator(dAtA, i, uint64(m.NumberSuccessful))
		i--
		dAtA[i] = 0x10
	}
	if m.Number != 0 {
		i = encodeVarintSimulator(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSimulator(dAtA []byte, offset int, v uint64) int {
	offset -= sovSimulator(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SimulationResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	if m.ClusterSpec != nil {
		l = m.ClusterSpec.Size()
		n += 1 + l + sovSimulator(uint64(l))
	}
	if m.WorkloadSpec != nil {
		l = m.WorkloadSpec.Size()
		n += 1 + l + sovSimulator(uint64(l))
	}
	l = len(m.SchedulingConfig)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	return n
}

func (m *ClusterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *WorkloadSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if m.RandomSeed != 0 {
		n += 1 + sovSimulator(uint64(m.RandomSeed))
	}
	if len(m.Queues) > 0 {
		for _, e := range m.Queues {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *Pool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if len(m.ClusterGroups) > 0 {
		for _, e := range m.ClusterGroups {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *ClusterGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if len(m.NodeTemplates) > 0 {
		for _, e := range m.NodeTemplates {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *NodeTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovSimulator(uint64(m.Number))
	}
	if len(m.Taints) > 0 {
		for _, e := range m.Taints {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSimulator(uint64(len(k))) + 1 + len(v) + sovSimulator(uint64(len(v)))
			n += mapEntrySize + 1 + sovSimulator(uint64(mapEntrySize))
		}
	}
	l = m.TotalResources.Size()
	n += 1 + l + sovSimulator(uint64(l))
	return n
}

func (m *Queue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if m.Weight != 0 {
		n += 9
	}
	if len(m.JobTemplates) > 0 {
		for _, e := range m.JobTemplates {
			l = e.Size()
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	return n
}

func (m *JobTemplate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovSimulator(uint64(m.Number))
	}
	if m.NumberSuccessful != 0 {
		n += 1 + sovSimulator(uint64(m.NumberSuccessful))
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	l = len(m.JobSet)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	if m.QueuePriority != 0 {
		n += 1 + sovSimulator(uint64(m.QueuePriority))
	}
	l = len(m.PriorityClassName)
	if l > 0 {
		n += 1 + l + sovSimulator(uint64(l))
	}
	l = m.Requirements.Size()
	n += 1 + l + sovSimulator(uint64(l))
	if len(m.Dependencies) > 0 {
		for _, s := range m.Dependencies {
			l = len(s)
			n += 1 + l + sovSimulator(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.EarliestSubmitTime)
	n += 1 + l + sovSimulator(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.RuntimeMin)
	n += 1 + l + sovSimulator(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.RuntimeVariance)
	n += 1 + l + sovSimulator(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.EarliestSubmitTimeFromDependencyCompletion)
	n += 1 + l + sovSimulator(uint64(l))
	return n
}

func sovSimulator(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSimulator(x uint64) (n int) {
	return sovSimulator(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SimulationResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimulationResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimulationResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &armadaevents.EventSequence{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterSpec == nil {
				m.ClusterSpec = &ClusterSpec{}
			}
			if err := m.ClusterSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkloadSpec == nil {
				m.WorkloadSpec = &WorkloadSpec{}
			}
			if err := m.WorkloadSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchedulingConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &Pool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSeed", wireType)
			}
			m.RandomSeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomSeed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queues = append(m.Queues, &Queue{})
			if err := m.Queues[len(m.Queues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterGroups = append(m.ClusterGroups, &ClusterGroup{})
			if err := m.ClusterGroups[len(m.ClusterGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, &Cluster{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeTemplates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeTemplates = append(m.NodeTemplates, &NodeTemplate{})
			if err := m.NodeTemplates[len(m.NodeTemplates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Taints = append(m.Taints, v1.Taint{})
			if err := m.Taints[len(m.Taints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSimulator
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSimulator
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSimulator
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSimulator
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSimulator
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSimulator
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSimulator
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSimulator(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSimulator
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Queue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Queue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Queue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Weight = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTemplates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobTemplates = append(m.JobTemplates, &JobTemplate{})
			if err := m.JobTemplates[len(m.JobTemplates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobTemplate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobTemplate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobTemplate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberSuccessful", wireType)
			}
			m.NumberSuccessful = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberSuccessful |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueuePriority", wireType)
			}
			m.QueuePriority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueuePriority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Requirements.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependencies", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependencies = append(m.Dependencies, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarliestSubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.EarliestSubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeMin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.RuntimeMin, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeVariance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.RuntimeVariance, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarliestSubmitTimeFromDependencyCompletion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSimulator
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSimulator
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.EarliestSubmitTimeFromDependencyCompletion, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSimulator(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSimulator
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSimulator(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSimulator
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSimulator
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSimulator
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSimulator
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSimulator
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSimulator        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSimulator          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSimulator = fmt.Errorf("proto: unexpected end of group")
)
