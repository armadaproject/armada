// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const countGroup = `-- name: CountGroup :one
SELECT COUNT(*) FROM markers WHERE group_id= $1
`

func (q *Queries) CountGroup(ctx context.Context, groupID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countGroup, groupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const findActiveRuns = `-- name: FindActiveRuns :many
SELECT run_id FROM runs WHERE run_id = ANY($1::UUID[])
                         AND (succeeded = false AND failed = false AND cancelled = false)
`

func (q *Queries) FindActiveRuns(ctx context.Context, runIds []uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, findActiveRuns, runIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var run_id uuid.UUID
		if err := rows.Scan(&run_id); err != nil {
			return nil, err
		}
		items = append(items, run_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markJobRunsCancelledByJobId = `-- name: MarkJobRunsCancelledByJobId :exec
UPDATE runs SET cancelled = true WHERE job_id = ANY($1::text[])
`

func (q *Queries) MarkJobRunsCancelledByJobId(ctx context.Context, jobIds []string) error {
	_, err := q.db.Exec(ctx, markJobRunsCancelledByJobId, jobIds)
	return err
}

const markJobRunsCancelledBySets = `-- name: MarkJobRunsCancelledBySets :exec
UPDATE runs SET cancelled = true WHERE job_set = ANY($1::text[])
`

func (q *Queries) MarkJobRunsCancelledBySets(ctx context.Context, jobSets []string) error {
	_, err := q.db.Exec(ctx, markJobRunsCancelledBySets, jobSets)
	return err
}

const markJobRunsFailedById = `-- name: MarkJobRunsFailedById :exec
UPDATE runs SET failed = true WHERE run_id = ANY($1::UUID[])
`

func (q *Queries) MarkJobRunsFailedById(ctx context.Context, runIds []uuid.UUID) error {
	_, err := q.db.Exec(ctx, markJobRunsFailedById, runIds)
	return err
}

const markJobRunsRunningById = `-- name: MarkJobRunsRunningById :exec
UPDATE runs SET running = true WHERE run_id = ANY($1::UUID[])
`

func (q *Queries) MarkJobRunsRunningById(ctx context.Context, runIds []uuid.UUID) error {
	_, err := q.db.Exec(ctx, markJobRunsRunningById, runIds)
	return err
}

const markJobRunsSucceededById = `-- name: MarkJobRunsSucceededById :exec
UPDATE runs SET succeeded = true WHERE run_id = ANY($1::UUID[])
`

func (q *Queries) MarkJobRunsSucceededById(ctx context.Context, runIds []uuid.UUID) error {
	_, err := q.db.Exec(ctx, markJobRunsSucceededById, runIds)
	return err
}

const markJobsCancelledById = `-- name: MarkJobsCancelledById :exec
UPDATE jobs SET cancelled = true WHERE job_id = ANY($1::text[])
`

func (q *Queries) MarkJobsCancelledById(ctx context.Context, jobIds []string) error {
	_, err := q.db.Exec(ctx, markJobsCancelledById, jobIds)
	return err
}

const markJobsCancelledBySets = `-- name: MarkJobsCancelledBySets :exec
UPDATE jobs SET cancelled = true WHERE job_set = ANY($1::text[])
`

func (q *Queries) MarkJobsCancelledBySets(ctx context.Context, jobSets []string) error {
	_, err := q.db.Exec(ctx, markJobsCancelledBySets, jobSets)
	return err
}

const markJobsFailedById = `-- name: MarkJobsFailedById :exec
UPDATE jobs SET failed = true WHERE job_id = ANY($1::text[])
`

func (q *Queries) MarkJobsFailedById(ctx context.Context, jobIds []string) error {
	_, err := q.db.Exec(ctx, markJobsFailedById, jobIds)
	return err
}

const markJobsSucceededById = `-- name: MarkJobsSucceededById :exec
UPDATE jobs SET succeeded = true WHERE job_id = ANY($1::text[])
`

func (q *Queries) MarkJobsSucceededById(ctx context.Context, jobIds []string) error {
	_, err := q.db.Exec(ctx, markJobsSucceededById, jobIds)
	return err
}

const selectJobsForExecutor = `-- name: SelectJobsForExecutor :many
SELECT jr.run_id, j.queue, j.job_set, j.user_id, j.groups, j.submit_message
FROM runs jr
         JOIN jobs j
              ON jr.job_id = j.job_id
WHERE jr.executor = $1
  AND jr.run_id NOT IN ($2::UUID[])
  AND jr.succeeded = false AND jr.failed = false AND jr.cancelled = false
`

type SelectJobsForExecutorParams struct {
	Executor string      `db:"executor"`
	RunIds   []uuid.UUID `db:"run_ids"`
}

type SelectJobsForExecutorRow struct {
	RunID         uuid.UUID `db:"run_id"`
	Queue         string    `db:"queue"`
	JobSet        string    `db:"job_set"`
	UserID        string    `db:"user_id"`
	Groups        []byte    `db:"groups"`
	SubmitMessage []byte    `db:"submit_message"`
}

func (q *Queries) SelectJobsForExecutor(ctx context.Context, arg SelectJobsForExecutorParams) ([]SelectJobsForExecutorRow, error) {
	rows, err := q.db.Query(ctx, selectJobsForExecutor, arg.Executor, arg.RunIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectJobsForExecutorRow
	for rows.Next() {
		var i SelectJobsForExecutorRow
		if err := rows.Scan(
			&i.RunID,
			&i.Queue,
			&i.JobSet,
			&i.UserID,
			&i.Groups,
			&i.SubmitMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNewJobs = `-- name: SelectNewJobs :many
SELECT job_id, job_set, queue, user_id, submitted, groups, priority, cancel_requested, cancelled, succeeded, failed, submit_message, scheduling_info, serial, last_modified FROM jobs WHERE serial > $1 ORDER BY serial LIMIT $2
`

type SelectNewJobsParams struct {
	Serial int64 `db:"serial"`
	Limit  int32 `db:"limit"`
}

func (q *Queries) SelectNewJobs(ctx context.Context, arg SelectNewJobsParams) ([]Job, error) {
	rows, err := q.db.Query(ctx, selectNewJobs, arg.Serial, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.JobID,
			&i.JobSet,
			&i.Queue,
			&i.UserID,
			&i.Submitted,
			&i.Groups,
			&i.Priority,
			&i.CancelRequested,
			&i.Cancelled,
			&i.Succeeded,
			&i.Failed,
			&i.SubmitMessage,
			&i.SchedulingInfo,
			&i.Serial,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNewRuns = `-- name: SelectNewRuns :many
SELECT run_id, job_id, job_set, executor, cancelled, running, succeeded, failed, returned, serial, last_modified FROM runs WHERE serial > $1 ORDER BY serial LIMIT $2
`

type SelectNewRunsParams struct {
	Serial int64 `db:"serial"`
	Limit  int32 `db:"limit"`
}

func (q *Queries) SelectNewRuns(ctx context.Context, arg SelectNewRunsParams) ([]Run, error) {
	rows, err := q.db.Query(ctx, selectNewRuns, arg.Serial, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.RunID,
			&i.JobID,
			&i.JobSet,
			&i.Executor,
			&i.Cancelled,
			&i.Running,
			&i.Succeeded,
			&i.Failed,
			&i.Returned,
			&i.Serial,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNewRunsForJobs = `-- name: SelectNewRunsForJobs :many
SELECT run_id, job_id, job_set, executor, cancelled, running, succeeded, failed, returned, serial, last_modified FROM runs WHERE serial > $1 AND job_id = ANY($2::text[]) ORDER BY serial
`

type SelectNewRunsForJobsParams struct {
	Serial int64    `db:"serial"`
	JobIds []string `db:"job_ids"`
}

func (q *Queries) SelectNewRunsForJobs(ctx context.Context, arg SelectNewRunsForJobsParams) ([]Run, error) {
	rows, err := q.db.Query(ctx, selectNewRunsForJobs, arg.Serial, arg.JobIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.RunID,
			&i.JobID,
			&i.JobSet,
			&i.Executor,
			&i.Cancelled,
			&i.Running,
			&i.Succeeded,
			&i.Failed,
			&i.Returned,
			&i.Serial,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRunErrorsById = `-- name: SelectRunErrorsById :many
SELECT run_id, error, serial, last_modified FROM job_run_errors WHERE run_id = ANY($1::UUID[])
`

// Run errors
func (q *Queries) SelectRunErrorsById(ctx context.Context, runIds []uuid.UUID) ([]JobRunError, error) {
	rows, err := q.db.Query(ctx, selectRunErrorsById, runIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobRunError
	for rows.Next() {
		var i JobRunError
		if err := rows.Scan(
			&i.RunID,
			&i.Error,
			&i.Serial,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUpdatedJobs = `-- name: SelectUpdatedJobs :many
SELECT job_id, job_set, queue, priority, submitted, cancel_requested, cancelled, succeeded, failed, scheduling_info, serial FROM jobs WHERE serial > $1 ORDER BY serial LIMIT $2
`

type SelectUpdatedJobsParams struct {
	Serial int64 `db:"serial"`
	Limit  int32 `db:"limit"`
}

type SelectUpdatedJobsRow struct {
	JobID           string `db:"job_id"`
	JobSet          string `db:"job_set"`
	Queue           string `db:"queue"`
	Priority        int64  `db:"priority"`
	Submitted       int64  `db:"submitted"`
	CancelRequested bool   `db:"cancel_requested"`
	Cancelled       bool   `db:"cancelled"`
	Succeeded       bool   `db:"succeeded"`
	Failed          bool   `db:"failed"`
	SchedulingInfo  []byte `db:"scheduling_info"`
	Serial          int64  `db:"serial"`
}

func (q *Queries) SelectUpdatedJobs(ctx context.Context, arg SelectUpdatedJobsParams) ([]SelectUpdatedJobsRow, error) {
	rows, err := q.db.Query(ctx, selectUpdatedJobs, arg.Serial, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectUpdatedJobsRow
	for rows.Next() {
		var i SelectUpdatedJobsRow
		if err := rows.Scan(
			&i.JobID,
			&i.JobSet,
			&i.Queue,
			&i.Priority,
			&i.Submitted,
			&i.CancelRequested,
			&i.Cancelled,
			&i.Succeeded,
			&i.Failed,
			&i.SchedulingInfo,
			&i.Serial,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobPriorityById = `-- name: UpdateJobPriorityById :exec
UPDATE jobs SET priority = $1 WHERE job_id = $2
`

type UpdateJobPriorityByIdParams struct {
	Priority int64  `db:"priority"`
	JobID    string `db:"job_id"`
}

func (q *Queries) UpdateJobPriorityById(ctx context.Context, arg UpdateJobPriorityByIdParams) error {
	_, err := q.db.Exec(ctx, updateJobPriorityById, arg.Priority, arg.JobID)
	return err
}

const updateJobPriorityByJobSet = `-- name: UpdateJobPriorityByJobSet :exec
UPDATE jobs SET priority = $1 WHERE job_set = $2
`

type UpdateJobPriorityByJobSetParams struct {
	Priority int64  `db:"priority"`
	JobSet   string `db:"job_set"`
}

func (q *Queries) UpdateJobPriorityByJobSet(ctx context.Context, arg UpdateJobPriorityByJobSetParams) error {
	_, err := q.db.Exec(ctx, updateJobPriorityByJobSet, arg.Priority, arg.JobSet)
	return err
}
