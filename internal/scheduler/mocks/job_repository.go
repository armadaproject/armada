// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/armadaproject/armada/internal/scheduler/database (interfaces: JobRepository)
//
// Generated by this command:
//
//	mockgen -destination=./job_repository.go -package=schedulermocks github.com/armadaproject/armada/internal/scheduler/database JobRepository
//

// Package schedulermocks is a generated GoMock package.
package schedulermocks

import (
	reflect "reflect"

	armadacontext "github.com/armadaproject/armada/internal/common/armadacontext"
	database "github.com/armadaproject/armada/internal/scheduler/database"
	armadaevents "github.com/armadaproject/armada/pkg/armadaevents"
	uuid "github.com/google/uuid"
	gomock "go.uber.org/mock/gomock"
)

// MockJobRepository is a mock of JobRepository interface.
type MockJobRepository struct {
	ctrl     *gomock.Controller
	recorder *MockJobRepositoryMockRecorder
	isgomock struct{}
}

// MockJobRepositoryMockRecorder is the mock recorder for MockJobRepository.
type MockJobRepositoryMockRecorder struct {
	mock *MockJobRepository
}

// NewMockJobRepository creates a new mock instance.
func NewMockJobRepository(ctrl *gomock.Controller) *MockJobRepository {
	mock := &MockJobRepository{ctrl: ctrl}
	mock.recorder = &MockJobRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJobRepository) EXPECT() *MockJobRepositoryMockRecorder {
	return m.recorder
}

// CountReceivedPartitions mocks base method.
func (m *MockJobRepository) CountReceivedPartitions(ctx *armadacontext.Context, groupId uuid.UUID) (uint32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountReceivedPartitions", ctx, groupId)
	ret0, _ := ret[0].(uint32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountReceivedPartitions indicates an expected call of CountReceivedPartitions.
func (mr *MockJobRepositoryMockRecorder) CountReceivedPartitions(ctx, groupId any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountReceivedPartitions", reflect.TypeOf((*MockJobRepository)(nil).CountReceivedPartitions), ctx, groupId)
}

// FetchInitialJobs mocks base method.
func (m *MockJobRepository) FetchInitialJobs(ctx *armadacontext.Context) ([]database.Job, []database.Run, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchInitialJobs", ctx)
	ret0, _ := ret[0].([]database.Job)
	ret1, _ := ret[1].([]database.Run)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FetchInitialJobs indicates an expected call of FetchInitialJobs.
func (mr *MockJobRepositoryMockRecorder) FetchInitialJobs(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchInitialJobs", reflect.TypeOf((*MockJobRepository)(nil).FetchInitialJobs), ctx)
}

// FetchJobRunErrors mocks base method.
func (m *MockJobRepository) FetchJobRunErrors(ctx *armadacontext.Context, runIds []string) (map[string]*armadaevents.Error, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchJobRunErrors", ctx, runIds)
	ret0, _ := ret[0].(map[string]*armadaevents.Error)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchJobRunErrors indicates an expected call of FetchJobRunErrors.
func (mr *MockJobRepositoryMockRecorder) FetchJobRunErrors(ctx, runIds any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchJobRunErrors", reflect.TypeOf((*MockJobRepository)(nil).FetchJobRunErrors), ctx, runIds)
}

// FetchJobRunLeases mocks base method.
func (m *MockJobRepository) FetchJobRunLeases(ctx *armadacontext.Context, executor string, maxResults uint, excludedRunIds []string) ([]*database.JobRunLease, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchJobRunLeases", ctx, executor, maxResults, excludedRunIds)
	ret0, _ := ret[0].([]*database.JobRunLease)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchJobRunLeases indicates an expected call of FetchJobRunLeases.
func (mr *MockJobRepositoryMockRecorder) FetchJobRunLeases(ctx, executor, maxResults, excludedRunIds any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchJobRunLeases", reflect.TypeOf((*MockJobRepository)(nil).FetchJobRunLeases), ctx, executor, maxResults, excludedRunIds)
}

// FetchJobUpdates mocks base method.
func (m *MockJobRepository) FetchJobUpdates(ctx *armadacontext.Context, jobSerial, jobRunSerial int64) ([]database.Job, []database.Run, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchJobUpdates", ctx, jobSerial, jobRunSerial)
	ret0, _ := ret[0].([]database.Job)
	ret1, _ := ret[1].([]database.Run)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FetchJobUpdates indicates an expected call of FetchJobUpdates.
func (mr *MockJobRepositoryMockRecorder) FetchJobUpdates(ctx, jobSerial, jobRunSerial any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchJobUpdates", reflect.TypeOf((*MockJobRepository)(nil).FetchJobUpdates), ctx, jobSerial, jobRunSerial)
}

// FindInactiveRuns mocks base method.
func (m *MockJobRepository) FindInactiveRuns(ctx *armadacontext.Context, runIds []string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindInactiveRuns", ctx, runIds)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindInactiveRuns indicates an expected call of FindInactiveRuns.
func (mr *MockJobRepositoryMockRecorder) FindInactiveRuns(ctx, runIds any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindInactiveRuns", reflect.TypeOf((*MockJobRepository)(nil).FindInactiveRuns), ctx, runIds)
}
