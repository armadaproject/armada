// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repository

import (
	"sync"
)

// Ensure, that JobTableUpdaterMock does implement JobTableUpdater.
// If this is not the case, regenerate this file with moq.
var _ JobTableUpdater = &JobTableUpdaterMock{}

// JobTableUpdaterMock is a mock implementation of JobTableUpdater.
//
// 	func TestSomethingThatUsesJobTableUpdater(t *testing.T) {
//
// 		// make and configure a mocked JobTableUpdater
// 		mockedJobTableUpdater := &JobTableUpdaterMock{
// 			IsJobSetSubscribedFunc: func(s1 string, s2 string) bool {
// 				panic("mock out the IsJobSetSubscribed method")
// 			},
// 			SubscribeJobSetFunc: func(s1 string, s2 string)  {
// 				panic("mock out the SubscribeJobSet method")
// 			},
// 			UpdateJobServiceDbFunc: func(jobStatus *JobStatus) error {
// 				panic("mock out the UpdateJobServiceDb method")
// 			},
// 		}
//
// 		// use mockedJobTableUpdater in code that requires JobTableUpdater
// 		// and then make assertions.
//
// 	}
type JobTableUpdaterMock struct {
	// IsJobSetSubscribedFunc mocks the IsJobSetSubscribed method.
	IsJobSetSubscribedFunc func(s1 string, s2 string) bool

	// SubscribeJobSetFunc mocks the SubscribeJobSet method.
	SubscribeJobSetFunc func(s1 string, s2 string)

	// UpdateJobServiceDbFunc mocks the UpdateJobServiceDb method.
	UpdateJobServiceDbFunc func(jobStatus *JobStatus) error

	// calls tracks calls to the methods.
	calls struct {
		// IsJobSetSubscribed holds details about calls to the IsJobSetSubscribed method.
		IsJobSetSubscribed []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
		// SubscribeJobSet holds details about calls to the SubscribeJobSet method.
		SubscribeJobSet []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
		// UpdateJobServiceDb holds details about calls to the UpdateJobServiceDb method.
		UpdateJobServiceDb []struct {
			// JobStatus is the jobStatus argument value.
			JobStatus *JobStatus
		}
	}
	lockIsJobSetSubscribed sync.RWMutex
	lockSubscribeJobSet    sync.RWMutex
	lockUpdateJobServiceDb sync.RWMutex
}

// IsJobSetSubscribed calls IsJobSetSubscribedFunc.
func (mock *JobTableUpdaterMock) IsJobSetSubscribed(s1 string, s2 string) bool {
	if mock.IsJobSetSubscribedFunc == nil {
		panic("JobTableUpdaterMock.IsJobSetSubscribedFunc: method is nil but JobTableUpdater.IsJobSetSubscribed was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
	}{
		S1: s1,
		S2: s2,
	}
	mock.lockIsJobSetSubscribed.Lock()
	mock.calls.IsJobSetSubscribed = append(mock.calls.IsJobSetSubscribed, callInfo)
	mock.lockIsJobSetSubscribed.Unlock()
	return mock.IsJobSetSubscribedFunc(s1, s2)
}

// IsJobSetSubscribedCalls gets all the calls that were made to IsJobSetSubscribed.
// Check the length with:
//     len(mockedJobTableUpdater.IsJobSetSubscribedCalls())
func (mock *JobTableUpdaterMock) IsJobSetSubscribedCalls() []struct {
	S1 string
	S2 string
} {
	var calls []struct {
		S1 string
		S2 string
	}
	mock.lockIsJobSetSubscribed.RLock()
	calls = mock.calls.IsJobSetSubscribed
	mock.lockIsJobSetSubscribed.RUnlock()
	return calls
}

// SubscribeJobSet calls SubscribeJobSetFunc.
func (mock *JobTableUpdaterMock) SubscribeJobSet(s1 string, s2 string) {
	if mock.SubscribeJobSetFunc == nil {
		panic("JobTableUpdaterMock.SubscribeJobSetFunc: method is nil but JobTableUpdater.SubscribeJobSet was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
	}{
		S1: s1,
		S2: s2,
	}
	mock.lockSubscribeJobSet.Lock()
	mock.calls.SubscribeJobSet = append(mock.calls.SubscribeJobSet, callInfo)
	mock.lockSubscribeJobSet.Unlock()
	mock.SubscribeJobSetFunc(s1, s2)
}

// SubscribeJobSetCalls gets all the calls that were made to SubscribeJobSet.
// Check the length with:
//     len(mockedJobTableUpdater.SubscribeJobSetCalls())
func (mock *JobTableUpdaterMock) SubscribeJobSetCalls() []struct {
	S1 string
	S2 string
} {
	var calls []struct {
		S1 string
		S2 string
	}
	mock.lockSubscribeJobSet.RLock()
	calls = mock.calls.SubscribeJobSet
	mock.lockSubscribeJobSet.RUnlock()
	return calls
}

// UpdateJobServiceDb calls UpdateJobServiceDbFunc.
func (mock *JobTableUpdaterMock) UpdateJobServiceDb(jobStatus *JobStatus) error {
	if mock.UpdateJobServiceDbFunc == nil {
		panic("JobTableUpdaterMock.UpdateJobServiceDbFunc: method is nil but JobTableUpdater.UpdateJobServiceDb was just called")
	}
	callInfo := struct {
		JobStatus *JobStatus
	}{
		JobStatus: jobStatus,
	}
	mock.lockUpdateJobServiceDb.Lock()
	mock.calls.UpdateJobServiceDb = append(mock.calls.UpdateJobServiceDb, callInfo)
	mock.lockUpdateJobServiceDb.Unlock()
	return mock.UpdateJobServiceDbFunc(jobStatus)
}

// UpdateJobServiceDbCalls gets all the calls that were made to UpdateJobServiceDb.
// Check the length with:
//     len(mockedJobTableUpdater.UpdateJobServiceDbCalls())
func (mock *JobTableUpdaterMock) UpdateJobServiceDbCalls() []struct {
	JobStatus *JobStatus
} {
	var calls []struct {
		JobStatus *JobStatus
	}
	mock.lockUpdateJobServiceDb.RLock()
	calls = mock.calls.UpdateJobServiceDb
	mock.lockUpdateJobServiceDb.RUnlock()
	return calls
}
