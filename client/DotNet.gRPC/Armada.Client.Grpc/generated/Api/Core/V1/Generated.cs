// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: k8s.io/api/core/v1/generated.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace K8S.Io.Api.Core.V1 {

  /// <summary>Holder for reflection information generated from k8s.io/api/core/v1/generated.proto</summary>
  public static partial class GeneratedReflection {

    #region Descriptor
    /// <summary>File descriptor for k8s.io/api/core/v1/generated.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static GeneratedReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiJrOHMuaW8vYXBpL2NvcmUvdjEvZ2VuZXJhdGVkLnByb3RvEhJrOHMuaW8u",
            "YXBpLmNvcmUudjEaNGs4cy5pby9hcGltYWNoaW5lcnkvcGtnL2FwaS9yZXNv",
            "dXJjZS9nZW5lcmF0ZWQucHJvdG8aNGs4cy5pby9hcGltYWNoaW5lcnkvcGtn",
            "L2FwaXMvbWV0YS92MS9nZW5lcmF0ZWQucHJvdG8aL2s4cy5pby9hcGltYWNo",
            "aW5lcnkvcGtnL3J1bnRpbWUvZ2VuZXJhdGVkLnByb3RvGjZrOHMuaW8vYXBp",
            "bWFjaGluZXJ5L3BrZy9ydW50aW1lL3NjaGVtYS9nZW5lcmF0ZWQucHJvdG8a",
            "M2s4cy5pby9hcGltYWNoaW5lcnkvcGtnL3V0aWwvaW50c3RyL2dlbmVyYXRl",
            "ZC5wcm90byJpCiBBV1NFbGFzdGljQmxvY2tTdG9yZVZvbHVtZVNvdXJjZRIQ",
            "Cgh2b2x1bWVJRBgBIAEoCRIOCgZmc1R5cGUYAiABKAkSEQoJcGFydGl0aW9u",
            "GAMgASgFEhAKCHJlYWRPbmx5GAQgASgIIrYBCghBZmZpbml0eRI2Cgxub2Rl",
            "QWZmaW5pdHkYASABKAsyIC5rOHMuaW8uYXBpLmNvcmUudjEuTm9kZUFmZmlu",
            "aXR5EjQKC3BvZEFmZmluaXR5GAIgASgLMh8uazhzLmlvLmFwaS5jb3JlLnYx",
            "LlBvZEFmZmluaXR5EjwKD3BvZEFudGlBZmZpbml0eRgDIAEoCzIjLms4cy5p",
            "by5hcGkuY29yZS52MS5Qb2RBbnRpQWZmaW5pdHkiMgoOQXR0YWNoZWRWb2x1",
            "bWUSDAoEbmFtZRgBIAEoCRISCgpkZXZpY2VQYXRoGAIgASgJIk4KCUF2b2lk",
            "UG9kcxJBCg9wcmVmZXJBdm9pZFBvZHMYASADKAsyKC5rOHMuaW8uYXBpLmNv",
            "cmUudjEuUHJlZmVyQXZvaWRQb2RzRW50cnkifwoVQXp1cmVEaXNrVm9sdW1l",
            "U291cmNlEhAKCGRpc2tOYW1lGAEgASgJEg8KB2Rpc2tVUkkYAiABKAkSEwoL",
            "Y2FjaGluZ01vZGUYAyABKAkSDgoGZnNUeXBlGAQgASgJEhAKCHJlYWRPbmx5",
            "GAUgASgIEgwKBGtpbmQYBiABKAkicwofQXp1cmVGaWxlUGVyc2lzdGVudFZv",
            "bHVtZVNvdXJjZRISCgpzZWNyZXROYW1lGAEgASgJEhEKCXNoYXJlTmFtZRgC",
            "IAEoCRIQCghyZWFkT25seRgDIAEoCBIXCg9zZWNyZXROYW1lc3BhY2UYBCAB",
            "KAkiUAoVQXp1cmVGaWxlVm9sdW1lU291cmNlEhIKCnNlY3JldE5hbWUYASAB",
            "KAkSEQoJc2hhcmVOYW1lGAIgASgJEhAKCHJlYWRPbmx5GAMgASgIIoIBCgdC",
            "aW5kaW5nEkIKCG1ldGFkYXRhGAEgASgLMjAuazhzLmlvLmFwaW1hY2hpbmVy",
            "eS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGESMwoGdGFyZ2V0GAIgASgL",
            "MiMuazhzLmlvLmFwaS5jb3JlLnYxLk9iamVjdFJlZmVyZW5jZSKQBAoZQ1NJ",
            "UGVyc2lzdGVudFZvbHVtZVNvdXJjZRIOCgZkcml2ZXIYASABKAkSFAoMdm9s",
            "dW1lSGFuZGxlGAIgASgJEhAKCHJlYWRPbmx5GAMgASgIEg4KBmZzVHlwZRgE",
            "IAEoCRJdChB2b2x1bWVBdHRyaWJ1dGVzGAUgAygLMkMuazhzLmlvLmFwaS5j",
            "b3JlLnYxLkNTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UuVm9sdW1lQXR0cmli",
            "dXRlc0VudHJ5EkcKGmNvbnRyb2xsZXJQdWJsaXNoU2VjcmV0UmVmGAYgASgL",
            "MiMuazhzLmlvLmFwaS5jb3JlLnYxLlNlY3JldFJlZmVyZW5jZRI/ChJub2Rl",
            "U3RhZ2VTZWNyZXRSZWYYByABKAsyIy5rOHMuaW8uYXBpLmNvcmUudjEuU2Vj",
            "cmV0UmVmZXJlbmNlEkEKFG5vZGVQdWJsaXNoU2VjcmV0UmVmGAggASgLMiMu",
            "azhzLmlvLmFwaS5jb3JlLnYxLlNlY3JldFJlZmVyZW5jZRJGChljb250cm9s",
            "bGVyRXhwYW5kU2VjcmV0UmVmGAkgASgLMiMuazhzLmlvLmFwaS5jb3JlLnYx",
            "LlNlY3JldFJlZmVyZW5jZRo3ChVWb2x1bWVBdHRyaWJ1dGVzRW50cnkSCwoD",
            "a2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKZAgoPQ1NJVm9sdW1lU291",
            "cmNlEg4KBmRyaXZlchgBIAEoCRIQCghyZWFkT25seRgCIAEoCBIOCgZmc1R5",
            "cGUYAyABKAkSUwoQdm9sdW1lQXR0cmlidXRlcxgEIAMoCzI5Lms4cy5pby5h",
            "cGkuY29yZS52MS5DU0lWb2x1bWVTb3VyY2UuVm9sdW1lQXR0cmlidXRlc0Vu",
            "dHJ5EkYKFG5vZGVQdWJsaXNoU2VjcmV0UmVmGAUgASgLMiguazhzLmlvLmFw",
            "aS5jb3JlLnYxLkxvY2FsT2JqZWN0UmVmZXJlbmNlGjcKFVZvbHVtZUF0dHJp",
            "YnV0ZXNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIikK",
            "DENhcGFiaWxpdGllcxILCgNhZGQYASADKAkSDAoEZHJvcBgCIAMoCSKqAQoc",
            "Q2VwaEZTUGVyc2lzdGVudFZvbHVtZVNvdXJjZRIQCghtb25pdG9ycxgBIAMo",
            "CRIMCgRwYXRoGAIgASgJEgwKBHVzZXIYAyABKAkSEgoKc2VjcmV0RmlsZRgE",
            "IAEoCRI2CglzZWNyZXRSZWYYBSABKAsyIy5rOHMuaW8uYXBpLmNvcmUudjEu",
            "U2VjcmV0UmVmZXJlbmNlEhAKCHJlYWRPbmx5GAYgASgIIqUBChJDZXBoRlNW",
            "b2x1bWVTb3VyY2USEAoIbW9uaXRvcnMYASADKAkSDAoEcGF0aBgCIAEoCRIM",
            "CgR1c2VyGAMgASgJEhIKCnNlY3JldEZpbGUYBCABKAkSOwoJc2VjcmV0UmVm",
            "GAUgASgLMiguazhzLmlvLmFwaS5jb3JlLnYxLkxvY2FsT2JqZWN0UmVmZXJl",
            "bmNlEhAKCHJlYWRPbmx5GAYgASgIIooBChxDaW5kZXJQZXJzaXN0ZW50Vm9s",
            "dW1lU291cmNlEhAKCHZvbHVtZUlEGAEgASgJEg4KBmZzVHlwZRgCIAEoCRIQ",
            "CghyZWFkT25seRgDIAEoCBI2CglzZWNyZXRSZWYYBCABKAsyIy5rOHMuaW8u",
            "YXBpLmNvcmUudjEuU2VjcmV0UmVmZXJlbmNlIoUBChJDaW5kZXJWb2x1bWVT",
            "b3VyY2USEAoIdm9sdW1lSUQYASABKAkSDgoGZnNUeXBlGAIgASgJEhAKCHJl",
            "YWRPbmx5GAMgASgIEjsKCXNlY3JldFJlZhgEIAEoCzIoLms4cy5pby5hcGku",
            "Y29yZS52MS5Mb2NhbE9iamVjdFJlZmVyZW5jZSIoCg5DbGllbnRJUENvbmZp",
            "ZxIWCg50aW1lb3V0U2Vjb25kcxgBIAEoBSJSChJDb21wb25lbnRDb25kaXRp",
            "b24SDAoEdHlwZRgBIAEoCRIOCgZzdGF0dXMYAiABKAkSDwoHbWVzc2FnZRgD",
            "IAEoCRINCgVlcnJvchgEIAEoCSKRAQoPQ29tcG9uZW50U3RhdHVzEkIKCG1l",
            "dGFkYXRhGAEgASgLMjAuazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5t",
            "ZXRhLnYxLk9iamVjdE1ldGESOgoKY29uZGl0aW9ucxgCIAMoCzImLms4cy5p",
            "by5hcGkuY29yZS52MS5Db21wb25lbnRDb25kaXRpb24iiwEKE0NvbXBvbmVu",
            "dFN0YXR1c0xpc3QSQAoIbWV0YWRhdGEYASABKAsyLi5rOHMuaW8uYXBpbWFj",
            "aGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGlzdE1ldGESMgoFaXRlbXMYAiAD",
            "KAsyIy5rOHMuaW8uYXBpLmNvcmUudjEuQ29tcG9uZW50U3RhdHVzIrwCCglD",
            "b25maWdNYXASQgoIbWV0YWRhdGEYASABKAsyMC5rOHMuaW8uYXBpbWFjaGlu",
            "ZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YRIRCglpbW11dGFibGUY",
            "BCABKAgSNQoEZGF0YRgCIAMoCzInLms4cy5pby5hcGkuY29yZS52MS5Db25m",
            "aWdNYXAuRGF0YUVudHJ5EkEKCmJpbmFyeURhdGEYAyADKAsyLS5rOHMuaW8u",
            "YXBpLmNvcmUudjEuQ29uZmlnTWFwLkJpbmFyeURhdGFFbnRyeRorCglEYXRh",
            "RW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ARoxCg9CaW5h",
            "cnlEYXRhRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgMOgI4ASJu",
            "ChJDb25maWdNYXBFbnZTb3VyY2USRgoUbG9jYWxPYmplY3RSZWZlcmVuY2UY",
            "ASABKAsyKC5rOHMuaW8uYXBpLmNvcmUudjEuTG9jYWxPYmplY3RSZWZlcmVu",
            "Y2USEAoIb3B0aW9uYWwYAiABKAgifQoUQ29uZmlnTWFwS2V5U2VsZWN0b3IS",
            "RgoUbG9jYWxPYmplY3RSZWZlcmVuY2UYASABKAsyKC5rOHMuaW8uYXBpLmNv",
            "cmUudjEuTG9jYWxPYmplY3RSZWZlcmVuY2USCwoDa2V5GAIgASgJEhAKCG9w",
            "dGlvbmFsGAMgASgIIn8KDUNvbmZpZ01hcExpc3QSQAoIbWV0YWRhdGEYASAB",
            "KAsyLi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGlz",
            "dE1ldGESLAoFaXRlbXMYAiADKAsyHS5rOHMuaW8uYXBpLmNvcmUudjEuQ29u",
            "ZmlnTWFwInwKGUNvbmZpZ01hcE5vZGVDb25maWdTb3VyY2USEQoJbmFtZXNw",
            "YWNlGAEgASgJEgwKBG5hbWUYAiABKAkSCwoDdWlkGAMgASgJEhcKD3Jlc291",
            "cmNlVmVyc2lvbhgEIAEoCRIYChBrdWJlbGV0Q29uZmlnS2V5GAUgASgJIp0B",
            "ChNDb25maWdNYXBQcm9qZWN0aW9uEkYKFGxvY2FsT2JqZWN0UmVmZXJlbmNl",
            "GAEgASgLMiguazhzLmlvLmFwaS5jb3JlLnYxLkxvY2FsT2JqZWN0UmVmZXJl",
            "bmNlEiwKBWl0ZW1zGAIgAygLMh0uazhzLmlvLmFwaS5jb3JlLnYxLktleVRv",
            "UGF0aBIQCghvcHRpb25hbBgEIAEoCCK0AQoVQ29uZmlnTWFwVm9sdW1lU291",
            "cmNlEkYKFGxvY2FsT2JqZWN0UmVmZXJlbmNlGAEgASgLMiguazhzLmlvLmFw",
            "aS5jb3JlLnYxLkxvY2FsT2JqZWN0UmVmZXJlbmNlEiwKBWl0ZW1zGAIgAygL",
            "Mh0uazhzLmlvLmFwaS5jb3JlLnYxLktleVRvUGF0aBITCgtkZWZhdWx0TW9k",
            "ZRgDIAEoBRIQCghvcHRpb25hbBgEIAEoCCKnBgoJQ29udGFpbmVyEgwKBG5h",
            "bWUYASABKAkSDQoFaW1hZ2UYAiABKAkSDwoHY29tbWFuZBgDIAMoCRIMCgRh",
            "cmdzGAQgAygJEhIKCndvcmtpbmdEaXIYBSABKAkSMAoFcG9ydHMYBiADKAsy",
            "IS5rOHMuaW8uYXBpLmNvcmUudjEuQ29udGFpbmVyUG9ydBIyCgdlbnZGcm9t",
            "GBMgAygLMiEuazhzLmlvLmFwaS5jb3JlLnYxLkVudkZyb21Tb3VyY2USJwoD",
            "ZW52GAcgAygLMhouazhzLmlvLmFwaS5jb3JlLnYxLkVudlZhchI7CglyZXNv",
            "dXJjZXMYCCABKAsyKC5rOHMuaW8uYXBpLmNvcmUudjEuUmVzb3VyY2VSZXF1",
            "aXJlbWVudHMSNQoMdm9sdW1lTW91bnRzGAkgAygLMh8uazhzLmlvLmFwaS5j",
            "b3JlLnYxLlZvbHVtZU1vdW50EjcKDXZvbHVtZURldmljZXMYFSADKAsyIC5r",
            "OHMuaW8uYXBpLmNvcmUudjEuVm9sdW1lRGV2aWNlEjAKDWxpdmVuZXNzUHJv",
            "YmUYCiABKAsyGS5rOHMuaW8uYXBpLmNvcmUudjEuUHJvYmUSMQoOcmVhZGlu",
            "ZXNzUHJvYmUYCyABKAsyGS5rOHMuaW8uYXBpLmNvcmUudjEuUHJvYmUSLwoM",
            "c3RhcnR1cFByb2JlGBYgASgLMhkuazhzLmlvLmFwaS5jb3JlLnYxLlByb2Jl",
            "EjAKCWxpZmVjeWNsZRgMIAEoCzIdLms4cy5pby5hcGkuY29yZS52MS5MaWZl",
            "Y3ljbGUSHgoWdGVybWluYXRpb25NZXNzYWdlUGF0aBgNIAEoCRIgChh0ZXJt",
            "aW5hdGlvbk1lc3NhZ2VQb2xpY3kYFCABKAkSFwoPaW1hZ2VQdWxsUG9saWN5",
            "GA4gASgJEjwKD3NlY3VyaXR5Q29udGV4dBgPIAEoCzIjLms4cy5pby5hcGku",
            "Y29yZS52MS5TZWN1cml0eUNvbnRleHQSDQoFc3RkaW4YECABKAgSEQoJc3Rk",
            "aW5PbmNlGBEgASgIEgsKA3R0eRgSIAEoCCIyCg5Db250YWluZXJJbWFnZRIN",
            "CgVuYW1lcxgBIAMoCRIRCglzaXplQnl0ZXMYAiABKAMiaAoNQ29udGFpbmVy",
            "UG9ydBIMCgRuYW1lGAEgASgJEhAKCGhvc3RQb3J0GAIgASgFEhUKDWNvbnRh",
            "aW5lclBvcnQYAyABKAUSEAoIcHJvdG9jb2wYBCABKAkSDgoGaG9zdElQGAUg",
            "ASgJIsoBCg5Db250YWluZXJTdGF0ZRI6Cgd3YWl0aW5nGAEgASgLMikuazhz",
            "LmlvLmFwaS5jb3JlLnYxLkNvbnRhaW5lclN0YXRlV2FpdGluZxI6CgdydW5u",
            "aW5nGAIgASgLMikuazhzLmlvLmFwaS5jb3JlLnYxLkNvbnRhaW5lclN0YXRl",
            "UnVubmluZxJACgp0ZXJtaW5hdGVkGAMgASgLMiwuazhzLmlvLmFwaS5jb3Jl",
            "LnYxLkNvbnRhaW5lclN0YXRlVGVybWluYXRlZCJWChVDb250YWluZXJTdGF0",
            "ZVJ1bm5pbmcSPQoJc3RhcnRlZEF0GAEgASgLMiouazhzLmlvLmFwaW1hY2hp",
            "bmVyeS5wa2cuYXBpcy5tZXRhLnYxLlRpbWUi8QEKGENvbnRhaW5lclN0YXRl",
            "VGVybWluYXRlZBIQCghleGl0Q29kZRgBIAEoBRIOCgZzaWduYWwYAiABKAUS",
            "DgoGcmVhc29uGAMgASgJEg8KB21lc3NhZ2UYBCABKAkSPQoJc3RhcnRlZEF0",
            "GAUgASgLMiouazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYx",
            "LlRpbWUSPgoKZmluaXNoZWRBdBgGIAEoCzIqLms4cy5pby5hcGltYWNoaW5l",
            "cnkucGtnLmFwaXMubWV0YS52MS5UaW1lEhMKC2NvbnRhaW5lcklEGAcgASgJ",
            "IjgKFUNvbnRhaW5lclN0YXRlV2FpdGluZxIOCgZyZWFzb24YASABKAkSDwoH",
            "bWVzc2FnZRgCIAEoCSL0AQoPQ29udGFpbmVyU3RhdHVzEgwKBG5hbWUYASAB",
            "KAkSMQoFc3RhdGUYAiABKAsyIi5rOHMuaW8uYXBpLmNvcmUudjEuQ29udGFp",
            "bmVyU3RhdGUSNQoJbGFzdFN0YXRlGAMgASgLMiIuazhzLmlvLmFwaS5jb3Jl",
            "LnYxLkNvbnRhaW5lclN0YXRlEg0KBXJlYWR5GAQgASgIEhQKDHJlc3RhcnRD",
            "b3VudBgFIAEoBRINCgVpbWFnZRgGIAEoCRIPCgdpbWFnZUlEGAcgASgJEhMK",
            "C2NvbnRhaW5lcklEGAggASgJEg8KB3N0YXJ0ZWQYCSABKAgiHgoORGFlbW9u",
            "RW5kcG9pbnQSDAoEUG9ydBgBIAEoBSJRChVEb3dud2FyZEFQSVByb2plY3Rp",
            "b24SOAoFaXRlbXMYASADKAsyKS5rOHMuaW8uYXBpLmNvcmUudjEuRG93bndh",
            "cmRBUElWb2x1bWVGaWxlIrMBChVEb3dud2FyZEFQSVZvbHVtZUZpbGUSDAoE",
            "cGF0aBgBIAEoCRI5CghmaWVsZFJlZhgCIAEoCzInLms4cy5pby5hcGkuY29y",
            "ZS52MS5PYmplY3RGaWVsZFNlbGVjdG9yEkMKEHJlc291cmNlRmllbGRSZWYY",
            "AyABKAsyKS5rOHMuaW8uYXBpLmNvcmUudjEuUmVzb3VyY2VGaWVsZFNlbGVj",
            "dG9yEgwKBG1vZGUYBCABKAUiaAoXRG93bndhcmRBUElWb2x1bWVTb3VyY2US",
            "OAoFaXRlbXMYASADKAsyKS5rOHMuaW8uYXBpLmNvcmUudjEuRG93bndhcmRB",
            "UElWb2x1bWVGaWxlEhMKC2RlZmF1bHRNb2RlGAIgASgFImkKFEVtcHR5RGly",
            "Vm9sdW1lU291cmNlEg4KBm1lZGl1bRgBIAEoCRJBCglzaXplTGltaXQYAiAB",
            "KAsyLi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5hcGkucmVzb3VyY2UuUXVh",
            "bnRpdHkieQoPRW5kcG9pbnRBZGRyZXNzEgoKAmlwGAEgASgJEhAKCGhvc3Ru",
            "YW1lGAMgASgJEhAKCG5vZGVOYW1lGAQgASgJEjYKCXRhcmdldFJlZhgCIAEo",
            "CzIjLms4cy5pby5hcGkuY29yZS52MS5PYmplY3RSZWZlcmVuY2UiUQoMRW5k",
            "cG9pbnRQb3J0EgwKBG5hbWUYASABKAkSDAoEcG9ydBgCIAEoBRIQCghwcm90",
            "b2NvbBgDIAEoCRITCgthcHBQcm90b2NvbBgEIAEoCSK5AQoORW5kcG9pbnRT",
            "dWJzZXQSNgoJYWRkcmVzc2VzGAEgAygLMiMuazhzLmlvLmFwaS5jb3JlLnYx",
            "LkVuZHBvaW50QWRkcmVzcxI+ChFub3RSZWFkeUFkZHJlc3NlcxgCIAMoCzIj",
            "Lms4cy5pby5hcGkuY29yZS52MS5FbmRwb2ludEFkZHJlc3MSLwoFcG9ydHMY",
            "AyADKAsyIC5rOHMuaW8uYXBpLmNvcmUudjEuRW5kcG9pbnRQb3J0IoQBCglF",
            "bmRwb2ludHMSQgoIbWV0YWRhdGEYASABKAsyMC5rOHMuaW8uYXBpbWFjaGlu",
            "ZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YRIzCgdzdWJzZXRzGAIg",
            "AygLMiIuazhzLmlvLmFwaS5jb3JlLnYxLkVuZHBvaW50U3Vic2V0In8KDUVu",
            "ZHBvaW50c0xpc3QSQAoIbWV0YWRhdGEYASABKAsyLi5rOHMuaW8uYXBpbWFj",
            "aGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGlzdE1ldGESLAoFaXRlbXMYAiAD",
            "KAsyHS5rOHMuaW8uYXBpLmNvcmUudjEuRW5kcG9pbnRzIpUBCg1FbnZGcm9t",
            "U291cmNlEg4KBnByZWZpeBgBIAEoCRI8Cgxjb25maWdNYXBSZWYYAiABKAsy",
            "Ji5rOHMuaW8uYXBpLmNvcmUudjEuQ29uZmlnTWFwRW52U291cmNlEjYKCXNl",
            "Y3JldFJlZhgDIAEoCzIjLms4cy5pby5hcGkuY29yZS52MS5TZWNyZXRFbnZT",
            "b3VyY2UiWgoGRW52VmFyEgwKBG5hbWUYASABKAkSDQoFdmFsdWUYAiABKAkS",
            "MwoJdmFsdWVGcm9tGAMgASgLMiAuazhzLmlvLmFwaS5jb3JlLnYxLkVudlZh",
            "clNvdXJjZSKOAgoMRW52VmFyU291cmNlEjkKCGZpZWxkUmVmGAEgASgLMicu",
            "azhzLmlvLmFwaS5jb3JlLnYxLk9iamVjdEZpZWxkU2VsZWN0b3ISQwoQcmVz",
            "b3VyY2VGaWVsZFJlZhgCIAEoCzIpLms4cy5pby5hcGkuY29yZS52MS5SZXNv",
            "dXJjZUZpZWxkU2VsZWN0b3ISQQoPY29uZmlnTWFwS2V5UmVmGAMgASgLMigu",
            "azhzLmlvLmFwaS5jb3JlLnYxLkNvbmZpZ01hcEtleVNlbGVjdG9yEjsKDHNl",
            "Y3JldEtleVJlZhgEIAEoCzIlLms4cy5pby5hcGkuY29yZS52MS5TZWNyZXRL",
            "ZXlTZWxlY3RvciKBAQoSRXBoZW1lcmFsQ29udGFpbmVyEk4KGGVwaGVtZXJh",
            "bENvbnRhaW5lckNvbW1vbhgBIAEoCzIsLms4cy5pby5hcGkuY29yZS52MS5F",
            "cGhlbWVyYWxDb250YWluZXJDb21tb24SGwoTdGFyZ2V0Q29udGFpbmVyTmFt",
            "ZRgCIAEoCSK2BgoYRXBoZW1lcmFsQ29udGFpbmVyQ29tbW9uEgwKBG5hbWUY",
            "ASABKAkSDQoFaW1hZ2UYAiABKAkSDwoHY29tbWFuZBgDIAMoCRIMCgRhcmdz",
            "GAQgAygJEhIKCndvcmtpbmdEaXIYBSABKAkSMAoFcG9ydHMYBiADKAsyIS5r",
            "OHMuaW8uYXBpLmNvcmUudjEuQ29udGFpbmVyUG9ydBIyCgdlbnZGcm9tGBMg",
            "AygLMiEuazhzLmlvLmFwaS5jb3JlLnYxLkVudkZyb21Tb3VyY2USJwoDZW52",
            "GAcgAygLMhouazhzLmlvLmFwaS5jb3JlLnYxLkVudlZhchI7CglyZXNvdXJj",
            "ZXMYCCABKAsyKC5rOHMuaW8uYXBpLmNvcmUudjEuUmVzb3VyY2VSZXF1aXJl",
            "bWVudHMSNQoMdm9sdW1lTW91bnRzGAkgAygLMh8uazhzLmlvLmFwaS5jb3Jl",
            "LnYxLlZvbHVtZU1vdW50EjcKDXZvbHVtZURldmljZXMYFSADKAsyIC5rOHMu",
            "aW8uYXBpLmNvcmUudjEuVm9sdW1lRGV2aWNlEjAKDWxpdmVuZXNzUHJvYmUY",
            "CiABKAsyGS5rOHMuaW8uYXBpLmNvcmUudjEuUHJvYmUSMQoOcmVhZGluZXNz",
            "UHJvYmUYCyABKAsyGS5rOHMuaW8uYXBpLmNvcmUudjEuUHJvYmUSLwoMc3Rh",
            "cnR1cFByb2JlGBYgASgLMhkuazhzLmlvLmFwaS5jb3JlLnYxLlByb2JlEjAK",
            "CWxpZmVjeWNsZRgMIAEoCzIdLms4cy5pby5hcGkuY29yZS52MS5MaWZlY3lj",
            "bGUSHgoWdGVybWluYXRpb25NZXNzYWdlUGF0aBgNIAEoCRIgChh0ZXJtaW5h",
            "dGlvbk1lc3NhZ2VQb2xpY3kYFCABKAkSFwoPaW1hZ2VQdWxsUG9saWN5GA4g",
            "ASgJEjwKD3NlY3VyaXR5Q29udGV4dBgPIAEoCzIjLms4cy5pby5hcGkuY29y",
            "ZS52MS5TZWN1cml0eUNvbnRleHQSDQoFc3RkaW4YECABKAgSEQoJc3RkaW5P",
            "bmNlGBEgASgIEgsKA3R0eRgSIAEoCCJnChVFcGhlbWVyYWxWb2x1bWVTb3Vy",
            "Y2USTgoTdm9sdW1lQ2xhaW1UZW1wbGF0ZRgBIAEoCzIxLms4cy5pby5hcGku",
            "Y29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1UZW1wbGF0ZSLwBAoFRXZl",
            "bnQSQgoIbWV0YWRhdGEYASABKAsyMC5rOHMuaW8uYXBpbWFjaGluZXJ5LnBr",
            "Zy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YRI7Cg5pbnZvbHZlZE9iamVjdBgC",
            "IAEoCzIjLms4cy5pby5hcGkuY29yZS52MS5PYmplY3RSZWZlcmVuY2USDgoG",
            "cmVhc29uGAMgASgJEg8KB21lc3NhZ2UYBCABKAkSLwoGc291cmNlGAUgASgL",
            "Mh8uazhzLmlvLmFwaS5jb3JlLnYxLkV2ZW50U291cmNlEkIKDmZpcnN0VGlt",
            "ZXN0YW1wGAYgASgLMiouazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5t",
            "ZXRhLnYxLlRpbWUSQQoNbGFzdFRpbWVzdGFtcBgHIAEoCzIqLms4cy5pby5h",
            "cGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5UaW1lEg0KBWNvdW50GAgg",
            "ASgFEgwKBHR5cGUYCSABKAkSQgoJZXZlbnRUaW1lGAogASgLMi8uazhzLmlv",
            "LmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk1pY3JvVGltZRIvCgZz",
            "ZXJpZXMYCyABKAsyHy5rOHMuaW8uYXBpLmNvcmUudjEuRXZlbnRTZXJpZXMS",
            "DgoGYWN0aW9uGAwgASgJEjQKB3JlbGF0ZWQYDSABKAsyIy5rOHMuaW8uYXBp",
            "LmNvcmUudjEuT2JqZWN0UmVmZXJlbmNlEhoKEnJlcG9ydGluZ0NvbXBvbmVu",
            "dBgOIAEoCRIZChFyZXBvcnRpbmdJbnN0YW5jZRgPIAEoCSJ3CglFdmVudExp",
            "c3QSQAoIbWV0YWRhdGEYASABKAsyLi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBr",
            "Zy5hcGlzLm1ldGEudjEuTGlzdE1ldGESKAoFaXRlbXMYAiADKAsyGS5rOHMu",
            "aW8uYXBpLmNvcmUudjEuRXZlbnQiZwoLRXZlbnRTZXJpZXMSDQoFY291bnQY",
            "ASABKAUSSQoQbGFzdE9ic2VydmVkVGltZRgCIAEoCzIvLms4cy5pby5hcGlt",
            "YWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5NaWNyb1RpbWUiLgoLRXZlbnRT",
            "b3VyY2USEQoJY29tcG9uZW50GAEgASgJEgwKBGhvc3QYAiABKAkiHQoKRXhl",
            "Y0FjdGlvbhIPCgdjb21tYW5kGAEgAygJImIKDkZDVm9sdW1lU291cmNlEhIK",
            "CnRhcmdldFdXTnMYASADKAkSCwoDbHVuGAIgASgFEg4KBmZzVHlwZRgDIAEo",
            "CRIQCghyZWFkT25seRgEIAEoCBINCgV3d2lkcxgFIAMoCSKEAgoaRmxleFBl",
            "cnNpc3RlbnRWb2x1bWVTb3VyY2USDgoGZHJpdmVyGAEgASgJEg4KBmZzVHlw",
            "ZRgCIAEoCRI2CglzZWNyZXRSZWYYAyABKAsyIy5rOHMuaW8uYXBpLmNvcmUu",
            "djEuU2VjcmV0UmVmZXJlbmNlEhAKCHJlYWRPbmx5GAQgASgIEkwKB29wdGlv",
            "bnMYBSADKAsyOy5rOHMuaW8uYXBpLmNvcmUudjEuRmxleFBlcnNpc3RlbnRW",
            "b2x1bWVTb3VyY2UuT3B0aW9uc0VudHJ5Gi4KDE9wdGlvbnNFbnRyeRILCgNr",
            "ZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIvUBChBGbGV4Vm9sdW1lU291",
            "cmNlEg4KBmRyaXZlchgBIAEoCRIOCgZmc1R5cGUYAiABKAkSOwoJc2VjcmV0",
            "UmVmGAMgASgLMiguazhzLmlvLmFwaS5jb3JlLnYxLkxvY2FsT2JqZWN0UmVm",
            "ZXJlbmNlEhAKCHJlYWRPbmx5GAQgASgIEkIKB29wdGlvbnMYBSADKAsyMS5r",
            "OHMuaW8uYXBpLmNvcmUudjEuRmxleFZvbHVtZVNvdXJjZS5PcHRpb25zRW50",
            "cnkaLgoMT3B0aW9uc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEo",
            "CToCOAEiPwoTRmxvY2tlclZvbHVtZVNvdXJjZRITCgtkYXRhc2V0TmFtZRgB",
            "IAEoCRITCgtkYXRhc2V0VVVJRBgCIAEoCSJkCh1HQ0VQZXJzaXN0ZW50RGlz",
            "a1ZvbHVtZVNvdXJjZRIOCgZwZE5hbWUYASABKAkSDgoGZnNUeXBlGAIgASgJ",
            "EhEKCXBhcnRpdGlvbhgDIAEoBRIQCghyZWFkT25seRgEIAEoCCJOChNHaXRS",
            "ZXBvVm9sdW1lU291cmNlEhIKCnJlcG9zaXRvcnkYASABKAkSEAoIcmV2aXNp",
            "b24YAiABKAkSEQoJZGlyZWN0b3J5GAMgASgJInAKH0dsdXN0ZXJmc1BlcnNp",
            "c3RlbnRWb2x1bWVTb3VyY2USEQoJZW5kcG9pbnRzGAEgASgJEgwKBHBhdGgY",
            "AiABKAkSEAoIcmVhZE9ubHkYAyABKAgSGgoSZW5kcG9pbnRzTmFtZXNwYWNl",
            "GAQgASgJIkoKFUdsdXN0ZXJmc1ZvbHVtZVNvdXJjZRIRCgllbmRwb2ludHMY",
            "ASABKAkSDAoEcGF0aBgCIAEoCRIQCghyZWFkT25seRgDIAEoCCKwAQoNSFRU",
            "UEdldEFjdGlvbhIMCgRwYXRoGAEgASgJEj4KBHBvcnQYAiABKAsyMC5rOHMu",
            "aW8uYXBpbWFjaGluZXJ5LnBrZy51dGlsLmludHN0ci5JbnRPclN0cmluZxIM",
            "CgRob3N0GAMgASgJEg4KBnNjaGVtZRgEIAEoCRIzCgtodHRwSGVhZGVycxgF",
            "IAMoCzIeLms4cy5pby5hcGkuY29yZS52MS5IVFRQSGVhZGVyIikKCkhUVFBI",
            "ZWFkZXISDAoEbmFtZRgBIAEoCRINCgV2YWx1ZRgCIAEoCSKjAQoHSGFuZGxl",
            "chIsCgRleGVjGAEgASgLMh4uazhzLmlvLmFwaS5jb3JlLnYxLkV4ZWNBY3Rp",
            "b24SMgoHaHR0cEdldBgCIAEoCzIhLms4cy5pby5hcGkuY29yZS52MS5IVFRQ",
            "R2V0QWN0aW9uEjYKCXRjcFNvY2tldBgDIAEoCzIjLms4cy5pby5hcGkuY29y",
            "ZS52MS5UQ1BTb2NrZXRBY3Rpb24iKgoJSG9zdEFsaWFzEgoKAmlwGAEgASgJ",
            "EhEKCWhvc3RuYW1lcxgCIAMoCSIyChRIb3N0UGF0aFZvbHVtZVNvdXJjZRIM",
            "CgRwYXRoGAEgASgJEgwKBHR5cGUYAiABKAkimwIKG0lTQ1NJUGVyc2lzdGVu",
            "dFZvbHVtZVNvdXJjZRIUCgx0YXJnZXRQb3J0YWwYASABKAkSCwoDaXFuGAIg",
            "ASgJEgsKA2x1bhgDIAEoBRIWCg5pc2NzaUludGVyZmFjZRgEIAEoCRIOCgZm",
            "c1R5cGUYBSABKAkSEAoIcmVhZE9ubHkYBiABKAgSDwoHcG9ydGFscxgHIAMo",
            "CRIZChFjaGFwQXV0aERpc2NvdmVyeRgIIAEoCBIXCg9jaGFwQXV0aFNlc3Np",
            "b24YCyABKAgSNgoJc2VjcmV0UmVmGAogASgLMiMuazhzLmlvLmFwaS5jb3Jl",
            "LnYxLlNlY3JldFJlZmVyZW5jZRIVCg1pbml0aWF0b3JOYW1lGAwgASgJIpYC",
            "ChFJU0NTSVZvbHVtZVNvdXJjZRIUCgx0YXJnZXRQb3J0YWwYASABKAkSCwoD",
            "aXFuGAIgASgJEgsKA2x1bhgDIAEoBRIWCg5pc2NzaUludGVyZmFjZRgEIAEo",
            "CRIOCgZmc1R5cGUYBSABKAkSEAoIcmVhZE9ubHkYBiABKAgSDwoHcG9ydGFs",
            "cxgHIAMoCRIZChFjaGFwQXV0aERpc2NvdmVyeRgIIAEoCBIXCg9jaGFwQXV0",
            "aFNlc3Npb24YCyABKAgSOwoJc2VjcmV0UmVmGAogASgLMiguazhzLmlvLmFw",
            "aS5jb3JlLnYxLkxvY2FsT2JqZWN0UmVmZXJlbmNlEhUKDWluaXRpYXRvck5h",
            "bWUYDCABKAkiNAoJS2V5VG9QYXRoEgsKA2tleRgBIAEoCRIMCgRwYXRoGAIg",
            "ASgJEgwKBG1vZGUYAyABKAUiaQoJTGlmZWN5Y2xlEi4KCXBvc3RTdGFydBgB",
            "IAEoCzIbLms4cy5pby5hcGkuY29yZS52MS5IYW5kbGVyEiwKB3ByZVN0b3AY",
            "AiABKAsyGy5rOHMuaW8uYXBpLmNvcmUudjEuSGFuZGxlciKCAQoKTGltaXRS",
            "YW5nZRJCCghtZXRhZGF0YRgBIAEoCzIwLms4cy5pby5hcGltYWNoaW5lcnku",
            "cGtnLmFwaXMubWV0YS52MS5PYmplY3RNZXRhEjAKBHNwZWMYAiABKAsyIi5r",
            "OHMuaW8uYXBpLmNvcmUudjEuTGltaXRSYW5nZVNwZWMi7AYKDkxpbWl0UmFu",
            "Z2VJdGVtEgwKBHR5cGUYASABKAkSOAoDbWF4GAIgAygLMisuazhzLmlvLmFw",
            "aS5jb3JlLnYxLkxpbWl0UmFuZ2VJdGVtLk1heEVudHJ5EjgKA21pbhgDIAMo",
            "CzIrLms4cy5pby5hcGkuY29yZS52MS5MaW1pdFJhbmdlSXRlbS5NaW5FbnRy",
            "eRJACgdkZWZhdWx0GAQgAygLMi8uazhzLmlvLmFwaS5jb3JlLnYxLkxpbWl0",
            "UmFuZ2VJdGVtLkRlZmF1bHRFbnRyeRJOCg5kZWZhdWx0UmVxdWVzdBgFIAMo",
            "CzI2Lms4cy5pby5hcGkuY29yZS52MS5MaW1pdFJhbmdlSXRlbS5EZWZhdWx0",
            "UmVxdWVzdEVudHJ5EloKFG1heExpbWl0UmVxdWVzdFJhdGlvGAYgAygLMjwu",
            "azhzLmlvLmFwaS5jb3JlLnYxLkxpbWl0UmFuZ2VJdGVtLk1heExpbWl0UmVx",
            "dWVzdFJhdGlvRW50cnkaWgoITWF4RW50cnkSCwoDa2V5GAEgASgJEj0KBXZh",
            "bHVlGAIgASgLMi4uazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpLnJlc291",
            "cmNlLlF1YW50aXR5OgI4ARpaCghNaW5FbnRyeRILCgNrZXkYASABKAkSPQoF",
            "dmFsdWUYAiABKAsyLi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5hcGkucmVz",
            "b3VyY2UuUXVhbnRpdHk6AjgBGl4KDERlZmF1bHRFbnRyeRILCgNrZXkYASAB",
            "KAkSPQoFdmFsdWUYAiABKAsyLi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5h",
            "cGkucmVzb3VyY2UuUXVhbnRpdHk6AjgBGmUKE0RlZmF1bHRSZXF1ZXN0RW50",
            "cnkSCwoDa2V5GAEgASgJEj0KBXZhbHVlGAIgASgLMi4uazhzLmlvLmFwaW1h",
            "Y2hpbmVyeS5wa2cuYXBpLnJlc291cmNlLlF1YW50aXR5OgI4ARprChlNYXhM",
            "aW1pdFJlcXVlc3RSYXRpb0VudHJ5EgsKA2tleRgBIAEoCRI9CgV2YWx1ZRgC",
            "IAEoCzIuLms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFwaS5yZXNvdXJjZS5R",
            "dWFudGl0eToCOAEigQEKDkxpbWl0UmFuZ2VMaXN0EkAKCG1ldGFkYXRhGAEg",
            "ASgLMi4uazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxp",
            "c3RNZXRhEi0KBWl0ZW1zGAIgAygLMh4uazhzLmlvLmFwaS5jb3JlLnYxLkxp",
            "bWl0UmFuZ2UiRAoOTGltaXRSYW5nZVNwZWMSMgoGbGltaXRzGAEgAygLMiIu",
            "azhzLmlvLmFwaS5jb3JlLnYxLkxpbWl0UmFuZ2VJdGVtIoYBCgRMaXN0EkAK",
            "CG1ldGFkYXRhGAEgASgLMi4uazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBp",
            "cy5tZXRhLnYxLkxpc3RNZXRhEjwKBWl0ZW1zGAIgAygLMi0uazhzLmlvLmFw",
            "aW1hY2hpbmVyeS5wa2cucnVudGltZS5SYXdFeHRlbnNpb24iYgoTTG9hZEJh",
            "bGFuY2VySW5ncmVzcxIKCgJpcBgBIAEoCRIQCghob3N0bmFtZRgCIAEoCRIt",
            "CgVwb3J0cxgEIAMoCzIeLms4cy5pby5hcGkuY29yZS52MS5Qb3J0U3RhdHVz",
            "Ik4KEkxvYWRCYWxhbmNlclN0YXR1cxI4CgdpbmdyZXNzGAEgAygLMicuazhz",
            "LmlvLmFwaS5jb3JlLnYxLkxvYWRCYWxhbmNlckluZ3Jlc3MiJAoUTG9jYWxP",
            "YmplY3RSZWZlcmVuY2USDAoEbmFtZRgBIAEoCSIxChFMb2NhbFZvbHVtZVNv",
            "dXJjZRIMCgRwYXRoGAEgASgJEg4KBmZzVHlwZRgCIAEoCSJBCg9ORlNWb2x1",
            "bWVTb3VyY2USDgoGc2VydmVyGAEgASgJEgwKBHBhdGgYAiABKAkSEAoIcmVh",
            "ZE9ubHkYAyABKAgitQEKCU5hbWVzcGFjZRJCCghtZXRhZGF0YRgBIAEoCzIw",
            "Lms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5PYmplY3RN",
            "ZXRhEi8KBHNwZWMYAiABKAsyIS5rOHMuaW8uYXBpLmNvcmUudjEuTmFtZXNw",
            "YWNlU3BlYxIzCgZzdGF0dXMYAyABKAsyIy5rOHMuaW8uYXBpLmNvcmUudjEu",
            "TmFtZXNwYWNlU3RhdHVzIpsBChJOYW1lc3BhY2VDb25kaXRpb24SDAoEdHlw",
            "ZRgBIAEoCRIOCgZzdGF0dXMYAiABKAkSRgoSbGFzdFRyYW5zaXRpb25UaW1l",
            "GAQgASgLMiouazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYx",
            "LlRpbWUSDgoGcmVhc29uGAUgASgJEg8KB21lc3NhZ2UYBiABKAkifwoNTmFt",
            "ZXNwYWNlTGlzdBJACghtZXRhZGF0YRgBIAEoCzIuLms4cy5pby5hcGltYWNo",
            "aW5lcnkucGtnLmFwaXMubWV0YS52MS5MaXN0TWV0YRIsCgVpdGVtcxgCIAMo",
            "CzIdLms4cy5pby5hcGkuY29yZS52MS5OYW1lc3BhY2UiIwoNTmFtZXNwYWNl",
            "U3BlYxISCgpmaW5hbGl6ZXJzGAEgAygJIlwKD05hbWVzcGFjZVN0YXR1cxIN",
            "CgVwaGFzZRgBIAEoCRI6Cgpjb25kaXRpb25zGAIgAygLMiYuazhzLmlvLmFw",
            "aS5jb3JlLnYxLk5hbWVzcGFjZUNvbmRpdGlvbiKmAQoETm9kZRJCCghtZXRh",
            "ZGF0YRgBIAEoCzIwLms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0",
            "YS52MS5PYmplY3RNZXRhEioKBHNwZWMYAiABKAsyHC5rOHMuaW8uYXBpLmNv",
            "cmUudjEuTm9kZVNwZWMSLgoGc3RhdHVzGAMgASgLMh4uazhzLmlvLmFwaS5j",
            "b3JlLnYxLk5vZGVTdGF0dXMiLAoLTm9kZUFkZHJlc3MSDAoEdHlwZRgBIAEo",
            "CRIPCgdhZGRyZXNzGAIgASgJIs4BCgxOb2RlQWZmaW5pdHkSWAoucmVxdWly",
            "ZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvbhgBIAEo",
            "CzIgLms4cy5pby5hcGkuY29yZS52MS5Ob2RlU2VsZWN0b3ISZAovcHJlZmVy",
            "cmVkRHVyaW5nU2NoZWR1bGluZ0lnbm9yZWREdXJpbmdFeGVjdXRpb24YAiAD",
            "KAsyKy5rOHMuaW8uYXBpLmNvcmUudjEuUHJlZmVycmVkU2NoZWR1bGluZ1Rl",
            "cm0i3QEKDU5vZGVDb25kaXRpb24SDAoEdHlwZRgBIAEoCRIOCgZzdGF0dXMY",
            "AiABKAkSRQoRbGFzdEhlYXJ0YmVhdFRpbWUYAyABKAsyKi5rOHMuaW8uYXBp",
            "bWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuVGltZRJGChJsYXN0VHJhbnNp",
            "dGlvblRpbWUYBCABKAsyKi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5hcGlz",
            "Lm1ldGEudjEuVGltZRIOCgZyZWFzb24YBSABKAkSDwoHbWVzc2FnZRgGIAEo",
            "CSJUChBOb2RlQ29uZmlnU291cmNlEkAKCWNvbmZpZ01hcBgCIAEoCzItLms4",
            "cy5pby5hcGkuY29yZS52MS5Db25maWdNYXBOb2RlQ29uZmlnU291cmNlIswB",
            "ChBOb2RlQ29uZmlnU3RhdHVzEjYKCGFzc2lnbmVkGAEgASgLMiQuazhzLmlv",
            "LmFwaS5jb3JlLnYxLk5vZGVDb25maWdTb3VyY2USNAoGYWN0aXZlGAIgASgL",
            "MiQuazhzLmlvLmFwaS5jb3JlLnYxLk5vZGVDb25maWdTb3VyY2USOwoNbGFz",
            "dEtub3duR29vZBgDIAEoCzIkLms4cy5pby5hcGkuY29yZS52MS5Ob2RlQ29u",
            "ZmlnU291cmNlEg0KBWVycm9yGAQgASgJIlIKE05vZGVEYWVtb25FbmRwb2lu",
            "dHMSOwoPa3ViZWxldEVuZHBvaW50GAEgASgLMiIuazhzLmlvLmFwaS5jb3Jl",
            "LnYxLkRhZW1vbkVuZHBvaW50InUKCE5vZGVMaXN0EkAKCG1ldGFkYXRhGAEg",
            "ASgLMi4uazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxp",
            "c3RNZXRhEicKBWl0ZW1zGAIgAygLMhguazhzLmlvLmFwaS5jb3JlLnYxLk5v",
            "ZGUiIAoQTm9kZVByb3h5T3B0aW9ucxIMCgRwYXRoGAEgASgJIrMBCg1Ob2Rl",
            "UmVzb3VyY2VzEkEKCGNhcGFjaXR5GAEgAygLMi8uazhzLmlvLmFwaS5jb3Jl",
            "LnYxLk5vZGVSZXNvdXJjZXMuQ2FwYWNpdHlFbnRyeRpfCg1DYXBhY2l0eUVu",
            "dHJ5EgsKA2tleRgBIAEoCRI9CgV2YWx1ZRgCIAEoCzIuLms4cy5pby5hcGlt",
            "YWNoaW5lcnkucGtnLmFwaS5yZXNvdXJjZS5RdWFudGl0eToCOAEiTwoMTm9k",
            "ZVNlbGVjdG9yEj8KEW5vZGVTZWxlY3RvclRlcm1zGAEgAygLMiQuazhzLmlv",
            "LmFwaS5jb3JlLnYxLk5vZGVTZWxlY3RvclRlcm0iSAoXTm9kZVNlbGVjdG9y",
            "UmVxdWlyZW1lbnQSCwoDa2V5GAEgASgJEhAKCG9wZXJhdG9yGAIgASgJEg4K",
            "BnZhbHVlcxgDIAMoCSKbAQoQTm9kZVNlbGVjdG9yVGVybRJFChBtYXRjaEV4",
            "cHJlc3Npb25zGAEgAygLMisuazhzLmlvLmFwaS5jb3JlLnYxLk5vZGVTZWxl",
            "Y3RvclJlcXVpcmVtZW50EkAKC21hdGNoRmllbGRzGAIgAygLMisuazhzLmlv",
            "LmFwaS5jb3JlLnYxLk5vZGVTZWxlY3RvclJlcXVpcmVtZW50ItMBCghOb2Rl",
            "U3BlYxIPCgdwb2RDSURSGAEgASgJEhAKCHBvZENJRFJzGAcgAygJEhIKCnBy",
            "b3ZpZGVySUQYAyABKAkSFQoNdW5zY2hlZHVsYWJsZRgEIAEoCBIpCgZ0YWlu",
            "dHMYBSADKAsyGS5rOHMuaW8uYXBpLmNvcmUudjEuVGFpbnQSOgoMY29uZmln",
            "U291cmNlGAYgASgLMiQuazhzLmlvLmFwaS5jb3JlLnYxLk5vZGVDb25maWdT",
            "b3VyY2USEgoKZXh0ZXJuYWxJRBgCIAEoCSKGBgoKTm9kZVN0YXR1cxI+Cghj",
            "YXBhY2l0eRgBIAMoCzIsLms4cy5pby5hcGkuY29yZS52MS5Ob2RlU3RhdHVz",
            "LkNhcGFjaXR5RW50cnkSRAoLYWxsb2NhdGFibGUYAiADKAsyLy5rOHMuaW8u",
            "YXBpLmNvcmUudjEuTm9kZVN0YXR1cy5BbGxvY2F0YWJsZUVudHJ5Eg0KBXBo",
            "YXNlGAMgASgJEjUKCmNvbmRpdGlvbnMYBCADKAsyIS5rOHMuaW8uYXBpLmNv",
            "cmUudjEuTm9kZUNvbmRpdGlvbhIyCglhZGRyZXNzZXMYBSADKAsyHy5rOHMu",
            "aW8uYXBpLmNvcmUudjEuTm9kZUFkZHJlc3MSQAoPZGFlbW9uRW5kcG9pbnRz",
            "GAYgASgLMicuazhzLmlvLmFwaS5jb3JlLnYxLk5vZGVEYWVtb25FbmRwb2lu",
            "dHMSNAoIbm9kZUluZm8YByABKAsyIi5rOHMuaW8uYXBpLmNvcmUudjEuTm9k",
            "ZVN5c3RlbUluZm8SMgoGaW1hZ2VzGAggAygLMiIuazhzLmlvLmFwaS5jb3Jl",
            "LnYxLkNvbnRhaW5lckltYWdlEhQKDHZvbHVtZXNJblVzZRgJIAMoCRI7Cg92",
            "b2x1bWVzQXR0YWNoZWQYCiADKAsyIi5rOHMuaW8uYXBpLmNvcmUudjEuQXR0",
            "YWNoZWRWb2x1bWUSNAoGY29uZmlnGAsgASgLMiQuazhzLmlvLmFwaS5jb3Jl",
            "LnYxLk5vZGVDb25maWdTdGF0dXMaXwoNQ2FwYWNpdHlFbnRyeRILCgNrZXkY",
            "ASABKAkSPQoFdmFsdWUYAiABKAsyLi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBr",
            "Zy5hcGkucmVzb3VyY2UuUXVhbnRpdHk6AjgBGmIKEEFsbG9jYXRhYmxlRW50",
            "cnkSCwoDa2V5GAEgASgJEj0KBXZhbHVlGAIgASgLMi4uazhzLmlvLmFwaW1h",
            "Y2hpbmVyeS5wa2cuYXBpLnJlc291cmNlLlF1YW50aXR5OgI4ASLxAQoOTm9k",
            "ZVN5c3RlbUluZm8SEQoJbWFjaGluZUlEGAEgASgJEhIKCnN5c3RlbVVVSUQY",
            "AiABKAkSDgoGYm9vdElEGAMgASgJEhUKDWtlcm5lbFZlcnNpb24YBCABKAkS",
            "DwoHb3NJbWFnZRgFIAEoCRIfChdjb250YWluZXJSdW50aW1lVmVyc2lvbhgG",
            "IAEoCRIWCg5rdWJlbGV0VmVyc2lvbhgHIAEoCRIYChBrdWJlUHJveHlWZXJz",
            "aW9uGAggASgJEhcKD29wZXJhdGluZ1N5c3RlbRgJIAEoCRIUCgxhcmNoaXRl",
            "Y3R1cmUYCiABKAkiPAoTT2JqZWN0RmllbGRTZWxlY3RvchISCgphcGlWZXJz",
            "aW9uGAEgASgJEhEKCWZpZWxkUGF0aBgCIAEoCSKNAQoPT2JqZWN0UmVmZXJl",
            "bmNlEgwKBGtpbmQYASABKAkSEQoJbmFtZXNwYWNlGAIgASgJEgwKBG5hbWUY",
            "AyABKAkSCwoDdWlkGAQgASgJEhIKCmFwaVZlcnNpb24YBSABKAkSFwoPcmVz",
            "b3VyY2VWZXJzaW9uGAYgASgJEhEKCWZpZWxkUGF0aBgHIAEoCSLKAQoQUGVy",
            "c2lzdGVudFZvbHVtZRJCCghtZXRhZGF0YRgBIAEoCzIwLms4cy5pby5hcGlt",
            "YWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5PYmplY3RNZXRhEjYKBHNwZWMY",
            "AiABKAsyKC5rOHMuaW8uYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZVNw",
            "ZWMSOgoGc3RhdHVzGAMgASgLMiouazhzLmlvLmFwaS5jb3JlLnYxLlBlcnNp",
            "c3RlbnRWb2x1bWVTdGF0dXMi2QEKFVBlcnNpc3RlbnRWb2x1bWVDbGFpbRJC",
            "CghtZXRhZGF0YRgBIAEoCzIwLms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFw",
            "aXMubWV0YS52MS5PYmplY3RNZXRhEjsKBHNwZWMYAiABKAsyLS5rOHMuaW8u",
            "YXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVtZUNsYWltU3BlYxI/CgZzdGF0",
            "dXMYAyABKAsyLy5rOHMuaW8uYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVt",
            "ZUNsYWltU3RhdHVzIuoBCh5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Db25kaXRp",
            "b24SDAoEdHlwZRgBIAEoCRIOCgZzdGF0dXMYAiABKAkSQQoNbGFzdFByb2Jl",
            "VGltZRgDIAEoCzIqLms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0",
            "YS52MS5UaW1lEkYKEmxhc3RUcmFuc2l0aW9uVGltZRgEIAEoCzIqLms4cy5p",
            "by5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5UaW1lEg4KBnJlYXNv",
            "bhgFIAEoCRIPCgdtZXNzYWdlGAYgASgJIpcBChlQZXJzaXN0ZW50Vm9sdW1l",
            "Q2xhaW1MaXN0EkAKCG1ldGFkYXRhGAEgASgLMi4uazhzLmlvLmFwaW1hY2hp",
            "bmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxpc3RNZXRhEjgKBWl0ZW1zGAIgAygL",
            "MikuazhzLmlvLmFwaS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVDbGFpbSL/",
            "AgoZUGVyc2lzdGVudFZvbHVtZUNsYWltU3BlYxITCgthY2Nlc3NNb2RlcxgB",
            "IAMoCRJFCghzZWxlY3RvchgEIAEoCzIzLms4cy5pby5hcGltYWNoaW5lcnku",
            "cGtnLmFwaXMubWV0YS52MS5MYWJlbFNlbGVjdG9yEjsKCXJlc291cmNlcxgC",
            "IAEoCzIoLms4cy5pby5hcGkuY29yZS52MS5SZXNvdXJjZVJlcXVpcmVtZW50",
            "cxISCgp2b2x1bWVOYW1lGAMgASgJEhgKEHN0b3JhZ2VDbGFzc05hbWUYBSAB",
            "KAkSEgoKdm9sdW1lTW9kZRgGIAEoCRJBCgpkYXRhU291cmNlGAcgASgLMi0u",
            "azhzLmlvLmFwaS5jb3JlLnYxLlR5cGVkTG9jYWxPYmplY3RSZWZlcmVuY2US",
            "RAoNZGF0YVNvdXJjZVJlZhgIIAEoCzItLms4cy5pby5hcGkuY29yZS52MS5U",
            "eXBlZExvY2FsT2JqZWN0UmVmZXJlbmNlIrsCChtQZXJzaXN0ZW50Vm9sdW1l",
            "Q2xhaW1TdGF0dXMSDQoFcGhhc2UYASABKAkSEwoLYWNjZXNzTW9kZXMYAiAD",
            "KAkSTwoIY2FwYWNpdHkYAyADKAsyPS5rOHMuaW8uYXBpLmNvcmUudjEuUGVy",
            "c2lzdGVudFZvbHVtZUNsYWltU3RhdHVzLkNhcGFjaXR5RW50cnkSRgoKY29u",
            "ZGl0aW9ucxgEIAMoCzIyLms4cy5pby5hcGkuY29yZS52MS5QZXJzaXN0ZW50",
            "Vm9sdW1lQ2xhaW1Db25kaXRpb24aXwoNQ2FwYWNpdHlFbnRyeRILCgNrZXkY",
            "ASABKAkSPQoFdmFsdWUYAiABKAsyLi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBr",
            "Zy5hcGkucmVzb3VyY2UuUXVhbnRpdHk6AjgBIqABCh1QZXJzaXN0ZW50Vm9s",
            "dW1lQ2xhaW1UZW1wbGF0ZRJCCghtZXRhZGF0YRgBIAEoCzIwLms4cy5pby5h",
            "cGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5PYmplY3RNZXRhEjsKBHNw",
            "ZWMYAiABKAsyLS5rOHMuaW8uYXBpLmNvcmUudjEuUGVyc2lzdGVudFZvbHVt",
            "ZUNsYWltU3BlYyJICiFQZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Wb2x1bWVTb3Vy",
            "Y2USEQoJY2xhaW1OYW1lGAEgASgJEhAKCHJlYWRPbmx5GAIgASgIIo0BChRQ",
            "ZXJzaXN0ZW50Vm9sdW1lTGlzdBJACghtZXRhZGF0YRgBIAEoCzIuLms4cy5p",
            "by5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5MaXN0TWV0YRIzCgVp",
            "dGVtcxgCIAMoCzIkLms4cy5pby5hcGkuY29yZS52MS5QZXJzaXN0ZW50Vm9s",
            "dW1lIr0LChZQZXJzaXN0ZW50Vm9sdW1lU291cmNlEkwKEWdjZVBlcnNpc3Rl",
            "bnREaXNrGAEgASgLMjEuazhzLmlvLmFwaS5jb3JlLnYxLkdDRVBlcnNpc3Rl",
            "bnREaXNrVm9sdW1lU291cmNlElIKFGF3c0VsYXN0aWNCbG9ja1N0b3JlGAIg",
            "ASgLMjQuazhzLmlvLmFwaS5jb3JlLnYxLkFXU0VsYXN0aWNCbG9ja1N0b3Jl",
            "Vm9sdW1lU291cmNlEjoKCGhvc3RQYXRoGAMgASgLMiguazhzLmlvLmFwaS5j",
            "b3JlLnYxLkhvc3RQYXRoVm9sdW1lU291cmNlEkYKCWdsdXN0ZXJmcxgEIAEo",
            "CzIzLms4cy5pby5hcGkuY29yZS52MS5HbHVzdGVyZnNQZXJzaXN0ZW50Vm9s",
            "dW1lU291cmNlEjAKA25mcxgFIAEoCzIjLms4cy5pby5hcGkuY29yZS52MS5O",
            "RlNWb2x1bWVTb3VyY2USOgoDcmJkGAYgASgLMi0uazhzLmlvLmFwaS5jb3Jl",
            "LnYxLlJCRFBlcnNpc3RlbnRWb2x1bWVTb3VyY2USPgoFaXNjc2kYByABKAsy",
            "Ly5rOHMuaW8uYXBpLmNvcmUudjEuSVNDU0lQZXJzaXN0ZW50Vm9sdW1lU291",
            "cmNlEkAKBmNpbmRlchgIIAEoCzIwLms4cy5pby5hcGkuY29yZS52MS5DaW5k",
            "ZXJQZXJzaXN0ZW50Vm9sdW1lU291cmNlEkAKBmNlcGhmcxgJIAEoCzIwLms4",
            "cy5pby5hcGkuY29yZS52MS5DZXBoRlNQZXJzaXN0ZW50Vm9sdW1lU291cmNl",
            "Ei4KAmZjGAogASgLMiIuazhzLmlvLmFwaS5jb3JlLnYxLkZDVm9sdW1lU291",
            "cmNlEjgKB2Zsb2NrZXIYCyABKAsyJy5rOHMuaW8uYXBpLmNvcmUudjEuRmxv",
            "Y2tlclZvbHVtZVNvdXJjZRJCCgpmbGV4Vm9sdW1lGAwgASgLMi4uazhzLmlv",
            "LmFwaS5jb3JlLnYxLkZsZXhQZXJzaXN0ZW50Vm9sdW1lU291cmNlEkYKCWF6",
            "dXJlRmlsZRgNIAEoCzIzLms4cy5pby5hcGkuY29yZS52MS5BenVyZUZpbGVQ",
            "ZXJzaXN0ZW50Vm9sdW1lU291cmNlEkkKDXZzcGhlcmVWb2x1bWUYDiABKAsy",
            "Mi5rOHMuaW8uYXBpLmNvcmUudjEuVnNwaGVyZVZpcnR1YWxEaXNrVm9sdW1l",
            "U291cmNlEjgKB3F1b2J5dGUYDyABKAsyJy5rOHMuaW8uYXBpLmNvcmUudjEu",
            "UXVvYnl0ZVZvbHVtZVNvdXJjZRI8CglhenVyZURpc2sYECABKAsyKS5rOHMu",
            "aW8uYXBpLmNvcmUudjEuQXp1cmVEaXNrVm9sdW1lU291cmNlElIKFHBob3Rv",
            "blBlcnNpc3RlbnREaXNrGBEgASgLMjQuazhzLmlvLmFwaS5jb3JlLnYxLlBo",
            "b3RvblBlcnNpc3RlbnREaXNrVm9sdW1lU291cmNlEkAKDnBvcnR3b3J4Vm9s",
            "dW1lGBIgASgLMiguazhzLmlvLmFwaS5jb3JlLnYxLlBvcnR3b3J4Vm9sdW1l",
            "U291cmNlEkIKB3NjYWxlSU8YEyABKAsyMS5rOHMuaW8uYXBpLmNvcmUudjEu",
            "U2NhbGVJT1BlcnNpc3RlbnRWb2x1bWVTb3VyY2USNAoFbG9jYWwYFCABKAsy",
            "JS5rOHMuaW8uYXBpLmNvcmUudjEuTG9jYWxWb2x1bWVTb3VyY2USRgoJc3Rv",
            "cmFnZW9zGBUgASgLMjMuazhzLmlvLmFwaS5jb3JlLnYxLlN0b3JhZ2VPU1Bl",
            "cnNpc3RlbnRWb2x1bWVTb3VyY2USOgoDY3NpGBYgASgLMi0uazhzLmlvLmFw",
            "aS5jb3JlLnYxLkNTSVBlcnNpc3RlbnRWb2x1bWVTb3VyY2UiggQKFFBlcnNp",
            "c3RlbnRWb2x1bWVTcGVjEkgKCGNhcGFjaXR5GAEgAygLMjYuazhzLmlvLmFw",
            "aS5jb3JlLnYxLlBlcnNpc3RlbnRWb2x1bWVTcGVjLkNhcGFjaXR5RW50cnkS",
            "SgoWcGVyc2lzdGVudFZvbHVtZVNvdXJjZRgCIAEoCzIqLms4cy5pby5hcGku",
            "Y29yZS52MS5QZXJzaXN0ZW50Vm9sdW1lU291cmNlEhMKC2FjY2Vzc01vZGVz",
            "GAMgAygJEjUKCGNsYWltUmVmGAQgASgLMiMuazhzLmlvLmFwaS5jb3JlLnYx",
            "Lk9iamVjdFJlZmVyZW5jZRIlCh1wZXJzaXN0ZW50Vm9sdW1lUmVjbGFpbVBv",
            "bGljeRgFIAEoCRIYChBzdG9yYWdlQ2xhc3NOYW1lGAYgASgJEhQKDG1vdW50",
            "T3B0aW9ucxgHIAMoCRISCgp2b2x1bWVNb2RlGAggASgJEjwKDG5vZGVBZmZp",
            "bml0eRgJIAEoCzImLms4cy5pby5hcGkuY29yZS52MS5Wb2x1bWVOb2RlQWZm",
            "aW5pdHkaXwoNQ2FwYWNpdHlFbnRyeRILCgNrZXkYASABKAkSPQoFdmFsdWUY",
            "AiABKAsyLi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5hcGkucmVzb3VyY2Uu",
            "UXVhbnRpdHk6AjgBIkgKFlBlcnNpc3RlbnRWb2x1bWVTdGF0dXMSDQoFcGhh",
            "c2UYASABKAkSDwoHbWVzc2FnZRgCIAEoCRIOCgZyZWFzb24YAyABKAkiQAog",
            "UGhvdG9uUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2USDAoEcGRJRBgBIAEo",
            "CRIOCgZmc1R5cGUYAiABKAkiowEKA1BvZBJCCghtZXRhZGF0YRgBIAEoCzIw",
            "Lms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5PYmplY3RN",
            "ZXRhEikKBHNwZWMYAiABKAsyGy5rOHMuaW8uYXBpLmNvcmUudjEuUG9kU3Bl",
            "YxItCgZzdGF0dXMYAyABKAsyHS5rOHMuaW8uYXBpLmNvcmUudjEuUG9kU3Rh",
            "dHVzItABCgtQb2RBZmZpbml0eRJbCi5yZXF1aXJlZER1cmluZ1NjaGVkdWxp",
            "bmdJZ25vcmVkRHVyaW5nRXhlY3V0aW9uGAEgAygLMiMuazhzLmlvLmFwaS5j",
            "b3JlLnYxLlBvZEFmZmluaXR5VGVybRJkCi9wcmVmZXJyZWREdXJpbmdTY2hl",
            "ZHVsaW5nSWdub3JlZER1cmluZ0V4ZWN1dGlvbhgCIAMoCzIrLms4cy5pby5h",
            "cGkuY29yZS52MS5XZWlnaHRlZFBvZEFmZmluaXR5VGVybSLWAQoPUG9kQWZm",
            "aW5pdHlUZXJtEkoKDWxhYmVsU2VsZWN0b3IYASABKAsyMy5rOHMuaW8uYXBp",
            "bWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGFiZWxTZWxlY3RvchISCgpu",
            "YW1lc3BhY2VzGAIgAygJEhMKC3RvcG9sb2d5S2V5GAMgASgJEk4KEW5hbWVz",
            "cGFjZVNlbGVjdG9yGAQgASgLMjMuazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cu",
            "YXBpcy5tZXRhLnYxLkxhYmVsU2VsZWN0b3Ii1AEKD1BvZEFudGlBZmZpbml0",
            "eRJbCi5yZXF1aXJlZER1cmluZ1NjaGVkdWxpbmdJZ25vcmVkRHVyaW5nRXhl",
            "Y3V0aW9uGAEgAygLMiMuazhzLmlvLmFwaS5jb3JlLnYxLlBvZEFmZmluaXR5",
            "VGVybRJkCi9wcmVmZXJyZWREdXJpbmdTY2hlZHVsaW5nSWdub3JlZER1cmlu",
            "Z0V4ZWN1dGlvbhgCIAMoCzIrLms4cy5pby5hcGkuY29yZS52MS5XZWlnaHRl",
            "ZFBvZEFmZmluaXR5VGVybSJhChBQb2RBdHRhY2hPcHRpb25zEg0KBXN0ZGlu",
            "GAEgASgIEg4KBnN0ZG91dBgCIAEoCBIOCgZzdGRlcnIYAyABKAgSCwoDdHR5",
            "GAQgASgIEhEKCWNvbnRhaW5lchgFIAEoCSLYAQoMUG9kQ29uZGl0aW9uEgwK",
            "BHR5cGUYASABKAkSDgoGc3RhdHVzGAIgASgJEkEKDWxhc3RQcm9iZVRpbWUY",
            "AyABKAsyKi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEu",
            "VGltZRJGChJsYXN0VHJhbnNpdGlvblRpbWUYBCABKAsyKi5rOHMuaW8uYXBp",
            "bWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuVGltZRIOCgZyZWFzb24YBSAB",
            "KAkSDwoHbWVzc2FnZRgGIAEoCSJuCgxQb2RETlNDb25maWcSEwoLbmFtZXNl",
            "cnZlcnMYASADKAkSEAoIc2VhcmNoZXMYAiADKAkSNwoHb3B0aW9ucxgDIAMo",
            "CzImLms4cy5pby5hcGkuY29yZS52MS5Qb2RETlNDb25maWdPcHRpb24iMQoS",
            "UG9kRE5TQ29uZmlnT3B0aW9uEgwKBG5hbWUYASABKAkSDQoFdmFsdWUYAiAB",
            "KAkicAoOUG9kRXhlY09wdGlvbnMSDQoFc3RkaW4YASABKAgSDgoGc3Rkb3V0",
            "GAIgASgIEg4KBnN0ZGVychgDIAEoCBILCgN0dHkYBCABKAgSEQoJY29udGFp",
            "bmVyGAUgASgJEg8KB2NvbW1hbmQYBiADKAkiEwoFUG9kSVASCgoCaXAYASAB",
            "KAkicwoHUG9kTGlzdBJACghtZXRhZGF0YRgBIAEoCzIuLms4cy5pby5hcGlt",
            "YWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5MaXN0TWV0YRImCgVpdGVtcxgC",
            "IAMoCzIXLms4cy5pby5hcGkuY29yZS52MS5Qb2Qi+gEKDVBvZExvZ09wdGlv",
            "bnMSEQoJY29udGFpbmVyGAEgASgJEg4KBmZvbGxvdxgCIAEoCBIQCghwcmV2",
            "aW91cxgDIAEoCBIUCgxzaW5jZVNlY29uZHMYBCABKAMSPQoJc2luY2VUaW1l",
            "GAUgASgLMiouazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYx",
            "LlRpbWUSEgoKdGltZXN0YW1wcxgGIAEoCBIRCgl0YWlsTGluZXMYByABKAMS",
            "EgoKbGltaXRCeXRlcxgIIAEoAxIkChxpbnNlY3VyZVNraXBUTFNWZXJpZnlC",
            "YWNrZW5kGAkgASgIIiYKFVBvZFBvcnRGb3J3YXJkT3B0aW9ucxINCgVwb3J0",
            "cxgBIAMoBSIfCg9Qb2RQcm94eU9wdGlvbnMSDAoEcGF0aBgBIAEoCSIpChBQ",
            "b2RSZWFkaW5lc3NHYXRlEhUKDWNvbmRpdGlvblR5cGUYASABKAkiiwMKElBv",
            "ZFNlY3VyaXR5Q29udGV4dBI6Cg5zZUxpbnV4T3B0aW9ucxgBIAEoCzIiLms4",
            "cy5pby5hcGkuY29yZS52MS5TRUxpbnV4T3B0aW9ucxJJCg53aW5kb3dzT3B0",
            "aW9ucxgIIAEoCzIxLms4cy5pby5hcGkuY29yZS52MS5XaW5kb3dzU2VjdXJp",
            "dHlDb250ZXh0T3B0aW9ucxIRCglydW5Bc1VzZXIYAiABKAMSEgoKcnVuQXNH",
            "cm91cBgGIAEoAxIUCgxydW5Bc05vblJvb3QYAyABKAgSGgoSc3VwcGxlbWVu",
            "dGFsR3JvdXBzGAQgAygDEg8KB2ZzR3JvdXAYBSABKAMSKwoHc3lzY3RscxgH",
            "IAMoCzIaLms4cy5pby5hcGkuY29yZS52MS5TeXNjdGwSGwoTZnNHcm91cENo",
            "YW5nZVBvbGljeRgJIAEoCRI6Cg5zZWNjb21wUHJvZmlsZRgKIAEoCzIiLms4",
            "cy5pby5hcGkuY29yZS52MS5TZWNjb21wUHJvZmlsZSJbCgxQb2RTaWduYXR1",
            "cmUSSwoNcG9kQ29udHJvbGxlchgBIAEoCzI0Lms4cy5pby5hcGltYWNoaW5l",
            "cnkucGtnLmFwaXMubWV0YS52MS5Pd25lclJlZmVyZW5jZSLlCwoHUG9kU3Bl",
            "YxIrCgd2b2x1bWVzGAEgAygLMhouazhzLmlvLmFwaS5jb3JlLnYxLlZvbHVt",
            "ZRI1Cg5pbml0Q29udGFpbmVycxgUIAMoCzIdLms4cy5pby5hcGkuY29yZS52",
            "MS5Db250YWluZXISMQoKY29udGFpbmVycxgCIAMoCzIdLms4cy5pby5hcGku",
            "Y29yZS52MS5Db250YWluZXISQwoTZXBoZW1lcmFsQ29udGFpbmVycxgiIAMo",
            "CzImLms4cy5pby5hcGkuY29yZS52MS5FcGhlbWVyYWxDb250YWluZXISFQoN",
            "cmVzdGFydFBvbGljeRgDIAEoCRIlCh10ZXJtaW5hdGlvbkdyYWNlUGVyaW9k",
            "U2Vjb25kcxgEIAEoAxIdChVhY3RpdmVEZWFkbGluZVNlY29uZHMYBSABKAMS",
            "EQoJZG5zUG9saWN5GAYgASgJEkMKDG5vZGVTZWxlY3RvchgHIAMoCzItLms4",
            "cy5pby5hcGkuY29yZS52MS5Qb2RTcGVjLk5vZGVTZWxlY3RvckVudHJ5EhoK",
            "EnNlcnZpY2VBY2NvdW50TmFtZRgIIAEoCRIWCg5zZXJ2aWNlQWNjb3VudBgJ",
            "IAEoCRIkChxhdXRvbW91bnRTZXJ2aWNlQWNjb3VudFRva2VuGBUgASgIEhAK",
            "CG5vZGVOYW1lGAogASgJEhMKC2hvc3ROZXR3b3JrGAsgASgIEg8KB2hvc3RQ",
            "SUQYDCABKAgSDwoHaG9zdElQQxgNIAEoCBIdChVzaGFyZVByb2Nlc3NOYW1l",
            "c3BhY2UYGyABKAgSPwoPc2VjdXJpdHlDb250ZXh0GA4gASgLMiYuazhzLmlv",
            "LmFwaS5jb3JlLnYxLlBvZFNlY3VyaXR5Q29udGV4dBJCChBpbWFnZVB1bGxT",
            "ZWNyZXRzGA8gAygLMiguazhzLmlvLmFwaS5jb3JlLnYxLkxvY2FsT2JqZWN0",
            "UmVmZXJlbmNlEhAKCGhvc3RuYW1lGBAgASgJEhEKCXN1YmRvbWFpbhgRIAEo",
            "CRIuCghhZmZpbml0eRgSIAEoCzIcLms4cy5pby5hcGkuY29yZS52MS5BZmZp",
            "bml0eRIVCg1zY2hlZHVsZXJOYW1lGBMgASgJEjMKC3RvbGVyYXRpb25zGBYg",
            "AygLMh4uazhzLmlvLmFwaS5jb3JlLnYxLlRvbGVyYXRpb24SMgoLaG9zdEFs",
            "aWFzZXMYFyADKAsyHS5rOHMuaW8uYXBpLmNvcmUudjEuSG9zdEFsaWFzEhkK",
            "EXByaW9yaXR5Q2xhc3NOYW1lGBggASgJEhAKCHByaW9yaXR5GBkgASgFEjMK",
            "CWRuc0NvbmZpZxgaIAEoCzIgLms4cy5pby5hcGkuY29yZS52MS5Qb2RETlND",
            "b25maWcSPAoOcmVhZGluZXNzR2F0ZXMYHCADKAsyJC5rOHMuaW8uYXBpLmNv",
            "cmUudjEuUG9kUmVhZGluZXNzR2F0ZRIYChBydW50aW1lQ2xhc3NOYW1lGB0g",
            "ASgJEhoKEmVuYWJsZVNlcnZpY2VMaW5rcxgeIAEoCBIYChBwcmVlbXB0aW9u",
            "UG9saWN5GB8gASgJEjsKCG92ZXJoZWFkGCAgAygLMikuazhzLmlvLmFwaS5j",
            "b3JlLnYxLlBvZFNwZWMuT3ZlcmhlYWRFbnRyeRJPChl0b3BvbG9neVNwcmVh",
            "ZENvbnN0cmFpbnRzGCEgAygLMiwuazhzLmlvLmFwaS5jb3JlLnYxLlRvcG9s",
            "b2d5U3ByZWFkQ29uc3RyYWludBIZChFzZXRIb3N0bmFtZUFzRlFEThgjIAEo",
            "CBozChFOb2RlU2VsZWN0b3JFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUY",
            "AiABKAk6AjgBGl8KDU92ZXJoZWFkRW50cnkSCwoDa2V5GAEgASgJEj0KBXZh",
            "bHVlGAIgASgLMi4uazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpLnJlc291",
            "cmNlLlF1YW50aXR5OgI4ASL0AwoJUG9kU3RhdHVzEg0KBXBoYXNlGAEgASgJ",
            "EjQKCmNvbmRpdGlvbnMYAiADKAsyIC5rOHMuaW8uYXBpLmNvcmUudjEuUG9k",
            "Q29uZGl0aW9uEg8KB21lc3NhZ2UYAyABKAkSDgoGcmVhc29uGAQgASgJEhkK",
            "EW5vbWluYXRlZE5vZGVOYW1lGAsgASgJEg4KBmhvc3RJUBgFIAEoCRINCgVw",
            "b2RJUBgGIAEoCRIpCgZwb2RJUHMYDCADKAsyGS5rOHMuaW8uYXBpLmNvcmUu",
            "djEuUG9kSVASPQoJc3RhcnRUaW1lGAcgASgLMiouazhzLmlvLmFwaW1hY2hp",
            "bmVyeS5wa2cuYXBpcy5tZXRhLnYxLlRpbWUSQgoVaW5pdENvbnRhaW5lclN0",
            "YXR1c2VzGAogAygLMiMuazhzLmlvLmFwaS5jb3JlLnYxLkNvbnRhaW5lclN0",
            "YXR1cxI+ChFjb250YWluZXJTdGF0dXNlcxgIIAMoCzIjLms4cy5pby5hcGku",
            "Y29yZS52MS5Db250YWluZXJTdGF0dXMSEAoIcW9zQ2xhc3MYCSABKAkSRwoa",
            "ZXBoZW1lcmFsQ29udGFpbmVyU3RhdHVzZXMYDSADKAsyIy5rOHMuaW8uYXBp",
            "LmNvcmUudjEuQ29udGFpbmVyU3RhdHVzIoQBCg9Qb2RTdGF0dXNSZXN1bHQS",
            "QgoIbWV0YWRhdGEYASABKAsyMC5rOHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5h",
            "cGlzLm1ldGEudjEuT2JqZWN0TWV0YRItCgZzdGF0dXMYAiABKAsyHS5rOHMu",
            "aW8uYXBpLmNvcmUudjEuUG9kU3RhdHVzIogBCgtQb2RUZW1wbGF0ZRJCCght",
            "ZXRhZGF0YRgBIAEoCzIwLms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFwaXMu",
            "bWV0YS52MS5PYmplY3RNZXRhEjUKCHRlbXBsYXRlGAIgASgLMiMuazhzLmlv",
            "LmFwaS5jb3JlLnYxLlBvZFRlbXBsYXRlU3BlYyKDAQoPUG9kVGVtcGxhdGVM",
            "aXN0EkAKCG1ldGFkYXRhGAEgASgLMi4uazhzLmlvLmFwaW1hY2hpbmVyeS5w",
            "a2cuYXBpcy5tZXRhLnYxLkxpc3RNZXRhEi4KBWl0ZW1zGAIgAygLMh8uazhz",
            "LmlvLmFwaS5jb3JlLnYxLlBvZFRlbXBsYXRlIoABCg9Qb2RUZW1wbGF0ZVNw",
            "ZWMSQgoIbWV0YWRhdGEYASABKAsyMC5rOHMuaW8uYXBpbWFjaGluZXJ5LnBr",
            "Zy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YRIpCgRzcGVjGAIgASgLMhsuazhz",
            "LmlvLmFwaS5jb3JlLnYxLlBvZFNwZWMiOwoKUG9ydFN0YXR1cxIMCgRwb3J0",
            "GAEgASgFEhAKCHByb3RvY29sGAIgASgJEg0KBWVycm9yGAMgASgJIkoKFFBv",
            "cnR3b3J4Vm9sdW1lU291cmNlEhAKCHZvbHVtZUlEGAEgASgJEg4KBmZzVHlw",
            "ZRgCIAEoCRIQCghyZWFkT25seRgDIAEoCCIcCg1QcmVjb25kaXRpb25zEgsK",
            "A3VpZBgBIAEoCSKxAQoUUHJlZmVyQXZvaWRQb2RzRW50cnkSNgoMcG9kU2ln",
            "bmF0dXJlGAEgASgLMiAuazhzLmlvLmFwaS5jb3JlLnYxLlBvZFNpZ25hdHVy",
            "ZRJACgxldmljdGlvblRpbWUYAiABKAsyKi5rOHMuaW8uYXBpbWFjaGluZXJ5",
            "LnBrZy5hcGlzLm1ldGEudjEuVGltZRIOCgZyZWFzb24YAyABKAkSDwoHbWVz",
            "c2FnZRgEIAEoCSJjChdQcmVmZXJyZWRTY2hlZHVsaW5nVGVybRIOCgZ3ZWln",
            "aHQYASABKAUSOAoKcHJlZmVyZW5jZRgCIAEoCzIkLms4cy5pby5hcGkuY29y",
            "ZS52MS5Ob2RlU2VsZWN0b3JUZXJtItwBCgVQcm9iZRIsCgdoYW5kbGVyGAEg",
            "ASgLMhsuazhzLmlvLmFwaS5jb3JlLnYxLkhhbmRsZXISGwoTaW5pdGlhbERl",
            "bGF5U2Vjb25kcxgCIAEoBRIWCg50aW1lb3V0U2Vjb25kcxgDIAEoBRIVCg1w",
            "ZXJpb2RTZWNvbmRzGAQgASgFEhgKEHN1Y2Nlc3NUaHJlc2hvbGQYBSABKAUS",
            "GAoQZmFpbHVyZVRocmVzaG9sZBgGIAEoBRIlCh10ZXJtaW5hdGlvbkdyYWNl",
            "UGVyaW9kU2Vjb25kcxgHIAEoAyJjChVQcm9qZWN0ZWRWb2x1bWVTb3VyY2US",
            "NQoHc291cmNlcxgBIAMoCzIkLms4cy5pby5hcGkuY29yZS52MS5Wb2x1bWVQ",
            "cm9qZWN0aW9uEhMKC2RlZmF1bHRNb2RlGAIgASgFInYKE1F1b2J5dGVWb2x1",
            "bWVTb3VyY2USEAoIcmVnaXN0cnkYASABKAkSDgoGdm9sdW1lGAIgASgJEhAK",
            "CHJlYWRPbmx5GAMgASgIEgwKBHVzZXIYBCABKAkSDQoFZ3JvdXAYBSABKAkS",
            "DgoGdGVuYW50GAYgASgJIsMBChlSQkRQZXJzaXN0ZW50Vm9sdW1lU291cmNl",
            "EhAKCG1vbml0b3JzGAEgAygJEg0KBWltYWdlGAIgASgJEg4KBmZzVHlwZRgD",
            "IAEoCRIMCgRwb29sGAQgASgJEgwKBHVzZXIYBSABKAkSDwoHa2V5cmluZxgG",
            "IAEoCRI2CglzZWNyZXRSZWYYByABKAsyIy5rOHMuaW8uYXBpLmNvcmUudjEu",
            "U2VjcmV0UmVmZXJlbmNlEhAKCHJlYWRPbmx5GAggASgIIr4BCg9SQkRWb2x1",
            "bWVTb3VyY2USEAoIbW9uaXRvcnMYASADKAkSDQoFaW1hZ2UYAiABKAkSDgoG",
            "ZnNUeXBlGAMgASgJEgwKBHBvb2wYBCABKAkSDAoEdXNlchgFIAEoCRIPCgdr",
            "ZXlyaW5nGAYgASgJEjsKCXNlY3JldFJlZhgHIAEoCzIoLms4cy5pby5hcGku",
            "Y29yZS52MS5Mb2NhbE9iamVjdFJlZmVyZW5jZRIQCghyZWFkT25seRgIIAEo",
            "CCJyCg9SYW5nZUFsbG9jYXRpb24SQgoIbWV0YWRhdGEYASABKAsyMC5rOHMu",
            "aW8uYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YRIN",
            "CgVyYW5nZRgCIAEoCRIMCgRkYXRhGAMgASgMItkBChVSZXBsaWNhdGlvbkNv",
            "bnRyb2xsZXISQgoIbWV0YWRhdGEYASABKAsyMC5rOHMuaW8uYXBpbWFjaGlu",
            "ZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YRI7CgRzcGVjGAIgASgL",
            "Mi0uazhzLmlvLmFwaS5jb3JlLnYxLlJlcGxpY2F0aW9uQ29udHJvbGxlclNw",
            "ZWMSPwoGc3RhdHVzGAMgASgLMi8uazhzLmlvLmFwaS5jb3JlLnYxLlJlcGxp",
            "Y2F0aW9uQ29udHJvbGxlclN0YXR1cyKnAQoeUmVwbGljYXRpb25Db250cm9s",
            "bGVyQ29uZGl0aW9uEgwKBHR5cGUYASABKAkSDgoGc3RhdHVzGAIgASgJEkYK",
            "Emxhc3RUcmFuc2l0aW9uVGltZRgDIAEoCzIqLms4cy5pby5hcGltYWNoaW5l",
            "cnkucGtnLmFwaXMubWV0YS52MS5UaW1lEg4KBnJlYXNvbhgEIAEoCRIPCgdt",
            "ZXNzYWdlGAUgASgJIpcBChlSZXBsaWNhdGlvbkNvbnRyb2xsZXJMaXN0EkAK",
            "CG1ldGFkYXRhGAEgASgLMi4uazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBp",
            "cy5tZXRhLnYxLkxpc3RNZXRhEjgKBWl0ZW1zGAIgAygLMikuazhzLmlvLmFw",
            "aS5jb3JlLnYxLlJlcGxpY2F0aW9uQ29udHJvbGxlciL9AQoZUmVwbGljYXRp",
            "b25Db250cm9sbGVyU3BlYxIQCghyZXBsaWNhcxgBIAEoBRIXCg9taW5SZWFk",
            "eVNlY29uZHMYBCABKAUSTQoIc2VsZWN0b3IYAiADKAsyOy5rOHMuaW8uYXBp",
            "LmNvcmUudjEuUmVwbGljYXRpb25Db250cm9sbGVyU3BlYy5TZWxlY3RvckVu",
            "dHJ5EjUKCHRlbXBsYXRlGAMgASgLMiMuazhzLmlvLmFwaS5jb3JlLnYxLlBv",
            "ZFRlbXBsYXRlU3BlYxovCg1TZWxlY3RvckVudHJ5EgsKA2tleRgBIAEoCRIN",
            "CgV2YWx1ZRgCIAEoCToCOAEi4wEKG1JlcGxpY2F0aW9uQ29udHJvbGxlclN0",
            "YXR1cxIQCghyZXBsaWNhcxgBIAEoBRIcChRmdWxseUxhYmVsZWRSZXBsaWNh",
            "cxgCIAEoBRIVCg1yZWFkeVJlcGxpY2FzGAQgASgFEhkKEWF2YWlsYWJsZVJl",
            "cGxpY2FzGAUgASgFEhoKEm9ic2VydmVkR2VuZXJhdGlvbhgDIAEoAxJGCgpj",
            "b25kaXRpb25zGAYgAygLMjIuazhzLmlvLmFwaS5jb3JlLnYxLlJlcGxpY2F0",
            "aW9uQ29udHJvbGxlckNvbmRpdGlvbiKBAQoVUmVzb3VyY2VGaWVsZFNlbGVj",
            "dG9yEhUKDWNvbnRhaW5lck5hbWUYASABKAkSEAoIcmVzb3VyY2UYAiABKAkS",
            "PwoHZGl2aXNvchgDIAEoCzIuLms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFw",
            "aS5yZXNvdXJjZS5RdWFudGl0eSLBAQoNUmVzb3VyY2VRdW90YRJCCghtZXRh",
            "ZGF0YRgBIAEoCzIwLms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0",
            "YS52MS5PYmplY3RNZXRhEjMKBHNwZWMYAiABKAsyJS5rOHMuaW8uYXBpLmNv",
            "cmUudjEuUmVzb3VyY2VRdW90YVNwZWMSNwoGc3RhdHVzGAMgASgLMicuazhz",
            "LmlvLmFwaS5jb3JlLnYxLlJlc291cmNlUXVvdGFTdGF0dXMihwEKEVJlc291",
            "cmNlUXVvdGFMaXN0EkAKCG1ldGFkYXRhGAEgASgLMi4uazhzLmlvLmFwaW1h",
            "Y2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxpc3RNZXRhEjAKBWl0ZW1zGAIg",
            "AygLMiEuazhzLmlvLmFwaS5jb3JlLnYxLlJlc291cmNlUXVvdGEi+QEKEVJl",
            "c291cmNlUXVvdGFTcGVjEj0KBGhhcmQYASADKAsyLy5rOHMuaW8uYXBpLmNv",
            "cmUudjEuUmVzb3VyY2VRdW90YVNwZWMuSGFyZEVudHJ5Eg4KBnNjb3BlcxgC",
            "IAMoCRI4Cg1zY29wZVNlbGVjdG9yGAMgASgLMiEuazhzLmlvLmFwaS5jb3Jl",
            "LnYxLlNjb3BlU2VsZWN0b3IaWwoJSGFyZEVudHJ5EgsKA2tleRgBIAEoCRI9",
            "CgV2YWx1ZRgCIAEoCzIuLms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFwaS5y",
            "ZXNvdXJjZS5RdWFudGl0eToCOAEi0QIKE1Jlc291cmNlUXVvdGFTdGF0dXMS",
            "PwoEaGFyZBgBIAMoCzIxLms4cy5pby5hcGkuY29yZS52MS5SZXNvdXJjZVF1",
            "b3RhU3RhdHVzLkhhcmRFbnRyeRI/CgR1c2VkGAIgAygLMjEuazhzLmlvLmFw",
            "aS5jb3JlLnYxLlJlc291cmNlUXVvdGFTdGF0dXMuVXNlZEVudHJ5GlsKCUhh",
            "cmRFbnRyeRILCgNrZXkYASABKAkSPQoFdmFsdWUYAiABKAsyLi5rOHMuaW8u",
            "YXBpbWFjaGluZXJ5LnBrZy5hcGkucmVzb3VyY2UuUXVhbnRpdHk6AjgBGlsK",
            "CVVzZWRFbnRyeRILCgNrZXkYASABKAkSPQoFdmFsdWUYAiABKAsyLi5rOHMu",
            "aW8uYXBpbWFjaGluZXJ5LnBrZy5hcGkucmVzb3VyY2UuUXVhbnRpdHk6AjgB",
            "IuYCChRSZXNvdXJjZVJlcXVpcmVtZW50cxJECgZsaW1pdHMYASADKAsyNC5r",
            "OHMuaW8uYXBpLmNvcmUudjEuUmVzb3VyY2VSZXF1aXJlbWVudHMuTGltaXRz",
            "RW50cnkSSAoIcmVxdWVzdHMYAiADKAsyNi5rOHMuaW8uYXBpLmNvcmUudjEu",
            "UmVzb3VyY2VSZXF1aXJlbWVudHMuUmVxdWVzdHNFbnRyeRpdCgtMaW1pdHNF",
            "bnRyeRILCgNrZXkYASABKAkSPQoFdmFsdWUYAiABKAsyLi5rOHMuaW8uYXBp",
            "bWFjaGluZXJ5LnBrZy5hcGkucmVzb3VyY2UuUXVhbnRpdHk6AjgBGl8KDVJl",
            "cXVlc3RzRW50cnkSCwoDa2V5GAEgASgJEj0KBXZhbHVlGAIgASgLMi4uazhz",
            "LmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpLnJlc291cmNlLlF1YW50aXR5OgI4",
            "ASJJCg5TRUxpbnV4T3B0aW9ucxIMCgR1c2VyGAEgASgJEgwKBHJvbGUYAiAB",
            "KAkSDAoEdHlwZRgDIAEoCRINCgVsZXZlbBgEIAEoCSKGAgodU2NhbGVJT1Bl",
            "cnNpc3RlbnRWb2x1bWVTb3VyY2USDwoHZ2F0ZXdheRgBIAEoCRIOCgZzeXN0",
            "ZW0YAiABKAkSNgoJc2VjcmV0UmVmGAMgASgLMiMuazhzLmlvLmFwaS5jb3Jl",
            "LnYxLlNlY3JldFJlZmVyZW5jZRISCgpzc2xFbmFibGVkGAQgASgIEhgKEHBy",
            "b3RlY3Rpb25Eb21haW4YBSABKAkSEwoLc3RvcmFnZVBvb2wYBiABKAkSEwoL",
            "c3RvcmFnZU1vZGUYByABKAkSEgoKdm9sdW1lTmFtZRgIIAEoCRIOCgZmc1R5",
            "cGUYCSABKAkSEAoIcmVhZE9ubHkYCiABKAgigQIKE1NjYWxlSU9Wb2x1bWVT",
            "b3VyY2USDwoHZ2F0ZXdheRgBIAEoCRIOCgZzeXN0ZW0YAiABKAkSOwoJc2Vj",
            "cmV0UmVmGAMgASgLMiguazhzLmlvLmFwaS5jb3JlLnYxLkxvY2FsT2JqZWN0",
            "UmVmZXJlbmNlEhIKCnNzbEVuYWJsZWQYBCABKAgSGAoQcHJvdGVjdGlvbkRv",
            "bWFpbhgFIAEoCRITCgtzdG9yYWdlUG9vbBgGIAEoCRITCgtzdG9yYWdlTW9k",
            "ZRgHIAEoCRISCgp2b2x1bWVOYW1lGAggASgJEg4KBmZzVHlwZRgJIAEoCRIQ",
            "CghyZWFkT25seRgKIAEoCCJgCg1TY29wZVNlbGVjdG9yEk8KEG1hdGNoRXhw",
            "cmVzc2lvbnMYASADKAsyNS5rOHMuaW8uYXBpLmNvcmUudjEuU2NvcGVkUmVz",
            "b3VyY2VTZWxlY3RvclJlcXVpcmVtZW50IlgKIVNjb3BlZFJlc291cmNlU2Vs",
            "ZWN0b3JSZXF1aXJlbWVudBIRCglzY29wZU5hbWUYASABKAkSEAoIb3BlcmF0",
            "b3IYAiABKAkSDgoGdmFsdWVzGAMgAygJIjgKDlNlY2NvbXBQcm9maWxlEgwK",
            "BHR5cGUYASABKAkSGAoQbG9jYWxob3N0UHJvZmlsZRgCIAEoCSLBAgoGU2Vj",
            "cmV0EkIKCG1ldGFkYXRhGAEgASgLMjAuazhzLmlvLmFwaW1hY2hpbmVyeS5w",
            "a2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGESEQoJaW1tdXRhYmxlGAUgASgI",
            "EjIKBGRhdGEYAiADKAsyJC5rOHMuaW8uYXBpLmNvcmUudjEuU2VjcmV0LkRh",
            "dGFFbnRyeRI+CgpzdHJpbmdEYXRhGAQgAygLMiouazhzLmlvLmFwaS5jb3Jl",
            "LnYxLlNlY3JldC5TdHJpbmdEYXRhRW50cnkSDAoEdHlwZRgDIAEoCRorCglE",
            "YXRhRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgMOgI4ARoxCg9T",
            "dHJpbmdEYXRhRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4",
            "ASJrCg9TZWNyZXRFbnZTb3VyY2USRgoUbG9jYWxPYmplY3RSZWZlcmVuY2UY",
            "ASABKAsyKC5rOHMuaW8uYXBpLmNvcmUudjEuTG9jYWxPYmplY3RSZWZlcmVu",
            "Y2USEAoIb3B0aW9uYWwYAiABKAgiegoRU2VjcmV0S2V5U2VsZWN0b3ISRgoU",
            "bG9jYWxPYmplY3RSZWZlcmVuY2UYASABKAsyKC5rOHMuaW8uYXBpLmNvcmUu",
            "djEuTG9jYWxPYmplY3RSZWZlcmVuY2USCwoDa2V5GAIgASgJEhAKCG9wdGlv",
            "bmFsGAMgASgIInkKClNlY3JldExpc3QSQAoIbWV0YWRhdGEYASABKAsyLi5r",
            "OHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGlzdE1ldGES",
            "KQoFaXRlbXMYAiADKAsyGi5rOHMuaW8uYXBpLmNvcmUudjEuU2VjcmV0IpoB",
            "ChBTZWNyZXRQcm9qZWN0aW9uEkYKFGxvY2FsT2JqZWN0UmVmZXJlbmNlGAEg",
            "ASgLMiguazhzLmlvLmFwaS5jb3JlLnYxLkxvY2FsT2JqZWN0UmVmZXJlbmNl",
            "EiwKBWl0ZW1zGAIgAygLMh0uazhzLmlvLmFwaS5jb3JlLnYxLktleVRvUGF0",
            "aBIQCghvcHRpb25hbBgEIAEoCCIyCg9TZWNyZXRSZWZlcmVuY2USDAoEbmFt",
            "ZRgBIAEoCRIRCgluYW1lc3BhY2UYAiABKAkifQoSU2VjcmV0Vm9sdW1lU291",
            "cmNlEhIKCnNlY3JldE5hbWUYASABKAkSLAoFaXRlbXMYAiADKAsyHS5rOHMu",
            "aW8uYXBpLmNvcmUudjEuS2V5VG9QYXRoEhMKC2RlZmF1bHRNb2RlGAMgASgF",
            "EhAKCG9wdGlvbmFsGAQgASgIIrIDCg9TZWN1cml0eUNvbnRleHQSNgoMY2Fw",
            "YWJpbGl0aWVzGAEgASgLMiAuazhzLmlvLmFwaS5jb3JlLnYxLkNhcGFiaWxp",
            "dGllcxISCgpwcml2aWxlZ2VkGAIgASgIEjoKDnNlTGludXhPcHRpb25zGAMg",
            "ASgLMiIuazhzLmlvLmFwaS5jb3JlLnYxLlNFTGludXhPcHRpb25zEkkKDndp",
            "bmRvd3NPcHRpb25zGAogASgLMjEuazhzLmlvLmFwaS5jb3JlLnYxLldpbmRv",
            "d3NTZWN1cml0eUNvbnRleHRPcHRpb25zEhEKCXJ1bkFzVXNlchgEIAEoAxIS",
            "CgpydW5Bc0dyb3VwGAggASgDEhQKDHJ1bkFzTm9uUm9vdBgFIAEoCBIeChZy",
            "ZWFkT25seVJvb3RGaWxlc3lzdGVtGAYgASgIEiAKGGFsbG93UHJpdmlsZWdl",
            "RXNjYWxhdGlvbhgHIAEoCBIRCglwcm9jTW91bnQYCSABKAkSOgoOc2VjY29t",
            "cFByb2ZpbGUYCyABKAsyIi5rOHMuaW8uYXBpLmNvcmUudjEuU2VjY29tcFBy",
            "b2ZpbGUiTQoTU2VyaWFsaXplZFJlZmVyZW5jZRI2CglyZWZlcmVuY2UYASAB",
            "KAsyIy5rOHMuaW8uYXBpLmNvcmUudjEuT2JqZWN0UmVmZXJlbmNlIq8BCgdT",
            "ZXJ2aWNlEkIKCG1ldGFkYXRhGAEgASgLMjAuazhzLmlvLmFwaW1hY2hpbmVy",
            "eS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGESLQoEc3BlYxgCIAEoCzIf",
            "Lms4cy5pby5hcGkuY29yZS52MS5TZXJ2aWNlU3BlYxIxCgZzdGF0dXMYAyAB",
            "KAsyIS5rOHMuaW8uYXBpLmNvcmUudjEuU2VydmljZVN0YXR1cyL0AQoOU2Vy",
            "dmljZUFjY291bnQSQgoIbWV0YWRhdGEYASABKAsyMC5rOHMuaW8uYXBpbWFj",
            "aGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuT2JqZWN0TWV0YRI0CgdzZWNyZXRz",
            "GAIgAygLMiMuazhzLmlvLmFwaS5jb3JlLnYxLk9iamVjdFJlZmVyZW5jZRJC",
            "ChBpbWFnZVB1bGxTZWNyZXRzGAMgAygLMiguazhzLmlvLmFwaS5jb3JlLnYx",
            "LkxvY2FsT2JqZWN0UmVmZXJlbmNlEiQKHGF1dG9tb3VudFNlcnZpY2VBY2Nv",
            "dW50VG9rZW4YBCABKAgiiQEKElNlcnZpY2VBY2NvdW50TGlzdBJACghtZXRh",
            "ZGF0YRgBIAEoCzIuLms4cy5pby5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0",
            "YS52MS5MaXN0TWV0YRIxCgVpdGVtcxgCIAMoCzIiLms4cy5pby5hcGkuY29y",
            "ZS52MS5TZXJ2aWNlQWNjb3VudCJaCh1TZXJ2aWNlQWNjb3VudFRva2VuUHJv",
            "amVjdGlvbhIQCghhdWRpZW5jZRgBIAEoCRIZChFleHBpcmF0aW9uU2Vjb25k",
            "cxgCIAEoAxIMCgRwYXRoGAMgASgJInsKC1NlcnZpY2VMaXN0EkAKCG1ldGFk",
            "YXRhGAEgASgLMi4uazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRh",
            "LnYxLkxpc3RNZXRhEioKBWl0ZW1zGAIgAygLMhsuazhzLmlvLmFwaS5jb3Jl",
            "LnYxLlNlcnZpY2UiqAEKC1NlcnZpY2VQb3J0EgwKBG5hbWUYASABKAkSEAoI",
            "cHJvdG9jb2wYAiABKAkSEwoLYXBwUHJvdG9jb2wYBiABKAkSDAoEcG9ydBgD",
            "IAEoBRJECgp0YXJnZXRQb3J0GAQgASgLMjAuazhzLmlvLmFwaW1hY2hpbmVy",
            "eS5wa2cudXRpbC5pbnRzdHIuSW50T3JTdHJpbmcSEAoIbm9kZVBvcnQYBSAB",
            "KAUiIwoTU2VydmljZVByb3h5T3B0aW9ucxIMCgRwYXRoGAEgASgJIpcFCgtT",
            "ZXJ2aWNlU3BlYxIuCgVwb3J0cxgBIAMoCzIfLms4cy5pby5hcGkuY29yZS52",
            "MS5TZXJ2aWNlUG9ydBI/CghzZWxlY3RvchgCIAMoCzItLms4cy5pby5hcGku",
            "Y29yZS52MS5TZXJ2aWNlU3BlYy5TZWxlY3RvckVudHJ5EhEKCWNsdXN0ZXJJ",
            "UBgDIAEoCRISCgpjbHVzdGVySVBzGBIgAygJEgwKBHR5cGUYBCABKAkSEwoL",
            "ZXh0ZXJuYWxJUHMYBSADKAkSFwoPc2Vzc2lvbkFmZmluaXR5GAcgASgJEhYK",
            "DmxvYWRCYWxhbmNlcklQGAggASgJEiAKGGxvYWRCYWxhbmNlclNvdXJjZVJh",
            "bmdlcxgJIAMoCRIUCgxleHRlcm5hbE5hbWUYCiABKAkSHQoVZXh0ZXJuYWxU",
            "cmFmZmljUG9saWN5GAsgASgJEhsKE2hlYWx0aENoZWNrTm9kZVBvcnQYDCAB",
            "KAUSIAoYcHVibGlzaE5vdFJlYWR5QWRkcmVzc2VzGA0gASgIEkgKFXNlc3Np",
            "b25BZmZpbml0eUNvbmZpZxgOIAEoCzIpLms4cy5pby5hcGkuY29yZS52MS5T",
            "ZXNzaW9uQWZmaW5pdHlDb25maWcSEgoKaXBGYW1pbGllcxgTIAMoCRIWCg5p",
            "cEZhbWlseVBvbGljeRgRIAEoCRIlCh1hbGxvY2F0ZUxvYWRCYWxhbmNlck5v",
            "ZGVQb3J0cxgUIAEoCBIZChFsb2FkQmFsYW5jZXJDbGFzcxgVIAEoCRIdChVp",
            "bnRlcm5hbFRyYWZmaWNQb2xpY3kYFiABKAkaLwoNU2VsZWN0b3JFbnRyeRIL",
            "CgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBIpIBCg1TZXJ2aWNlU3Rh",
            "dHVzEjwKDGxvYWRCYWxhbmNlchgBIAEoCzImLms4cy5pby5hcGkuY29yZS52",
            "MS5Mb2FkQmFsYW5jZXJTdGF0dXMSQwoKY29uZGl0aW9ucxgCIAMoCzIvLms4",
            "cy5pby5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5Db25kaXRpb24i",
            "TQoVU2Vzc2lvbkFmZmluaXR5Q29uZmlnEjQKCGNsaWVudElQGAEgASgLMiIu",
            "azhzLmlvLmFwaS5jb3JlLnYxLkNsaWVudElQQ29uZmlnIqgBCh9TdG9yYWdl",
            "T1NQZXJzaXN0ZW50Vm9sdW1lU291cmNlEhIKCnZvbHVtZU5hbWUYASABKAkS",
            "FwoPdm9sdW1lTmFtZXNwYWNlGAIgASgJEg4KBmZzVHlwZRgDIAEoCRIQCghy",
            "ZWFkT25seRgEIAEoCBI2CglzZWNyZXRSZWYYBSABKAsyIy5rOHMuaW8uYXBp",
            "LmNvcmUudjEuT2JqZWN0UmVmZXJlbmNlIqMBChVTdG9yYWdlT1NWb2x1bWVT",
            "b3VyY2USEgoKdm9sdW1lTmFtZRgBIAEoCRIXCg92b2x1bWVOYW1lc3BhY2UY",
            "AiABKAkSDgoGZnNUeXBlGAMgASgJEhAKCHJlYWRPbmx5GAQgASgIEjsKCXNl",
            "Y3JldFJlZhgFIAEoCzIoLms4cy5pby5hcGkuY29yZS52MS5Mb2NhbE9iamVj",
            "dFJlZmVyZW5jZSIlCgZTeXNjdGwSDAoEbmFtZRgBIAEoCRINCgV2YWx1ZRgC",
            "IAEoCSJfCg9UQ1BTb2NrZXRBY3Rpb24SPgoEcG9ydBgBIAEoCzIwLms4cy5p",
            "by5hcGltYWNoaW5lcnkucGtnLnV0aWwuaW50c3RyLkludE9yU3RyaW5nEgwK",
            "BGhvc3QYAiABKAkicgoFVGFpbnQSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIg",
            "ASgJEg4KBmVmZmVjdBgDIAEoCRI9Cgl0aW1lQWRkZWQYBCABKAsyKi5rOHMu",
            "aW8uYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuVGltZSJlCgpUb2xl",
            "cmF0aW9uEgsKA2tleRgBIAEoCRIQCghvcGVyYXRvchgCIAEoCRINCgV2YWx1",
            "ZRgDIAEoCRIOCgZlZmZlY3QYBCABKAkSGQoRdG9sZXJhdGlvblNlY29uZHMY",
            "BSABKAMiPwogVG9wb2xvZ3lTZWxlY3RvckxhYmVsUmVxdWlyZW1lbnQSCwoD",
            "a2V5GAEgASgJEg4KBnZhbHVlcxgCIAMoCSJrChRUb3BvbG9neVNlbGVjdG9y",
            "VGVybRJTChVtYXRjaExhYmVsRXhwcmVzc2lvbnMYASADKAsyNC5rOHMuaW8u",
            "YXBpLmNvcmUudjEuVG9wb2xvZ3lTZWxlY3RvckxhYmVsUmVxdWlyZW1lbnQi",
            "pwEKGFRvcG9sb2d5U3ByZWFkQ29uc3RyYWludBIPCgdtYXhTa2V3GAEgASgF",
            "EhMKC3RvcG9sb2d5S2V5GAIgASgJEhkKEXdoZW5VbnNhdGlzZmlhYmxlGAMg",
            "ASgJEkoKDWxhYmVsU2VsZWN0b3IYBCABKAsyMy5rOHMuaW8uYXBpbWFjaGlu",
            "ZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGFiZWxTZWxlY3RvciJJChlUeXBlZExv",
            "Y2FsT2JqZWN0UmVmZXJlbmNlEhAKCGFwaUdyb3VwGAEgASgJEgwKBGtpbmQY",
            "AiABKAkSDAoEbmFtZRgDIAEoCSJOCgZWb2x1bWUSDAoEbmFtZRgBIAEoCRI2",
            "Cgx2b2x1bWVTb3VyY2UYAiABKAsyIC5rOHMuaW8uYXBpLmNvcmUudjEuVm9s",
            "dW1lU291cmNlIjAKDFZvbHVtZURldmljZRIMCgRuYW1lGAEgASgJEhIKCmRl",
            "dmljZVBhdGgYAiABKAkigAEKC1ZvbHVtZU1vdW50EgwKBG5hbWUYASABKAkS",
            "EAoIcmVhZE9ubHkYAiABKAgSEQoJbW91bnRQYXRoGAMgASgJEg8KB3N1YlBh",
            "dGgYBCABKAkSGAoQbW91bnRQcm9wYWdhdGlvbhgFIAEoCRITCgtzdWJQYXRo",
            "RXhwchgGIAEoCSJIChJWb2x1bWVOb2RlQWZmaW5pdHkSMgoIcmVxdWlyZWQY",
            "ASABKAsyIC5rOHMuaW8uYXBpLmNvcmUudjEuTm9kZVNlbGVjdG9yIpQCChBW",
            "b2x1bWVQcm9qZWN0aW9uEjQKBnNlY3JldBgBIAEoCzIkLms4cy5pby5hcGku",
            "Y29yZS52MS5TZWNyZXRQcm9qZWN0aW9uEj4KC2Rvd253YXJkQVBJGAIgASgL",
            "MikuazhzLmlvLmFwaS5jb3JlLnYxLkRvd253YXJkQVBJUHJvamVjdGlvbhI6",
            "Cgljb25maWdNYXAYAyABKAsyJy5rOHMuaW8uYXBpLmNvcmUudjEuQ29uZmln",
            "TWFwUHJvamVjdGlvbhJOChNzZXJ2aWNlQWNjb3VudFRva2VuGAQgASgLMjEu",
            "azhzLmlvLmFwaS5jb3JlLnYxLlNlcnZpY2VBY2NvdW50VG9rZW5Qcm9qZWN0",
            "aW9uIpkOCgxWb2x1bWVTb3VyY2USOgoIaG9zdFBhdGgYASABKAsyKC5rOHMu",
            "aW8uYXBpLmNvcmUudjEuSG9zdFBhdGhWb2x1bWVTb3VyY2USOgoIZW1wdHlE",
            "aXIYAiABKAsyKC5rOHMuaW8uYXBpLmNvcmUudjEuRW1wdHlEaXJWb2x1bWVT",
            "b3VyY2USTAoRZ2NlUGVyc2lzdGVudERpc2sYAyABKAsyMS5rOHMuaW8uYXBp",
            "LmNvcmUudjEuR0NFUGVyc2lzdGVudERpc2tWb2x1bWVTb3VyY2USUgoUYXdz",
            "RWxhc3RpY0Jsb2NrU3RvcmUYBCABKAsyNC5rOHMuaW8uYXBpLmNvcmUudjEu",
            "QVdTRWxhc3RpY0Jsb2NrU3RvcmVWb2x1bWVTb3VyY2USOAoHZ2l0UmVwbxgF",
            "IAEoCzInLms4cy5pby5hcGkuY29yZS52MS5HaXRSZXBvVm9sdW1lU291cmNl",
            "EjYKBnNlY3JldBgGIAEoCzImLms4cy5pby5hcGkuY29yZS52MS5TZWNyZXRW",
            "b2x1bWVTb3VyY2USMAoDbmZzGAcgASgLMiMuazhzLmlvLmFwaS5jb3JlLnYx",
            "Lk5GU1ZvbHVtZVNvdXJjZRI0CgVpc2NzaRgIIAEoCzIlLms4cy5pby5hcGku",
            "Y29yZS52MS5JU0NTSVZvbHVtZVNvdXJjZRI8CglnbHVzdGVyZnMYCSABKAsy",
            "KS5rOHMuaW8uYXBpLmNvcmUudjEuR2x1c3RlcmZzVm9sdW1lU291cmNlElQK",
            "FXBlcnNpc3RlbnRWb2x1bWVDbGFpbRgKIAEoCzI1Lms4cy5pby5hcGkuY29y",
            "ZS52MS5QZXJzaXN0ZW50Vm9sdW1lQ2xhaW1Wb2x1bWVTb3VyY2USMAoDcmJk",
            "GAsgASgLMiMuazhzLmlvLmFwaS5jb3JlLnYxLlJCRFZvbHVtZVNvdXJjZRI4",
            "CgpmbGV4Vm9sdW1lGAwgASgLMiQuazhzLmlvLmFwaS5jb3JlLnYxLkZsZXhW",
            "b2x1bWVTb3VyY2USNgoGY2luZGVyGA0gASgLMiYuazhzLmlvLmFwaS5jb3Jl",
            "LnYxLkNpbmRlclZvbHVtZVNvdXJjZRI2CgZjZXBoZnMYDiABKAsyJi5rOHMu",
            "aW8uYXBpLmNvcmUudjEuQ2VwaEZTVm9sdW1lU291cmNlEjgKB2Zsb2NrZXIY",
            "DyABKAsyJy5rOHMuaW8uYXBpLmNvcmUudjEuRmxvY2tlclZvbHVtZVNvdXJj",
            "ZRJACgtkb3dud2FyZEFQSRgQIAEoCzIrLms4cy5pby5hcGkuY29yZS52MS5E",
            "b3dud2FyZEFQSVZvbHVtZVNvdXJjZRIuCgJmYxgRIAEoCzIiLms4cy5pby5h",
            "cGkuY29yZS52MS5GQ1ZvbHVtZVNvdXJjZRI8CglhenVyZUZpbGUYEiABKAsy",
            "KS5rOHMuaW8uYXBpLmNvcmUudjEuQXp1cmVGaWxlVm9sdW1lU291cmNlEjwK",
            "CWNvbmZpZ01hcBgTIAEoCzIpLms4cy5pby5hcGkuY29yZS52MS5Db25maWdN",
            "YXBWb2x1bWVTb3VyY2USSQoNdnNwaGVyZVZvbHVtZRgUIAEoCzIyLms4cy5p",
            "by5hcGkuY29yZS52MS5Wc3BoZXJlVmlydHVhbERpc2tWb2x1bWVTb3VyY2US",
            "OAoHcXVvYnl0ZRgVIAEoCzInLms4cy5pby5hcGkuY29yZS52MS5RdW9ieXRl",
            "Vm9sdW1lU291cmNlEjwKCWF6dXJlRGlzaxgWIAEoCzIpLms4cy5pby5hcGku",
            "Y29yZS52MS5BenVyZURpc2tWb2x1bWVTb3VyY2USUgoUcGhvdG9uUGVyc2lz",
            "dGVudERpc2sYFyABKAsyNC5rOHMuaW8uYXBpLmNvcmUudjEuUGhvdG9uUGVy",
            "c2lzdGVudERpc2tWb2x1bWVTb3VyY2USPAoJcHJvamVjdGVkGBogASgLMiku",
            "azhzLmlvLmFwaS5jb3JlLnYxLlByb2plY3RlZFZvbHVtZVNvdXJjZRJACg5w",
            "b3J0d29yeFZvbHVtZRgYIAEoCzIoLms4cy5pby5hcGkuY29yZS52MS5Qb3J0",
            "d29yeFZvbHVtZVNvdXJjZRI4CgdzY2FsZUlPGBkgASgLMicuazhzLmlvLmFw",
            "aS5jb3JlLnYxLlNjYWxlSU9Wb2x1bWVTb3VyY2USPAoJc3RvcmFnZW9zGBsg",
            "ASgLMikuazhzLmlvLmFwaS5jb3JlLnYxLlN0b3JhZ2VPU1ZvbHVtZVNvdXJj",
            "ZRIwCgNjc2kYHCABKAsyIy5rOHMuaW8uYXBpLmNvcmUudjEuQ1NJVm9sdW1l",
            "U291cmNlEjwKCWVwaGVtZXJhbBgdIAEoCzIpLms4cy5pby5hcGkuY29yZS52",
            "MS5FcGhlbWVyYWxWb2x1bWVTb3VyY2UieAoeVnNwaGVyZVZpcnR1YWxEaXNr",
            "Vm9sdW1lU291cmNlEhIKCnZvbHVtZVBhdGgYASABKAkSDgoGZnNUeXBlGAIg",
            "ASgJEhkKEXN0b3JhZ2VQb2xpY3lOYW1lGAMgASgJEhcKD3N0b3JhZ2VQb2xp",
            "Y3lJRBgEIAEoCSJnChdXZWlnaHRlZFBvZEFmZmluaXR5VGVybRIOCgZ3ZWln",
            "aHQYASABKAUSPAoPcG9kQWZmaW5pdHlUZXJtGAIgASgLMiMuazhzLmlvLmFw",
            "aS5jb3JlLnYxLlBvZEFmZmluaXR5VGVybSKHAQodV2luZG93c1NlY3VyaXR5",
            "Q29udGV4dE9wdGlvbnMSHgoWZ21zYUNyZWRlbnRpYWxTcGVjTmFtZRgBIAEo",
            "CRIaChJnbXNhQ3JlZGVudGlhbFNwZWMYAiABKAkSFQoNcnVuQXNVc2VyTmFt",
            "ZRgDIAEoCRITCgtob3N0UHJvY2VzcxgEIAEoCEIEWgJ2MQ=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::K8S.Io.Apimachinery.Pkg.Api.Resource.GeneratedReflection.Descriptor, global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.GeneratedReflection.Descriptor, global::K8S.Io.Apimachinery.Pkg.Runtime.GeneratedReflection.Descriptor, global::K8S.Io.Apimachinery.Pkg.Runtime.Schema.GeneratedReflection.Descriptor, global::K8S.Io.Apimachinery.Pkg.Util.Intstr.GeneratedReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource), global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource.Parser, new[]{ "VolumeID", "FsType", "Partition", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Affinity), global::K8S.Io.Api.Core.V1.Affinity.Parser, new[]{ "NodeAffinity", "PodAffinity", "PodAntiAffinity" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.AttachedVolume), global::K8S.Io.Api.Core.V1.AttachedVolume.Parser, new[]{ "Name", "DevicePath" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.AvoidPods), global::K8S.Io.Api.Core.V1.AvoidPods.Parser, new[]{ "PreferAvoidPods" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource), global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource.Parser, new[]{ "DiskName", "DiskURI", "CachingMode", "FsType", "ReadOnly", "Kind" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.AzureFilePersistentVolumeSource), global::K8S.Io.Api.Core.V1.AzureFilePersistentVolumeSource.Parser, new[]{ "SecretName", "ShareName", "ReadOnly", "SecretNamespace" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.AzureFileVolumeSource), global::K8S.Io.Api.Core.V1.AzureFileVolumeSource.Parser, new[]{ "SecretName", "ShareName", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Binding), global::K8S.Io.Api.Core.V1.Binding.Parser, new[]{ "Metadata", "Target" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.CSIPersistentVolumeSource), global::K8S.Io.Api.Core.V1.CSIPersistentVolumeSource.Parser, new[]{ "Driver", "VolumeHandle", "ReadOnly", "FsType", "VolumeAttributes", "ControllerPublishSecretRef", "NodeStageSecretRef", "NodePublishSecretRef", "ControllerExpandSecretRef" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.CSIVolumeSource), global::K8S.Io.Api.Core.V1.CSIVolumeSource.Parser, new[]{ "Driver", "ReadOnly", "FsType", "VolumeAttributes", "NodePublishSecretRef" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Capabilities), global::K8S.Io.Api.Core.V1.Capabilities.Parser, new[]{ "Add", "Drop" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.CephFSPersistentVolumeSource), global::K8S.Io.Api.Core.V1.CephFSPersistentVolumeSource.Parser, new[]{ "Monitors", "Path", "User", "SecretFile", "SecretRef", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.CephFSVolumeSource), global::K8S.Io.Api.Core.V1.CephFSVolumeSource.Parser, new[]{ "Monitors", "Path", "User", "SecretFile", "SecretRef", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.CinderPersistentVolumeSource), global::K8S.Io.Api.Core.V1.CinderPersistentVolumeSource.Parser, new[]{ "VolumeID", "FsType", "ReadOnly", "SecretRef" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.CinderVolumeSource), global::K8S.Io.Api.Core.V1.CinderVolumeSource.Parser, new[]{ "VolumeID", "FsType", "ReadOnly", "SecretRef" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ClientIPConfig), global::K8S.Io.Api.Core.V1.ClientIPConfig.Parser, new[]{ "TimeoutSeconds" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ComponentCondition), global::K8S.Io.Api.Core.V1.ComponentCondition.Parser, new[]{ "Type", "Status", "Message", "Error" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ComponentStatus), global::K8S.Io.Api.Core.V1.ComponentStatus.Parser, new[]{ "Metadata", "Conditions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ComponentStatusList), global::K8S.Io.Api.Core.V1.ComponentStatusList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ConfigMap), global::K8S.Io.Api.Core.V1.ConfigMap.Parser, new[]{ "Metadata", "Immutable", "Data", "BinaryData" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ConfigMapEnvSource), global::K8S.Io.Api.Core.V1.ConfigMapEnvSource.Parser, new[]{ "LocalObjectReference", "Optional" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ConfigMapKeySelector), global::K8S.Io.Api.Core.V1.ConfigMapKeySelector.Parser, new[]{ "LocalObjectReference", "Key", "Optional" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ConfigMapList), global::K8S.Io.Api.Core.V1.ConfigMapList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ConfigMapNodeConfigSource), global::K8S.Io.Api.Core.V1.ConfigMapNodeConfigSource.Parser, new[]{ "Namespace", "Name", "Uid", "ResourceVersion", "KubeletConfigKey" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ConfigMapProjection), global::K8S.Io.Api.Core.V1.ConfigMapProjection.Parser, new[]{ "LocalObjectReference", "Items", "Optional" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ConfigMapVolumeSource), global::K8S.Io.Api.Core.V1.ConfigMapVolumeSource.Parser, new[]{ "LocalObjectReference", "Items", "DefaultMode", "Optional" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Container), global::K8S.Io.Api.Core.V1.Container.Parser, new[]{ "Name", "Image", "Command", "Args", "WorkingDir", "Ports", "EnvFrom", "Env", "Resources", "VolumeMounts", "VolumeDevices", "LivenessProbe", "ReadinessProbe", "StartupProbe", "Lifecycle", "TerminationMessagePath", "TerminationMessagePolicy", "ImagePullPolicy", "SecurityContext", "Stdin", "StdinOnce", "Tty" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ContainerImage), global::K8S.Io.Api.Core.V1.ContainerImage.Parser, new[]{ "Names", "SizeBytes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ContainerPort), global::K8S.Io.Api.Core.V1.ContainerPort.Parser, new[]{ "Name", "HostPort", "ContainerPort_", "Protocol", "HostIP" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ContainerState), global::K8S.Io.Api.Core.V1.ContainerState.Parser, new[]{ "Waiting", "Running", "Terminated" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ContainerStateRunning), global::K8S.Io.Api.Core.V1.ContainerStateRunning.Parser, new[]{ "StartedAt" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ContainerStateTerminated), global::K8S.Io.Api.Core.V1.ContainerStateTerminated.Parser, new[]{ "ExitCode", "Signal", "Reason", "Message", "StartedAt", "FinishedAt", "ContainerID" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ContainerStateWaiting), global::K8S.Io.Api.Core.V1.ContainerStateWaiting.Parser, new[]{ "Reason", "Message" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ContainerStatus), global::K8S.Io.Api.Core.V1.ContainerStatus.Parser, new[]{ "Name", "State", "LastState", "Ready", "RestartCount", "Image", "ImageID", "ContainerID", "Started" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.DaemonEndpoint), global::K8S.Io.Api.Core.V1.DaemonEndpoint.Parser, new[]{ "Port" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.DownwardAPIProjection), global::K8S.Io.Api.Core.V1.DownwardAPIProjection.Parser, new[]{ "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile), global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile.Parser, new[]{ "Path", "FieldRef", "ResourceFieldRef", "Mode" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.DownwardAPIVolumeSource), global::K8S.Io.Api.Core.V1.DownwardAPIVolumeSource.Parser, new[]{ "Items", "DefaultMode" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EmptyDirVolumeSource), global::K8S.Io.Api.Core.V1.EmptyDirVolumeSource.Parser, new[]{ "Medium", "SizeLimit" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EndpointAddress), global::K8S.Io.Api.Core.V1.EndpointAddress.Parser, new[]{ "Ip", "Hostname", "NodeName", "TargetRef" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EndpointPort), global::K8S.Io.Api.Core.V1.EndpointPort.Parser, new[]{ "Name", "Port", "Protocol", "AppProtocol" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EndpointSubset), global::K8S.Io.Api.Core.V1.EndpointSubset.Parser, new[]{ "Addresses", "NotReadyAddresses", "Ports" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Endpoints), global::K8S.Io.Api.Core.V1.Endpoints.Parser, new[]{ "Metadata", "Subsets" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EndpointsList), global::K8S.Io.Api.Core.V1.EndpointsList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EnvFromSource), global::K8S.Io.Api.Core.V1.EnvFromSource.Parser, new[]{ "Prefix", "ConfigMapRef", "SecretRef" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EnvVar), global::K8S.Io.Api.Core.V1.EnvVar.Parser, new[]{ "Name", "Value", "ValueFrom" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EnvVarSource), global::K8S.Io.Api.Core.V1.EnvVarSource.Parser, new[]{ "FieldRef", "ResourceFieldRef", "ConfigMapKeyRef", "SecretKeyRef" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EphemeralContainer), global::K8S.Io.Api.Core.V1.EphemeralContainer.Parser, new[]{ "EphemeralContainerCommon", "TargetContainerName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EphemeralContainerCommon), global::K8S.Io.Api.Core.V1.EphemeralContainerCommon.Parser, new[]{ "Name", "Image", "Command", "Args", "WorkingDir", "Ports", "EnvFrom", "Env", "Resources", "VolumeMounts", "VolumeDevices", "LivenessProbe", "ReadinessProbe", "StartupProbe", "Lifecycle", "TerminationMessagePath", "TerminationMessagePolicy", "ImagePullPolicy", "SecurityContext", "Stdin", "StdinOnce", "Tty" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EphemeralVolumeSource), global::K8S.Io.Api.Core.V1.EphemeralVolumeSource.Parser, new[]{ "VolumeClaimTemplate" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Event), global::K8S.Io.Api.Core.V1.Event.Parser, new[]{ "Metadata", "InvolvedObject", "Reason", "Message", "Source", "FirstTimestamp", "LastTimestamp", "Count", "Type", "EventTime", "Series", "Action", "Related", "ReportingComponent", "ReportingInstance" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EventList), global::K8S.Io.Api.Core.V1.EventList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EventSeries), global::K8S.Io.Api.Core.V1.EventSeries.Parser, new[]{ "Count", "LastObservedTime" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.EventSource), global::K8S.Io.Api.Core.V1.EventSource.Parser, new[]{ "Component", "Host" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ExecAction), global::K8S.Io.Api.Core.V1.ExecAction.Parser, new[]{ "Command" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.FCVolumeSource), global::K8S.Io.Api.Core.V1.FCVolumeSource.Parser, new[]{ "TargetWWNs", "Lun", "FsType", "ReadOnly", "Wwids" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.FlexPersistentVolumeSource), global::K8S.Io.Api.Core.V1.FlexPersistentVolumeSource.Parser, new[]{ "Driver", "FsType", "SecretRef", "ReadOnly", "Options" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.FlexVolumeSource), global::K8S.Io.Api.Core.V1.FlexVolumeSource.Parser, new[]{ "Driver", "FsType", "SecretRef", "ReadOnly", "Options" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.FlockerVolumeSource), global::K8S.Io.Api.Core.V1.FlockerVolumeSource.Parser, new[]{ "DatasetName", "DatasetUUID" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource), global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource.Parser, new[]{ "PdName", "FsType", "Partition", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.GitRepoVolumeSource), global::K8S.Io.Api.Core.V1.GitRepoVolumeSource.Parser, new[]{ "Repository", "Revision", "Directory" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.GlusterfsPersistentVolumeSource), global::K8S.Io.Api.Core.V1.GlusterfsPersistentVolumeSource.Parser, new[]{ "Endpoints", "Path", "ReadOnly", "EndpointsNamespace" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.GlusterfsVolumeSource), global::K8S.Io.Api.Core.V1.GlusterfsVolumeSource.Parser, new[]{ "Endpoints", "Path", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.HTTPGetAction), global::K8S.Io.Api.Core.V1.HTTPGetAction.Parser, new[]{ "Path", "Port", "Host", "Scheme", "HttpHeaders" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.HTTPHeader), global::K8S.Io.Api.Core.V1.HTTPHeader.Parser, new[]{ "Name", "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Handler), global::K8S.Io.Api.Core.V1.Handler.Parser, new[]{ "Exec", "HttpGet", "TcpSocket" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.HostAlias), global::K8S.Io.Api.Core.V1.HostAlias.Parser, new[]{ "Ip", "Hostnames" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.HostPathVolumeSource), global::K8S.Io.Api.Core.V1.HostPathVolumeSource.Parser, new[]{ "Path", "Type" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ISCSIPersistentVolumeSource), global::K8S.Io.Api.Core.V1.ISCSIPersistentVolumeSource.Parser, new[]{ "TargetPortal", "Iqn", "Lun", "IscsiInterface", "FsType", "ReadOnly", "Portals", "ChapAuthDiscovery", "ChapAuthSession", "SecretRef", "InitiatorName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ISCSIVolumeSource), global::K8S.Io.Api.Core.V1.ISCSIVolumeSource.Parser, new[]{ "TargetPortal", "Iqn", "Lun", "IscsiInterface", "FsType", "ReadOnly", "Portals", "ChapAuthDiscovery", "ChapAuthSession", "SecretRef", "InitiatorName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.KeyToPath), global::K8S.Io.Api.Core.V1.KeyToPath.Parser, new[]{ "Key", "Path", "Mode" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Lifecycle), global::K8S.Io.Api.Core.V1.Lifecycle.Parser, new[]{ "PostStart", "PreStop" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.LimitRange), global::K8S.Io.Api.Core.V1.LimitRange.Parser, new[]{ "Metadata", "Spec" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.LimitRangeItem), global::K8S.Io.Api.Core.V1.LimitRangeItem.Parser, new[]{ "Type", "Max", "Min", "Default", "DefaultRequest", "MaxLimitRequestRatio" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, null, null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.LimitRangeList), global::K8S.Io.Api.Core.V1.LimitRangeList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.LimitRangeSpec), global::K8S.Io.Api.Core.V1.LimitRangeSpec.Parser, new[]{ "Limits" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.List), global::K8S.Io.Api.Core.V1.List.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.LoadBalancerIngress), global::K8S.Io.Api.Core.V1.LoadBalancerIngress.Parser, new[]{ "Ip", "Hostname", "Ports" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.LoadBalancerStatus), global::K8S.Io.Api.Core.V1.LoadBalancerStatus.Parser, new[]{ "Ingress" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.LocalObjectReference), global::K8S.Io.Api.Core.V1.LocalObjectReference.Parser, new[]{ "Name" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.LocalVolumeSource), global::K8S.Io.Api.Core.V1.LocalVolumeSource.Parser, new[]{ "Path", "FsType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NFSVolumeSource), global::K8S.Io.Api.Core.V1.NFSVolumeSource.Parser, new[]{ "Server", "Path", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Namespace), global::K8S.Io.Api.Core.V1.Namespace.Parser, new[]{ "Metadata", "Spec", "Status" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NamespaceCondition), global::K8S.Io.Api.Core.V1.NamespaceCondition.Parser, new[]{ "Type", "Status", "LastTransitionTime", "Reason", "Message" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NamespaceList), global::K8S.Io.Api.Core.V1.NamespaceList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NamespaceSpec), global::K8S.Io.Api.Core.V1.NamespaceSpec.Parser, new[]{ "Finalizers" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NamespaceStatus), global::K8S.Io.Api.Core.V1.NamespaceStatus.Parser, new[]{ "Phase", "Conditions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Node), global::K8S.Io.Api.Core.V1.Node.Parser, new[]{ "Metadata", "Spec", "Status" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeAddress), global::K8S.Io.Api.Core.V1.NodeAddress.Parser, new[]{ "Type", "Address" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeAffinity), global::K8S.Io.Api.Core.V1.NodeAffinity.Parser, new[]{ "RequiredDuringSchedulingIgnoredDuringExecution", "PreferredDuringSchedulingIgnoredDuringExecution" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeCondition), global::K8S.Io.Api.Core.V1.NodeCondition.Parser, new[]{ "Type", "Status", "LastHeartbeatTime", "LastTransitionTime", "Reason", "Message" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeConfigSource), global::K8S.Io.Api.Core.V1.NodeConfigSource.Parser, new[]{ "ConfigMap" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeConfigStatus), global::K8S.Io.Api.Core.V1.NodeConfigStatus.Parser, new[]{ "Assigned", "Active", "LastKnownGood", "Error" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeDaemonEndpoints), global::K8S.Io.Api.Core.V1.NodeDaemonEndpoints.Parser, new[]{ "KubeletEndpoint" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeList), global::K8S.Io.Api.Core.V1.NodeList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeProxyOptions), global::K8S.Io.Api.Core.V1.NodeProxyOptions.Parser, new[]{ "Path" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeResources), global::K8S.Io.Api.Core.V1.NodeResources.Parser, new[]{ "Capacity" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeSelector), global::K8S.Io.Api.Core.V1.NodeSelector.Parser, new[]{ "NodeSelectorTerms" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeSelectorRequirement), global::K8S.Io.Api.Core.V1.NodeSelectorRequirement.Parser, new[]{ "Key", "Operator", "Values" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeSelectorTerm), global::K8S.Io.Api.Core.V1.NodeSelectorTerm.Parser, new[]{ "MatchExpressions", "MatchFields" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeSpec), global::K8S.Io.Api.Core.V1.NodeSpec.Parser, new[]{ "PodCIDR", "PodCIDRs", "ProviderID", "Unschedulable", "Taints", "ConfigSource", "ExternalID" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeStatus), global::K8S.Io.Api.Core.V1.NodeStatus.Parser, new[]{ "Capacity", "Allocatable", "Phase", "Conditions", "Addresses", "DaemonEndpoints", "NodeInfo", "Images", "VolumesInUse", "VolumesAttached", "Config" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.NodeSystemInfo), global::K8S.Io.Api.Core.V1.NodeSystemInfo.Parser, new[]{ "MachineID", "SystemUUID", "BootID", "KernelVersion", "OsImage", "ContainerRuntimeVersion", "KubeletVersion", "KubeProxyVersion", "OperatingSystem", "Architecture" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ObjectFieldSelector), global::K8S.Io.Api.Core.V1.ObjectFieldSelector.Parser, new[]{ "ApiVersion", "FieldPath" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ObjectReference), global::K8S.Io.Api.Core.V1.ObjectReference.Parser, new[]{ "Kind", "Namespace", "Name", "Uid", "ApiVersion", "ResourceVersion", "FieldPath" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolume), global::K8S.Io.Api.Core.V1.PersistentVolume.Parser, new[]{ "Metadata", "Spec", "Status" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeClaim), global::K8S.Io.Api.Core.V1.PersistentVolumeClaim.Parser, new[]{ "Metadata", "Spec", "Status" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeClaimCondition), global::K8S.Io.Api.Core.V1.PersistentVolumeClaimCondition.Parser, new[]{ "Type", "Status", "LastProbeTime", "LastTransitionTime", "Reason", "Message" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeClaimList), global::K8S.Io.Api.Core.V1.PersistentVolumeClaimList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec), global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec.Parser, new[]{ "AccessModes", "Selector", "Resources", "VolumeName", "StorageClassName", "VolumeMode", "DataSource", "DataSourceRef" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeClaimStatus), global::K8S.Io.Api.Core.V1.PersistentVolumeClaimStatus.Parser, new[]{ "Phase", "AccessModes", "Capacity", "Conditions" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeClaimTemplate), global::K8S.Io.Api.Core.V1.PersistentVolumeClaimTemplate.Parser, new[]{ "Metadata", "Spec" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeClaimVolumeSource), global::K8S.Io.Api.Core.V1.PersistentVolumeClaimVolumeSource.Parser, new[]{ "ClaimName", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeList), global::K8S.Io.Api.Core.V1.PersistentVolumeList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeSource), global::K8S.Io.Api.Core.V1.PersistentVolumeSource.Parser, new[]{ "GcePersistentDisk", "AwsElasticBlockStore", "HostPath", "Glusterfs", "Nfs", "Rbd", "Iscsi", "Cinder", "Cephfs", "Fc", "Flocker", "FlexVolume", "AzureFile", "VsphereVolume", "Quobyte", "AzureDisk", "PhotonPersistentDisk", "PortworxVolume", "ScaleIO", "Local", "Storageos", "Csi" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeSpec), global::K8S.Io.Api.Core.V1.PersistentVolumeSpec.Parser, new[]{ "Capacity", "PersistentVolumeSource", "AccessModes", "ClaimRef", "PersistentVolumeReclaimPolicy", "StorageClassName", "MountOptions", "VolumeMode", "NodeAffinity" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PersistentVolumeStatus), global::K8S.Io.Api.Core.V1.PersistentVolumeStatus.Parser, new[]{ "Phase", "Message", "Reason" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource), global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource.Parser, new[]{ "PdID", "FsType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Pod), global::K8S.Io.Api.Core.V1.Pod.Parser, new[]{ "Metadata", "Spec", "Status" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodAffinity), global::K8S.Io.Api.Core.V1.PodAffinity.Parser, new[]{ "RequiredDuringSchedulingIgnoredDuringExecution", "PreferredDuringSchedulingIgnoredDuringExecution" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodAffinityTerm), global::K8S.Io.Api.Core.V1.PodAffinityTerm.Parser, new[]{ "LabelSelector", "Namespaces", "TopologyKey", "NamespaceSelector" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodAntiAffinity), global::K8S.Io.Api.Core.V1.PodAntiAffinity.Parser, new[]{ "RequiredDuringSchedulingIgnoredDuringExecution", "PreferredDuringSchedulingIgnoredDuringExecution" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodAttachOptions), global::K8S.Io.Api.Core.V1.PodAttachOptions.Parser, new[]{ "Stdin", "Stdout", "Stderr", "Tty", "Container" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodCondition), global::K8S.Io.Api.Core.V1.PodCondition.Parser, new[]{ "Type", "Status", "LastProbeTime", "LastTransitionTime", "Reason", "Message" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodDNSConfig), global::K8S.Io.Api.Core.V1.PodDNSConfig.Parser, new[]{ "Nameservers", "Searches", "Options" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodDNSConfigOption), global::K8S.Io.Api.Core.V1.PodDNSConfigOption.Parser, new[]{ "Name", "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodExecOptions), global::K8S.Io.Api.Core.V1.PodExecOptions.Parser, new[]{ "Stdin", "Stdout", "Stderr", "Tty", "Container", "Command" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodIP), global::K8S.Io.Api.Core.V1.PodIP.Parser, new[]{ "Ip" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodList), global::K8S.Io.Api.Core.V1.PodList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodLogOptions), global::K8S.Io.Api.Core.V1.PodLogOptions.Parser, new[]{ "Container", "Follow", "Previous", "SinceSeconds", "SinceTime", "Timestamps", "TailLines", "LimitBytes", "InsecureSkipTLSVerifyBackend" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodPortForwardOptions), global::K8S.Io.Api.Core.V1.PodPortForwardOptions.Parser, new[]{ "Ports" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodProxyOptions), global::K8S.Io.Api.Core.V1.PodProxyOptions.Parser, new[]{ "Path" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodReadinessGate), global::K8S.Io.Api.Core.V1.PodReadinessGate.Parser, new[]{ "ConditionType" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodSecurityContext), global::K8S.Io.Api.Core.V1.PodSecurityContext.Parser, new[]{ "SeLinuxOptions", "WindowsOptions", "RunAsUser", "RunAsGroup", "RunAsNonRoot", "SupplementalGroups", "FsGroup", "Sysctls", "FsGroupChangePolicy", "SeccompProfile" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodSignature), global::K8S.Io.Api.Core.V1.PodSignature.Parser, new[]{ "PodController" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodSpec), global::K8S.Io.Api.Core.V1.PodSpec.Parser, new[]{ "Volumes", "InitContainers", "Containers", "EphemeralContainers", "RestartPolicy", "TerminationGracePeriodSeconds", "ActiveDeadlineSeconds", "DnsPolicy", "NodeSelector", "ServiceAccountName", "ServiceAccount", "AutomountServiceAccountToken", "NodeName", "HostNetwork", "HostPID", "HostIPC", "ShareProcessNamespace", "SecurityContext", "ImagePullSecrets", "Hostname", "Subdomain", "Affinity", "SchedulerName", "Tolerations", "HostAliases", "PriorityClassName", "Priority", "DnsConfig", "ReadinessGates", "RuntimeClassName", "EnableServiceLinks", "PreemptionPolicy", "Overhead", "TopologySpreadConstraints", "SetHostnameAsFQDN" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodStatus), global::K8S.Io.Api.Core.V1.PodStatus.Parser, new[]{ "Phase", "Conditions", "Message", "Reason", "NominatedNodeName", "HostIP", "PodIP", "PodIPs", "StartTime", "InitContainerStatuses", "ContainerStatuses", "QosClass", "EphemeralContainerStatuses" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodStatusResult), global::K8S.Io.Api.Core.V1.PodStatusResult.Parser, new[]{ "Metadata", "Status" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodTemplate), global::K8S.Io.Api.Core.V1.PodTemplate.Parser, new[]{ "Metadata", "Template" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodTemplateList), global::K8S.Io.Api.Core.V1.PodTemplateList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PodTemplateSpec), global::K8S.Io.Api.Core.V1.PodTemplateSpec.Parser, new[]{ "Metadata", "Spec" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PortStatus), global::K8S.Io.Api.Core.V1.PortStatus.Parser, new[]{ "Port", "Protocol", "Error" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PortworxVolumeSource), global::K8S.Io.Api.Core.V1.PortworxVolumeSource.Parser, new[]{ "VolumeID", "FsType", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Preconditions), global::K8S.Io.Api.Core.V1.Preconditions.Parser, new[]{ "Uid" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PreferAvoidPodsEntry), global::K8S.Io.Api.Core.V1.PreferAvoidPodsEntry.Parser, new[]{ "PodSignature", "EvictionTime", "Reason", "Message" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.PreferredSchedulingTerm), global::K8S.Io.Api.Core.V1.PreferredSchedulingTerm.Parser, new[]{ "Weight", "Preference" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Probe), global::K8S.Io.Api.Core.V1.Probe.Parser, new[]{ "Handler", "InitialDelaySeconds", "TimeoutSeconds", "PeriodSeconds", "SuccessThreshold", "FailureThreshold", "TerminationGracePeriodSeconds" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ProjectedVolumeSource), global::K8S.Io.Api.Core.V1.ProjectedVolumeSource.Parser, new[]{ "Sources", "DefaultMode" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.QuobyteVolumeSource), global::K8S.Io.Api.Core.V1.QuobyteVolumeSource.Parser, new[]{ "Registry", "Volume", "ReadOnly", "User", "Group", "Tenant" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.RBDPersistentVolumeSource), global::K8S.Io.Api.Core.V1.RBDPersistentVolumeSource.Parser, new[]{ "Monitors", "Image", "FsType", "Pool", "User", "Keyring", "SecretRef", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.RBDVolumeSource), global::K8S.Io.Api.Core.V1.RBDVolumeSource.Parser, new[]{ "Monitors", "Image", "FsType", "Pool", "User", "Keyring", "SecretRef", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.RangeAllocation), global::K8S.Io.Api.Core.V1.RangeAllocation.Parser, new[]{ "Metadata", "Range", "Data" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ReplicationController), global::K8S.Io.Api.Core.V1.ReplicationController.Parser, new[]{ "Metadata", "Spec", "Status" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ReplicationControllerCondition), global::K8S.Io.Api.Core.V1.ReplicationControllerCondition.Parser, new[]{ "Type", "Status", "LastTransitionTime", "Reason", "Message" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ReplicationControllerList), global::K8S.Io.Api.Core.V1.ReplicationControllerList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ReplicationControllerSpec), global::K8S.Io.Api.Core.V1.ReplicationControllerSpec.Parser, new[]{ "Replicas", "MinReadySeconds", "Selector", "Template" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ReplicationControllerStatus), global::K8S.Io.Api.Core.V1.ReplicationControllerStatus.Parser, new[]{ "Replicas", "FullyLabeledReplicas", "ReadyReplicas", "AvailableReplicas", "ObservedGeneration", "Conditions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ResourceFieldSelector), global::K8S.Io.Api.Core.V1.ResourceFieldSelector.Parser, new[]{ "ContainerName", "Resource", "Divisor" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ResourceQuota), global::K8S.Io.Api.Core.V1.ResourceQuota.Parser, new[]{ "Metadata", "Spec", "Status" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ResourceQuotaList), global::K8S.Io.Api.Core.V1.ResourceQuotaList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ResourceQuotaSpec), global::K8S.Io.Api.Core.V1.ResourceQuotaSpec.Parser, new[]{ "Hard", "Scopes", "ScopeSelector" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ResourceQuotaStatus), global::K8S.Io.Api.Core.V1.ResourceQuotaStatus.Parser, new[]{ "Hard", "Used" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ResourceRequirements), global::K8S.Io.Api.Core.V1.ResourceRequirements.Parser, new[]{ "Limits", "Requests" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SELinuxOptions), global::K8S.Io.Api.Core.V1.SELinuxOptions.Parser, new[]{ "User", "Role", "Type", "Level" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ScaleIOPersistentVolumeSource), global::K8S.Io.Api.Core.V1.ScaleIOPersistentVolumeSource.Parser, new[]{ "Gateway", "System", "SecretRef", "SslEnabled", "ProtectionDomain", "StoragePool", "StorageMode", "VolumeName", "FsType", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ScaleIOVolumeSource), global::K8S.Io.Api.Core.V1.ScaleIOVolumeSource.Parser, new[]{ "Gateway", "System", "SecretRef", "SslEnabled", "ProtectionDomain", "StoragePool", "StorageMode", "VolumeName", "FsType", "ReadOnly" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ScopeSelector), global::K8S.Io.Api.Core.V1.ScopeSelector.Parser, new[]{ "MatchExpressions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ScopedResourceSelectorRequirement), global::K8S.Io.Api.Core.V1.ScopedResourceSelectorRequirement.Parser, new[]{ "ScopeName", "Operator", "Values" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SeccompProfile), global::K8S.Io.Api.Core.V1.SeccompProfile.Parser, new[]{ "Type", "LocalhostProfile" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Secret), global::K8S.Io.Api.Core.V1.Secret.Parser, new[]{ "Metadata", "Immutable", "Data", "StringData", "Type" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SecretEnvSource), global::K8S.Io.Api.Core.V1.SecretEnvSource.Parser, new[]{ "LocalObjectReference", "Optional" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SecretKeySelector), global::K8S.Io.Api.Core.V1.SecretKeySelector.Parser, new[]{ "LocalObjectReference", "Key", "Optional" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SecretList), global::K8S.Io.Api.Core.V1.SecretList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SecretProjection), global::K8S.Io.Api.Core.V1.SecretProjection.Parser, new[]{ "LocalObjectReference", "Items", "Optional" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SecretReference), global::K8S.Io.Api.Core.V1.SecretReference.Parser, new[]{ "Name", "Namespace" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SecretVolumeSource), global::K8S.Io.Api.Core.V1.SecretVolumeSource.Parser, new[]{ "SecretName", "Items", "DefaultMode", "Optional" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SecurityContext), global::K8S.Io.Api.Core.V1.SecurityContext.Parser, new[]{ "Capabilities", "Privileged", "SeLinuxOptions", "WindowsOptions", "RunAsUser", "RunAsGroup", "RunAsNonRoot", "ReadOnlyRootFilesystem", "AllowPrivilegeEscalation", "ProcMount", "SeccompProfile" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SerializedReference), global::K8S.Io.Api.Core.V1.SerializedReference.Parser, new[]{ "Reference" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Service), global::K8S.Io.Api.Core.V1.Service.Parser, new[]{ "Metadata", "Spec", "Status" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ServiceAccount), global::K8S.Io.Api.Core.V1.ServiceAccount.Parser, new[]{ "Metadata", "Secrets", "ImagePullSecrets", "AutomountServiceAccountToken" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ServiceAccountList), global::K8S.Io.Api.Core.V1.ServiceAccountList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ServiceAccountTokenProjection), global::K8S.Io.Api.Core.V1.ServiceAccountTokenProjection.Parser, new[]{ "Audience", "ExpirationSeconds", "Path" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ServiceList), global::K8S.Io.Api.Core.V1.ServiceList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ServicePort), global::K8S.Io.Api.Core.V1.ServicePort.Parser, new[]{ "Name", "Protocol", "AppProtocol", "Port", "TargetPort", "NodePort" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ServiceProxyOptions), global::K8S.Io.Api.Core.V1.ServiceProxyOptions.Parser, new[]{ "Path" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ServiceSpec), global::K8S.Io.Api.Core.V1.ServiceSpec.Parser, new[]{ "Ports", "Selector", "ClusterIP", "ClusterIPs", "Type", "ExternalIPs", "SessionAffinity", "LoadBalancerIP", "LoadBalancerSourceRanges", "ExternalName", "ExternalTrafficPolicy", "HealthCheckNodePort", "PublishNotReadyAddresses", "SessionAffinityConfig", "IpFamilies", "IpFamilyPolicy", "AllocateLoadBalancerNodePorts", "LoadBalancerClass", "InternalTrafficPolicy" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.ServiceStatus), global::K8S.Io.Api.Core.V1.ServiceStatus.Parser, new[]{ "LoadBalancer", "Conditions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.SessionAffinityConfig), global::K8S.Io.Api.Core.V1.SessionAffinityConfig.Parser, new[]{ "ClientIP" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.StorageOSPersistentVolumeSource), global::K8S.Io.Api.Core.V1.StorageOSPersistentVolumeSource.Parser, new[]{ "VolumeName", "VolumeNamespace", "FsType", "ReadOnly", "SecretRef" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.StorageOSVolumeSource), global::K8S.Io.Api.Core.V1.StorageOSVolumeSource.Parser, new[]{ "VolumeName", "VolumeNamespace", "FsType", "ReadOnly", "SecretRef" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Sysctl), global::K8S.Io.Api.Core.V1.Sysctl.Parser, new[]{ "Name", "Value" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.TCPSocketAction), global::K8S.Io.Api.Core.V1.TCPSocketAction.Parser, new[]{ "Port", "Host" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Taint), global::K8S.Io.Api.Core.V1.Taint.Parser, new[]{ "Key", "Value", "Effect", "TimeAdded" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Toleration), global::K8S.Io.Api.Core.V1.Toleration.Parser, new[]{ "Key", "Operator", "Value", "Effect", "TolerationSeconds" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.TopologySelectorLabelRequirement), global::K8S.Io.Api.Core.V1.TopologySelectorLabelRequirement.Parser, new[]{ "Key", "Values" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.TopologySelectorTerm), global::K8S.Io.Api.Core.V1.TopologySelectorTerm.Parser, new[]{ "MatchLabelExpressions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.TopologySpreadConstraint), global::K8S.Io.Api.Core.V1.TopologySpreadConstraint.Parser, new[]{ "MaxSkew", "TopologyKey", "WhenUnsatisfiable", "LabelSelector" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.TypedLocalObjectReference), global::K8S.Io.Api.Core.V1.TypedLocalObjectReference.Parser, new[]{ "ApiGroup", "Kind", "Name" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.Volume), global::K8S.Io.Api.Core.V1.Volume.Parser, new[]{ "Name", "VolumeSource" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.VolumeDevice), global::K8S.Io.Api.Core.V1.VolumeDevice.Parser, new[]{ "Name", "DevicePath" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.VolumeMount), global::K8S.Io.Api.Core.V1.VolumeMount.Parser, new[]{ "Name", "ReadOnly", "MountPath", "SubPath", "MountPropagation", "SubPathExpr" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.VolumeNodeAffinity), global::K8S.Io.Api.Core.V1.VolumeNodeAffinity.Parser, new[]{ "Required" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.VolumeProjection), global::K8S.Io.Api.Core.V1.VolumeProjection.Parser, new[]{ "Secret", "DownwardAPI", "ConfigMap", "ServiceAccountToken" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.VolumeSource), global::K8S.Io.Api.Core.V1.VolumeSource.Parser, new[]{ "HostPath", "EmptyDir", "GcePersistentDisk", "AwsElasticBlockStore", "GitRepo", "Secret", "Nfs", "Iscsi", "Glusterfs", "PersistentVolumeClaim", "Rbd", "FlexVolume", "Cinder", "Cephfs", "Flocker", "DownwardAPI", "Fc", "AzureFile", "ConfigMap", "VsphereVolume", "Quobyte", "AzureDisk", "PhotonPersistentDisk", "Projected", "PortworxVolume", "ScaleIO", "Storageos", "Csi", "Ephemeral" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource), global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource.Parser, new[]{ "VolumePath", "FsType", "StoragePolicyName", "StoragePolicyID" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm), global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm.Parser, new[]{ "Weight", "PodAffinityTerm" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions), global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions.Parser, new[]{ "GmsaCredentialSpecName", "GmsaCredentialSpec", "RunAsUserName", "HostProcess" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Represents a Persistent Disk resource in AWS.
  ///
  /// An AWS EBS disk must exist before mounting to a container. The disk
  /// must also be in the same AWS zone as the kubelet. An AWS EBS disk
  /// can only be mounted as read/write once. AWS EBS volumes support
  /// ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class AWSElasticBlockStoreVolumeSource : pb::IMessage<AWSElasticBlockStoreVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AWSElasticBlockStoreVolumeSource> _parser = new pb::MessageParser<AWSElasticBlockStoreVolumeSource>(() => new AWSElasticBlockStoreVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AWSElasticBlockStoreVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AWSElasticBlockStoreVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AWSElasticBlockStoreVolumeSource(AWSElasticBlockStoreVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      volumeID_ = other.volumeID_;
      fsType_ = other.fsType_;
      partition_ = other.partition_;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AWSElasticBlockStoreVolumeSource Clone() {
      return new AWSElasticBlockStoreVolumeSource(this);
    }

    /// <summary>Field number for the "volumeID" field.</summary>
    public const int VolumeIDFieldNumber = 1;
    private readonly static string VolumeIDDefaultValue = "";

    private string volumeID_;
    /// <summary>
    /// Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeID {
      get { return volumeID_ ?? VolumeIDDefaultValue; }
      set {
        volumeID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeID {
      get { return volumeID_ != null; }
    }
    /// <summary>Clears the value of the "volumeID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeID() {
      volumeID_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 2;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "partition" field.</summary>
    public const int PartitionFieldNumber = 3;
    private readonly static int PartitionDefaultValue = 0;

    private int partition_;
    /// <summary>
    /// The partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Partition {
      get { if ((_hasBits0 & 1) != 0) { return partition_; } else { return PartitionDefaultValue; } }
      set {
        _hasBits0 |= 1;
        partition_ = value;
      }
    }
    /// <summary>Gets whether the "partition" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPartition {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "partition" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPartition() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 4;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
    /// If omitted, the default is "false".
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 2) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AWSElasticBlockStoreVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AWSElasticBlockStoreVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeID != other.VolumeID) return false;
      if (FsType != other.FsType) return false;
      if (Partition != other.Partition) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasVolumeID) hash ^= VolumeID.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasPartition) hash ^= Partition.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasVolumeID) {
        output.WriteRawTag(10);
        output.WriteString(VolumeID);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasPartition) {
        output.WriteRawTag(24);
        output.WriteInt32(Partition);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasVolumeID) {
        output.WriteRawTag(10);
        output.WriteString(VolumeID);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasPartition) {
        output.WriteRawTag(24);
        output.WriteInt32(Partition);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasVolumeID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeID);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasPartition) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Partition);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AWSElasticBlockStoreVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasVolumeID) {
        VolumeID = other.VolumeID;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasPartition) {
        Partition = other.Partition;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeID = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 24: {
            Partition = input.ReadInt32();
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            VolumeID = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 24: {
            Partition = input.ReadInt32();
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Affinity is a group of affinity scheduling rules.
  /// </summary>
  public sealed partial class Affinity : pb::IMessage<Affinity>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Affinity> _parser = new pb::MessageParser<Affinity>(() => new Affinity());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Affinity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Affinity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Affinity(Affinity other) : this() {
      nodeAffinity_ = other.nodeAffinity_ != null ? other.nodeAffinity_.Clone() : null;
      podAffinity_ = other.podAffinity_ != null ? other.podAffinity_.Clone() : null;
      podAntiAffinity_ = other.podAntiAffinity_ != null ? other.podAntiAffinity_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Affinity Clone() {
      return new Affinity(this);
    }

    /// <summary>Field number for the "nodeAffinity" field.</summary>
    public const int NodeAffinityFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.NodeAffinity nodeAffinity_;
    /// <summary>
    /// Describes node affinity scheduling rules for the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeAffinity NodeAffinity {
      get { return nodeAffinity_; }
      set {
        nodeAffinity_ = value;
      }
    }

    /// <summary>Field number for the "podAffinity" field.</summary>
    public const int PodAffinityFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.PodAffinity podAffinity_;
    /// <summary>
    /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodAffinity PodAffinity {
      get { return podAffinity_; }
      set {
        podAffinity_ = value;
      }
    }

    /// <summary>Field number for the "podAntiAffinity" field.</summary>
    public const int PodAntiAffinityFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.PodAntiAffinity podAntiAffinity_;
    /// <summary>
    /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodAntiAffinity PodAntiAffinity {
      get { return podAntiAffinity_; }
      set {
        podAntiAffinity_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Affinity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Affinity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(NodeAffinity, other.NodeAffinity)) return false;
      if (!object.Equals(PodAffinity, other.PodAffinity)) return false;
      if (!object.Equals(PodAntiAffinity, other.PodAntiAffinity)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (nodeAffinity_ != null) hash ^= NodeAffinity.GetHashCode();
      if (podAffinity_ != null) hash ^= PodAffinity.GetHashCode();
      if (podAntiAffinity_ != null) hash ^= PodAntiAffinity.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (nodeAffinity_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(NodeAffinity);
      }
      if (podAffinity_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PodAffinity);
      }
      if (podAntiAffinity_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PodAntiAffinity);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (nodeAffinity_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(NodeAffinity);
      }
      if (podAffinity_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PodAffinity);
      }
      if (podAntiAffinity_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(PodAntiAffinity);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (nodeAffinity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NodeAffinity);
      }
      if (podAffinity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PodAffinity);
      }
      if (podAntiAffinity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PodAntiAffinity);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Affinity other) {
      if (other == null) {
        return;
      }
      if (other.nodeAffinity_ != null) {
        if (nodeAffinity_ == null) {
          NodeAffinity = new global::K8S.Io.Api.Core.V1.NodeAffinity();
        }
        NodeAffinity.MergeFrom(other.NodeAffinity);
      }
      if (other.podAffinity_ != null) {
        if (podAffinity_ == null) {
          PodAffinity = new global::K8S.Io.Api.Core.V1.PodAffinity();
        }
        PodAffinity.MergeFrom(other.PodAffinity);
      }
      if (other.podAntiAffinity_ != null) {
        if (podAntiAffinity_ == null) {
          PodAntiAffinity = new global::K8S.Io.Api.Core.V1.PodAntiAffinity();
        }
        PodAntiAffinity.MergeFrom(other.PodAntiAffinity);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (nodeAffinity_ == null) {
              NodeAffinity = new global::K8S.Io.Api.Core.V1.NodeAffinity();
            }
            input.ReadMessage(NodeAffinity);
            break;
          }
          case 18: {
            if (podAffinity_ == null) {
              PodAffinity = new global::K8S.Io.Api.Core.V1.PodAffinity();
            }
            input.ReadMessage(PodAffinity);
            break;
          }
          case 26: {
            if (podAntiAffinity_ == null) {
              PodAntiAffinity = new global::K8S.Io.Api.Core.V1.PodAntiAffinity();
            }
            input.ReadMessage(PodAntiAffinity);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (nodeAffinity_ == null) {
              NodeAffinity = new global::K8S.Io.Api.Core.V1.NodeAffinity();
            }
            input.ReadMessage(NodeAffinity);
            break;
          }
          case 18: {
            if (podAffinity_ == null) {
              PodAffinity = new global::K8S.Io.Api.Core.V1.PodAffinity();
            }
            input.ReadMessage(PodAffinity);
            break;
          }
          case 26: {
            if (podAntiAffinity_ == null) {
              PodAntiAffinity = new global::K8S.Io.Api.Core.V1.PodAntiAffinity();
            }
            input.ReadMessage(PodAntiAffinity);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// AttachedVolume describes a volume attached to a node
  /// </summary>
  public sealed partial class AttachedVolume : pb::IMessage<AttachedVolume>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AttachedVolume> _parser = new pb::MessageParser<AttachedVolume>(() => new AttachedVolume());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AttachedVolume> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AttachedVolume() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AttachedVolume(AttachedVolume other) : this() {
      name_ = other.name_;
      devicePath_ = other.devicePath_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AttachedVolume Clone() {
      return new AttachedVolume(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name of the attached volume
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "devicePath" field.</summary>
    public const int DevicePathFieldNumber = 2;
    private readonly static string DevicePathDefaultValue = "";

    private string devicePath_;
    /// <summary>
    /// DevicePath represents the device path where the volume should be available
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DevicePath {
      get { return devicePath_ ?? DevicePathDefaultValue; }
      set {
        devicePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "devicePath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDevicePath {
      get { return devicePath_ != null; }
    }
    /// <summary>Clears the value of the "devicePath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDevicePath() {
      devicePath_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AttachedVolume);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AttachedVolume other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DevicePath != other.DevicePath) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasDevicePath) hash ^= DevicePath.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasDevicePath) {
        output.WriteRawTag(18);
        output.WriteString(DevicePath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasDevicePath) {
        output.WriteRawTag(18);
        output.WriteString(DevicePath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasDevicePath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DevicePath);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AttachedVolume other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasDevicePath) {
        DevicePath = other.DevicePath;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            DevicePath = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            DevicePath = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// AvoidPods describes pods that should avoid this node. This is the value for a
  /// Node annotation with key scheduler.alpha.kubernetes.io/preferAvoidPods and
  /// will eventually become a field of NodeStatus.
  /// </summary>
  public sealed partial class AvoidPods : pb::IMessage<AvoidPods>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AvoidPods> _parser = new pb::MessageParser<AvoidPods>(() => new AvoidPods());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AvoidPods> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AvoidPods() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AvoidPods(AvoidPods other) : this() {
      preferAvoidPods_ = other.preferAvoidPods_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AvoidPods Clone() {
      return new AvoidPods(this);
    }

    /// <summary>Field number for the "preferAvoidPods" field.</summary>
    public const int PreferAvoidPodsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PreferAvoidPodsEntry> _repeated_preferAvoidPods_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.PreferAvoidPodsEntry.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PreferAvoidPodsEntry> preferAvoidPods_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PreferAvoidPodsEntry>();
    /// <summary>
    /// Bounded-sized list of signatures of pods that should avoid this node, sorted
    /// in timestamp order from oldest to newest. Size of the slice is unspecified.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PreferAvoidPodsEntry> PreferAvoidPods {
      get { return preferAvoidPods_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AvoidPods);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AvoidPods other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!preferAvoidPods_.Equals(other.preferAvoidPods_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= preferAvoidPods_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      preferAvoidPods_.WriteTo(output, _repeated_preferAvoidPods_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      preferAvoidPods_.WriteTo(ref output, _repeated_preferAvoidPods_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += preferAvoidPods_.CalculateSize(_repeated_preferAvoidPods_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AvoidPods other) {
      if (other == null) {
        return;
      }
      preferAvoidPods_.Add(other.preferAvoidPods_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            preferAvoidPods_.AddEntriesFrom(input, _repeated_preferAvoidPods_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            preferAvoidPods_.AddEntriesFrom(ref input, _repeated_preferAvoidPods_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  /// </summary>
  public sealed partial class AzureDiskVolumeSource : pb::IMessage<AzureDiskVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AzureDiskVolumeSource> _parser = new pb::MessageParser<AzureDiskVolumeSource>(() => new AzureDiskVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AzureDiskVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AzureDiskVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AzureDiskVolumeSource(AzureDiskVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      diskName_ = other.diskName_;
      diskURI_ = other.diskURI_;
      cachingMode_ = other.cachingMode_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      kind_ = other.kind_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AzureDiskVolumeSource Clone() {
      return new AzureDiskVolumeSource(this);
    }

    /// <summary>Field number for the "diskName" field.</summary>
    public const int DiskNameFieldNumber = 1;
    private readonly static string DiskNameDefaultValue = "";

    private string diskName_;
    /// <summary>
    /// The Name of the data disk in the blob storage
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DiskName {
      get { return diskName_ ?? DiskNameDefaultValue; }
      set {
        diskName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "diskName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDiskName {
      get { return diskName_ != null; }
    }
    /// <summary>Clears the value of the "diskName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDiskName() {
      diskName_ = null;
    }

    /// <summary>Field number for the "diskURI" field.</summary>
    public const int DiskURIFieldNumber = 2;
    private readonly static string DiskURIDefaultValue = "";

    private string diskURI_;
    /// <summary>
    /// The URI the data disk in the blob storage
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DiskURI {
      get { return diskURI_ ?? DiskURIDefaultValue; }
      set {
        diskURI_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "diskURI" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDiskURI {
      get { return diskURI_ != null; }
    }
    /// <summary>Clears the value of the "diskURI" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDiskURI() {
      diskURI_ = null;
    }

    /// <summary>Field number for the "cachingMode" field.</summary>
    public const int CachingModeFieldNumber = 3;
    private readonly static string CachingModeDefaultValue = "";

    private string cachingMode_;
    /// <summary>
    /// Host Caching mode: None, Read Only, Read Write.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string CachingMode {
      get { return cachingMode_ ?? CachingModeDefaultValue; }
      set {
        cachingMode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "cachingMode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCachingMode {
      get { return cachingMode_ != null; }
    }
    /// <summary>Clears the value of the "cachingMode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCachingMode() {
      cachingMode_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 4;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 5;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 6;
    private readonly static string KindDefaultValue = "";

    private string kind_;
    /// <summary>
    /// Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Kind {
      get { return kind_ ?? KindDefaultValue; }
      set {
        kind_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "kind" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKind {
      get { return kind_ != null; }
    }
    /// <summary>Clears the value of the "kind" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKind() {
      kind_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AzureDiskVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AzureDiskVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DiskName != other.DiskName) return false;
      if (DiskURI != other.DiskURI) return false;
      if (CachingMode != other.CachingMode) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (Kind != other.Kind) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDiskName) hash ^= DiskName.GetHashCode();
      if (HasDiskURI) hash ^= DiskURI.GetHashCode();
      if (HasCachingMode) hash ^= CachingMode.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (HasKind) hash ^= Kind.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDiskName) {
        output.WriteRawTag(10);
        output.WriteString(DiskName);
      }
      if (HasDiskURI) {
        output.WriteRawTag(18);
        output.WriteString(DiskURI);
      }
      if (HasCachingMode) {
        output.WriteRawTag(26);
        output.WriteString(CachingMode);
      }
      if (HasFsType) {
        output.WriteRawTag(34);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(40);
        output.WriteBool(ReadOnly);
      }
      if (HasKind) {
        output.WriteRawTag(50);
        output.WriteString(Kind);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDiskName) {
        output.WriteRawTag(10);
        output.WriteString(DiskName);
      }
      if (HasDiskURI) {
        output.WriteRawTag(18);
        output.WriteString(DiskURI);
      }
      if (HasCachingMode) {
        output.WriteRawTag(26);
        output.WriteString(CachingMode);
      }
      if (HasFsType) {
        output.WriteRawTag(34);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(40);
        output.WriteBool(ReadOnly);
      }
      if (HasKind) {
        output.WriteRawTag(50);
        output.WriteString(Kind);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDiskName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DiskName);
      }
      if (HasDiskURI) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DiskURI);
      }
      if (HasCachingMode) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CachingMode);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (HasKind) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Kind);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AzureDiskVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasDiskName) {
        DiskName = other.DiskName;
      }
      if (other.HasDiskURI) {
        DiskURI = other.DiskURI;
      }
      if (other.HasCachingMode) {
        CachingMode = other.CachingMode;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.HasKind) {
        Kind = other.Kind;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            DiskName = input.ReadString();
            break;
          }
          case 18: {
            DiskURI = input.ReadString();
            break;
          }
          case 26: {
            CachingMode = input.ReadString();
            break;
          }
          case 34: {
            FsType = input.ReadString();
            break;
          }
          case 40: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 50: {
            Kind = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            DiskName = input.ReadString();
            break;
          }
          case 18: {
            DiskURI = input.ReadString();
            break;
          }
          case 26: {
            CachingMode = input.ReadString();
            break;
          }
          case 34: {
            FsType = input.ReadString();
            break;
          }
          case 40: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 50: {
            Kind = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
  /// </summary>
  public sealed partial class AzureFilePersistentVolumeSource : pb::IMessage<AzureFilePersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AzureFilePersistentVolumeSource> _parser = new pb::MessageParser<AzureFilePersistentVolumeSource>(() => new AzureFilePersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AzureFilePersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AzureFilePersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AzureFilePersistentVolumeSource(AzureFilePersistentVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      secretName_ = other.secretName_;
      shareName_ = other.shareName_;
      readOnly_ = other.readOnly_;
      secretNamespace_ = other.secretNamespace_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AzureFilePersistentVolumeSource Clone() {
      return new AzureFilePersistentVolumeSource(this);
    }

    /// <summary>Field number for the "secretName" field.</summary>
    public const int SecretNameFieldNumber = 1;
    private readonly static string SecretNameDefaultValue = "";

    private string secretName_;
    /// <summary>
    /// the name of secret that contains Azure Storage Account Name and Key
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SecretName {
      get { return secretName_ ?? SecretNameDefaultValue; }
      set {
        secretName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "secretName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSecretName {
      get { return secretName_ != null; }
    }
    /// <summary>Clears the value of the "secretName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSecretName() {
      secretName_ = null;
    }

    /// <summary>Field number for the "shareName" field.</summary>
    public const int ShareNameFieldNumber = 2;
    private readonly static string ShareNameDefaultValue = "";

    private string shareName_;
    /// <summary>
    /// Share Name
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ShareName {
      get { return shareName_ ?? ShareNameDefaultValue; }
      set {
        shareName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "shareName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasShareName {
      get { return shareName_ != null; }
    }
    /// <summary>Clears the value of the "shareName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearShareName() {
      shareName_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 3;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "secretNamespace" field.</summary>
    public const int SecretNamespaceFieldNumber = 4;
    private readonly static string SecretNamespaceDefaultValue = "";

    private string secretNamespace_;
    /// <summary>
    /// the namespace of the secret that contains Azure Storage Account Name and Key
    /// default is the same as the Pod
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SecretNamespace {
      get { return secretNamespace_ ?? SecretNamespaceDefaultValue; }
      set {
        secretNamespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "secretNamespace" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSecretNamespace {
      get { return secretNamespace_ != null; }
    }
    /// <summary>Clears the value of the "secretNamespace" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSecretNamespace() {
      secretNamespace_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AzureFilePersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AzureFilePersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SecretName != other.SecretName) return false;
      if (ShareName != other.ShareName) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (SecretNamespace != other.SecretNamespace) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSecretName) hash ^= SecretName.GetHashCode();
      if (HasShareName) hash ^= ShareName.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (HasSecretNamespace) hash ^= SecretNamespace.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSecretName) {
        output.WriteRawTag(10);
        output.WriteString(SecretName);
      }
      if (HasShareName) {
        output.WriteRawTag(18);
        output.WriteString(ShareName);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (HasSecretNamespace) {
        output.WriteRawTag(34);
        output.WriteString(SecretNamespace);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSecretName) {
        output.WriteRawTag(10);
        output.WriteString(SecretName);
      }
      if (HasShareName) {
        output.WriteRawTag(18);
        output.WriteString(ShareName);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (HasSecretNamespace) {
        output.WriteRawTag(34);
        output.WriteString(SecretNamespace);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSecretName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SecretName);
      }
      if (HasShareName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ShareName);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (HasSecretNamespace) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SecretNamespace);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AzureFilePersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasSecretName) {
        SecretName = other.SecretName;
      }
      if (other.HasShareName) {
        ShareName = other.ShareName;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.HasSecretNamespace) {
        SecretNamespace = other.SecretNamespace;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            SecretName = input.ReadString();
            break;
          }
          case 18: {
            ShareName = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            SecretNamespace = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            SecretName = input.ReadString();
            break;
          }
          case 18: {
            ShareName = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            SecretNamespace = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
  /// </summary>
  public sealed partial class AzureFileVolumeSource : pb::IMessage<AzureFileVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AzureFileVolumeSource> _parser = new pb::MessageParser<AzureFileVolumeSource>(() => new AzureFileVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<AzureFileVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AzureFileVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AzureFileVolumeSource(AzureFileVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      secretName_ = other.secretName_;
      shareName_ = other.shareName_;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public AzureFileVolumeSource Clone() {
      return new AzureFileVolumeSource(this);
    }

    /// <summary>Field number for the "secretName" field.</summary>
    public const int SecretNameFieldNumber = 1;
    private readonly static string SecretNameDefaultValue = "";

    private string secretName_;
    /// <summary>
    /// the name of secret that contains Azure Storage Account Name and Key
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SecretName {
      get { return secretName_ ?? SecretNameDefaultValue; }
      set {
        secretName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "secretName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSecretName {
      get { return secretName_ != null; }
    }
    /// <summary>Clears the value of the "secretName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSecretName() {
      secretName_ = null;
    }

    /// <summary>Field number for the "shareName" field.</summary>
    public const int ShareNameFieldNumber = 2;
    private readonly static string ShareNameDefaultValue = "";

    private string shareName_;
    /// <summary>
    /// Share Name
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ShareName {
      get { return shareName_ ?? ShareNameDefaultValue; }
      set {
        shareName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "shareName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasShareName {
      get { return shareName_ != null; }
    }
    /// <summary>Clears the value of the "shareName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearShareName() {
      shareName_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 3;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as AzureFileVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(AzureFileVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SecretName != other.SecretName) return false;
      if (ShareName != other.ShareName) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSecretName) hash ^= SecretName.GetHashCode();
      if (HasShareName) hash ^= ShareName.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSecretName) {
        output.WriteRawTag(10);
        output.WriteString(SecretName);
      }
      if (HasShareName) {
        output.WriteRawTag(18);
        output.WriteString(ShareName);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSecretName) {
        output.WriteRawTag(10);
        output.WriteString(SecretName);
      }
      if (HasShareName) {
        output.WriteRawTag(18);
        output.WriteString(ShareName);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSecretName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SecretName);
      }
      if (HasShareName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ShareName);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(AzureFileVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasSecretName) {
        SecretName = other.SecretName;
      }
      if (other.HasShareName) {
        ShareName = other.ShareName;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            SecretName = input.ReadString();
            break;
          }
          case 18: {
            ShareName = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            SecretName = input.ReadString();
            break;
          }
          case 18: {
            ShareName = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
  /// Deprecated in 1.7, please use the bindings subresource of pods instead.
  /// </summary>
  public sealed partial class Binding : pb::IMessage<Binding>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Binding> _parser = new pb::MessageParser<Binding>(() => new Binding());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Binding> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Binding() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Binding(Binding other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      target_ = other.target_ != null ? other.target_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Binding Clone() {
      return new Binding(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ObjectReference target_;
    /// <summary>
    /// The target object that you want to bind to the standard object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ObjectReference Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Binding);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Binding other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Target, other.Target)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (target_ != null) hash ^= Target.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (target_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (target_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Target);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (target_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Target);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Binding other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.target_ != null) {
        if (target_ == null) {
          Target = new global::K8S.Io.Api.Core.V1.ObjectReference();
        }
        Target.MergeFrom(other.Target);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (target_ == null) {
              Target = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (target_ == null) {
              Target = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(Target);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents storage that is managed by an external CSI volume driver (Beta feature)
  /// </summary>
  public sealed partial class CSIPersistentVolumeSource : pb::IMessage<CSIPersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CSIPersistentVolumeSource> _parser = new pb::MessageParser<CSIPersistentVolumeSource>(() => new CSIPersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CSIPersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CSIPersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CSIPersistentVolumeSource(CSIPersistentVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      driver_ = other.driver_;
      volumeHandle_ = other.volumeHandle_;
      readOnly_ = other.readOnly_;
      fsType_ = other.fsType_;
      volumeAttributes_ = other.volumeAttributes_.Clone();
      controllerPublishSecretRef_ = other.controllerPublishSecretRef_ != null ? other.controllerPublishSecretRef_.Clone() : null;
      nodeStageSecretRef_ = other.nodeStageSecretRef_ != null ? other.nodeStageSecretRef_.Clone() : null;
      nodePublishSecretRef_ = other.nodePublishSecretRef_ != null ? other.nodePublishSecretRef_.Clone() : null;
      controllerExpandSecretRef_ = other.controllerExpandSecretRef_ != null ? other.controllerExpandSecretRef_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CSIPersistentVolumeSource Clone() {
      return new CSIPersistentVolumeSource(this);
    }

    /// <summary>Field number for the "driver" field.</summary>
    public const int DriverFieldNumber = 1;
    private readonly static string DriverDefaultValue = "";

    private string driver_;
    /// <summary>
    /// Driver is the name of the driver to use for this volume.
    /// Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Driver {
      get { return driver_ ?? DriverDefaultValue; }
      set {
        driver_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "driver" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDriver {
      get { return driver_ != null; }
    }
    /// <summary>Clears the value of the "driver" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDriver() {
      driver_ = null;
    }

    /// <summary>Field number for the "volumeHandle" field.</summary>
    public const int VolumeHandleFieldNumber = 2;
    private readonly static string VolumeHandleDefaultValue = "";

    private string volumeHandle_;
    /// <summary>
    /// VolumeHandle is the unique volume name returned by the CSI volume
    /// plugin’s CreateVolume to refer to the volume on all subsequent calls.
    /// Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeHandle {
      get { return volumeHandle_ ?? VolumeHandleDefaultValue; }
      set {
        volumeHandle_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeHandle" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeHandle {
      get { return volumeHandle_ != null; }
    }
    /// <summary>Clears the value of the "volumeHandle" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeHandle() {
      volumeHandle_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 3;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Optional: The value to pass to ControllerPublishVolumeRequest.
    /// Defaults to false (read/write).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 4;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "volumeAttributes" field.</summary>
    public const int VolumeAttributesFieldNumber = 5;
    private static readonly pbc::MapField<string, string>.Codec _map_volumeAttributes_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 42);
    private readonly pbc::MapField<string, string> volumeAttributes_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Attributes of the volume to publish.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> VolumeAttributes {
      get { return volumeAttributes_; }
    }

    /// <summary>Field number for the "controllerPublishSecretRef" field.</summary>
    public const int ControllerPublishSecretRefFieldNumber = 6;
    private global::K8S.Io.Api.Core.V1.SecretReference controllerPublishSecretRef_;
    /// <summary>
    /// ControllerPublishSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// ControllerPublishVolume and ControllerUnpublishVolume calls.
    /// This field is optional, and may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secrets are passed.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretReference ControllerPublishSecretRef {
      get { return controllerPublishSecretRef_; }
      set {
        controllerPublishSecretRef_ = value;
      }
    }

    /// <summary>Field number for the "nodeStageSecretRef" field.</summary>
    public const int NodeStageSecretRefFieldNumber = 7;
    private global::K8S.Io.Api.Core.V1.SecretReference nodeStageSecretRef_;
    /// <summary>
    /// NodeStageSecretRef is a reference to the secret object containing sensitive
    /// information to pass to the CSI driver to complete the CSI NodeStageVolume
    /// and NodeStageVolume and NodeUnstageVolume calls.
    /// This field is optional, and may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secrets are passed.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretReference NodeStageSecretRef {
      get { return nodeStageSecretRef_; }
      set {
        nodeStageSecretRef_ = value;
      }
    }

    /// <summary>Field number for the "nodePublishSecretRef" field.</summary>
    public const int NodePublishSecretRefFieldNumber = 8;
    private global::K8S.Io.Api.Core.V1.SecretReference nodePublishSecretRef_;
    /// <summary>
    /// NodePublishSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// NodePublishVolume and NodeUnpublishVolume calls.
    /// This field is optional, and may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secrets are passed.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretReference NodePublishSecretRef {
      get { return nodePublishSecretRef_; }
      set {
        nodePublishSecretRef_ = value;
      }
    }

    /// <summary>Field number for the "controllerExpandSecretRef" field.</summary>
    public const int ControllerExpandSecretRefFieldNumber = 9;
    private global::K8S.Io.Api.Core.V1.SecretReference controllerExpandSecretRef_;
    /// <summary>
    /// ControllerExpandSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// ControllerExpandVolume call.
    /// This is an alpha field and requires enabling ExpandCSIVolumes feature gate.
    /// This field is optional, and may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secrets are passed.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretReference ControllerExpandSecretRef {
      get { return controllerExpandSecretRef_; }
      set {
        controllerExpandSecretRef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CSIPersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CSIPersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Driver != other.Driver) return false;
      if (VolumeHandle != other.VolumeHandle) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (FsType != other.FsType) return false;
      if (!VolumeAttributes.Equals(other.VolumeAttributes)) return false;
      if (!object.Equals(ControllerPublishSecretRef, other.ControllerPublishSecretRef)) return false;
      if (!object.Equals(NodeStageSecretRef, other.NodeStageSecretRef)) return false;
      if (!object.Equals(NodePublishSecretRef, other.NodePublishSecretRef)) return false;
      if (!object.Equals(ControllerExpandSecretRef, other.ControllerExpandSecretRef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDriver) hash ^= Driver.GetHashCode();
      if (HasVolumeHandle) hash ^= VolumeHandle.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      hash ^= VolumeAttributes.GetHashCode();
      if (controllerPublishSecretRef_ != null) hash ^= ControllerPublishSecretRef.GetHashCode();
      if (nodeStageSecretRef_ != null) hash ^= NodeStageSecretRef.GetHashCode();
      if (nodePublishSecretRef_ != null) hash ^= NodePublishSecretRef.GetHashCode();
      if (controllerExpandSecretRef_ != null) hash ^= ControllerExpandSecretRef.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDriver) {
        output.WriteRawTag(10);
        output.WriteString(Driver);
      }
      if (HasVolumeHandle) {
        output.WriteRawTag(18);
        output.WriteString(VolumeHandle);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (HasFsType) {
        output.WriteRawTag(34);
        output.WriteString(FsType);
      }
      volumeAttributes_.WriteTo(output, _map_volumeAttributes_codec);
      if (controllerPublishSecretRef_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ControllerPublishSecretRef);
      }
      if (nodeStageSecretRef_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(NodeStageSecretRef);
      }
      if (nodePublishSecretRef_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(NodePublishSecretRef);
      }
      if (controllerExpandSecretRef_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(ControllerExpandSecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDriver) {
        output.WriteRawTag(10);
        output.WriteString(Driver);
      }
      if (HasVolumeHandle) {
        output.WriteRawTag(18);
        output.WriteString(VolumeHandle);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (HasFsType) {
        output.WriteRawTag(34);
        output.WriteString(FsType);
      }
      volumeAttributes_.WriteTo(ref output, _map_volumeAttributes_codec);
      if (controllerPublishSecretRef_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ControllerPublishSecretRef);
      }
      if (nodeStageSecretRef_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(NodeStageSecretRef);
      }
      if (nodePublishSecretRef_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(NodePublishSecretRef);
      }
      if (controllerExpandSecretRef_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(ControllerExpandSecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDriver) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Driver);
      }
      if (HasVolumeHandle) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeHandle);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      size += volumeAttributes_.CalculateSize(_map_volumeAttributes_codec);
      if (controllerPublishSecretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ControllerPublishSecretRef);
      }
      if (nodeStageSecretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NodeStageSecretRef);
      }
      if (nodePublishSecretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NodePublishSecretRef);
      }
      if (controllerExpandSecretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ControllerExpandSecretRef);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CSIPersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasDriver) {
        Driver = other.Driver;
      }
      if (other.HasVolumeHandle) {
        VolumeHandle = other.VolumeHandle;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      volumeAttributes_.Add(other.volumeAttributes_);
      if (other.controllerPublishSecretRef_ != null) {
        if (controllerPublishSecretRef_ == null) {
          ControllerPublishSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
        }
        ControllerPublishSecretRef.MergeFrom(other.ControllerPublishSecretRef);
      }
      if (other.nodeStageSecretRef_ != null) {
        if (nodeStageSecretRef_ == null) {
          NodeStageSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
        }
        NodeStageSecretRef.MergeFrom(other.NodeStageSecretRef);
      }
      if (other.nodePublishSecretRef_ != null) {
        if (nodePublishSecretRef_ == null) {
          NodePublishSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
        }
        NodePublishSecretRef.MergeFrom(other.NodePublishSecretRef);
      }
      if (other.controllerExpandSecretRef_ != null) {
        if (controllerExpandSecretRef_ == null) {
          ControllerExpandSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
        }
        ControllerExpandSecretRef.MergeFrom(other.ControllerExpandSecretRef);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Driver = input.ReadString();
            break;
          }
          case 18: {
            VolumeHandle = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            FsType = input.ReadString();
            break;
          }
          case 42: {
            volumeAttributes_.AddEntriesFrom(input, _map_volumeAttributes_codec);
            break;
          }
          case 50: {
            if (controllerPublishSecretRef_ == null) {
              ControllerPublishSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(ControllerPublishSecretRef);
            break;
          }
          case 58: {
            if (nodeStageSecretRef_ == null) {
              NodeStageSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(NodeStageSecretRef);
            break;
          }
          case 66: {
            if (nodePublishSecretRef_ == null) {
              NodePublishSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(NodePublishSecretRef);
            break;
          }
          case 74: {
            if (controllerExpandSecretRef_ == null) {
              ControllerExpandSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(ControllerExpandSecretRef);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Driver = input.ReadString();
            break;
          }
          case 18: {
            VolumeHandle = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            FsType = input.ReadString();
            break;
          }
          case 42: {
            volumeAttributes_.AddEntriesFrom(ref input, _map_volumeAttributes_codec);
            break;
          }
          case 50: {
            if (controllerPublishSecretRef_ == null) {
              ControllerPublishSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(ControllerPublishSecretRef);
            break;
          }
          case 58: {
            if (nodeStageSecretRef_ == null) {
              NodeStageSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(NodeStageSecretRef);
            break;
          }
          case 66: {
            if (nodePublishSecretRef_ == null) {
              NodePublishSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(NodePublishSecretRef);
            break;
          }
          case 74: {
            if (controllerExpandSecretRef_ == null) {
              ControllerExpandSecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(ControllerExpandSecretRef);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a source location of a volume to mount, managed by an external CSI driver
  /// </summary>
  public sealed partial class CSIVolumeSource : pb::IMessage<CSIVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CSIVolumeSource> _parser = new pb::MessageParser<CSIVolumeSource>(() => new CSIVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CSIVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CSIVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CSIVolumeSource(CSIVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      driver_ = other.driver_;
      readOnly_ = other.readOnly_;
      fsType_ = other.fsType_;
      volumeAttributes_ = other.volumeAttributes_.Clone();
      nodePublishSecretRef_ = other.nodePublishSecretRef_ != null ? other.nodePublishSecretRef_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CSIVolumeSource Clone() {
      return new CSIVolumeSource(this);
    }

    /// <summary>Field number for the "driver" field.</summary>
    public const int DriverFieldNumber = 1;
    private readonly static string DriverDefaultValue = "";

    private string driver_;
    /// <summary>
    /// Driver is the name of the CSI driver that handles this volume.
    /// Consult with your admin for the correct name as registered in the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Driver {
      get { return driver_ ?? DriverDefaultValue; }
      set {
        driver_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "driver" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDriver {
      get { return driver_ != null; }
    }
    /// <summary>Clears the value of the "driver" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDriver() {
      driver_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 2;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Specifies a read-only configuration for the volume.
    /// Defaults to false (read/write).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 3;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs".
    /// If not provided, the empty value is passed to the associated CSI driver
    /// which will determine the default filesystem to apply.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "volumeAttributes" field.</summary>
    public const int VolumeAttributesFieldNumber = 4;
    private static readonly pbc::MapField<string, string>.Codec _map_volumeAttributes_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 34);
    private readonly pbc::MapField<string, string> volumeAttributes_ = new pbc::MapField<string, string>();
    /// <summary>
    /// VolumeAttributes stores driver-specific properties that are passed to the CSI
    /// driver. Consult your driver's documentation for supported values.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> VolumeAttributes {
      get { return volumeAttributes_; }
    }

    /// <summary>Field number for the "nodePublishSecretRef" field.</summary>
    public const int NodePublishSecretRefFieldNumber = 5;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference nodePublishSecretRef_;
    /// <summary>
    /// NodePublishSecretRef is a reference to the secret object containing
    /// sensitive information to pass to the CSI driver to complete the CSI
    /// NodePublishVolume and NodeUnpublishVolume calls.
    /// This field is optional, and  may be empty if no secret is required. If the
    /// secret object contains more than one secret, all secret references are passed.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference NodePublishSecretRef {
      get { return nodePublishSecretRef_; }
      set {
        nodePublishSecretRef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CSIVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CSIVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Driver != other.Driver) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (FsType != other.FsType) return false;
      if (!VolumeAttributes.Equals(other.VolumeAttributes)) return false;
      if (!object.Equals(NodePublishSecretRef, other.NodePublishSecretRef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDriver) hash ^= Driver.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      hash ^= VolumeAttributes.GetHashCode();
      if (nodePublishSecretRef_ != null) hash ^= NodePublishSecretRef.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDriver) {
        output.WriteRawTag(10);
        output.WriteString(Driver);
      }
      if (HasReadOnly) {
        output.WriteRawTag(16);
        output.WriteBool(ReadOnly);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      volumeAttributes_.WriteTo(output, _map_volumeAttributes_codec);
      if (nodePublishSecretRef_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(NodePublishSecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDriver) {
        output.WriteRawTag(10);
        output.WriteString(Driver);
      }
      if (HasReadOnly) {
        output.WriteRawTag(16);
        output.WriteBool(ReadOnly);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      volumeAttributes_.WriteTo(ref output, _map_volumeAttributes_codec);
      if (nodePublishSecretRef_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(NodePublishSecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDriver) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Driver);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      size += volumeAttributes_.CalculateSize(_map_volumeAttributes_codec);
      if (nodePublishSecretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NodePublishSecretRef);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CSIVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasDriver) {
        Driver = other.Driver;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      volumeAttributes_.Add(other.volumeAttributes_);
      if (other.nodePublishSecretRef_ != null) {
        if (nodePublishSecretRef_ == null) {
          NodePublishSecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        NodePublishSecretRef.MergeFrom(other.NodePublishSecretRef);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Driver = input.ReadString();
            break;
          }
          case 16: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 34: {
            volumeAttributes_.AddEntriesFrom(input, _map_volumeAttributes_codec);
            break;
          }
          case 42: {
            if (nodePublishSecretRef_ == null) {
              NodePublishSecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(NodePublishSecretRef);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Driver = input.ReadString();
            break;
          }
          case 16: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 34: {
            volumeAttributes_.AddEntriesFrom(ref input, _map_volumeAttributes_codec);
            break;
          }
          case 42: {
            if (nodePublishSecretRef_ == null) {
              NodePublishSecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(NodePublishSecretRef);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Adds and removes POSIX capabilities from running containers.
  /// </summary>
  public sealed partial class Capabilities : pb::IMessage<Capabilities>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Capabilities> _parser = new pb::MessageParser<Capabilities>(() => new Capabilities());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Capabilities> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Capabilities() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Capabilities(Capabilities other) : this() {
      add_ = other.add_.Clone();
      drop_ = other.drop_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Capabilities Clone() {
      return new Capabilities(this);
    }

    /// <summary>Field number for the "add" field.</summary>
    public const int AddFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_add_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> add_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Added capabilities
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Add {
      get { return add_; }
    }

    /// <summary>Field number for the "drop" field.</summary>
    public const int DropFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_drop_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> drop_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Removed capabilities
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Drop {
      get { return drop_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Capabilities);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Capabilities other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!add_.Equals(other.add_)) return false;
      if(!drop_.Equals(other.drop_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= add_.GetHashCode();
      hash ^= drop_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      add_.WriteTo(output, _repeated_add_codec);
      drop_.WriteTo(output, _repeated_drop_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      add_.WriteTo(ref output, _repeated_add_codec);
      drop_.WriteTo(ref output, _repeated_drop_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += add_.CalculateSize(_repeated_add_codec);
      size += drop_.CalculateSize(_repeated_drop_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Capabilities other) {
      if (other == null) {
        return;
      }
      add_.Add(other.add_);
      drop_.Add(other.drop_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            add_.AddEntriesFrom(input, _repeated_add_codec);
            break;
          }
          case 18: {
            drop_.AddEntriesFrom(input, _repeated_drop_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            add_.AddEntriesFrom(ref input, _repeated_add_codec);
            break;
          }
          case 18: {
            drop_.AddEntriesFrom(ref input, _repeated_drop_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
  /// Cephfs volumes do not support ownership management or SELinux relabeling.
  /// </summary>
  public sealed partial class CephFSPersistentVolumeSource : pb::IMessage<CephFSPersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CephFSPersistentVolumeSource> _parser = new pb::MessageParser<CephFSPersistentVolumeSource>(() => new CephFSPersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CephFSPersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CephFSPersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CephFSPersistentVolumeSource(CephFSPersistentVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      monitors_ = other.monitors_.Clone();
      path_ = other.path_;
      user_ = other.user_;
      secretFile_ = other.secretFile_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CephFSPersistentVolumeSource Clone() {
      return new CephFSPersistentVolumeSource(this);
    }

    /// <summary>Field number for the "monitors" field.</summary>
    public const int MonitorsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_monitors_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> monitors_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Required: Monitors is a collection of Ceph monitors
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Monitors {
      get { return monitors_; }
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 2;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "user" field.</summary>
    public const int UserFieldNumber = 3;
    private readonly static string UserDefaultValue = "";

    private string user_;
    /// <summary>
    /// Optional: User is the rados user name, default is admin
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string User {
      get { return user_ ?? UserDefaultValue; }
      set {
        user_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "user" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUser {
      get { return user_ != null; }
    }
    /// <summary>Clears the value of the "user" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUser() {
      user_ = null;
    }

    /// <summary>Field number for the "secretFile" field.</summary>
    public const int SecretFileFieldNumber = 4;
    private readonly static string SecretFileDefaultValue = "";

    private string secretFile_;
    /// <summary>
    /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SecretFile {
      get { return secretFile_ ?? SecretFileDefaultValue; }
      set {
        secretFile_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "secretFile" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSecretFile {
      get { return secretFile_ != null; }
    }
    /// <summary>Clears the value of the "secretFile" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSecretFile() {
      secretFile_ = null;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 5;
    private global::K8S.Io.Api.Core.V1.SecretReference secretRef_;
    /// <summary>
    /// Optional: SecretRef is reference to the authentication secret for User, default is empty.
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 6;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CephFSPersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CephFSPersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!monitors_.Equals(other.monitors_)) return false;
      if (Path != other.Path) return false;
      if (User != other.User) return false;
      if (SecretFile != other.SecretFile) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= monitors_.GetHashCode();
      if (HasPath) hash ^= Path.GetHashCode();
      if (HasUser) hash ^= User.GetHashCode();
      if (HasSecretFile) hash ^= SecretFile.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      monitors_.WriteTo(output, _repeated_monitors_codec);
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasUser) {
        output.WriteRawTag(26);
        output.WriteString(User);
      }
      if (HasSecretFile) {
        output.WriteRawTag(34);
        output.WriteString(SecretFile);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(48);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      monitors_.WriteTo(ref output, _repeated_monitors_codec);
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasUser) {
        output.WriteRawTag(26);
        output.WriteString(User);
      }
      if (HasSecretFile) {
        output.WriteRawTag(34);
        output.WriteString(SecretFile);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(48);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += monitors_.CalculateSize(_repeated_monitors_codec);
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (HasUser) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(User);
      }
      if (HasSecretFile) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SecretFile);
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CephFSPersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      monitors_.Add(other.monitors_);
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.HasUser) {
        User = other.User;
      }
      if (other.HasSecretFile) {
        SecretFile = other.SecretFile;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            monitors_.AddEntriesFrom(input, _repeated_monitors_codec);
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 26: {
            User = input.ReadString();
            break;
          }
          case 34: {
            SecretFile = input.ReadString();
            break;
          }
          case 42: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 48: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            monitors_.AddEntriesFrom(ref input, _repeated_monitors_codec);
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 26: {
            User = input.ReadString();
            break;
          }
          case 34: {
            SecretFile = input.ReadString();
            break;
          }
          case 42: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 48: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
  /// Cephfs volumes do not support ownership management or SELinux relabeling.
  /// </summary>
  public sealed partial class CephFSVolumeSource : pb::IMessage<CephFSVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CephFSVolumeSource> _parser = new pb::MessageParser<CephFSVolumeSource>(() => new CephFSVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CephFSVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CephFSVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CephFSVolumeSource(CephFSVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      monitors_ = other.monitors_.Clone();
      path_ = other.path_;
      user_ = other.user_;
      secretFile_ = other.secretFile_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CephFSVolumeSource Clone() {
      return new CephFSVolumeSource(this);
    }

    /// <summary>Field number for the "monitors" field.</summary>
    public const int MonitorsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_monitors_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> monitors_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Required: Monitors is a collection of Ceph monitors
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Monitors {
      get { return monitors_; }
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 2;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "user" field.</summary>
    public const int UserFieldNumber = 3;
    private readonly static string UserDefaultValue = "";

    private string user_;
    /// <summary>
    /// Optional: User is the rados user name, default is admin
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string User {
      get { return user_ ?? UserDefaultValue; }
      set {
        user_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "user" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUser {
      get { return user_ != null; }
    }
    /// <summary>Clears the value of the "user" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUser() {
      user_ = null;
    }

    /// <summary>Field number for the "secretFile" field.</summary>
    public const int SecretFileFieldNumber = 4;
    private readonly static string SecretFileDefaultValue = "";

    private string secretFile_;
    /// <summary>
    /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SecretFile {
      get { return secretFile_ ?? SecretFileDefaultValue; }
      set {
        secretFile_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "secretFile" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSecretFile {
      get { return secretFile_ != null; }
    }
    /// <summary>Clears the value of the "secretFile" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSecretFile() {
      secretFile_ = null;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 5;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference secretRef_;
    /// <summary>
    /// Optional: SecretRef is reference to the authentication secret for User, default is empty.
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 6;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CephFSVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CephFSVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!monitors_.Equals(other.monitors_)) return false;
      if (Path != other.Path) return false;
      if (User != other.User) return false;
      if (SecretFile != other.SecretFile) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= monitors_.GetHashCode();
      if (HasPath) hash ^= Path.GetHashCode();
      if (HasUser) hash ^= User.GetHashCode();
      if (HasSecretFile) hash ^= SecretFile.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      monitors_.WriteTo(output, _repeated_monitors_codec);
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasUser) {
        output.WriteRawTag(26);
        output.WriteString(User);
      }
      if (HasSecretFile) {
        output.WriteRawTag(34);
        output.WriteString(SecretFile);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(48);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      monitors_.WriteTo(ref output, _repeated_monitors_codec);
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasUser) {
        output.WriteRawTag(26);
        output.WriteString(User);
      }
      if (HasSecretFile) {
        output.WriteRawTag(34);
        output.WriteString(SecretFile);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(48);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += monitors_.CalculateSize(_repeated_monitors_codec);
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (HasUser) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(User);
      }
      if (HasSecretFile) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SecretFile);
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CephFSVolumeSource other) {
      if (other == null) {
        return;
      }
      monitors_.Add(other.monitors_);
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.HasUser) {
        User = other.User;
      }
      if (other.HasSecretFile) {
        SecretFile = other.SecretFile;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            monitors_.AddEntriesFrom(input, _repeated_monitors_codec);
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 26: {
            User = input.ReadString();
            break;
          }
          case 34: {
            SecretFile = input.ReadString();
            break;
          }
          case 42: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 48: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            monitors_.AddEntriesFrom(ref input, _repeated_monitors_codec);
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 26: {
            User = input.ReadString();
            break;
          }
          case 34: {
            SecretFile = input.ReadString();
            break;
          }
          case 42: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 48: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a cinder volume resource in Openstack.
  /// A Cinder volume must exist before mounting to a container.
  /// The volume must also be in the same region as the kubelet.
  /// Cinder volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class CinderPersistentVolumeSource : pb::IMessage<CinderPersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CinderPersistentVolumeSource> _parser = new pb::MessageParser<CinderPersistentVolumeSource>(() => new CinderPersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CinderPersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CinderPersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CinderPersistentVolumeSource(CinderPersistentVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      volumeID_ = other.volumeID_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CinderPersistentVolumeSource Clone() {
      return new CinderPersistentVolumeSource(this);
    }

    /// <summary>Field number for the "volumeID" field.</summary>
    public const int VolumeIDFieldNumber = 1;
    private readonly static string VolumeIDDefaultValue = "";

    private string volumeID_;
    /// <summary>
    /// volume id used to identify the volume in cinder.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeID {
      get { return volumeID_ ?? VolumeIDDefaultValue; }
      set {
        volumeID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeID {
      get { return volumeID_ != null; }
    }
    /// <summary>Clears the value of the "volumeID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeID() {
      volumeID_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 2;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 3;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 4;
    private global::K8S.Io.Api.Core.V1.SecretReference secretRef_;
    /// <summary>
    /// Optional: points to a secret object containing parameters used to connect
    /// to OpenStack.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CinderPersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CinderPersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeID != other.VolumeID) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasVolumeID) hash ^= VolumeID.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasVolumeID) {
        output.WriteRawTag(10);
        output.WriteString(VolumeID);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasVolumeID) {
        output.WriteRawTag(10);
        output.WriteString(VolumeID);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasVolumeID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeID);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CinderPersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasVolumeID) {
        VolumeID = other.VolumeID;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeID = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            VolumeID = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a cinder volume resource in Openstack.
  /// A Cinder volume must exist before mounting to a container.
  /// The volume must also be in the same region as the kubelet.
  /// Cinder volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class CinderVolumeSource : pb::IMessage<CinderVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<CinderVolumeSource> _parser = new pb::MessageParser<CinderVolumeSource>(() => new CinderVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<CinderVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CinderVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CinderVolumeSource(CinderVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      volumeID_ = other.volumeID_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public CinderVolumeSource Clone() {
      return new CinderVolumeSource(this);
    }

    /// <summary>Field number for the "volumeID" field.</summary>
    public const int VolumeIDFieldNumber = 1;
    private readonly static string VolumeIDDefaultValue = "";

    private string volumeID_;
    /// <summary>
    /// volume id used to identify the volume in cinder.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeID {
      get { return volumeID_ ?? VolumeIDDefaultValue; }
      set {
        volumeID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeID {
      get { return volumeID_ != null; }
    }
    /// <summary>Clears the value of the "volumeID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeID() {
      volumeID_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 2;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 3;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 4;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference secretRef_;
    /// <summary>
    /// Optional: points to a secret object containing parameters used to connect
    /// to OpenStack.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as CinderVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(CinderVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeID != other.VolumeID) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasVolumeID) hash ^= VolumeID.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasVolumeID) {
        output.WriteRawTag(10);
        output.WriteString(VolumeID);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasVolumeID) {
        output.WriteRawTag(10);
        output.WriteString(VolumeID);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasVolumeID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeID);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(CinderVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasVolumeID) {
        VolumeID = other.VolumeID;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeID = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            VolumeID = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ClientIPConfig represents the configurations of Client IP based session affinity.
  /// </summary>
  public sealed partial class ClientIPConfig : pb::IMessage<ClientIPConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ClientIPConfig> _parser = new pb::MessageParser<ClientIPConfig>(() => new ClientIPConfig());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ClientIPConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientIPConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientIPConfig(ClientIPConfig other) : this() {
      _hasBits0 = other._hasBits0;
      timeoutSeconds_ = other.timeoutSeconds_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ClientIPConfig Clone() {
      return new ClientIPConfig(this);
    }

    /// <summary>Field number for the "timeoutSeconds" field.</summary>
    public const int TimeoutSecondsFieldNumber = 1;
    private readonly static int TimeoutSecondsDefaultValue = 0;

    private int timeoutSeconds_;
    /// <summary>
    /// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
    /// The value must be >0 &amp;&amp; &lt;=86400(for 1 day) if ServiceAffinity == "ClientIP".
    /// Default value is 10800(for 3 hours).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TimeoutSeconds {
      get { if ((_hasBits0 & 1) != 0) { return timeoutSeconds_; } else { return TimeoutSecondsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        timeoutSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "timeoutSeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTimeoutSeconds {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "timeoutSeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTimeoutSeconds() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ClientIPConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ClientIPConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TimeoutSeconds != other.TimeoutSeconds) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTimeoutSeconds) hash ^= TimeoutSeconds.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTimeoutSeconds) {
        output.WriteRawTag(8);
        output.WriteInt32(TimeoutSeconds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTimeoutSeconds) {
        output.WriteRawTag(8);
        output.WriteInt32(TimeoutSeconds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasTimeoutSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TimeoutSeconds);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ClientIPConfig other) {
      if (other == null) {
        return;
      }
      if (other.HasTimeoutSeconds) {
        TimeoutSeconds = other.TimeoutSeconds;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TimeoutSeconds = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TimeoutSeconds = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Information about the condition of a component.
  /// </summary>
  public sealed partial class ComponentCondition : pb::IMessage<ComponentCondition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ComponentCondition> _parser = new pb::MessageParser<ComponentCondition>(() => new ComponentCondition());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ComponentCondition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComponentCondition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComponentCondition(ComponentCondition other) : this() {
      type_ = other.type_;
      status_ = other.status_;
      message_ = other.message_;
      error_ = other.error_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComponentCondition Clone() {
      return new ComponentCondition(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Type of condition for a component.
    /// Valid value: "Healthy"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 2;
    private readonly static string StatusDefaultValue = "";

    private string status_;
    /// <summary>
    /// Status of the condition for a component.
    /// Valid values for "Healthy": "True", "False", or "Unknown".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Status {
      get { return status_ ?? StatusDefaultValue; }
      set {
        status_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStatus {
      get { return status_ != null; }
    }
    /// <summary>Clears the value of the "status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStatus() {
      status_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 3;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// Message about the condition for a component.
    /// For example, information about a health check.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "error" field.</summary>
    public const int ErrorFieldNumber = 4;
    private readonly static string ErrorDefaultValue = "";

    private string error_;
    /// <summary>
    /// Condition error code for a component.
    /// For example, a health check error code.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Error {
      get { return error_ ?? ErrorDefaultValue; }
      set {
        error_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "error" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasError {
      get { return error_ != null; }
    }
    /// <summary>Clears the value of the "error" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearError() {
      error_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ComponentCondition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ComponentCondition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Status != other.Status) return false;
      if (Message != other.Message) return false;
      if (Error != other.Error) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasStatus) hash ^= Status.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (HasError) hash ^= Error.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (HasMessage) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (HasError) {
        output.WriteRawTag(34);
        output.WriteString(Error);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (HasMessage) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (HasError) {
        output.WriteRawTag(34);
        output.WriteString(Error);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasStatus) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Status);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (HasError) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Error);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ComponentCondition other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasStatus) {
        Status = other.Status;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.HasError) {
        Error = other.Error;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            Error = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            Error = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ComponentStatus (and ComponentStatusList) holds the cluster validation info.
  /// Deprecated: This API is deprecated in v1.19+
  /// </summary>
  public sealed partial class ComponentStatus : pb::IMessage<ComponentStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ComponentStatus> _parser = new pb::MessageParser<ComponentStatus>(() => new ComponentStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ComponentStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComponentStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComponentStatus(ComponentStatus other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      conditions_ = other.conditions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComponentStatus Clone() {
      return new ComponentStatus(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "conditions" field.</summary>
    public const int ConditionsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ComponentCondition> _repeated_conditions_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.ComponentCondition.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ComponentCondition> conditions_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ComponentCondition>();
    /// <summary>
    /// List of component conditions observed
    /// +optional
    /// +patchMergeKey=type
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ComponentCondition> Conditions {
      get { return conditions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ComponentStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ComponentStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!conditions_.Equals(other.conditions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= conditions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      conditions_.WriteTo(output, _repeated_conditions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      conditions_.WriteTo(ref output, _repeated_conditions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += conditions_.CalculateSize(_repeated_conditions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ComponentStatus other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      conditions_.Add(other.conditions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            conditions_.AddEntriesFrom(ref input, _repeated_conditions_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Status of all the conditions for the component as a list of ComponentStatus objects.
  /// Deprecated: This API is deprecated in v1.19+
  /// </summary>
  public sealed partial class ComponentStatusList : pb::IMessage<ComponentStatusList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ComponentStatusList> _parser = new pb::MessageParser<ComponentStatusList>(() => new ComponentStatusList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ComponentStatusList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComponentStatusList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComponentStatusList(ComponentStatusList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ComponentStatusList Clone() {
      return new ComponentStatusList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ComponentStatus> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.ComponentStatus.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ComponentStatus> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ComponentStatus>();
    /// <summary>
    /// List of ComponentStatus objects.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ComponentStatus> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ComponentStatusList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ComponentStatusList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ComponentStatusList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ConfigMap holds configuration data for pods to consume.
  /// </summary>
  public sealed partial class ConfigMap : pb::IMessage<ConfigMap>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConfigMap> _parser = new pb::MessageParser<ConfigMap>(() => new ConfigMap());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConfigMap> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMap() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMap(ConfigMap other) : this() {
      _hasBits0 = other._hasBits0;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      immutable_ = other.immutable_;
      data_ = other.data_.Clone();
      binaryData_ = other.binaryData_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMap Clone() {
      return new ConfigMap(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "immutable" field.</summary>
    public const int ImmutableFieldNumber = 4;
    private readonly static bool ImmutableDefaultValue = false;

    private bool immutable_;
    /// <summary>
    /// Immutable, if set to true, ensures that data stored in the ConfigMap cannot
    /// be updated (only object metadata can be modified).
    /// If not set to true, the field can be modified at any time.
    /// Defaulted to nil.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Immutable {
      get { if ((_hasBits0 & 1) != 0) { return immutable_; } else { return ImmutableDefaultValue; } }
      set {
        _hasBits0 |= 1;
        immutable_ = value;
      }
    }
    /// <summary>Gets whether the "immutable" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImmutable {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "immutable" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImmutable() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "data" field.</summary>
    public const int DataFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_data_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 18);
    private readonly pbc::MapField<string, string> data_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Data contains the configuration data.
    /// Each key must consist of alphanumeric characters, '-', '_' or '.'.
    /// Values with non-UTF-8 byte sequences must use the BinaryData field.
    /// The keys stored in Data must not overlap with the keys in
    /// the BinaryData field, this is enforced during validation process.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> Data {
      get { return data_; }
    }

    /// <summary>Field number for the "binaryData" field.</summary>
    public const int BinaryDataFieldNumber = 3;
    private static readonly pbc::MapField<string, pb::ByteString>.Codec _map_binaryData_codec
        = new pbc::MapField<string, pb::ByteString>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForBytes(18, pb::ByteString.Empty), 26);
    private readonly pbc::MapField<string, pb::ByteString> binaryData_ = new pbc::MapField<string, pb::ByteString>();
    /// <summary>
    /// BinaryData contains the binary data.
    /// Each key must consist of alphanumeric characters, '-', '_' or '.'.
    /// BinaryData can contain byte sequences that are not in the UTF-8 range.
    /// The keys stored in BinaryData must not overlap with the ones in
    /// the Data field, this is enforced during validation process.
    /// Using this field will require 1.10+ apiserver and
    /// kubelet.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, pb::ByteString> BinaryData {
      get { return binaryData_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConfigMap);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConfigMap other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (Immutable != other.Immutable) return false;
      if (!Data.Equals(other.Data)) return false;
      if (!BinaryData.Equals(other.BinaryData)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (HasImmutable) hash ^= Immutable.GetHashCode();
      hash ^= Data.GetHashCode();
      hash ^= BinaryData.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      data_.WriteTo(output, _map_data_codec);
      binaryData_.WriteTo(output, _map_binaryData_codec);
      if (HasImmutable) {
        output.WriteRawTag(32);
        output.WriteBool(Immutable);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      data_.WriteTo(ref output, _map_data_codec);
      binaryData_.WriteTo(ref output, _map_binaryData_codec);
      if (HasImmutable) {
        output.WriteRawTag(32);
        output.WriteBool(Immutable);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (HasImmutable) {
        size += 1 + 1;
      }
      size += data_.CalculateSize(_map_data_codec);
      size += binaryData_.CalculateSize(_map_binaryData_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConfigMap other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.HasImmutable) {
        Immutable = other.Immutable;
      }
      data_.Add(other.data_);
      binaryData_.Add(other.binaryData_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            data_.AddEntriesFrom(input, _map_data_codec);
            break;
          }
          case 26: {
            binaryData_.AddEntriesFrom(input, _map_binaryData_codec);
            break;
          }
          case 32: {
            Immutable = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            data_.AddEntriesFrom(ref input, _map_data_codec);
            break;
          }
          case 26: {
            binaryData_.AddEntriesFrom(ref input, _map_binaryData_codec);
            break;
          }
          case 32: {
            Immutable = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ConfigMapEnvSource selects a ConfigMap to populate the environment
  /// variables with.
  ///
  /// The contents of the target ConfigMap's Data field will represent the
  /// key-value pairs as environment variables.
  /// </summary>
  public sealed partial class ConfigMapEnvSource : pb::IMessage<ConfigMapEnvSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConfigMapEnvSource> _parser = new pb::MessageParser<ConfigMapEnvSource>(() => new ConfigMapEnvSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConfigMapEnvSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapEnvSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapEnvSource(ConfigMapEnvSource other) : this() {
      _hasBits0 = other._hasBits0;
      localObjectReference_ = other.localObjectReference_ != null ? other.localObjectReference_.Clone() : null;
      optional_ = other.optional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapEnvSource Clone() {
      return new ConfigMapEnvSource(this);
    }

    /// <summary>Field number for the "localObjectReference" field.</summary>
    public const int LocalObjectReferenceFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference localObjectReference_;
    /// <summary>
    /// The ConfigMap to select from.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference LocalObjectReference {
      get { return localObjectReference_; }
      set {
        localObjectReference_ = value;
      }
    }

    /// <summary>Field number for the "optional" field.</summary>
    public const int OptionalFieldNumber = 2;
    private readonly static bool OptionalDefaultValue = false;

    private bool optional_;
    /// <summary>
    /// Specify whether the ConfigMap must be defined
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Optional {
      get { if ((_hasBits0 & 1) != 0) { return optional_; } else { return OptionalDefaultValue; } }
      set {
        _hasBits0 |= 1;
        optional_ = value;
      }
    }
    /// <summary>Gets whether the "optional" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOptional {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "optional" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOptional() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConfigMapEnvSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConfigMapEnvSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LocalObjectReference, other.LocalObjectReference)) return false;
      if (Optional != other.Optional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (localObjectReference_ != null) hash ^= LocalObjectReference.GetHashCode();
      if (HasOptional) hash ^= Optional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      if (HasOptional) {
        output.WriteRawTag(16);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      if (HasOptional) {
        output.WriteRawTag(16);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (localObjectReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalObjectReference);
      }
      if (HasOptional) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConfigMapEnvSource other) {
      if (other == null) {
        return;
      }
      if (other.localObjectReference_ != null) {
        if (localObjectReference_ == null) {
          LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        LocalObjectReference.MergeFrom(other.LocalObjectReference);
      }
      if (other.HasOptional) {
        Optional = other.Optional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 16: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 16: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Selects a key from a ConfigMap.
  /// +structType=atomic
  /// </summary>
  public sealed partial class ConfigMapKeySelector : pb::IMessage<ConfigMapKeySelector>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConfigMapKeySelector> _parser = new pb::MessageParser<ConfigMapKeySelector>(() => new ConfigMapKeySelector());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConfigMapKeySelector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapKeySelector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapKeySelector(ConfigMapKeySelector other) : this() {
      _hasBits0 = other._hasBits0;
      localObjectReference_ = other.localObjectReference_ != null ? other.localObjectReference_.Clone() : null;
      key_ = other.key_;
      optional_ = other.optional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapKeySelector Clone() {
      return new ConfigMapKeySelector(this);
    }

    /// <summary>Field number for the "localObjectReference" field.</summary>
    public const int LocalObjectReferenceFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference localObjectReference_;
    /// <summary>
    /// The ConfigMap to select from.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference LocalObjectReference {
      get { return localObjectReference_; }
      set {
        localObjectReference_ = value;
      }
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 2;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    /// <summary>
    /// The key to select.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "optional" field.</summary>
    public const int OptionalFieldNumber = 3;
    private readonly static bool OptionalDefaultValue = false;

    private bool optional_;
    /// <summary>
    /// Specify whether the ConfigMap or its key must be defined
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Optional {
      get { if ((_hasBits0 & 1) != 0) { return optional_; } else { return OptionalDefaultValue; } }
      set {
        _hasBits0 |= 1;
        optional_ = value;
      }
    }
    /// <summary>Gets whether the "optional" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOptional {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "optional" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOptional() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConfigMapKeySelector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConfigMapKeySelector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LocalObjectReference, other.LocalObjectReference)) return false;
      if (Key != other.Key) return false;
      if (Optional != other.Optional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (localObjectReference_ != null) hash ^= LocalObjectReference.GetHashCode();
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasOptional) hash ^= Optional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      if (HasKey) {
        output.WriteRawTag(18);
        output.WriteString(Key);
      }
      if (HasOptional) {
        output.WriteRawTag(24);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      if (HasKey) {
        output.WriteRawTag(18);
        output.WriteString(Key);
      }
      if (HasOptional) {
        output.WriteRawTag(24);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (localObjectReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalObjectReference);
      }
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (HasOptional) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConfigMapKeySelector other) {
      if (other == null) {
        return;
      }
      if (other.localObjectReference_ != null) {
        if (localObjectReference_ == null) {
          LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        LocalObjectReference.MergeFrom(other.LocalObjectReference);
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasOptional) {
        Optional = other.Optional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 18: {
            Key = input.ReadString();
            break;
          }
          case 24: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 18: {
            Key = input.ReadString();
            break;
          }
          case 24: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ConfigMapList is a resource containing a list of ConfigMap objects.
  /// </summary>
  public sealed partial class ConfigMapList : pb::IMessage<ConfigMapList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConfigMapList> _parser = new pb::MessageParser<ConfigMapList>(() => new ConfigMapList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConfigMapList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapList(ConfigMapList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapList Clone() {
      return new ConfigMapList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ConfigMap> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.ConfigMap.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ConfigMap> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ConfigMap>();
    /// <summary>
    /// Items is the list of ConfigMaps.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ConfigMap> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConfigMapList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConfigMapList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConfigMapList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node.
  /// This API is deprecated since 1.22: https://git.k8s.io/enhancements/keps/sig-node/281-dynamic-kubelet-configuration
  /// </summary>
  public sealed partial class ConfigMapNodeConfigSource : pb::IMessage<ConfigMapNodeConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConfigMapNodeConfigSource> _parser = new pb::MessageParser<ConfigMapNodeConfigSource>(() => new ConfigMapNodeConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConfigMapNodeConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapNodeConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapNodeConfigSource(ConfigMapNodeConfigSource other) : this() {
      namespace_ = other.namespace_;
      name_ = other.name_;
      uid_ = other.uid_;
      resourceVersion_ = other.resourceVersion_;
      kubeletConfigKey_ = other.kubeletConfigKey_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapNodeConfigSource Clone() {
      return new ConfigMapNodeConfigSource(this);
    }

    /// <summary>Field number for the "namespace" field.</summary>
    public const int NamespaceFieldNumber = 1;
    private readonly static string NamespaceDefaultValue = "";

    private string namespace_;
    /// <summary>
    /// Namespace is the metadata.namespace of the referenced ConfigMap.
    /// This field is required in all cases.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Namespace {
      get { return namespace_ ?? NamespaceDefaultValue; }
      set {
        namespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "namespace" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNamespace {
      get { return namespace_ != null; }
    }
    /// <summary>Clears the value of the "namespace" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNamespace() {
      namespace_ = null;
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name is the metadata.name of the referenced ConfigMap.
    /// This field is required in all cases.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "uid" field.</summary>
    public const int UidFieldNumber = 3;
    private readonly static string UidDefaultValue = "";

    private string uid_;
    /// <summary>
    /// UID is the metadata.UID of the referenced ConfigMap.
    /// This field is forbidden in Node.Spec, and required in Node.Status.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Uid {
      get { return uid_ ?? UidDefaultValue; }
      set {
        uid_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "uid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUid {
      get { return uid_ != null; }
    }
    /// <summary>Clears the value of the "uid" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUid() {
      uid_ = null;
    }

    /// <summary>Field number for the "resourceVersion" field.</summary>
    public const int ResourceVersionFieldNumber = 4;
    private readonly static string ResourceVersionDefaultValue = "";

    private string resourceVersion_;
    /// <summary>
    /// ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap.
    /// This field is forbidden in Node.Spec, and required in Node.Status.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ResourceVersion {
      get { return resourceVersion_ ?? ResourceVersionDefaultValue; }
      set {
        resourceVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "resourceVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasResourceVersion {
      get { return resourceVersion_ != null; }
    }
    /// <summary>Clears the value of the "resourceVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearResourceVersion() {
      resourceVersion_ = null;
    }

    /// <summary>Field number for the "kubeletConfigKey" field.</summary>
    public const int KubeletConfigKeyFieldNumber = 5;
    private readonly static string KubeletConfigKeyDefaultValue = "";

    private string kubeletConfigKey_;
    /// <summary>
    /// KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure
    /// This field is required in all cases.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string KubeletConfigKey {
      get { return kubeletConfigKey_ ?? KubeletConfigKeyDefaultValue; }
      set {
        kubeletConfigKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "kubeletConfigKey" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKubeletConfigKey {
      get { return kubeletConfigKey_ != null; }
    }
    /// <summary>Clears the value of the "kubeletConfigKey" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKubeletConfigKey() {
      kubeletConfigKey_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConfigMapNodeConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConfigMapNodeConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Namespace != other.Namespace) return false;
      if (Name != other.Name) return false;
      if (Uid != other.Uid) return false;
      if (ResourceVersion != other.ResourceVersion) return false;
      if (KubeletConfigKey != other.KubeletConfigKey) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasNamespace) hash ^= Namespace.GetHashCode();
      if (HasName) hash ^= Name.GetHashCode();
      if (HasUid) hash ^= Uid.GetHashCode();
      if (HasResourceVersion) hash ^= ResourceVersion.GetHashCode();
      if (HasKubeletConfigKey) hash ^= KubeletConfigKey.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasNamespace) {
        output.WriteRawTag(10);
        output.WriteString(Namespace);
      }
      if (HasName) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (HasUid) {
        output.WriteRawTag(26);
        output.WriteString(Uid);
      }
      if (HasResourceVersion) {
        output.WriteRawTag(34);
        output.WriteString(ResourceVersion);
      }
      if (HasKubeletConfigKey) {
        output.WriteRawTag(42);
        output.WriteString(KubeletConfigKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasNamespace) {
        output.WriteRawTag(10);
        output.WriteString(Namespace);
      }
      if (HasName) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (HasUid) {
        output.WriteRawTag(26);
        output.WriteString(Uid);
      }
      if (HasResourceVersion) {
        output.WriteRawTag(34);
        output.WriteString(ResourceVersion);
      }
      if (HasKubeletConfigKey) {
        output.WriteRawTag(42);
        output.WriteString(KubeletConfigKey);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasNamespace) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Namespace);
      }
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasUid) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uid);
      }
      if (HasResourceVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ResourceVersion);
      }
      if (HasKubeletConfigKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(KubeletConfigKey);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConfigMapNodeConfigSource other) {
      if (other == null) {
        return;
      }
      if (other.HasNamespace) {
        Namespace = other.Namespace;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasUid) {
        Uid = other.Uid;
      }
      if (other.HasResourceVersion) {
        ResourceVersion = other.ResourceVersion;
      }
      if (other.HasKubeletConfigKey) {
        KubeletConfigKey = other.KubeletConfigKey;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Namespace = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            Uid = input.ReadString();
            break;
          }
          case 34: {
            ResourceVersion = input.ReadString();
            break;
          }
          case 42: {
            KubeletConfigKey = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Namespace = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            Uid = input.ReadString();
            break;
          }
          case 34: {
            ResourceVersion = input.ReadString();
            break;
          }
          case 42: {
            KubeletConfigKey = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Adapts a ConfigMap into a projected volume.
  ///
  /// The contents of the target ConfigMap's Data field will be presented in a
  /// projected volume as files using the keys in the Data field as the file names,
  /// unless the items element is populated with specific mappings of keys to paths.
  /// Note that this is identical to a configmap volume source without the default
  /// mode.
  /// </summary>
  public sealed partial class ConfigMapProjection : pb::IMessage<ConfigMapProjection>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConfigMapProjection> _parser = new pb::MessageParser<ConfigMapProjection>(() => new ConfigMapProjection());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConfigMapProjection> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapProjection() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapProjection(ConfigMapProjection other) : this() {
      _hasBits0 = other._hasBits0;
      localObjectReference_ = other.localObjectReference_ != null ? other.localObjectReference_.Clone() : null;
      items_ = other.items_.Clone();
      optional_ = other.optional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapProjection Clone() {
      return new ConfigMapProjection(this);
    }

    /// <summary>Field number for the "localObjectReference" field.</summary>
    public const int LocalObjectReferenceFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference localObjectReference_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference LocalObjectReference {
      get { return localObjectReference_; }
      set {
        localObjectReference_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.KeyToPath> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.KeyToPath.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath>();
    /// <summary>
    /// If unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath> Items {
      get { return items_; }
    }

    /// <summary>Field number for the "optional" field.</summary>
    public const int OptionalFieldNumber = 4;
    private readonly static bool OptionalDefaultValue = false;

    private bool optional_;
    /// <summary>
    /// Specify whether the ConfigMap or its keys must be defined
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Optional {
      get { if ((_hasBits0 & 1) != 0) { return optional_; } else { return OptionalDefaultValue; } }
      set {
        _hasBits0 |= 1;
        optional_ = value;
      }
    }
    /// <summary>Gets whether the "optional" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOptional {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "optional" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOptional() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConfigMapProjection);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConfigMapProjection other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LocalObjectReference, other.LocalObjectReference)) return false;
      if(!items_.Equals(other.items_)) return false;
      if (Optional != other.Optional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (localObjectReference_ != null) hash ^= LocalObjectReference.GetHashCode();
      hash ^= items_.GetHashCode();
      if (HasOptional) hash ^= Optional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (HasOptional) {
        output.WriteRawTag(32);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (HasOptional) {
        output.WriteRawTag(32);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (localObjectReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalObjectReference);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (HasOptional) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConfigMapProjection other) {
      if (other == null) {
        return;
      }
      if (other.localObjectReference_ != null) {
        if (localObjectReference_ == null) {
          LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        LocalObjectReference.MergeFrom(other.LocalObjectReference);
      }
      items_.Add(other.items_);
      if (other.HasOptional) {
        Optional = other.Optional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
          case 32: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
          case 32: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Adapts a ConfigMap into a volume.
  ///
  /// The contents of the target ConfigMap's Data field will be presented in a
  /// volume as files using the keys in the Data field as the file names, unless
  /// the items element is populated with specific mappings of keys to paths.
  /// ConfigMap volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class ConfigMapVolumeSource : pb::IMessage<ConfigMapVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ConfigMapVolumeSource> _parser = new pb::MessageParser<ConfigMapVolumeSource>(() => new ConfigMapVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ConfigMapVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapVolumeSource(ConfigMapVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      localObjectReference_ = other.localObjectReference_ != null ? other.localObjectReference_.Clone() : null;
      items_ = other.items_.Clone();
      defaultMode_ = other.defaultMode_;
      optional_ = other.optional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ConfigMapVolumeSource Clone() {
      return new ConfigMapVolumeSource(this);
    }

    /// <summary>Field number for the "localObjectReference" field.</summary>
    public const int LocalObjectReferenceFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference localObjectReference_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference LocalObjectReference {
      get { return localObjectReference_; }
      set {
        localObjectReference_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.KeyToPath> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.KeyToPath.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath>();
    /// <summary>
    /// If unspecified, each key-value pair in the Data field of the referenced
    /// ConfigMap will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the ConfigMap,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath> Items {
      get { return items_; }
    }

    /// <summary>Field number for the "defaultMode" field.</summary>
    public const int DefaultModeFieldNumber = 3;
    private readonly static int DefaultModeDefaultValue = 0;

    private int defaultMode_;
    /// <summary>
    /// Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int DefaultMode {
      get { if ((_hasBits0 & 1) != 0) { return defaultMode_; } else { return DefaultModeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        defaultMode_ = value;
      }
    }
    /// <summary>Gets whether the "defaultMode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDefaultMode {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "defaultMode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDefaultMode() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "optional" field.</summary>
    public const int OptionalFieldNumber = 4;
    private readonly static bool OptionalDefaultValue = false;

    private bool optional_;
    /// <summary>
    /// Specify whether the ConfigMap or its keys must be defined
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Optional {
      get { if ((_hasBits0 & 2) != 0) { return optional_; } else { return OptionalDefaultValue; } }
      set {
        _hasBits0 |= 2;
        optional_ = value;
      }
    }
    /// <summary>Gets whether the "optional" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOptional {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "optional" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOptional() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ConfigMapVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ConfigMapVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LocalObjectReference, other.LocalObjectReference)) return false;
      if(!items_.Equals(other.items_)) return false;
      if (DefaultMode != other.DefaultMode) return false;
      if (Optional != other.Optional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (localObjectReference_ != null) hash ^= LocalObjectReference.GetHashCode();
      hash ^= items_.GetHashCode();
      if (HasDefaultMode) hash ^= DefaultMode.GetHashCode();
      if (HasOptional) hash ^= Optional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (HasDefaultMode) {
        output.WriteRawTag(24);
        output.WriteInt32(DefaultMode);
      }
      if (HasOptional) {
        output.WriteRawTag(32);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (HasDefaultMode) {
        output.WriteRawTag(24);
        output.WriteInt32(DefaultMode);
      }
      if (HasOptional) {
        output.WriteRawTag(32);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (localObjectReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalObjectReference);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (HasDefaultMode) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DefaultMode);
      }
      if (HasOptional) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ConfigMapVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.localObjectReference_ != null) {
        if (localObjectReference_ == null) {
          LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        LocalObjectReference.MergeFrom(other.LocalObjectReference);
      }
      items_.Add(other.items_);
      if (other.HasDefaultMode) {
        DefaultMode = other.DefaultMode;
      }
      if (other.HasOptional) {
        Optional = other.Optional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
          case 24: {
            DefaultMode = input.ReadInt32();
            break;
          }
          case 32: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
          case 24: {
            DefaultMode = input.ReadInt32();
            break;
          }
          case 32: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A single application container that you want to run within a pod.
  /// </summary>
  public sealed partial class Container : pb::IMessage<Container>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Container> _parser = new pb::MessageParser<Container>(() => new Container());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Container> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[26]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Container() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Container(Container other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      image_ = other.image_;
      command_ = other.command_.Clone();
      args_ = other.args_.Clone();
      workingDir_ = other.workingDir_;
      ports_ = other.ports_.Clone();
      envFrom_ = other.envFrom_.Clone();
      env_ = other.env_.Clone();
      resources_ = other.resources_ != null ? other.resources_.Clone() : null;
      volumeMounts_ = other.volumeMounts_.Clone();
      volumeDevices_ = other.volumeDevices_.Clone();
      livenessProbe_ = other.livenessProbe_ != null ? other.livenessProbe_.Clone() : null;
      readinessProbe_ = other.readinessProbe_ != null ? other.readinessProbe_.Clone() : null;
      startupProbe_ = other.startupProbe_ != null ? other.startupProbe_.Clone() : null;
      lifecycle_ = other.lifecycle_ != null ? other.lifecycle_.Clone() : null;
      terminationMessagePath_ = other.terminationMessagePath_;
      terminationMessagePolicy_ = other.terminationMessagePolicy_;
      imagePullPolicy_ = other.imagePullPolicy_;
      securityContext_ = other.securityContext_ != null ? other.securityContext_.Clone() : null;
      stdin_ = other.stdin_;
      stdinOnce_ = other.stdinOnce_;
      tty_ = other.tty_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Container Clone() {
      return new Container(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name of the container specified as a DNS_LABEL.
    /// Each container in a pod must have a unique name (DNS_LABEL).
    /// Cannot be updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "image" field.</summary>
    public const int ImageFieldNumber = 2;
    private readonly static string ImageDefaultValue = "";

    private string image_;
    /// <summary>
    /// Docker image name.
    /// More info: https://kubernetes.io/docs/concepts/containers/images
    /// This field is optional to allow higher level config management to default or override
    /// container images in workload controllers like Deployments and StatefulSets.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Image {
      get { return image_ ?? ImageDefaultValue; }
      set {
        image_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "image" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImage {
      get { return image_ != null; }
    }
    /// <summary>Clears the value of the "image" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImage() {
      image_ = null;
    }

    /// <summary>Field number for the "command" field.</summary>
    public const int CommandFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_command_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> command_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Entrypoint array. Not executed within a shell.
    /// The docker image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Command {
      get { return command_; }
    }

    /// <summary>Field number for the "args" field.</summary>
    public const int ArgsFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_args_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> args_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Arguments to the entrypoint.
    /// The docker image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Args {
      get { return args_; }
    }

    /// <summary>Field number for the "workingDir" field.</summary>
    public const int WorkingDirFieldNumber = 5;
    private readonly static string WorkingDirDefaultValue = "";

    private string workingDir_;
    /// <summary>
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string WorkingDir {
      get { return workingDir_ ?? WorkingDirDefaultValue; }
      set {
        workingDir_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "workingDir" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWorkingDir {
      get { return workingDir_ != null; }
    }
    /// <summary>Clears the value of the "workingDir" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWorkingDir() {
      workingDir_ = null;
    }

    /// <summary>Field number for the "ports" field.</summary>
    public const int PortsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ContainerPort> _repeated_ports_codec
        = pb::FieldCodec.ForMessage(50, global::K8S.Io.Api.Core.V1.ContainerPort.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerPort> ports_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerPort>();
    /// <summary>
    /// List of ports to expose from the container. Exposing a port here gives
    /// the system additional information about the network connections a
    /// container uses, but is primarily informational. Not specifying a port here
    /// DOES NOT prevent that port from being exposed. Any port which is
    /// listening on the default "0.0.0.0" address inside a container will be
    /// accessible from the network.
    /// Cannot be updated.
    /// +optional
    /// +patchMergeKey=containerPort
    /// +patchStrategy=merge
    /// +listType=map
    /// +listMapKey=containerPort
    /// +listMapKey=protocol
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerPort> Ports {
      get { return ports_; }
    }

    /// <summary>Field number for the "envFrom" field.</summary>
    public const int EnvFromFieldNumber = 19;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.EnvFromSource> _repeated_envFrom_codec
        = pb::FieldCodec.ForMessage(154, global::K8S.Io.Api.Core.V1.EnvFromSource.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvFromSource> envFrom_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvFromSource>();
    /// <summary>
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvFromSource> EnvFrom {
      get { return envFrom_; }
    }

    /// <summary>Field number for the "env" field.</summary>
    public const int EnvFieldNumber = 7;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.EnvVar> _repeated_env_codec
        = pb::FieldCodec.ForMessage(58, global::K8S.Io.Api.Core.V1.EnvVar.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvVar> env_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvVar>();
    /// <summary>
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    /// +optional
    /// +patchMergeKey=name
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvVar> Env {
      get { return env_; }
    }

    /// <summary>Field number for the "resources" field.</summary>
    public const int ResourcesFieldNumber = 8;
    private global::K8S.Io.Api.Core.V1.ResourceRequirements resources_;
    /// <summary>
    /// Compute Resources required by this container.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ResourceRequirements Resources {
      get { return resources_; }
      set {
        resources_ = value;
      }
    }

    /// <summary>Field number for the "volumeMounts" field.</summary>
    public const int VolumeMountsFieldNumber = 9;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.VolumeMount> _repeated_volumeMounts_codec
        = pb::FieldCodec.ForMessage(74, global::K8S.Io.Api.Core.V1.VolumeMount.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeMount> volumeMounts_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeMount>();
    /// <summary>
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    /// +optional
    /// +patchMergeKey=mountPath
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeMount> VolumeMounts {
      get { return volumeMounts_; }
    }

    /// <summary>Field number for the "volumeDevices" field.</summary>
    public const int VolumeDevicesFieldNumber = 21;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.VolumeDevice> _repeated_volumeDevices_codec
        = pb::FieldCodec.ForMessage(170, global::K8S.Io.Api.Core.V1.VolumeDevice.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeDevice> volumeDevices_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeDevice>();
    /// <summary>
    /// volumeDevices is the list of block devices to be used by the container.
    /// +patchMergeKey=devicePath
    /// +patchStrategy=merge
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeDevice> VolumeDevices {
      get { return volumeDevices_; }
    }

    /// <summary>Field number for the "livenessProbe" field.</summary>
    public const int LivenessProbeFieldNumber = 10;
    private global::K8S.Io.Api.Core.V1.Probe livenessProbe_;
    /// <summary>
    /// Periodic probe of container liveness.
    /// Container will be restarted if the probe fails.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Probe LivenessProbe {
      get { return livenessProbe_; }
      set {
        livenessProbe_ = value;
      }
    }

    /// <summary>Field number for the "readinessProbe" field.</summary>
    public const int ReadinessProbeFieldNumber = 11;
    private global::K8S.Io.Api.Core.V1.Probe readinessProbe_;
    /// <summary>
    /// Periodic probe of container service readiness.
    /// Container will be removed from service endpoints if the probe fails.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Probe ReadinessProbe {
      get { return readinessProbe_; }
      set {
        readinessProbe_ = value;
      }
    }

    /// <summary>Field number for the "startupProbe" field.</summary>
    public const int StartupProbeFieldNumber = 22;
    private global::K8S.Io.Api.Core.V1.Probe startupProbe_;
    /// <summary>
    /// StartupProbe indicates that the Pod has successfully initialized.
    /// If specified, no other probes are executed until this completes successfully.
    /// If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    /// This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    /// when it might take a long time to load data or warm a cache, than during steady-state operation.
    /// This cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Probe StartupProbe {
      get { return startupProbe_; }
      set {
        startupProbe_ = value;
      }
    }

    /// <summary>Field number for the "lifecycle" field.</summary>
    public const int LifecycleFieldNumber = 12;
    private global::K8S.Io.Api.Core.V1.Lifecycle lifecycle_;
    /// <summary>
    /// Actions that the management system should take in response to container lifecycle events.
    /// Cannot be updated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Lifecycle Lifecycle {
      get { return lifecycle_; }
      set {
        lifecycle_ = value;
      }
    }

    /// <summary>Field number for the "terminationMessagePath" field.</summary>
    public const int TerminationMessagePathFieldNumber = 13;
    private readonly static string TerminationMessagePathDefaultValue = "";

    private string terminationMessagePath_;
    /// <summary>
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TerminationMessagePath {
      get { return terminationMessagePath_ ?? TerminationMessagePathDefaultValue; }
      set {
        terminationMessagePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "terminationMessagePath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTerminationMessagePath {
      get { return terminationMessagePath_ != null; }
    }
    /// <summary>Clears the value of the "terminationMessagePath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTerminationMessagePath() {
      terminationMessagePath_ = null;
    }

    /// <summary>Field number for the "terminationMessagePolicy" field.</summary>
    public const int TerminationMessagePolicyFieldNumber = 20;
    private readonly static string TerminationMessagePolicyDefaultValue = "";

    private string terminationMessagePolicy_;
    /// <summary>
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TerminationMessagePolicy {
      get { return terminationMessagePolicy_ ?? TerminationMessagePolicyDefaultValue; }
      set {
        terminationMessagePolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "terminationMessagePolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTerminationMessagePolicy {
      get { return terminationMessagePolicy_ != null; }
    }
    /// <summary>Clears the value of the "terminationMessagePolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTerminationMessagePolicy() {
      terminationMessagePolicy_ = null;
    }

    /// <summary>Field number for the "imagePullPolicy" field.</summary>
    public const int ImagePullPolicyFieldNumber = 14;
    private readonly static string ImagePullPolicyDefaultValue = "";

    private string imagePullPolicy_;
    /// <summary>
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ImagePullPolicy {
      get { return imagePullPolicy_ ?? ImagePullPolicyDefaultValue; }
      set {
        imagePullPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "imagePullPolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImagePullPolicy {
      get { return imagePullPolicy_ != null; }
    }
    /// <summary>Clears the value of the "imagePullPolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImagePullPolicy() {
      imagePullPolicy_ = null;
    }

    /// <summary>Field number for the "securityContext" field.</summary>
    public const int SecurityContextFieldNumber = 15;
    private global::K8S.Io.Api.Core.V1.SecurityContext securityContext_;
    /// <summary>
    /// SecurityContext defines the security options the container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecurityContext SecurityContext {
      get { return securityContext_; }
      set {
        securityContext_ = value;
      }
    }

    /// <summary>Field number for the "stdin" field.</summary>
    public const int StdinFieldNumber = 16;
    private readonly static bool StdinDefaultValue = false;

    private bool stdin_;
    /// <summary>
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Stdin {
      get { if ((_hasBits0 & 1) != 0) { return stdin_; } else { return StdinDefaultValue; } }
      set {
        _hasBits0 |= 1;
        stdin_ = value;
      }
    }
    /// <summary>Gets whether the "stdin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStdin {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "stdin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStdin() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "stdinOnce" field.</summary>
    public const int StdinOnceFieldNumber = 17;
    private readonly static bool StdinOnceDefaultValue = false;

    private bool stdinOnce_;
    /// <summary>
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool StdinOnce {
      get { if ((_hasBits0 & 2) != 0) { return stdinOnce_; } else { return StdinOnceDefaultValue; } }
      set {
        _hasBits0 |= 2;
        stdinOnce_ = value;
      }
    }
    /// <summary>Gets whether the "stdinOnce" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStdinOnce {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "stdinOnce" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStdinOnce() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "tty" field.</summary>
    public const int TtyFieldNumber = 18;
    private readonly static bool TtyDefaultValue = false;

    private bool tty_;
    /// <summary>
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Tty {
      get { if ((_hasBits0 & 4) != 0) { return tty_; } else { return TtyDefaultValue; } }
      set {
        _hasBits0 |= 4;
        tty_ = value;
      }
    }
    /// <summary>Gets whether the "tty" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTty {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "tty" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTty() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Container);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Container other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Image != other.Image) return false;
      if(!command_.Equals(other.command_)) return false;
      if(!args_.Equals(other.args_)) return false;
      if (WorkingDir != other.WorkingDir) return false;
      if(!ports_.Equals(other.ports_)) return false;
      if(!envFrom_.Equals(other.envFrom_)) return false;
      if(!env_.Equals(other.env_)) return false;
      if (!object.Equals(Resources, other.Resources)) return false;
      if(!volumeMounts_.Equals(other.volumeMounts_)) return false;
      if(!volumeDevices_.Equals(other.volumeDevices_)) return false;
      if (!object.Equals(LivenessProbe, other.LivenessProbe)) return false;
      if (!object.Equals(ReadinessProbe, other.ReadinessProbe)) return false;
      if (!object.Equals(StartupProbe, other.StartupProbe)) return false;
      if (!object.Equals(Lifecycle, other.Lifecycle)) return false;
      if (TerminationMessagePath != other.TerminationMessagePath) return false;
      if (TerminationMessagePolicy != other.TerminationMessagePolicy) return false;
      if (ImagePullPolicy != other.ImagePullPolicy) return false;
      if (!object.Equals(SecurityContext, other.SecurityContext)) return false;
      if (Stdin != other.Stdin) return false;
      if (StdinOnce != other.StdinOnce) return false;
      if (Tty != other.Tty) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasImage) hash ^= Image.GetHashCode();
      hash ^= command_.GetHashCode();
      hash ^= args_.GetHashCode();
      if (HasWorkingDir) hash ^= WorkingDir.GetHashCode();
      hash ^= ports_.GetHashCode();
      hash ^= envFrom_.GetHashCode();
      hash ^= env_.GetHashCode();
      if (resources_ != null) hash ^= Resources.GetHashCode();
      hash ^= volumeMounts_.GetHashCode();
      hash ^= volumeDevices_.GetHashCode();
      if (livenessProbe_ != null) hash ^= LivenessProbe.GetHashCode();
      if (readinessProbe_ != null) hash ^= ReadinessProbe.GetHashCode();
      if (startupProbe_ != null) hash ^= StartupProbe.GetHashCode();
      if (lifecycle_ != null) hash ^= Lifecycle.GetHashCode();
      if (HasTerminationMessagePath) hash ^= TerminationMessagePath.GetHashCode();
      if (HasTerminationMessagePolicy) hash ^= TerminationMessagePolicy.GetHashCode();
      if (HasImagePullPolicy) hash ^= ImagePullPolicy.GetHashCode();
      if (securityContext_ != null) hash ^= SecurityContext.GetHashCode();
      if (HasStdin) hash ^= Stdin.GetHashCode();
      if (HasStdinOnce) hash ^= StdinOnce.GetHashCode();
      if (HasTty) hash ^= Tty.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasImage) {
        output.WriteRawTag(18);
        output.WriteString(Image);
      }
      command_.WriteTo(output, _repeated_command_codec);
      args_.WriteTo(output, _repeated_args_codec);
      if (HasWorkingDir) {
        output.WriteRawTag(42);
        output.WriteString(WorkingDir);
      }
      ports_.WriteTo(output, _repeated_ports_codec);
      env_.WriteTo(output, _repeated_env_codec);
      if (resources_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Resources);
      }
      volumeMounts_.WriteTo(output, _repeated_volumeMounts_codec);
      if (livenessProbe_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(LivenessProbe);
      }
      if (readinessProbe_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(ReadinessProbe);
      }
      if (lifecycle_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Lifecycle);
      }
      if (HasTerminationMessagePath) {
        output.WriteRawTag(106);
        output.WriteString(TerminationMessagePath);
      }
      if (HasImagePullPolicy) {
        output.WriteRawTag(114);
        output.WriteString(ImagePullPolicy);
      }
      if (securityContext_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(SecurityContext);
      }
      if (HasStdin) {
        output.WriteRawTag(128, 1);
        output.WriteBool(Stdin);
      }
      if (HasStdinOnce) {
        output.WriteRawTag(136, 1);
        output.WriteBool(StdinOnce);
      }
      if (HasTty) {
        output.WriteRawTag(144, 1);
        output.WriteBool(Tty);
      }
      envFrom_.WriteTo(output, _repeated_envFrom_codec);
      if (HasTerminationMessagePolicy) {
        output.WriteRawTag(162, 1);
        output.WriteString(TerminationMessagePolicy);
      }
      volumeDevices_.WriteTo(output, _repeated_volumeDevices_codec);
      if (startupProbe_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(StartupProbe);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasImage) {
        output.WriteRawTag(18);
        output.WriteString(Image);
      }
      command_.WriteTo(ref output, _repeated_command_codec);
      args_.WriteTo(ref output, _repeated_args_codec);
      if (HasWorkingDir) {
        output.WriteRawTag(42);
        output.WriteString(WorkingDir);
      }
      ports_.WriteTo(ref output, _repeated_ports_codec);
      env_.WriteTo(ref output, _repeated_env_codec);
      if (resources_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Resources);
      }
      volumeMounts_.WriteTo(ref output, _repeated_volumeMounts_codec);
      if (livenessProbe_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(LivenessProbe);
      }
      if (readinessProbe_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(ReadinessProbe);
      }
      if (lifecycle_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Lifecycle);
      }
      if (HasTerminationMessagePath) {
        output.WriteRawTag(106);
        output.WriteString(TerminationMessagePath);
      }
      if (HasImagePullPolicy) {
        output.WriteRawTag(114);
        output.WriteString(ImagePullPolicy);
      }
      if (securityContext_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(SecurityContext);
      }
      if (HasStdin) {
        output.WriteRawTag(128, 1);
        output.WriteBool(Stdin);
      }
      if (HasStdinOnce) {
        output.WriteRawTag(136, 1);
        output.WriteBool(StdinOnce);
      }
      if (HasTty) {
        output.WriteRawTag(144, 1);
        output.WriteBool(Tty);
      }
      envFrom_.WriteTo(ref output, _repeated_envFrom_codec);
      if (HasTerminationMessagePolicy) {
        output.WriteRawTag(162, 1);
        output.WriteString(TerminationMessagePolicy);
      }
      volumeDevices_.WriteTo(ref output, _repeated_volumeDevices_codec);
      if (startupProbe_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(StartupProbe);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasImage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Image);
      }
      size += command_.CalculateSize(_repeated_command_codec);
      size += args_.CalculateSize(_repeated_args_codec);
      if (HasWorkingDir) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WorkingDir);
      }
      size += ports_.CalculateSize(_repeated_ports_codec);
      size += envFrom_.CalculateSize(_repeated_envFrom_codec);
      size += env_.CalculateSize(_repeated_env_codec);
      if (resources_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Resources);
      }
      size += volumeMounts_.CalculateSize(_repeated_volumeMounts_codec);
      size += volumeDevices_.CalculateSize(_repeated_volumeDevices_codec);
      if (livenessProbe_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LivenessProbe);
      }
      if (readinessProbe_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReadinessProbe);
      }
      if (startupProbe_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartupProbe);
      }
      if (lifecycle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lifecycle);
      }
      if (HasTerminationMessagePath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TerminationMessagePath);
      }
      if (HasTerminationMessagePolicy) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(TerminationMessagePolicy);
      }
      if (HasImagePullPolicy) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ImagePullPolicy);
      }
      if (securityContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecurityContext);
      }
      if (HasStdin) {
        size += 2 + 1;
      }
      if (HasStdinOnce) {
        size += 2 + 1;
      }
      if (HasTty) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Container other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasImage) {
        Image = other.Image;
      }
      command_.Add(other.command_);
      args_.Add(other.args_);
      if (other.HasWorkingDir) {
        WorkingDir = other.WorkingDir;
      }
      ports_.Add(other.ports_);
      envFrom_.Add(other.envFrom_);
      env_.Add(other.env_);
      if (other.resources_ != null) {
        if (resources_ == null) {
          Resources = new global::K8S.Io.Api.Core.V1.ResourceRequirements();
        }
        Resources.MergeFrom(other.Resources);
      }
      volumeMounts_.Add(other.volumeMounts_);
      volumeDevices_.Add(other.volumeDevices_);
      if (other.livenessProbe_ != null) {
        if (livenessProbe_ == null) {
          LivenessProbe = new global::K8S.Io.Api.Core.V1.Probe();
        }
        LivenessProbe.MergeFrom(other.LivenessProbe);
      }
      if (other.readinessProbe_ != null) {
        if (readinessProbe_ == null) {
          ReadinessProbe = new global::K8S.Io.Api.Core.V1.Probe();
        }
        ReadinessProbe.MergeFrom(other.ReadinessProbe);
      }
      if (other.startupProbe_ != null) {
        if (startupProbe_ == null) {
          StartupProbe = new global::K8S.Io.Api.Core.V1.Probe();
        }
        StartupProbe.MergeFrom(other.StartupProbe);
      }
      if (other.lifecycle_ != null) {
        if (lifecycle_ == null) {
          Lifecycle = new global::K8S.Io.Api.Core.V1.Lifecycle();
        }
        Lifecycle.MergeFrom(other.Lifecycle);
      }
      if (other.HasTerminationMessagePath) {
        TerminationMessagePath = other.TerminationMessagePath;
      }
      if (other.HasTerminationMessagePolicy) {
        TerminationMessagePolicy = other.TerminationMessagePolicy;
      }
      if (other.HasImagePullPolicy) {
        ImagePullPolicy = other.ImagePullPolicy;
      }
      if (other.securityContext_ != null) {
        if (securityContext_ == null) {
          SecurityContext = new global::K8S.Io.Api.Core.V1.SecurityContext();
        }
        SecurityContext.MergeFrom(other.SecurityContext);
      }
      if (other.HasStdin) {
        Stdin = other.Stdin;
      }
      if (other.HasStdinOnce) {
        StdinOnce = other.StdinOnce;
      }
      if (other.HasTty) {
        Tty = other.Tty;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Image = input.ReadString();
            break;
          }
          case 26: {
            command_.AddEntriesFrom(input, _repeated_command_codec);
            break;
          }
          case 34: {
            args_.AddEntriesFrom(input, _repeated_args_codec);
            break;
          }
          case 42: {
            WorkingDir = input.ReadString();
            break;
          }
          case 50: {
            ports_.AddEntriesFrom(input, _repeated_ports_codec);
            break;
          }
          case 58: {
            env_.AddEntriesFrom(input, _repeated_env_codec);
            break;
          }
          case 66: {
            if (resources_ == null) {
              Resources = new global::K8S.Io.Api.Core.V1.ResourceRequirements();
            }
            input.ReadMessage(Resources);
            break;
          }
          case 74: {
            volumeMounts_.AddEntriesFrom(input, _repeated_volumeMounts_codec);
            break;
          }
          case 82: {
            if (livenessProbe_ == null) {
              LivenessProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(LivenessProbe);
            break;
          }
          case 90: {
            if (readinessProbe_ == null) {
              ReadinessProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(ReadinessProbe);
            break;
          }
          case 98: {
            if (lifecycle_ == null) {
              Lifecycle = new global::K8S.Io.Api.Core.V1.Lifecycle();
            }
            input.ReadMessage(Lifecycle);
            break;
          }
          case 106: {
            TerminationMessagePath = input.ReadString();
            break;
          }
          case 114: {
            ImagePullPolicy = input.ReadString();
            break;
          }
          case 122: {
            if (securityContext_ == null) {
              SecurityContext = new global::K8S.Io.Api.Core.V1.SecurityContext();
            }
            input.ReadMessage(SecurityContext);
            break;
          }
          case 128: {
            Stdin = input.ReadBool();
            break;
          }
          case 136: {
            StdinOnce = input.ReadBool();
            break;
          }
          case 144: {
            Tty = input.ReadBool();
            break;
          }
          case 154: {
            envFrom_.AddEntriesFrom(input, _repeated_envFrom_codec);
            break;
          }
          case 162: {
            TerminationMessagePolicy = input.ReadString();
            break;
          }
          case 170: {
            volumeDevices_.AddEntriesFrom(input, _repeated_volumeDevices_codec);
            break;
          }
          case 178: {
            if (startupProbe_ == null) {
              StartupProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(StartupProbe);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Image = input.ReadString();
            break;
          }
          case 26: {
            command_.AddEntriesFrom(ref input, _repeated_command_codec);
            break;
          }
          case 34: {
            args_.AddEntriesFrom(ref input, _repeated_args_codec);
            break;
          }
          case 42: {
            WorkingDir = input.ReadString();
            break;
          }
          case 50: {
            ports_.AddEntriesFrom(ref input, _repeated_ports_codec);
            break;
          }
          case 58: {
            env_.AddEntriesFrom(ref input, _repeated_env_codec);
            break;
          }
          case 66: {
            if (resources_ == null) {
              Resources = new global::K8S.Io.Api.Core.V1.ResourceRequirements();
            }
            input.ReadMessage(Resources);
            break;
          }
          case 74: {
            volumeMounts_.AddEntriesFrom(ref input, _repeated_volumeMounts_codec);
            break;
          }
          case 82: {
            if (livenessProbe_ == null) {
              LivenessProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(LivenessProbe);
            break;
          }
          case 90: {
            if (readinessProbe_ == null) {
              ReadinessProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(ReadinessProbe);
            break;
          }
          case 98: {
            if (lifecycle_ == null) {
              Lifecycle = new global::K8S.Io.Api.Core.V1.Lifecycle();
            }
            input.ReadMessage(Lifecycle);
            break;
          }
          case 106: {
            TerminationMessagePath = input.ReadString();
            break;
          }
          case 114: {
            ImagePullPolicy = input.ReadString();
            break;
          }
          case 122: {
            if (securityContext_ == null) {
              SecurityContext = new global::K8S.Io.Api.Core.V1.SecurityContext();
            }
            input.ReadMessage(SecurityContext);
            break;
          }
          case 128: {
            Stdin = input.ReadBool();
            break;
          }
          case 136: {
            StdinOnce = input.ReadBool();
            break;
          }
          case 144: {
            Tty = input.ReadBool();
            break;
          }
          case 154: {
            envFrom_.AddEntriesFrom(ref input, _repeated_envFrom_codec);
            break;
          }
          case 162: {
            TerminationMessagePolicy = input.ReadString();
            break;
          }
          case 170: {
            volumeDevices_.AddEntriesFrom(ref input, _repeated_volumeDevices_codec);
            break;
          }
          case 178: {
            if (startupProbe_ == null) {
              StartupProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(StartupProbe);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describe a container image
  /// </summary>
  public sealed partial class ContainerImage : pb::IMessage<ContainerImage>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContainerImage> _parser = new pb::MessageParser<ContainerImage>(() => new ContainerImage());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ContainerImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[27]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerImage(ContainerImage other) : this() {
      _hasBits0 = other._hasBits0;
      names_ = other.names_.Clone();
      sizeBytes_ = other.sizeBytes_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerImage Clone() {
      return new ContainerImage(this);
    }

    /// <summary>Field number for the "names" field.</summary>
    public const int NamesFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_names_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> names_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Names by which this image is known.
    /// e.g. ["k8s.gcr.io/hyperkube:v1.0.7", "dockerhub.io/google_containers/hyperkube:v1.0.7"]
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Names {
      get { return names_; }
    }

    /// <summary>Field number for the "sizeBytes" field.</summary>
    public const int SizeBytesFieldNumber = 2;
    private readonly static long SizeBytesDefaultValue = 0L;

    private long sizeBytes_;
    /// <summary>
    /// The size of the image in bytes.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long SizeBytes {
      get { if ((_hasBits0 & 1) != 0) { return sizeBytes_; } else { return SizeBytesDefaultValue; } }
      set {
        _hasBits0 |= 1;
        sizeBytes_ = value;
      }
    }
    /// <summary>Gets whether the "sizeBytes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSizeBytes {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "sizeBytes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSizeBytes() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ContainerImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ContainerImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!names_.Equals(other.names_)) return false;
      if (SizeBytes != other.SizeBytes) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= names_.GetHashCode();
      if (HasSizeBytes) hash ^= SizeBytes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      names_.WriteTo(output, _repeated_names_codec);
      if (HasSizeBytes) {
        output.WriteRawTag(16);
        output.WriteInt64(SizeBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      names_.WriteTo(ref output, _repeated_names_codec);
      if (HasSizeBytes) {
        output.WriteRawTag(16);
        output.WriteInt64(SizeBytes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += names_.CalculateSize(_repeated_names_codec);
      if (HasSizeBytes) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(SizeBytes);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ContainerImage other) {
      if (other == null) {
        return;
      }
      names_.Add(other.names_);
      if (other.HasSizeBytes) {
        SizeBytes = other.SizeBytes;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            names_.AddEntriesFrom(input, _repeated_names_codec);
            break;
          }
          case 16: {
            SizeBytes = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            names_.AddEntriesFrom(ref input, _repeated_names_codec);
            break;
          }
          case 16: {
            SizeBytes = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ContainerPort represents a network port in a single container.
  /// </summary>
  public sealed partial class ContainerPort : pb::IMessage<ContainerPort>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContainerPort> _parser = new pb::MessageParser<ContainerPort>(() => new ContainerPort());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ContainerPort> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[28]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerPort() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerPort(ContainerPort other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      hostPort_ = other.hostPort_;
      containerPort_ = other.containerPort_;
      protocol_ = other.protocol_;
      hostIP_ = other.hostIP_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerPort Clone() {
      return new ContainerPort(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    /// named port in a pod must have a unique name. Name for the port that can be
    /// referred to by services.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "hostPort" field.</summary>
    public const int HostPortFieldNumber = 2;
    private readonly static int HostPortDefaultValue = 0;

    private int hostPort_;
    /// <summary>
    /// Number of port to expose on the host.
    /// If specified, this must be a valid port number, 0 &lt; x &lt; 65536.
    /// If HostNetwork is specified, this must match ContainerPort.
    /// Most containers do not need this.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int HostPort {
      get { if ((_hasBits0 & 1) != 0) { return hostPort_; } else { return HostPortDefaultValue; } }
      set {
        _hasBits0 |= 1;
        hostPort_ = value;
      }
    }
    /// <summary>Gets whether the "hostPort" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostPort {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "hostPort" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostPort() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "containerPort" field.</summary>
    public const int ContainerPort_FieldNumber = 3;
    private readonly static int ContainerPort_DefaultValue = 0;

    private int containerPort_;
    /// <summary>
    /// Number of port to expose on the pod's IP address.
    /// This must be a valid port number, 0 &lt; x &lt; 65536.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ContainerPort_ {
      get { if ((_hasBits0 & 2) != 0) { return containerPort_; } else { return ContainerPort_DefaultValue; } }
      set {
        _hasBits0 |= 2;
        containerPort_ = value;
      }
    }
    /// <summary>Gets whether the "containerPort" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContainerPort_ {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "containerPort" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContainerPort_() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 4;
    private readonly static string ProtocolDefaultValue = "";

    private string protocol_;
    /// <summary>
    /// Protocol for port. Must be UDP, TCP, or SCTP.
    /// Defaults to "TCP".
    /// +optional
    /// +default="TCP"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Protocol {
      get { return protocol_ ?? ProtocolDefaultValue; }
      set {
        protocol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "protocol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProtocol {
      get { return protocol_ != null; }
    }
    /// <summary>Clears the value of the "protocol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProtocol() {
      protocol_ = null;
    }

    /// <summary>Field number for the "hostIP" field.</summary>
    public const int HostIPFieldNumber = 5;
    private readonly static string HostIPDefaultValue = "";

    private string hostIP_;
    /// <summary>
    /// What host IP to bind the external port to.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string HostIP {
      get { return hostIP_ ?? HostIPDefaultValue; }
      set {
        hostIP_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hostIP" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostIP {
      get { return hostIP_ != null; }
    }
    /// <summary>Clears the value of the "hostIP" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostIP() {
      hostIP_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ContainerPort);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ContainerPort other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (HostPort != other.HostPort) return false;
      if (ContainerPort_ != other.ContainerPort_) return false;
      if (Protocol != other.Protocol) return false;
      if (HostIP != other.HostIP) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasHostPort) hash ^= HostPort.GetHashCode();
      if (HasContainerPort_) hash ^= ContainerPort_.GetHashCode();
      if (HasProtocol) hash ^= Protocol.GetHashCode();
      if (HasHostIP) hash ^= HostIP.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasHostPort) {
        output.WriteRawTag(16);
        output.WriteInt32(HostPort);
      }
      if (HasContainerPort_) {
        output.WriteRawTag(24);
        output.WriteInt32(ContainerPort_);
      }
      if (HasProtocol) {
        output.WriteRawTag(34);
        output.WriteString(Protocol);
      }
      if (HasHostIP) {
        output.WriteRawTag(42);
        output.WriteString(HostIP);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasHostPort) {
        output.WriteRawTag(16);
        output.WriteInt32(HostPort);
      }
      if (HasContainerPort_) {
        output.WriteRawTag(24);
        output.WriteInt32(ContainerPort_);
      }
      if (HasProtocol) {
        output.WriteRawTag(34);
        output.WriteString(Protocol);
      }
      if (HasHostIP) {
        output.WriteRawTag(42);
        output.WriteString(HostIP);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasHostPort) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(HostPort);
      }
      if (HasContainerPort_) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ContainerPort_);
      }
      if (HasProtocol) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Protocol);
      }
      if (HasHostIP) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HostIP);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ContainerPort other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasHostPort) {
        HostPort = other.HostPort;
      }
      if (other.HasContainerPort_) {
        ContainerPort_ = other.ContainerPort_;
      }
      if (other.HasProtocol) {
        Protocol = other.Protocol;
      }
      if (other.HasHostIP) {
        HostIP = other.HostIP;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            HostPort = input.ReadInt32();
            break;
          }
          case 24: {
            ContainerPort_ = input.ReadInt32();
            break;
          }
          case 34: {
            Protocol = input.ReadString();
            break;
          }
          case 42: {
            HostIP = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            HostPort = input.ReadInt32();
            break;
          }
          case 24: {
            ContainerPort_ = input.ReadInt32();
            break;
          }
          case 34: {
            Protocol = input.ReadString();
            break;
          }
          case 42: {
            HostIP = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ContainerState holds a possible state of container.
  /// Only one of its members may be specified.
  /// If none of them is specified, the default one is ContainerStateWaiting.
  /// </summary>
  public sealed partial class ContainerState : pb::IMessage<ContainerState>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContainerState> _parser = new pb::MessageParser<ContainerState>(() => new ContainerState());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ContainerState> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[29]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerState() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerState(ContainerState other) : this() {
      waiting_ = other.waiting_ != null ? other.waiting_.Clone() : null;
      running_ = other.running_ != null ? other.running_.Clone() : null;
      terminated_ = other.terminated_ != null ? other.terminated_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerState Clone() {
      return new ContainerState(this);
    }

    /// <summary>Field number for the "waiting" field.</summary>
    public const int WaitingFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.ContainerStateWaiting waiting_;
    /// <summary>
    /// Details about a waiting container
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ContainerStateWaiting Waiting {
      get { return waiting_; }
      set {
        waiting_ = value;
      }
    }

    /// <summary>Field number for the "running" field.</summary>
    public const int RunningFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ContainerStateRunning running_;
    /// <summary>
    /// Details about a running container
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ContainerStateRunning Running {
      get { return running_; }
      set {
        running_ = value;
      }
    }

    /// <summary>Field number for the "terminated" field.</summary>
    public const int TerminatedFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.ContainerStateTerminated terminated_;
    /// <summary>
    /// Details about a terminated container
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ContainerStateTerminated Terminated {
      get { return terminated_; }
      set {
        terminated_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ContainerState);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ContainerState other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Waiting, other.Waiting)) return false;
      if (!object.Equals(Running, other.Running)) return false;
      if (!object.Equals(Terminated, other.Terminated)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (waiting_ != null) hash ^= Waiting.GetHashCode();
      if (running_ != null) hash ^= Running.GetHashCode();
      if (terminated_ != null) hash ^= Terminated.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (waiting_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Waiting);
      }
      if (running_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Running);
      }
      if (terminated_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Terminated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (waiting_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Waiting);
      }
      if (running_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Running);
      }
      if (terminated_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Terminated);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (waiting_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Waiting);
      }
      if (running_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Running);
      }
      if (terminated_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Terminated);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ContainerState other) {
      if (other == null) {
        return;
      }
      if (other.waiting_ != null) {
        if (waiting_ == null) {
          Waiting = new global::K8S.Io.Api.Core.V1.ContainerStateWaiting();
        }
        Waiting.MergeFrom(other.Waiting);
      }
      if (other.running_ != null) {
        if (running_ == null) {
          Running = new global::K8S.Io.Api.Core.V1.ContainerStateRunning();
        }
        Running.MergeFrom(other.Running);
      }
      if (other.terminated_ != null) {
        if (terminated_ == null) {
          Terminated = new global::K8S.Io.Api.Core.V1.ContainerStateTerminated();
        }
        Terminated.MergeFrom(other.Terminated);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (waiting_ == null) {
              Waiting = new global::K8S.Io.Api.Core.V1.ContainerStateWaiting();
            }
            input.ReadMessage(Waiting);
            break;
          }
          case 18: {
            if (running_ == null) {
              Running = new global::K8S.Io.Api.Core.V1.ContainerStateRunning();
            }
            input.ReadMessage(Running);
            break;
          }
          case 26: {
            if (terminated_ == null) {
              Terminated = new global::K8S.Io.Api.Core.V1.ContainerStateTerminated();
            }
            input.ReadMessage(Terminated);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (waiting_ == null) {
              Waiting = new global::K8S.Io.Api.Core.V1.ContainerStateWaiting();
            }
            input.ReadMessage(Waiting);
            break;
          }
          case 18: {
            if (running_ == null) {
              Running = new global::K8S.Io.Api.Core.V1.ContainerStateRunning();
            }
            input.ReadMessage(Running);
            break;
          }
          case 26: {
            if (terminated_ == null) {
              Terminated = new global::K8S.Io.Api.Core.V1.ContainerStateTerminated();
            }
            input.ReadMessage(Terminated);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ContainerStateRunning is a running state of a container.
  /// </summary>
  public sealed partial class ContainerStateRunning : pb::IMessage<ContainerStateRunning>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContainerStateRunning> _parser = new pb::MessageParser<ContainerStateRunning>(() => new ContainerStateRunning());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ContainerStateRunning> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[30]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStateRunning() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStateRunning(ContainerStateRunning other) : this() {
      startedAt_ = other.startedAt_ != null ? other.startedAt_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStateRunning Clone() {
      return new ContainerStateRunning(this);
    }

    /// <summary>Field number for the "startedAt" field.</summary>
    public const int StartedAtFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time startedAt_;
    /// <summary>
    /// Time at which the container was last (re-)started
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time StartedAt {
      get { return startedAt_; }
      set {
        startedAt_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ContainerStateRunning);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ContainerStateRunning other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(StartedAt, other.StartedAt)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (startedAt_ != null) hash ^= StartedAt.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (startedAt_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StartedAt);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (startedAt_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(StartedAt);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (startedAt_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartedAt);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ContainerStateRunning other) {
      if (other == null) {
        return;
      }
      if (other.startedAt_ != null) {
        if (startedAt_ == null) {
          StartedAt = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        StartedAt.MergeFrom(other.StartedAt);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (startedAt_ == null) {
              StartedAt = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(StartedAt);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (startedAt_ == null) {
              StartedAt = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(StartedAt);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ContainerStateTerminated is a terminated state of a container.
  /// </summary>
  public sealed partial class ContainerStateTerminated : pb::IMessage<ContainerStateTerminated>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContainerStateTerminated> _parser = new pb::MessageParser<ContainerStateTerminated>(() => new ContainerStateTerminated());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ContainerStateTerminated> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[31]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStateTerminated() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStateTerminated(ContainerStateTerminated other) : this() {
      _hasBits0 = other._hasBits0;
      exitCode_ = other.exitCode_;
      signal_ = other.signal_;
      reason_ = other.reason_;
      message_ = other.message_;
      startedAt_ = other.startedAt_ != null ? other.startedAt_.Clone() : null;
      finishedAt_ = other.finishedAt_ != null ? other.finishedAt_.Clone() : null;
      containerID_ = other.containerID_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStateTerminated Clone() {
      return new ContainerStateTerminated(this);
    }

    /// <summary>Field number for the "exitCode" field.</summary>
    public const int ExitCodeFieldNumber = 1;
    private readonly static int ExitCodeDefaultValue = 0;

    private int exitCode_;
    /// <summary>
    /// Exit status from the last termination of the container
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ExitCode {
      get { if ((_hasBits0 & 1) != 0) { return exitCode_; } else { return ExitCodeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        exitCode_ = value;
      }
    }
    /// <summary>Gets whether the "exitCode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExitCode {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "exitCode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExitCode() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "signal" field.</summary>
    public const int SignalFieldNumber = 2;
    private readonly static int SignalDefaultValue = 0;

    private int signal_;
    /// <summary>
    /// Signal from the last termination of the container
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Signal {
      get { if ((_hasBits0 & 2) != 0) { return signal_; } else { return SignalDefaultValue; } }
      set {
        _hasBits0 |= 2;
        signal_ = value;
      }
    }
    /// <summary>Gets whether the "signal" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSignal {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "signal" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSignal() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 3;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// (brief) reason from the last termination of the container
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 4;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// Message regarding the last termination of the container
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "startedAt" field.</summary>
    public const int StartedAtFieldNumber = 5;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time startedAt_;
    /// <summary>
    /// Time at which previous execution of the container started
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time StartedAt {
      get { return startedAt_; }
      set {
        startedAt_ = value;
      }
    }

    /// <summary>Field number for the "finishedAt" field.</summary>
    public const int FinishedAtFieldNumber = 6;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time finishedAt_;
    /// <summary>
    /// Time at which the container last terminated
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time FinishedAt {
      get { return finishedAt_; }
      set {
        finishedAt_ = value;
      }
    }

    /// <summary>Field number for the "containerID" field.</summary>
    public const int ContainerIDFieldNumber = 7;
    private readonly static string ContainerIDDefaultValue = "";

    private string containerID_;
    /// <summary>
    /// Container's ID in the format 'docker://&lt;container_id>'
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ContainerID {
      get { return containerID_ ?? ContainerIDDefaultValue; }
      set {
        containerID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "containerID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContainerID {
      get { return containerID_ != null; }
    }
    /// <summary>Clears the value of the "containerID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContainerID() {
      containerID_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ContainerStateTerminated);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ContainerStateTerminated other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ExitCode != other.ExitCode) return false;
      if (Signal != other.Signal) return false;
      if (Reason != other.Reason) return false;
      if (Message != other.Message) return false;
      if (!object.Equals(StartedAt, other.StartedAt)) return false;
      if (!object.Equals(FinishedAt, other.FinishedAt)) return false;
      if (ContainerID != other.ContainerID) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasExitCode) hash ^= ExitCode.GetHashCode();
      if (HasSignal) hash ^= Signal.GetHashCode();
      if (HasReason) hash ^= Reason.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (startedAt_ != null) hash ^= StartedAt.GetHashCode();
      if (finishedAt_ != null) hash ^= FinishedAt.GetHashCode();
      if (HasContainerID) hash ^= ContainerID.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasExitCode) {
        output.WriteRawTag(8);
        output.WriteInt32(ExitCode);
      }
      if (HasSignal) {
        output.WriteRawTag(16);
        output.WriteInt32(Signal);
      }
      if (HasReason) {
        output.WriteRawTag(26);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(34);
        output.WriteString(Message);
      }
      if (startedAt_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(StartedAt);
      }
      if (finishedAt_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(FinishedAt);
      }
      if (HasContainerID) {
        output.WriteRawTag(58);
        output.WriteString(ContainerID);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasExitCode) {
        output.WriteRawTag(8);
        output.WriteInt32(ExitCode);
      }
      if (HasSignal) {
        output.WriteRawTag(16);
        output.WriteInt32(Signal);
      }
      if (HasReason) {
        output.WriteRawTag(26);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(34);
        output.WriteString(Message);
      }
      if (startedAt_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(StartedAt);
      }
      if (finishedAt_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(FinishedAt);
      }
      if (HasContainerID) {
        output.WriteRawTag(58);
        output.WriteString(ContainerID);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasExitCode) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ExitCode);
      }
      if (HasSignal) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Signal);
      }
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (startedAt_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartedAt);
      }
      if (finishedAt_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FinishedAt);
      }
      if (HasContainerID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ContainerID);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ContainerStateTerminated other) {
      if (other == null) {
        return;
      }
      if (other.HasExitCode) {
        ExitCode = other.ExitCode;
      }
      if (other.HasSignal) {
        Signal = other.Signal;
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.startedAt_ != null) {
        if (startedAt_ == null) {
          StartedAt = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        StartedAt.MergeFrom(other.StartedAt);
      }
      if (other.finishedAt_ != null) {
        if (finishedAt_ == null) {
          FinishedAt = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        FinishedAt.MergeFrom(other.FinishedAt);
      }
      if (other.HasContainerID) {
        ContainerID = other.ContainerID;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ExitCode = input.ReadInt32();
            break;
          }
          case 16: {
            Signal = input.ReadInt32();
            break;
          }
          case 26: {
            Reason = input.ReadString();
            break;
          }
          case 34: {
            Message = input.ReadString();
            break;
          }
          case 42: {
            if (startedAt_ == null) {
              StartedAt = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(StartedAt);
            break;
          }
          case 50: {
            if (finishedAt_ == null) {
              FinishedAt = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(FinishedAt);
            break;
          }
          case 58: {
            ContainerID = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            ExitCode = input.ReadInt32();
            break;
          }
          case 16: {
            Signal = input.ReadInt32();
            break;
          }
          case 26: {
            Reason = input.ReadString();
            break;
          }
          case 34: {
            Message = input.ReadString();
            break;
          }
          case 42: {
            if (startedAt_ == null) {
              StartedAt = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(StartedAt);
            break;
          }
          case 50: {
            if (finishedAt_ == null) {
              FinishedAt = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(FinishedAt);
            break;
          }
          case 58: {
            ContainerID = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ContainerStateWaiting is a waiting state of a container.
  /// </summary>
  public sealed partial class ContainerStateWaiting : pb::IMessage<ContainerStateWaiting>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContainerStateWaiting> _parser = new pb::MessageParser<ContainerStateWaiting>(() => new ContainerStateWaiting());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ContainerStateWaiting> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[32]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStateWaiting() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStateWaiting(ContainerStateWaiting other) : this() {
      reason_ = other.reason_;
      message_ = other.message_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStateWaiting Clone() {
      return new ContainerStateWaiting(this);
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 1;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// (brief) reason the container is not yet running.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 2;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// Message regarding why the container is not yet running.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ContainerStateWaiting);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ContainerStateWaiting other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Reason != other.Reason) return false;
      if (Message != other.Message) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasReason) hash ^= Reason.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasReason) {
        output.WriteRawTag(10);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasReason) {
        output.WriteRawTag(10);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ContainerStateWaiting other) {
      if (other == null) {
        return;
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Reason = input.ReadString();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Reason = input.ReadString();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ContainerStatus contains details for the current status of this container.
  /// </summary>
  public sealed partial class ContainerStatus : pb::IMessage<ContainerStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ContainerStatus> _parser = new pb::MessageParser<ContainerStatus>(() => new ContainerStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ContainerStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[33]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStatus(ContainerStatus other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      state_ = other.state_ != null ? other.state_.Clone() : null;
      lastState_ = other.lastState_ != null ? other.lastState_.Clone() : null;
      ready_ = other.ready_;
      restartCount_ = other.restartCount_;
      image_ = other.image_;
      imageID_ = other.imageID_;
      containerID_ = other.containerID_;
      started_ = other.started_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ContainerStatus Clone() {
      return new ContainerStatus(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// This must be a DNS_LABEL. Each container in a pod must have a unique name.
    /// Cannot be updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ContainerState state_;
    /// <summary>
    /// Details about the container's current condition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ContainerState State {
      get { return state_; }
      set {
        state_ = value;
      }
    }

    /// <summary>Field number for the "lastState" field.</summary>
    public const int LastStateFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.ContainerState lastState_;
    /// <summary>
    /// Details about the container's last termination condition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ContainerState LastState {
      get { return lastState_; }
      set {
        lastState_ = value;
      }
    }

    /// <summary>Field number for the "ready" field.</summary>
    public const int ReadyFieldNumber = 4;
    private readonly static bool ReadyDefaultValue = false;

    private bool ready_;
    /// <summary>
    /// Specifies whether the container has passed its readiness probe.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Ready {
      get { if ((_hasBits0 & 1) != 0) { return ready_; } else { return ReadyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        ready_ = value;
      }
    }
    /// <summary>Gets whether the "ready" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReady {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "ready" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReady() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "restartCount" field.</summary>
    public const int RestartCountFieldNumber = 5;
    private readonly static int RestartCountDefaultValue = 0;

    private int restartCount_;
    /// <summary>
    /// The number of times the container has been restarted, currently based on
    /// the number of dead containers that have not yet been removed.
    /// Note that this is calculated from dead containers. But those containers are subject to
    /// garbage collection. This value will get capped at 5 by GC.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int RestartCount {
      get { if ((_hasBits0 & 2) != 0) { return restartCount_; } else { return RestartCountDefaultValue; } }
      set {
        _hasBits0 |= 2;
        restartCount_ = value;
      }
    }
    /// <summary>Gets whether the "restartCount" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRestartCount {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "restartCount" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRestartCount() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "image" field.</summary>
    public const int ImageFieldNumber = 6;
    private readonly static string ImageDefaultValue = "";

    private string image_;
    /// <summary>
    /// The image the container is running.
    /// More info: https://kubernetes.io/docs/concepts/containers/images
    /// TODO(dchen1107): Which image the container is running with?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Image {
      get { return image_ ?? ImageDefaultValue; }
      set {
        image_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "image" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImage {
      get { return image_ != null; }
    }
    /// <summary>Clears the value of the "image" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImage() {
      image_ = null;
    }

    /// <summary>Field number for the "imageID" field.</summary>
    public const int ImageIDFieldNumber = 7;
    private readonly static string ImageIDDefaultValue = "";

    private string imageID_;
    /// <summary>
    /// ImageID of the container's image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ImageID {
      get { return imageID_ ?? ImageIDDefaultValue; }
      set {
        imageID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "imageID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImageID {
      get { return imageID_ != null; }
    }
    /// <summary>Clears the value of the "imageID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImageID() {
      imageID_ = null;
    }

    /// <summary>Field number for the "containerID" field.</summary>
    public const int ContainerIDFieldNumber = 8;
    private readonly static string ContainerIDDefaultValue = "";

    private string containerID_;
    /// <summary>
    /// Container's ID in the format 'docker://&lt;container_id>'.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ContainerID {
      get { return containerID_ ?? ContainerIDDefaultValue; }
      set {
        containerID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "containerID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContainerID {
      get { return containerID_ != null; }
    }
    /// <summary>Clears the value of the "containerID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContainerID() {
      containerID_ = null;
    }

    /// <summary>Field number for the "started" field.</summary>
    public const int StartedFieldNumber = 9;
    private readonly static bool StartedDefaultValue = false;

    private bool started_;
    /// <summary>
    /// Specifies whether the container has passed its startup probe.
    /// Initialized as false, becomes true after startupProbe is considered successful.
    /// Resets to false when the container is restarted, or if kubelet loses state temporarily.
    /// Is always true when no startupProbe is defined.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Started {
      get { if ((_hasBits0 & 4) != 0) { return started_; } else { return StartedDefaultValue; } }
      set {
        _hasBits0 |= 4;
        started_ = value;
      }
    }
    /// <summary>Gets whether the "started" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStarted {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "started" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStarted() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ContainerStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ContainerStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(State, other.State)) return false;
      if (!object.Equals(LastState, other.LastState)) return false;
      if (Ready != other.Ready) return false;
      if (RestartCount != other.RestartCount) return false;
      if (Image != other.Image) return false;
      if (ImageID != other.ImageID) return false;
      if (ContainerID != other.ContainerID) return false;
      if (Started != other.Started) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (state_ != null) hash ^= State.GetHashCode();
      if (lastState_ != null) hash ^= LastState.GetHashCode();
      if (HasReady) hash ^= Ready.GetHashCode();
      if (HasRestartCount) hash ^= RestartCount.GetHashCode();
      if (HasImage) hash ^= Image.GetHashCode();
      if (HasImageID) hash ^= ImageID.GetHashCode();
      if (HasContainerID) hash ^= ContainerID.GetHashCode();
      if (HasStarted) hash ^= Started.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (state_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(State);
      }
      if (lastState_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastState);
      }
      if (HasReady) {
        output.WriteRawTag(32);
        output.WriteBool(Ready);
      }
      if (HasRestartCount) {
        output.WriteRawTag(40);
        output.WriteInt32(RestartCount);
      }
      if (HasImage) {
        output.WriteRawTag(50);
        output.WriteString(Image);
      }
      if (HasImageID) {
        output.WriteRawTag(58);
        output.WriteString(ImageID);
      }
      if (HasContainerID) {
        output.WriteRawTag(66);
        output.WriteString(ContainerID);
      }
      if (HasStarted) {
        output.WriteRawTag(72);
        output.WriteBool(Started);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (state_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(State);
      }
      if (lastState_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastState);
      }
      if (HasReady) {
        output.WriteRawTag(32);
        output.WriteBool(Ready);
      }
      if (HasRestartCount) {
        output.WriteRawTag(40);
        output.WriteInt32(RestartCount);
      }
      if (HasImage) {
        output.WriteRawTag(50);
        output.WriteString(Image);
      }
      if (HasImageID) {
        output.WriteRawTag(58);
        output.WriteString(ImageID);
      }
      if (HasContainerID) {
        output.WriteRawTag(66);
        output.WriteString(ContainerID);
      }
      if (HasStarted) {
        output.WriteRawTag(72);
        output.WriteBool(Started);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (state_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(State);
      }
      if (lastState_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastState);
      }
      if (HasReady) {
        size += 1 + 1;
      }
      if (HasRestartCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(RestartCount);
      }
      if (HasImage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Image);
      }
      if (HasImageID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ImageID);
      }
      if (HasContainerID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ContainerID);
      }
      if (HasStarted) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ContainerStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.state_ != null) {
        if (state_ == null) {
          State = new global::K8S.Io.Api.Core.V1.ContainerState();
        }
        State.MergeFrom(other.State);
      }
      if (other.lastState_ != null) {
        if (lastState_ == null) {
          LastState = new global::K8S.Io.Api.Core.V1.ContainerState();
        }
        LastState.MergeFrom(other.LastState);
      }
      if (other.HasReady) {
        Ready = other.Ready;
      }
      if (other.HasRestartCount) {
        RestartCount = other.RestartCount;
      }
      if (other.HasImage) {
        Image = other.Image;
      }
      if (other.HasImageID) {
        ImageID = other.ImageID;
      }
      if (other.HasContainerID) {
        ContainerID = other.ContainerID;
      }
      if (other.HasStarted) {
        Started = other.Started;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (state_ == null) {
              State = new global::K8S.Io.Api.Core.V1.ContainerState();
            }
            input.ReadMessage(State);
            break;
          }
          case 26: {
            if (lastState_ == null) {
              LastState = new global::K8S.Io.Api.Core.V1.ContainerState();
            }
            input.ReadMessage(LastState);
            break;
          }
          case 32: {
            Ready = input.ReadBool();
            break;
          }
          case 40: {
            RestartCount = input.ReadInt32();
            break;
          }
          case 50: {
            Image = input.ReadString();
            break;
          }
          case 58: {
            ImageID = input.ReadString();
            break;
          }
          case 66: {
            ContainerID = input.ReadString();
            break;
          }
          case 72: {
            Started = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (state_ == null) {
              State = new global::K8S.Io.Api.Core.V1.ContainerState();
            }
            input.ReadMessage(State);
            break;
          }
          case 26: {
            if (lastState_ == null) {
              LastState = new global::K8S.Io.Api.Core.V1.ContainerState();
            }
            input.ReadMessage(LastState);
            break;
          }
          case 32: {
            Ready = input.ReadBool();
            break;
          }
          case 40: {
            RestartCount = input.ReadInt32();
            break;
          }
          case 50: {
            Image = input.ReadString();
            break;
          }
          case 58: {
            ImageID = input.ReadString();
            break;
          }
          case 66: {
            ContainerID = input.ReadString();
            break;
          }
          case 72: {
            Started = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// DaemonEndpoint contains information about a single Daemon endpoint.
  /// </summary>
  public sealed partial class DaemonEndpoint : pb::IMessage<DaemonEndpoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DaemonEndpoint> _parser = new pb::MessageParser<DaemonEndpoint>(() => new DaemonEndpoint());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DaemonEndpoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[34]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DaemonEndpoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DaemonEndpoint(DaemonEndpoint other) : this() {
      _hasBits0 = other._hasBits0;
      port_ = other.port_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DaemonEndpoint Clone() {
      return new DaemonEndpoint(this);
    }

    /// <summary>Field number for the "Port" field.</summary>
    public const int PortFieldNumber = 1;
    private readonly static int PortDefaultValue = 0;

    private int port_;
    /// <summary>
    /// Port number of the given endpoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Port {
      get { if ((_hasBits0 & 1) != 0) { return port_; } else { return PortDefaultValue; } }
      set {
        _hasBits0 |= 1;
        port_ = value;
      }
    }
    /// <summary>Gets whether the "Port" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPort {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "Port" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPort() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DaemonEndpoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DaemonEndpoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Port != other.Port) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPort) hash ^= Port.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPort) {
        output.WriteRawTag(8);
        output.WriteInt32(Port);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPort) {
        output.WriteRawTag(8);
        output.WriteInt32(Port);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPort) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Port);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DaemonEndpoint other) {
      if (other == null) {
        return;
      }
      if (other.HasPort) {
        Port = other.Port;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Port = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Port = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents downward API info for projecting into a projected volume.
  /// Note that this is identical to a downwardAPI volume source without the default
  /// mode.
  /// </summary>
  public sealed partial class DownwardAPIProjection : pb::IMessage<DownwardAPIProjection>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DownwardAPIProjection> _parser = new pb::MessageParser<DownwardAPIProjection>(() => new DownwardAPIProjection());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DownwardAPIProjection> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[35]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownwardAPIProjection() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownwardAPIProjection(DownwardAPIProjection other) : this() {
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownwardAPIProjection Clone() {
      return new DownwardAPIProjection(this);
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile> _repeated_items_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile>();
    /// <summary>
    /// Items is a list of DownwardAPIVolume file
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DownwardAPIProjection);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DownwardAPIProjection other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DownwardAPIProjection other) {
      if (other == null) {
        return;
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// DownwardAPIVolumeFile represents information to create the file containing the pod field
  /// </summary>
  public sealed partial class DownwardAPIVolumeFile : pb::IMessage<DownwardAPIVolumeFile>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DownwardAPIVolumeFile> _parser = new pb::MessageParser<DownwardAPIVolumeFile>(() => new DownwardAPIVolumeFile());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DownwardAPIVolumeFile> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[36]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownwardAPIVolumeFile() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownwardAPIVolumeFile(DownwardAPIVolumeFile other) : this() {
      _hasBits0 = other._hasBits0;
      path_ = other.path_;
      fieldRef_ = other.fieldRef_ != null ? other.fieldRef_.Clone() : null;
      resourceFieldRef_ = other.resourceFieldRef_ != null ? other.resourceFieldRef_.Clone() : null;
      mode_ = other.mode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownwardAPIVolumeFile Clone() {
      return new DownwardAPIVolumeFile(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "fieldRef" field.</summary>
    public const int FieldRefFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ObjectFieldSelector fieldRef_;
    /// <summary>
    /// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ObjectFieldSelector FieldRef {
      get { return fieldRef_; }
      set {
        fieldRef_ = value;
      }
    }

    /// <summary>Field number for the "resourceFieldRef" field.</summary>
    public const int ResourceFieldRefFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.ResourceFieldSelector resourceFieldRef_;
    /// <summary>
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ResourceFieldSelector ResourceFieldRef {
      get { return resourceFieldRef_; }
      set {
        resourceFieldRef_ = value;
      }
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 4;
    private readonly static int ModeDefaultValue = 0;

    private int mode_;
    /// <summary>
    /// Optional: mode bits used to set permissions on this file, must be an octal value
    /// between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Mode {
      get { if ((_hasBits0 & 1) != 0) { return mode_; } else { return ModeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        mode_ = value;
      }
    }
    /// <summary>Gets whether the "mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMode {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMode() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DownwardAPIVolumeFile);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DownwardAPIVolumeFile other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      if (!object.Equals(FieldRef, other.FieldRef)) return false;
      if (!object.Equals(ResourceFieldRef, other.ResourceFieldRef)) return false;
      if (Mode != other.Mode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPath) hash ^= Path.GetHashCode();
      if (fieldRef_ != null) hash ^= FieldRef.GetHashCode();
      if (resourceFieldRef_ != null) hash ^= ResourceFieldRef.GetHashCode();
      if (HasMode) hash ^= Mode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (fieldRef_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FieldRef);
      }
      if (resourceFieldRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ResourceFieldRef);
      }
      if (HasMode) {
        output.WriteRawTag(32);
        output.WriteInt32(Mode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (fieldRef_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(FieldRef);
      }
      if (resourceFieldRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ResourceFieldRef);
      }
      if (HasMode) {
        output.WriteRawTag(32);
        output.WriteInt32(Mode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (fieldRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FieldRef);
      }
      if (resourceFieldRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ResourceFieldRef);
      }
      if (HasMode) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Mode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DownwardAPIVolumeFile other) {
      if (other == null) {
        return;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.fieldRef_ != null) {
        if (fieldRef_ == null) {
          FieldRef = new global::K8S.Io.Api.Core.V1.ObjectFieldSelector();
        }
        FieldRef.MergeFrom(other.FieldRef);
      }
      if (other.resourceFieldRef_ != null) {
        if (resourceFieldRef_ == null) {
          ResourceFieldRef = new global::K8S.Io.Api.Core.V1.ResourceFieldSelector();
        }
        ResourceFieldRef.MergeFrom(other.ResourceFieldRef);
      }
      if (other.HasMode) {
        Mode = other.Mode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            if (fieldRef_ == null) {
              FieldRef = new global::K8S.Io.Api.Core.V1.ObjectFieldSelector();
            }
            input.ReadMessage(FieldRef);
            break;
          }
          case 26: {
            if (resourceFieldRef_ == null) {
              ResourceFieldRef = new global::K8S.Io.Api.Core.V1.ResourceFieldSelector();
            }
            input.ReadMessage(ResourceFieldRef);
            break;
          }
          case 32: {
            Mode = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            if (fieldRef_ == null) {
              FieldRef = new global::K8S.Io.Api.Core.V1.ObjectFieldSelector();
            }
            input.ReadMessage(FieldRef);
            break;
          }
          case 26: {
            if (resourceFieldRef_ == null) {
              ResourceFieldRef = new global::K8S.Io.Api.Core.V1.ResourceFieldSelector();
            }
            input.ReadMessage(ResourceFieldRef);
            break;
          }
          case 32: {
            Mode = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// DownwardAPIVolumeSource represents a volume containing downward API info.
  /// Downward API volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class DownwardAPIVolumeSource : pb::IMessage<DownwardAPIVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<DownwardAPIVolumeSource> _parser = new pb::MessageParser<DownwardAPIVolumeSource>(() => new DownwardAPIVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<DownwardAPIVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[37]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownwardAPIVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownwardAPIVolumeSource(DownwardAPIVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      items_ = other.items_.Clone();
      defaultMode_ = other.defaultMode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DownwardAPIVolumeSource Clone() {
      return new DownwardAPIVolumeSource(this);
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile> _repeated_items_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile>();
    /// <summary>
    /// Items is a list of downward API volume file
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.DownwardAPIVolumeFile> Items {
      get { return items_; }
    }

    /// <summary>Field number for the "defaultMode" field.</summary>
    public const int DefaultModeFieldNumber = 2;
    private readonly static int DefaultModeDefaultValue = 0;

    private int defaultMode_;
    /// <summary>
    /// Optional: mode bits to use on created files by default. Must be a
    /// Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int DefaultMode {
      get { if ((_hasBits0 & 1) != 0) { return defaultMode_; } else { return DefaultModeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        defaultMode_ = value;
      }
    }
    /// <summary>Gets whether the "defaultMode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDefaultMode {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "defaultMode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDefaultMode() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as DownwardAPIVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(DownwardAPIVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!items_.Equals(other.items_)) return false;
      if (DefaultMode != other.DefaultMode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= items_.GetHashCode();
      if (HasDefaultMode) hash ^= DefaultMode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      items_.WriteTo(output, _repeated_items_codec);
      if (HasDefaultMode) {
        output.WriteRawTag(16);
        output.WriteInt32(DefaultMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      items_.WriteTo(ref output, _repeated_items_codec);
      if (HasDefaultMode) {
        output.WriteRawTag(16);
        output.WriteInt32(DefaultMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += items_.CalculateSize(_repeated_items_codec);
      if (HasDefaultMode) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DefaultMode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(DownwardAPIVolumeSource other) {
      if (other == null) {
        return;
      }
      items_.Add(other.items_);
      if (other.HasDefaultMode) {
        DefaultMode = other.DefaultMode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
          case 16: {
            DefaultMode = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
          case 16: {
            DefaultMode = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents an empty directory for a pod.
  /// Empty directory volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class EmptyDirVolumeSource : pb::IMessage<EmptyDirVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EmptyDirVolumeSource> _parser = new pb::MessageParser<EmptyDirVolumeSource>(() => new EmptyDirVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EmptyDirVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[38]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EmptyDirVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EmptyDirVolumeSource(EmptyDirVolumeSource other) : this() {
      medium_ = other.medium_;
      sizeLimit_ = other.sizeLimit_ != null ? other.sizeLimit_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EmptyDirVolumeSource Clone() {
      return new EmptyDirVolumeSource(this);
    }

    /// <summary>Field number for the "medium" field.</summary>
    public const int MediumFieldNumber = 1;
    private readonly static string MediumDefaultValue = "";

    private string medium_;
    /// <summary>
    /// What type of storage medium should back this directory.
    /// The default is "" which means to use the node's default medium.
    /// Must be an empty string (default) or Memory.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Medium {
      get { return medium_ ?? MediumDefaultValue; }
      set {
        medium_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "medium" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMedium {
      get { return medium_ != null; }
    }
    /// <summary>Clears the value of the "medium" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMedium() {
      medium_ = null;
    }

    /// <summary>Field number for the "sizeLimit" field.</summary>
    public const int SizeLimitFieldNumber = 2;
    private global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity sizeLimit_;
    /// <summary>
    /// Total amount of local storage required for this EmptyDir volume.
    /// The size limit is also applicable for memory medium.
    /// The maximum usage on memory medium EmptyDir would be the minimum value between
    /// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
    /// The default is nil which means that the limit is undefined.
    /// More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity SizeLimit {
      get { return sizeLimit_; }
      set {
        sizeLimit_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EmptyDirVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EmptyDirVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Medium != other.Medium) return false;
      if (!object.Equals(SizeLimit, other.SizeLimit)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMedium) hash ^= Medium.GetHashCode();
      if (sizeLimit_ != null) hash ^= SizeLimit.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasMedium) {
        output.WriteRawTag(10);
        output.WriteString(Medium);
      }
      if (sizeLimit_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SizeLimit);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMedium) {
        output.WriteRawTag(10);
        output.WriteString(Medium);
      }
      if (sizeLimit_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(SizeLimit);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasMedium) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Medium);
      }
      if (sizeLimit_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SizeLimit);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EmptyDirVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasMedium) {
        Medium = other.Medium;
      }
      if (other.sizeLimit_ != null) {
        if (sizeLimit_ == null) {
          SizeLimit = new global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity();
        }
        SizeLimit.MergeFrom(other.SizeLimit);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Medium = input.ReadString();
            break;
          }
          case 18: {
            if (sizeLimit_ == null) {
              SizeLimit = new global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity();
            }
            input.ReadMessage(SizeLimit);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Medium = input.ReadString();
            break;
          }
          case 18: {
            if (sizeLimit_ == null) {
              SizeLimit = new global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity();
            }
            input.ReadMessage(SizeLimit);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EndpointAddress is a tuple that describes single IP address.
  /// +structType=atomic
  /// </summary>
  public sealed partial class EndpointAddress : pb::IMessage<EndpointAddress>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EndpointAddress> _parser = new pb::MessageParser<EndpointAddress>(() => new EndpointAddress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EndpointAddress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[39]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointAddress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointAddress(EndpointAddress other) : this() {
      ip_ = other.ip_;
      hostname_ = other.hostname_;
      nodeName_ = other.nodeName_;
      targetRef_ = other.targetRef_ != null ? other.targetRef_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointAddress Clone() {
      return new EndpointAddress(this);
    }

    /// <summary>Field number for the "ip" field.</summary>
    public const int IpFieldNumber = 1;
    private readonly static string IpDefaultValue = "";

    private string ip_;
    /// <summary>
    /// The IP of this endpoint.
    /// May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
    /// or link-local multicast ((224.0.0.0/24).
    /// IPv6 is also accepted but not fully supported on all platforms. Also, certain
    /// kubernetes components, like kube-proxy, are not IPv6 ready.
    /// TODO: This should allow hostname or IP, See #4447.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Ip {
      get { return ip_ ?? IpDefaultValue; }
      set {
        ip_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ip" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIp {
      get { return ip_ != null; }
    }
    /// <summary>Clears the value of the "ip" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIp() {
      ip_ = null;
    }

    /// <summary>Field number for the "hostname" field.</summary>
    public const int HostnameFieldNumber = 3;
    private readonly static string HostnameDefaultValue = "";

    private string hostname_;
    /// <summary>
    /// The Hostname of this endpoint
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Hostname {
      get { return hostname_ ?? HostnameDefaultValue; }
      set {
        hostname_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hostname" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostname {
      get { return hostname_ != null; }
    }
    /// <summary>Clears the value of the "hostname" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostname() {
      hostname_ = null;
    }

    /// <summary>Field number for the "nodeName" field.</summary>
    public const int NodeNameFieldNumber = 4;
    private readonly static string NodeNameDefaultValue = "";

    private string nodeName_;
    /// <summary>
    /// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string NodeName {
      get { return nodeName_ ?? NodeNameDefaultValue; }
      set {
        nodeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "nodeName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeName {
      get { return nodeName_ != null; }
    }
    /// <summary>Clears the value of the "nodeName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeName() {
      nodeName_ = null;
    }

    /// <summary>Field number for the "targetRef" field.</summary>
    public const int TargetRefFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ObjectReference targetRef_;
    /// <summary>
    /// Reference to object providing the endpoint.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ObjectReference TargetRef {
      get { return targetRef_; }
      set {
        targetRef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EndpointAddress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EndpointAddress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Ip != other.Ip) return false;
      if (Hostname != other.Hostname) return false;
      if (NodeName != other.NodeName) return false;
      if (!object.Equals(TargetRef, other.TargetRef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasIp) hash ^= Ip.GetHashCode();
      if (HasHostname) hash ^= Hostname.GetHashCode();
      if (HasNodeName) hash ^= NodeName.GetHashCode();
      if (targetRef_ != null) hash ^= TargetRef.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasIp) {
        output.WriteRawTag(10);
        output.WriteString(Ip);
      }
      if (targetRef_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TargetRef);
      }
      if (HasHostname) {
        output.WriteRawTag(26);
        output.WriteString(Hostname);
      }
      if (HasNodeName) {
        output.WriteRawTag(34);
        output.WriteString(NodeName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasIp) {
        output.WriteRawTag(10);
        output.WriteString(Ip);
      }
      if (targetRef_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TargetRef);
      }
      if (HasHostname) {
        output.WriteRawTag(26);
        output.WriteString(Hostname);
      }
      if (HasNodeName) {
        output.WriteRawTag(34);
        output.WriteString(NodeName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasIp) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Ip);
      }
      if (HasHostname) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Hostname);
      }
      if (HasNodeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NodeName);
      }
      if (targetRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TargetRef);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EndpointAddress other) {
      if (other == null) {
        return;
      }
      if (other.HasIp) {
        Ip = other.Ip;
      }
      if (other.HasHostname) {
        Hostname = other.Hostname;
      }
      if (other.HasNodeName) {
        NodeName = other.NodeName;
      }
      if (other.targetRef_ != null) {
        if (targetRef_ == null) {
          TargetRef = new global::K8S.Io.Api.Core.V1.ObjectReference();
        }
        TargetRef.MergeFrom(other.TargetRef);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Ip = input.ReadString();
            break;
          }
          case 18: {
            if (targetRef_ == null) {
              TargetRef = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(TargetRef);
            break;
          }
          case 26: {
            Hostname = input.ReadString();
            break;
          }
          case 34: {
            NodeName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Ip = input.ReadString();
            break;
          }
          case 18: {
            if (targetRef_ == null) {
              TargetRef = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(TargetRef);
            break;
          }
          case 26: {
            Hostname = input.ReadString();
            break;
          }
          case 34: {
            NodeName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EndpointPort is a tuple that describes a single port.
  /// +structType=atomic
  /// </summary>
  public sealed partial class EndpointPort : pb::IMessage<EndpointPort>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EndpointPort> _parser = new pb::MessageParser<EndpointPort>(() => new EndpointPort());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EndpointPort> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[40]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointPort() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointPort(EndpointPort other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      port_ = other.port_;
      protocol_ = other.protocol_;
      appProtocol_ = other.appProtocol_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointPort Clone() {
      return new EndpointPort(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// The name of this port.  This must match the 'name' field in the
    /// corresponding ServicePort.
    /// Must be a DNS_LABEL.
    /// Optional only if one port is defined.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "port" field.</summary>
    public const int PortFieldNumber = 2;
    private readonly static int PortDefaultValue = 0;

    private int port_;
    /// <summary>
    /// The port number of the endpoint.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Port {
      get { if ((_hasBits0 & 1) != 0) { return port_; } else { return PortDefaultValue; } }
      set {
        _hasBits0 |= 1;
        port_ = value;
      }
    }
    /// <summary>Gets whether the "port" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPort {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "port" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPort() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 3;
    private readonly static string ProtocolDefaultValue = "";

    private string protocol_;
    /// <summary>
    /// The IP protocol for this port.
    /// Must be UDP, TCP, or SCTP.
    /// Default is TCP.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Protocol {
      get { return protocol_ ?? ProtocolDefaultValue; }
      set {
        protocol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "protocol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProtocol {
      get { return protocol_ != null; }
    }
    /// <summary>Clears the value of the "protocol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProtocol() {
      protocol_ = null;
    }

    /// <summary>Field number for the "appProtocol" field.</summary>
    public const int AppProtocolFieldNumber = 4;
    private readonly static string AppProtocolDefaultValue = "";

    private string appProtocol_;
    /// <summary>
    /// The application protocol for this port.
    /// This field follows standard Kubernetes label syntax.
    /// Un-prefixed names are reserved for IANA standard service names (as per
    /// RFC-6335 and http://www.iana.org/assignments/service-names).
    /// Non-standard protocols should use prefixed names such as
    /// mycompany.com/my-custom-protocol.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AppProtocol {
      get { return appProtocol_ ?? AppProtocolDefaultValue; }
      set {
        appProtocol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "appProtocol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAppProtocol {
      get { return appProtocol_ != null; }
    }
    /// <summary>Clears the value of the "appProtocol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAppProtocol() {
      appProtocol_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EndpointPort);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EndpointPort other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Port != other.Port) return false;
      if (Protocol != other.Protocol) return false;
      if (AppProtocol != other.AppProtocol) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasPort) hash ^= Port.GetHashCode();
      if (HasProtocol) hash ^= Protocol.GetHashCode();
      if (HasAppProtocol) hash ^= AppProtocol.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasPort) {
        output.WriteRawTag(16);
        output.WriteInt32(Port);
      }
      if (HasProtocol) {
        output.WriteRawTag(26);
        output.WriteString(Protocol);
      }
      if (HasAppProtocol) {
        output.WriteRawTag(34);
        output.WriteString(AppProtocol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasPort) {
        output.WriteRawTag(16);
        output.WriteInt32(Port);
      }
      if (HasProtocol) {
        output.WriteRawTag(26);
        output.WriteString(Protocol);
      }
      if (HasAppProtocol) {
        output.WriteRawTag(34);
        output.WriteString(AppProtocol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasPort) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Port);
      }
      if (HasProtocol) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Protocol);
      }
      if (HasAppProtocol) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AppProtocol);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EndpointPort other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasPort) {
        Port = other.Port;
      }
      if (other.HasProtocol) {
        Protocol = other.Protocol;
      }
      if (other.HasAppProtocol) {
        AppProtocol = other.AppProtocol;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Port = input.ReadInt32();
            break;
          }
          case 26: {
            Protocol = input.ReadString();
            break;
          }
          case 34: {
            AppProtocol = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Port = input.ReadInt32();
            break;
          }
          case 26: {
            Protocol = input.ReadString();
            break;
          }
          case 34: {
            AppProtocol = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EndpointSubset is a group of addresses with a common set of ports. The
  /// expanded set of endpoints is the Cartesian product of Addresses x Ports.
  /// For example, given:
  ///   {
  ///     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
  ///     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
  ///   }
  /// The resulting set of endpoints can be viewed as:
  ///     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
  ///     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
  /// </summary>
  public sealed partial class EndpointSubset : pb::IMessage<EndpointSubset>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EndpointSubset> _parser = new pb::MessageParser<EndpointSubset>(() => new EndpointSubset());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EndpointSubset> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[41]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointSubset() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointSubset(EndpointSubset other) : this() {
      addresses_ = other.addresses_.Clone();
      notReadyAddresses_ = other.notReadyAddresses_.Clone();
      ports_ = other.ports_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointSubset Clone() {
      return new EndpointSubset(this);
    }

    /// <summary>Field number for the "addresses" field.</summary>
    public const int AddressesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.EndpointAddress> _repeated_addresses_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.EndpointAddress.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointAddress> addresses_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointAddress>();
    /// <summary>
    /// IP addresses which offer the related ports that are marked as ready. These endpoints
    /// should be considered safe for load balancers and clients to utilize.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointAddress> Addresses {
      get { return addresses_; }
    }

    /// <summary>Field number for the "notReadyAddresses" field.</summary>
    public const int NotReadyAddressesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.EndpointAddress> _repeated_notReadyAddresses_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.EndpointAddress.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointAddress> notReadyAddresses_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointAddress>();
    /// <summary>
    /// IP addresses which offer the related ports but are not currently marked as ready
    /// because they have not yet finished starting, have recently failed a readiness check,
    /// or have recently failed a liveness check.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointAddress> NotReadyAddresses {
      get { return notReadyAddresses_; }
    }

    /// <summary>Field number for the "ports" field.</summary>
    public const int PortsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.EndpointPort> _repeated_ports_codec
        = pb::FieldCodec.ForMessage(26, global::K8S.Io.Api.Core.V1.EndpointPort.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointPort> ports_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointPort>();
    /// <summary>
    /// Port numbers available on the related IP addresses.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointPort> Ports {
      get { return ports_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EndpointSubset);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EndpointSubset other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!addresses_.Equals(other.addresses_)) return false;
      if(!notReadyAddresses_.Equals(other.notReadyAddresses_)) return false;
      if(!ports_.Equals(other.ports_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= addresses_.GetHashCode();
      hash ^= notReadyAddresses_.GetHashCode();
      hash ^= ports_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      addresses_.WriteTo(output, _repeated_addresses_codec);
      notReadyAddresses_.WriteTo(output, _repeated_notReadyAddresses_codec);
      ports_.WriteTo(output, _repeated_ports_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      addresses_.WriteTo(ref output, _repeated_addresses_codec);
      notReadyAddresses_.WriteTo(ref output, _repeated_notReadyAddresses_codec);
      ports_.WriteTo(ref output, _repeated_ports_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += addresses_.CalculateSize(_repeated_addresses_codec);
      size += notReadyAddresses_.CalculateSize(_repeated_notReadyAddresses_codec);
      size += ports_.CalculateSize(_repeated_ports_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EndpointSubset other) {
      if (other == null) {
        return;
      }
      addresses_.Add(other.addresses_);
      notReadyAddresses_.Add(other.notReadyAddresses_);
      ports_.Add(other.ports_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            addresses_.AddEntriesFrom(input, _repeated_addresses_codec);
            break;
          }
          case 18: {
            notReadyAddresses_.AddEntriesFrom(input, _repeated_notReadyAddresses_codec);
            break;
          }
          case 26: {
            ports_.AddEntriesFrom(input, _repeated_ports_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            addresses_.AddEntriesFrom(ref input, _repeated_addresses_codec);
            break;
          }
          case 18: {
            notReadyAddresses_.AddEntriesFrom(ref input, _repeated_notReadyAddresses_codec);
            break;
          }
          case 26: {
            ports_.AddEntriesFrom(ref input, _repeated_ports_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Endpoints is a collection of endpoints that implement the actual service. Example:
  ///   Name: "mysvc",
  ///   Subsets: [
  ///     {
  ///       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
  ///       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
  ///     },
  ///     {
  ///       Addresses: [{"ip": "10.10.3.3"}],
  ///       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
  ///     },
  ///  ]
  /// </summary>
  public sealed partial class Endpoints : pb::IMessage<Endpoints>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Endpoints> _parser = new pb::MessageParser<Endpoints>(() => new Endpoints());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Endpoints> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[42]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Endpoints() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Endpoints(Endpoints other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      subsets_ = other.subsets_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Endpoints Clone() {
      return new Endpoints(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "subsets" field.</summary>
    public const int SubsetsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.EndpointSubset> _repeated_subsets_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.EndpointSubset.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointSubset> subsets_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointSubset>();
    /// <summary>
    /// The set of all endpoints is the union of all subsets. Addresses are placed into
    /// subsets according to the IPs they share. A single address with multiple ports,
    /// some of which are ready and some of which are not (because they come from
    /// different containers) will result in the address being displayed in different
    /// subsets for the different ports. No address will appear in both Addresses and
    /// NotReadyAddresses in the same subset.
    /// Sets of addresses and ports that comprise a service.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EndpointSubset> Subsets {
      get { return subsets_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Endpoints);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Endpoints other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!subsets_.Equals(other.subsets_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= subsets_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      subsets_.WriteTo(output, _repeated_subsets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      subsets_.WriteTo(ref output, _repeated_subsets_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += subsets_.CalculateSize(_repeated_subsets_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Endpoints other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      subsets_.Add(other.subsets_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            subsets_.AddEntriesFrom(input, _repeated_subsets_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            subsets_.AddEntriesFrom(ref input, _repeated_subsets_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EndpointsList is a list of endpoints.
  /// </summary>
  public sealed partial class EndpointsList : pb::IMessage<EndpointsList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EndpointsList> _parser = new pb::MessageParser<EndpointsList>(() => new EndpointsList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EndpointsList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[43]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointsList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointsList(EndpointsList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EndpointsList Clone() {
      return new EndpointsList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Endpoints> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.Endpoints.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Endpoints> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Endpoints>();
    /// <summary>
    /// List of endpoints.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Endpoints> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EndpointsList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EndpointsList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EndpointsList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EnvFromSource represents the source of a set of ConfigMaps
  /// </summary>
  public sealed partial class EnvFromSource : pb::IMessage<EnvFromSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnvFromSource> _parser = new pb::MessageParser<EnvFromSource>(() => new EnvFromSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EnvFromSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[44]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvFromSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvFromSource(EnvFromSource other) : this() {
      prefix_ = other.prefix_;
      configMapRef_ = other.configMapRef_ != null ? other.configMapRef_.Clone() : null;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvFromSource Clone() {
      return new EnvFromSource(this);
    }

    /// <summary>Field number for the "prefix" field.</summary>
    public const int PrefixFieldNumber = 1;
    private readonly static string PrefixDefaultValue = "";

    private string prefix_;
    /// <summary>
    /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Prefix {
      get { return prefix_ ?? PrefixDefaultValue; }
      set {
        prefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "prefix" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPrefix {
      get { return prefix_ != null; }
    }
    /// <summary>Clears the value of the "prefix" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPrefix() {
      prefix_ = null;
    }

    /// <summary>Field number for the "configMapRef" field.</summary>
    public const int ConfigMapRefFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ConfigMapEnvSource configMapRef_;
    /// <summary>
    /// The ConfigMap to select from
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ConfigMapEnvSource ConfigMapRef {
      get { return configMapRef_; }
      set {
        configMapRef_ = value;
      }
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.SecretEnvSource secretRef_;
    /// <summary>
    /// The Secret to select from
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretEnvSource SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EnvFromSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EnvFromSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Prefix != other.Prefix) return false;
      if (!object.Equals(ConfigMapRef, other.ConfigMapRef)) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPrefix) hash ^= Prefix.GetHashCode();
      if (configMapRef_ != null) hash ^= ConfigMapRef.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPrefix) {
        output.WriteRawTag(10);
        output.WriteString(Prefix);
      }
      if (configMapRef_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ConfigMapRef);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPrefix) {
        output.WriteRawTag(10);
        output.WriteString(Prefix);
      }
      if (configMapRef_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ConfigMapRef);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPrefix) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Prefix);
      }
      if (configMapRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigMapRef);
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EnvFromSource other) {
      if (other == null) {
        return;
      }
      if (other.HasPrefix) {
        Prefix = other.Prefix;
      }
      if (other.configMapRef_ != null) {
        if (configMapRef_ == null) {
          ConfigMapRef = new global::K8S.Io.Api.Core.V1.ConfigMapEnvSource();
        }
        ConfigMapRef.MergeFrom(other.ConfigMapRef);
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.SecretEnvSource();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Prefix = input.ReadString();
            break;
          }
          case 18: {
            if (configMapRef_ == null) {
              ConfigMapRef = new global::K8S.Io.Api.Core.V1.ConfigMapEnvSource();
            }
            input.ReadMessage(ConfigMapRef);
            break;
          }
          case 26: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretEnvSource();
            }
            input.ReadMessage(SecretRef);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Prefix = input.ReadString();
            break;
          }
          case 18: {
            if (configMapRef_ == null) {
              ConfigMapRef = new global::K8S.Io.Api.Core.V1.ConfigMapEnvSource();
            }
            input.ReadMessage(ConfigMapRef);
            break;
          }
          case 26: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretEnvSource();
            }
            input.ReadMessage(SecretRef);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EnvVar represents an environment variable present in a Container.
  /// </summary>
  public sealed partial class EnvVar : pb::IMessage<EnvVar>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnvVar> _parser = new pb::MessageParser<EnvVar>(() => new EnvVar());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EnvVar> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[45]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvVar() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvVar(EnvVar other) : this() {
      name_ = other.name_;
      value_ = other.value_;
      valueFrom_ = other.valueFrom_ != null ? other.valueFrom_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvVar Clone() {
      return new EnvVar(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    /// <summary>
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      value_ = null;
    }

    /// <summary>Field number for the "valueFrom" field.</summary>
    public const int ValueFromFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.EnvVarSource valueFrom_;
    /// <summary>
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.EnvVarSource ValueFrom {
      get { return valueFrom_; }
      set {
        valueFrom_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EnvVar);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EnvVar other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Value != other.Value) return false;
      if (!object.Equals(ValueFrom, other.ValueFrom)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (valueFrom_ != null) hash ^= ValueFrom.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (valueFrom_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ValueFrom);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (valueFrom_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ValueFrom);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (valueFrom_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValueFrom);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EnvVar other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      if (other.valueFrom_ != null) {
        if (valueFrom_ == null) {
          ValueFrom = new global::K8S.Io.Api.Core.V1.EnvVarSource();
        }
        ValueFrom.MergeFrom(other.ValueFrom);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
          case 26: {
            if (valueFrom_ == null) {
              ValueFrom = new global::K8S.Io.Api.Core.V1.EnvVarSource();
            }
            input.ReadMessage(ValueFrom);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
          case 26: {
            if (valueFrom_ == null) {
              ValueFrom = new global::K8S.Io.Api.Core.V1.EnvVarSource();
            }
            input.ReadMessage(ValueFrom);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EnvVarSource represents a source for the value of an EnvVar.
  /// </summary>
  public sealed partial class EnvVarSource : pb::IMessage<EnvVarSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EnvVarSource> _parser = new pb::MessageParser<EnvVarSource>(() => new EnvVarSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EnvVarSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[46]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvVarSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvVarSource(EnvVarSource other) : this() {
      fieldRef_ = other.fieldRef_ != null ? other.fieldRef_.Clone() : null;
      resourceFieldRef_ = other.resourceFieldRef_ != null ? other.resourceFieldRef_.Clone() : null;
      configMapKeyRef_ = other.configMapKeyRef_ != null ? other.configMapKeyRef_.Clone() : null;
      secretKeyRef_ = other.secretKeyRef_ != null ? other.secretKeyRef_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EnvVarSource Clone() {
      return new EnvVarSource(this);
    }

    /// <summary>Field number for the "fieldRef" field.</summary>
    public const int FieldRefFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.ObjectFieldSelector fieldRef_;
    /// <summary>
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['&lt;KEY>']`, `metadata.annotations['&lt;KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ObjectFieldSelector FieldRef {
      get { return fieldRef_; }
      set {
        fieldRef_ = value;
      }
    }

    /// <summary>Field number for the "resourceFieldRef" field.</summary>
    public const int ResourceFieldRefFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ResourceFieldSelector resourceFieldRef_;
    /// <summary>
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ResourceFieldSelector ResourceFieldRef {
      get { return resourceFieldRef_; }
      set {
        resourceFieldRef_ = value;
      }
    }

    /// <summary>Field number for the "configMapKeyRef" field.</summary>
    public const int ConfigMapKeyRefFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.ConfigMapKeySelector configMapKeyRef_;
    /// <summary>
    /// Selects a key of a ConfigMap.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ConfigMapKeySelector ConfigMapKeyRef {
      get { return configMapKeyRef_; }
      set {
        configMapKeyRef_ = value;
      }
    }

    /// <summary>Field number for the "secretKeyRef" field.</summary>
    public const int SecretKeyRefFieldNumber = 4;
    private global::K8S.Io.Api.Core.V1.SecretKeySelector secretKeyRef_;
    /// <summary>
    /// Selects a key of a secret in the pod's namespace
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretKeySelector SecretKeyRef {
      get { return secretKeyRef_; }
      set {
        secretKeyRef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EnvVarSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EnvVarSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FieldRef, other.FieldRef)) return false;
      if (!object.Equals(ResourceFieldRef, other.ResourceFieldRef)) return false;
      if (!object.Equals(ConfigMapKeyRef, other.ConfigMapKeyRef)) return false;
      if (!object.Equals(SecretKeyRef, other.SecretKeyRef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (fieldRef_ != null) hash ^= FieldRef.GetHashCode();
      if (resourceFieldRef_ != null) hash ^= ResourceFieldRef.GetHashCode();
      if (configMapKeyRef_ != null) hash ^= ConfigMapKeyRef.GetHashCode();
      if (secretKeyRef_ != null) hash ^= SecretKeyRef.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (fieldRef_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FieldRef);
      }
      if (resourceFieldRef_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ResourceFieldRef);
      }
      if (configMapKeyRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ConfigMapKeyRef);
      }
      if (secretKeyRef_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SecretKeyRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (fieldRef_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FieldRef);
      }
      if (resourceFieldRef_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ResourceFieldRef);
      }
      if (configMapKeyRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ConfigMapKeyRef);
      }
      if (secretKeyRef_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(SecretKeyRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (fieldRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FieldRef);
      }
      if (resourceFieldRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ResourceFieldRef);
      }
      if (configMapKeyRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigMapKeyRef);
      }
      if (secretKeyRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretKeyRef);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EnvVarSource other) {
      if (other == null) {
        return;
      }
      if (other.fieldRef_ != null) {
        if (fieldRef_ == null) {
          FieldRef = new global::K8S.Io.Api.Core.V1.ObjectFieldSelector();
        }
        FieldRef.MergeFrom(other.FieldRef);
      }
      if (other.resourceFieldRef_ != null) {
        if (resourceFieldRef_ == null) {
          ResourceFieldRef = new global::K8S.Io.Api.Core.V1.ResourceFieldSelector();
        }
        ResourceFieldRef.MergeFrom(other.ResourceFieldRef);
      }
      if (other.configMapKeyRef_ != null) {
        if (configMapKeyRef_ == null) {
          ConfigMapKeyRef = new global::K8S.Io.Api.Core.V1.ConfigMapKeySelector();
        }
        ConfigMapKeyRef.MergeFrom(other.ConfigMapKeyRef);
      }
      if (other.secretKeyRef_ != null) {
        if (secretKeyRef_ == null) {
          SecretKeyRef = new global::K8S.Io.Api.Core.V1.SecretKeySelector();
        }
        SecretKeyRef.MergeFrom(other.SecretKeyRef);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (fieldRef_ == null) {
              FieldRef = new global::K8S.Io.Api.Core.V1.ObjectFieldSelector();
            }
            input.ReadMessage(FieldRef);
            break;
          }
          case 18: {
            if (resourceFieldRef_ == null) {
              ResourceFieldRef = new global::K8S.Io.Api.Core.V1.ResourceFieldSelector();
            }
            input.ReadMessage(ResourceFieldRef);
            break;
          }
          case 26: {
            if (configMapKeyRef_ == null) {
              ConfigMapKeyRef = new global::K8S.Io.Api.Core.V1.ConfigMapKeySelector();
            }
            input.ReadMessage(ConfigMapKeyRef);
            break;
          }
          case 34: {
            if (secretKeyRef_ == null) {
              SecretKeyRef = new global::K8S.Io.Api.Core.V1.SecretKeySelector();
            }
            input.ReadMessage(SecretKeyRef);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (fieldRef_ == null) {
              FieldRef = new global::K8S.Io.Api.Core.V1.ObjectFieldSelector();
            }
            input.ReadMessage(FieldRef);
            break;
          }
          case 18: {
            if (resourceFieldRef_ == null) {
              ResourceFieldRef = new global::K8S.Io.Api.Core.V1.ResourceFieldSelector();
            }
            input.ReadMessage(ResourceFieldRef);
            break;
          }
          case 26: {
            if (configMapKeyRef_ == null) {
              ConfigMapKeyRef = new global::K8S.Io.Api.Core.V1.ConfigMapKeySelector();
            }
            input.ReadMessage(ConfigMapKeyRef);
            break;
          }
          case 34: {
            if (secretKeyRef_ == null) {
              SecretKeyRef = new global::K8S.Io.Api.Core.V1.SecretKeySelector();
            }
            input.ReadMessage(SecretKeyRef);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// An EphemeralContainer is a container that may be added temporarily to an existing pod for
  /// user-initiated activities such as debugging. Ephemeral containers have no resource or
  /// scheduling guarantees, and they will not be restarted when they exit or when a pod is
  /// removed or restarted. If an ephemeral container causes a pod to exceed its resource
  /// allocation, the pod may be evicted.
  /// Ephemeral containers may not be added by directly updating the pod spec. They must be added
  /// via the pod's ephemeralcontainers subresource, and they will appear in the pod spec
  /// once added.
  /// This is an alpha feature enabled by the EphemeralContainers feature flag.
  /// </summary>
  public sealed partial class EphemeralContainer : pb::IMessage<EphemeralContainer>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EphemeralContainer> _parser = new pb::MessageParser<EphemeralContainer>(() => new EphemeralContainer());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EphemeralContainer> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[47]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EphemeralContainer() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EphemeralContainer(EphemeralContainer other) : this() {
      ephemeralContainerCommon_ = other.ephemeralContainerCommon_ != null ? other.ephemeralContainerCommon_.Clone() : null;
      targetContainerName_ = other.targetContainerName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EphemeralContainer Clone() {
      return new EphemeralContainer(this);
    }

    /// <summary>Field number for the "ephemeralContainerCommon" field.</summary>
    public const int EphemeralContainerCommonFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.EphemeralContainerCommon ephemeralContainerCommon_;
    /// <summary>
    /// Ephemeral containers have all of the fields of Container, plus additional fields
    /// specific to ephemeral containers. Fields in common with Container are in the
    /// following inlined struct so than an EphemeralContainer may easily be converted
    /// to a Container.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.EphemeralContainerCommon EphemeralContainerCommon {
      get { return ephemeralContainerCommon_; }
      set {
        ephemeralContainerCommon_ = value;
      }
    }

    /// <summary>Field number for the "targetContainerName" field.</summary>
    public const int TargetContainerNameFieldNumber = 2;
    private readonly static string TargetContainerNameDefaultValue = "";

    private string targetContainerName_;
    /// <summary>
    /// If set, the name of the container from PodSpec that this ephemeral container targets.
    /// The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
    /// If not set then the ephemeral container is run in whatever namespaces are shared
    /// for the pod. Note that the container runtime must support this feature.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TargetContainerName {
      get { return targetContainerName_ ?? TargetContainerNameDefaultValue; }
      set {
        targetContainerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "targetContainerName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTargetContainerName {
      get { return targetContainerName_ != null; }
    }
    /// <summary>Clears the value of the "targetContainerName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTargetContainerName() {
      targetContainerName_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EphemeralContainer);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EphemeralContainer other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(EphemeralContainerCommon, other.EphemeralContainerCommon)) return false;
      if (TargetContainerName != other.TargetContainerName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (ephemeralContainerCommon_ != null) hash ^= EphemeralContainerCommon.GetHashCode();
      if (HasTargetContainerName) hash ^= TargetContainerName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (ephemeralContainerCommon_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(EphemeralContainerCommon);
      }
      if (HasTargetContainerName) {
        output.WriteRawTag(18);
        output.WriteString(TargetContainerName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (ephemeralContainerCommon_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(EphemeralContainerCommon);
      }
      if (HasTargetContainerName) {
        output.WriteRawTag(18);
        output.WriteString(TargetContainerName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (ephemeralContainerCommon_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EphemeralContainerCommon);
      }
      if (HasTargetContainerName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TargetContainerName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EphemeralContainer other) {
      if (other == null) {
        return;
      }
      if (other.ephemeralContainerCommon_ != null) {
        if (ephemeralContainerCommon_ == null) {
          EphemeralContainerCommon = new global::K8S.Io.Api.Core.V1.EphemeralContainerCommon();
        }
        EphemeralContainerCommon.MergeFrom(other.EphemeralContainerCommon);
      }
      if (other.HasTargetContainerName) {
        TargetContainerName = other.TargetContainerName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (ephemeralContainerCommon_ == null) {
              EphemeralContainerCommon = new global::K8S.Io.Api.Core.V1.EphemeralContainerCommon();
            }
            input.ReadMessage(EphemeralContainerCommon);
            break;
          }
          case 18: {
            TargetContainerName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (ephemeralContainerCommon_ == null) {
              EphemeralContainerCommon = new global::K8S.Io.Api.Core.V1.EphemeralContainerCommon();
            }
            input.ReadMessage(EphemeralContainerCommon);
            break;
          }
          case 18: {
            TargetContainerName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EphemeralContainerCommon is a copy of all fields in Container to be inlined in
  /// EphemeralContainer. This separate type allows easy conversion from EphemeralContainer
  /// to Container and allows separate documentation for the fields of EphemeralContainer.
  /// When a new field is added to Container it must be added here as well.
  /// </summary>
  public sealed partial class EphemeralContainerCommon : pb::IMessage<EphemeralContainerCommon>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EphemeralContainerCommon> _parser = new pb::MessageParser<EphemeralContainerCommon>(() => new EphemeralContainerCommon());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EphemeralContainerCommon> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[48]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EphemeralContainerCommon() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EphemeralContainerCommon(EphemeralContainerCommon other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      image_ = other.image_;
      command_ = other.command_.Clone();
      args_ = other.args_.Clone();
      workingDir_ = other.workingDir_;
      ports_ = other.ports_.Clone();
      envFrom_ = other.envFrom_.Clone();
      env_ = other.env_.Clone();
      resources_ = other.resources_ != null ? other.resources_.Clone() : null;
      volumeMounts_ = other.volumeMounts_.Clone();
      volumeDevices_ = other.volumeDevices_.Clone();
      livenessProbe_ = other.livenessProbe_ != null ? other.livenessProbe_.Clone() : null;
      readinessProbe_ = other.readinessProbe_ != null ? other.readinessProbe_.Clone() : null;
      startupProbe_ = other.startupProbe_ != null ? other.startupProbe_.Clone() : null;
      lifecycle_ = other.lifecycle_ != null ? other.lifecycle_.Clone() : null;
      terminationMessagePath_ = other.terminationMessagePath_;
      terminationMessagePolicy_ = other.terminationMessagePolicy_;
      imagePullPolicy_ = other.imagePullPolicy_;
      securityContext_ = other.securityContext_ != null ? other.securityContext_.Clone() : null;
      stdin_ = other.stdin_;
      stdinOnce_ = other.stdinOnce_;
      tty_ = other.tty_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EphemeralContainerCommon Clone() {
      return new EphemeralContainerCommon(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name of the ephemeral container specified as a DNS_LABEL.
    /// This name must be unique among all containers, init containers and ephemeral containers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "image" field.</summary>
    public const int ImageFieldNumber = 2;
    private readonly static string ImageDefaultValue = "";

    private string image_;
    /// <summary>
    /// Docker image name.
    /// More info: https://kubernetes.io/docs/concepts/containers/images
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Image {
      get { return image_ ?? ImageDefaultValue; }
      set {
        image_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "image" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImage {
      get { return image_ != null; }
    }
    /// <summary>Clears the value of the "image" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImage() {
      image_ = null;
    }

    /// <summary>Field number for the "command" field.</summary>
    public const int CommandFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_command_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> command_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Entrypoint array. Not executed within a shell.
    /// The docker image's ENTRYPOINT is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Command {
      get { return command_; }
    }

    /// <summary>Field number for the "args" field.</summary>
    public const int ArgsFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_args_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> args_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Arguments to the entrypoint.
    /// The docker image's CMD is used if this is not provided.
    /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    /// of whether the variable exists or not. Cannot be updated.
    /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Args {
      get { return args_; }
    }

    /// <summary>Field number for the "workingDir" field.</summary>
    public const int WorkingDirFieldNumber = 5;
    private readonly static string WorkingDirDefaultValue = "";

    private string workingDir_;
    /// <summary>
    /// Container's working directory.
    /// If not specified, the container runtime's default will be used, which
    /// might be configured in the container image.
    /// Cannot be updated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string WorkingDir {
      get { return workingDir_ ?? WorkingDirDefaultValue; }
      set {
        workingDir_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "workingDir" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWorkingDir {
      get { return workingDir_ != null; }
    }
    /// <summary>Clears the value of the "workingDir" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWorkingDir() {
      workingDir_ = null;
    }

    /// <summary>Field number for the "ports" field.</summary>
    public const int PortsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ContainerPort> _repeated_ports_codec
        = pb::FieldCodec.ForMessage(50, global::K8S.Io.Api.Core.V1.ContainerPort.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerPort> ports_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerPort>();
    /// <summary>
    /// Ports are not allowed for ephemeral containers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerPort> Ports {
      get { return ports_; }
    }

    /// <summary>Field number for the "envFrom" field.</summary>
    public const int EnvFromFieldNumber = 19;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.EnvFromSource> _repeated_envFrom_codec
        = pb::FieldCodec.ForMessage(154, global::K8S.Io.Api.Core.V1.EnvFromSource.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvFromSource> envFrom_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvFromSource>();
    /// <summary>
    /// List of sources to populate environment variables in the container.
    /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    /// will be reported as an event when the container is starting. When a key exists in multiple
    /// sources, the value associated with the last source will take precedence.
    /// Values defined by an Env with a duplicate key will take precedence.
    /// Cannot be updated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvFromSource> EnvFrom {
      get { return envFrom_; }
    }

    /// <summary>Field number for the "env" field.</summary>
    public const int EnvFieldNumber = 7;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.EnvVar> _repeated_env_codec
        = pb::FieldCodec.ForMessage(58, global::K8S.Io.Api.Core.V1.EnvVar.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvVar> env_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvVar>();
    /// <summary>
    /// List of environment variables to set in the container.
    /// Cannot be updated.
    /// +optional
    /// +patchMergeKey=name
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EnvVar> Env {
      get { return env_; }
    }

    /// <summary>Field number for the "resources" field.</summary>
    public const int ResourcesFieldNumber = 8;
    private global::K8S.Io.Api.Core.V1.ResourceRequirements resources_;
    /// <summary>
    /// Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
    /// already allocated to the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ResourceRequirements Resources {
      get { return resources_; }
      set {
        resources_ = value;
      }
    }

    /// <summary>Field number for the "volumeMounts" field.</summary>
    public const int VolumeMountsFieldNumber = 9;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.VolumeMount> _repeated_volumeMounts_codec
        = pb::FieldCodec.ForMessage(74, global::K8S.Io.Api.Core.V1.VolumeMount.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeMount> volumeMounts_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeMount>();
    /// <summary>
    /// Pod volumes to mount into the container's filesystem.
    /// Cannot be updated.
    /// +optional
    /// +patchMergeKey=mountPath
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeMount> VolumeMounts {
      get { return volumeMounts_; }
    }

    /// <summary>Field number for the "volumeDevices" field.</summary>
    public const int VolumeDevicesFieldNumber = 21;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.VolumeDevice> _repeated_volumeDevices_codec
        = pb::FieldCodec.ForMessage(170, global::K8S.Io.Api.Core.V1.VolumeDevice.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeDevice> volumeDevices_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeDevice>();
    /// <summary>
    /// volumeDevices is the list of block devices to be used by the container.
    /// +patchMergeKey=devicePath
    /// +patchStrategy=merge
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeDevice> VolumeDevices {
      get { return volumeDevices_; }
    }

    /// <summary>Field number for the "livenessProbe" field.</summary>
    public const int LivenessProbeFieldNumber = 10;
    private global::K8S.Io.Api.Core.V1.Probe livenessProbe_;
    /// <summary>
    /// Probes are not allowed for ephemeral containers.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Probe LivenessProbe {
      get { return livenessProbe_; }
      set {
        livenessProbe_ = value;
      }
    }

    /// <summary>Field number for the "readinessProbe" field.</summary>
    public const int ReadinessProbeFieldNumber = 11;
    private global::K8S.Io.Api.Core.V1.Probe readinessProbe_;
    /// <summary>
    /// Probes are not allowed for ephemeral containers.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Probe ReadinessProbe {
      get { return readinessProbe_; }
      set {
        readinessProbe_ = value;
      }
    }

    /// <summary>Field number for the "startupProbe" field.</summary>
    public const int StartupProbeFieldNumber = 22;
    private global::K8S.Io.Api.Core.V1.Probe startupProbe_;
    /// <summary>
    /// Probes are not allowed for ephemeral containers.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Probe StartupProbe {
      get { return startupProbe_; }
      set {
        startupProbe_ = value;
      }
    }

    /// <summary>Field number for the "lifecycle" field.</summary>
    public const int LifecycleFieldNumber = 12;
    private global::K8S.Io.Api.Core.V1.Lifecycle lifecycle_;
    /// <summary>
    /// Lifecycle is not allowed for ephemeral containers.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Lifecycle Lifecycle {
      get { return lifecycle_; }
      set {
        lifecycle_ = value;
      }
    }

    /// <summary>Field number for the "terminationMessagePath" field.</summary>
    public const int TerminationMessagePathFieldNumber = 13;
    private readonly static string TerminationMessagePathDefaultValue = "";

    private string terminationMessagePath_;
    /// <summary>
    /// Optional: Path at which the file to which the container's termination message
    /// will be written is mounted into the container's filesystem.
    /// Message written is intended to be brief final status, such as an assertion failure message.
    /// Will be truncated by the node if greater than 4096 bytes. The total message length across
    /// all containers will be limited to 12kb.
    /// Defaults to /dev/termination-log.
    /// Cannot be updated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TerminationMessagePath {
      get { return terminationMessagePath_ ?? TerminationMessagePathDefaultValue; }
      set {
        terminationMessagePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "terminationMessagePath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTerminationMessagePath {
      get { return terminationMessagePath_ != null; }
    }
    /// <summary>Clears the value of the "terminationMessagePath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTerminationMessagePath() {
      terminationMessagePath_ = null;
    }

    /// <summary>Field number for the "terminationMessagePolicy" field.</summary>
    public const int TerminationMessagePolicyFieldNumber = 20;
    private readonly static string TerminationMessagePolicyDefaultValue = "";

    private string terminationMessagePolicy_;
    /// <summary>
    /// Indicate how the termination message should be populated. File will use the contents of
    /// terminationMessagePath to populate the container status message on both success and failure.
    /// FallbackToLogsOnError will use the last chunk of container log output if the termination
    /// message file is empty and the container exited with an error.
    /// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    /// Defaults to File.
    /// Cannot be updated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TerminationMessagePolicy {
      get { return terminationMessagePolicy_ ?? TerminationMessagePolicyDefaultValue; }
      set {
        terminationMessagePolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "terminationMessagePolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTerminationMessagePolicy {
      get { return terminationMessagePolicy_ != null; }
    }
    /// <summary>Clears the value of the "terminationMessagePolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTerminationMessagePolicy() {
      terminationMessagePolicy_ = null;
    }

    /// <summary>Field number for the "imagePullPolicy" field.</summary>
    public const int ImagePullPolicyFieldNumber = 14;
    private readonly static string ImagePullPolicyDefaultValue = "";

    private string imagePullPolicy_;
    /// <summary>
    /// Image pull policy.
    /// One of Always, Never, IfNotPresent.
    /// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ImagePullPolicy {
      get { return imagePullPolicy_ ?? ImagePullPolicyDefaultValue; }
      set {
        imagePullPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "imagePullPolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImagePullPolicy {
      get { return imagePullPolicy_ != null; }
    }
    /// <summary>Clears the value of the "imagePullPolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImagePullPolicy() {
      imagePullPolicy_ = null;
    }

    /// <summary>Field number for the "securityContext" field.</summary>
    public const int SecurityContextFieldNumber = 15;
    private global::K8S.Io.Api.Core.V1.SecurityContext securityContext_;
    /// <summary>
    /// Optional: SecurityContext defines the security options the ephemeral container should be run with.
    /// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecurityContext SecurityContext {
      get { return securityContext_; }
      set {
        securityContext_ = value;
      }
    }

    /// <summary>Field number for the "stdin" field.</summary>
    public const int StdinFieldNumber = 16;
    private readonly static bool StdinDefaultValue = false;

    private bool stdin_;
    /// <summary>
    /// Whether this container should allocate a buffer for stdin in the container runtime. If this
    /// is not set, reads from stdin in the container will always result in EOF.
    /// Default is false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Stdin {
      get { if ((_hasBits0 & 1) != 0) { return stdin_; } else { return StdinDefaultValue; } }
      set {
        _hasBits0 |= 1;
        stdin_ = value;
      }
    }
    /// <summary>Gets whether the "stdin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStdin {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "stdin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStdin() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "stdinOnce" field.</summary>
    public const int StdinOnceFieldNumber = 17;
    private readonly static bool StdinOnceDefaultValue = false;

    private bool stdinOnce_;
    /// <summary>
    /// Whether the container runtime should close the stdin channel after it has been opened by
    /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
    /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
    /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
    /// at which time stdin is closed and remains closed until the container is restarted. If this
    /// flag is false, a container processes that reads from stdin will never receive an EOF.
    /// Default is false
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool StdinOnce {
      get { if ((_hasBits0 & 2) != 0) { return stdinOnce_; } else { return StdinOnceDefaultValue; } }
      set {
        _hasBits0 |= 2;
        stdinOnce_ = value;
      }
    }
    /// <summary>Gets whether the "stdinOnce" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStdinOnce {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "stdinOnce" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStdinOnce() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "tty" field.</summary>
    public const int TtyFieldNumber = 18;
    private readonly static bool TtyDefaultValue = false;

    private bool tty_;
    /// <summary>
    /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
    /// Default is false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Tty {
      get { if ((_hasBits0 & 4) != 0) { return tty_; } else { return TtyDefaultValue; } }
      set {
        _hasBits0 |= 4;
        tty_ = value;
      }
    }
    /// <summary>Gets whether the "tty" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTty {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "tty" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTty() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EphemeralContainerCommon);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EphemeralContainerCommon other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Image != other.Image) return false;
      if(!command_.Equals(other.command_)) return false;
      if(!args_.Equals(other.args_)) return false;
      if (WorkingDir != other.WorkingDir) return false;
      if(!ports_.Equals(other.ports_)) return false;
      if(!envFrom_.Equals(other.envFrom_)) return false;
      if(!env_.Equals(other.env_)) return false;
      if (!object.Equals(Resources, other.Resources)) return false;
      if(!volumeMounts_.Equals(other.volumeMounts_)) return false;
      if(!volumeDevices_.Equals(other.volumeDevices_)) return false;
      if (!object.Equals(LivenessProbe, other.LivenessProbe)) return false;
      if (!object.Equals(ReadinessProbe, other.ReadinessProbe)) return false;
      if (!object.Equals(StartupProbe, other.StartupProbe)) return false;
      if (!object.Equals(Lifecycle, other.Lifecycle)) return false;
      if (TerminationMessagePath != other.TerminationMessagePath) return false;
      if (TerminationMessagePolicy != other.TerminationMessagePolicy) return false;
      if (ImagePullPolicy != other.ImagePullPolicy) return false;
      if (!object.Equals(SecurityContext, other.SecurityContext)) return false;
      if (Stdin != other.Stdin) return false;
      if (StdinOnce != other.StdinOnce) return false;
      if (Tty != other.Tty) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasImage) hash ^= Image.GetHashCode();
      hash ^= command_.GetHashCode();
      hash ^= args_.GetHashCode();
      if (HasWorkingDir) hash ^= WorkingDir.GetHashCode();
      hash ^= ports_.GetHashCode();
      hash ^= envFrom_.GetHashCode();
      hash ^= env_.GetHashCode();
      if (resources_ != null) hash ^= Resources.GetHashCode();
      hash ^= volumeMounts_.GetHashCode();
      hash ^= volumeDevices_.GetHashCode();
      if (livenessProbe_ != null) hash ^= LivenessProbe.GetHashCode();
      if (readinessProbe_ != null) hash ^= ReadinessProbe.GetHashCode();
      if (startupProbe_ != null) hash ^= StartupProbe.GetHashCode();
      if (lifecycle_ != null) hash ^= Lifecycle.GetHashCode();
      if (HasTerminationMessagePath) hash ^= TerminationMessagePath.GetHashCode();
      if (HasTerminationMessagePolicy) hash ^= TerminationMessagePolicy.GetHashCode();
      if (HasImagePullPolicy) hash ^= ImagePullPolicy.GetHashCode();
      if (securityContext_ != null) hash ^= SecurityContext.GetHashCode();
      if (HasStdin) hash ^= Stdin.GetHashCode();
      if (HasStdinOnce) hash ^= StdinOnce.GetHashCode();
      if (HasTty) hash ^= Tty.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasImage) {
        output.WriteRawTag(18);
        output.WriteString(Image);
      }
      command_.WriteTo(output, _repeated_command_codec);
      args_.WriteTo(output, _repeated_args_codec);
      if (HasWorkingDir) {
        output.WriteRawTag(42);
        output.WriteString(WorkingDir);
      }
      ports_.WriteTo(output, _repeated_ports_codec);
      env_.WriteTo(output, _repeated_env_codec);
      if (resources_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Resources);
      }
      volumeMounts_.WriteTo(output, _repeated_volumeMounts_codec);
      if (livenessProbe_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(LivenessProbe);
      }
      if (readinessProbe_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(ReadinessProbe);
      }
      if (lifecycle_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Lifecycle);
      }
      if (HasTerminationMessagePath) {
        output.WriteRawTag(106);
        output.WriteString(TerminationMessagePath);
      }
      if (HasImagePullPolicy) {
        output.WriteRawTag(114);
        output.WriteString(ImagePullPolicy);
      }
      if (securityContext_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(SecurityContext);
      }
      if (HasStdin) {
        output.WriteRawTag(128, 1);
        output.WriteBool(Stdin);
      }
      if (HasStdinOnce) {
        output.WriteRawTag(136, 1);
        output.WriteBool(StdinOnce);
      }
      if (HasTty) {
        output.WriteRawTag(144, 1);
        output.WriteBool(Tty);
      }
      envFrom_.WriteTo(output, _repeated_envFrom_codec);
      if (HasTerminationMessagePolicy) {
        output.WriteRawTag(162, 1);
        output.WriteString(TerminationMessagePolicy);
      }
      volumeDevices_.WriteTo(output, _repeated_volumeDevices_codec);
      if (startupProbe_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(StartupProbe);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasImage) {
        output.WriteRawTag(18);
        output.WriteString(Image);
      }
      command_.WriteTo(ref output, _repeated_command_codec);
      args_.WriteTo(ref output, _repeated_args_codec);
      if (HasWorkingDir) {
        output.WriteRawTag(42);
        output.WriteString(WorkingDir);
      }
      ports_.WriteTo(ref output, _repeated_ports_codec);
      env_.WriteTo(ref output, _repeated_env_codec);
      if (resources_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Resources);
      }
      volumeMounts_.WriteTo(ref output, _repeated_volumeMounts_codec);
      if (livenessProbe_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(LivenessProbe);
      }
      if (readinessProbe_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(ReadinessProbe);
      }
      if (lifecycle_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Lifecycle);
      }
      if (HasTerminationMessagePath) {
        output.WriteRawTag(106);
        output.WriteString(TerminationMessagePath);
      }
      if (HasImagePullPolicy) {
        output.WriteRawTag(114);
        output.WriteString(ImagePullPolicy);
      }
      if (securityContext_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(SecurityContext);
      }
      if (HasStdin) {
        output.WriteRawTag(128, 1);
        output.WriteBool(Stdin);
      }
      if (HasStdinOnce) {
        output.WriteRawTag(136, 1);
        output.WriteBool(StdinOnce);
      }
      if (HasTty) {
        output.WriteRawTag(144, 1);
        output.WriteBool(Tty);
      }
      envFrom_.WriteTo(ref output, _repeated_envFrom_codec);
      if (HasTerminationMessagePolicy) {
        output.WriteRawTag(162, 1);
        output.WriteString(TerminationMessagePolicy);
      }
      volumeDevices_.WriteTo(ref output, _repeated_volumeDevices_codec);
      if (startupProbe_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(StartupProbe);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasImage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Image);
      }
      size += command_.CalculateSize(_repeated_command_codec);
      size += args_.CalculateSize(_repeated_args_codec);
      if (HasWorkingDir) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WorkingDir);
      }
      size += ports_.CalculateSize(_repeated_ports_codec);
      size += envFrom_.CalculateSize(_repeated_envFrom_codec);
      size += env_.CalculateSize(_repeated_env_codec);
      if (resources_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Resources);
      }
      size += volumeMounts_.CalculateSize(_repeated_volumeMounts_codec);
      size += volumeDevices_.CalculateSize(_repeated_volumeDevices_codec);
      if (livenessProbe_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LivenessProbe);
      }
      if (readinessProbe_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ReadinessProbe);
      }
      if (startupProbe_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(StartupProbe);
      }
      if (lifecycle_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lifecycle);
      }
      if (HasTerminationMessagePath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TerminationMessagePath);
      }
      if (HasTerminationMessagePolicy) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(TerminationMessagePolicy);
      }
      if (HasImagePullPolicy) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ImagePullPolicy);
      }
      if (securityContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecurityContext);
      }
      if (HasStdin) {
        size += 2 + 1;
      }
      if (HasStdinOnce) {
        size += 2 + 1;
      }
      if (HasTty) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EphemeralContainerCommon other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasImage) {
        Image = other.Image;
      }
      command_.Add(other.command_);
      args_.Add(other.args_);
      if (other.HasWorkingDir) {
        WorkingDir = other.WorkingDir;
      }
      ports_.Add(other.ports_);
      envFrom_.Add(other.envFrom_);
      env_.Add(other.env_);
      if (other.resources_ != null) {
        if (resources_ == null) {
          Resources = new global::K8S.Io.Api.Core.V1.ResourceRequirements();
        }
        Resources.MergeFrom(other.Resources);
      }
      volumeMounts_.Add(other.volumeMounts_);
      volumeDevices_.Add(other.volumeDevices_);
      if (other.livenessProbe_ != null) {
        if (livenessProbe_ == null) {
          LivenessProbe = new global::K8S.Io.Api.Core.V1.Probe();
        }
        LivenessProbe.MergeFrom(other.LivenessProbe);
      }
      if (other.readinessProbe_ != null) {
        if (readinessProbe_ == null) {
          ReadinessProbe = new global::K8S.Io.Api.Core.V1.Probe();
        }
        ReadinessProbe.MergeFrom(other.ReadinessProbe);
      }
      if (other.startupProbe_ != null) {
        if (startupProbe_ == null) {
          StartupProbe = new global::K8S.Io.Api.Core.V1.Probe();
        }
        StartupProbe.MergeFrom(other.StartupProbe);
      }
      if (other.lifecycle_ != null) {
        if (lifecycle_ == null) {
          Lifecycle = new global::K8S.Io.Api.Core.V1.Lifecycle();
        }
        Lifecycle.MergeFrom(other.Lifecycle);
      }
      if (other.HasTerminationMessagePath) {
        TerminationMessagePath = other.TerminationMessagePath;
      }
      if (other.HasTerminationMessagePolicy) {
        TerminationMessagePolicy = other.TerminationMessagePolicy;
      }
      if (other.HasImagePullPolicy) {
        ImagePullPolicy = other.ImagePullPolicy;
      }
      if (other.securityContext_ != null) {
        if (securityContext_ == null) {
          SecurityContext = new global::K8S.Io.Api.Core.V1.SecurityContext();
        }
        SecurityContext.MergeFrom(other.SecurityContext);
      }
      if (other.HasStdin) {
        Stdin = other.Stdin;
      }
      if (other.HasStdinOnce) {
        StdinOnce = other.StdinOnce;
      }
      if (other.HasTty) {
        Tty = other.Tty;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Image = input.ReadString();
            break;
          }
          case 26: {
            command_.AddEntriesFrom(input, _repeated_command_codec);
            break;
          }
          case 34: {
            args_.AddEntriesFrom(input, _repeated_args_codec);
            break;
          }
          case 42: {
            WorkingDir = input.ReadString();
            break;
          }
          case 50: {
            ports_.AddEntriesFrom(input, _repeated_ports_codec);
            break;
          }
          case 58: {
            env_.AddEntriesFrom(input, _repeated_env_codec);
            break;
          }
          case 66: {
            if (resources_ == null) {
              Resources = new global::K8S.Io.Api.Core.V1.ResourceRequirements();
            }
            input.ReadMessage(Resources);
            break;
          }
          case 74: {
            volumeMounts_.AddEntriesFrom(input, _repeated_volumeMounts_codec);
            break;
          }
          case 82: {
            if (livenessProbe_ == null) {
              LivenessProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(LivenessProbe);
            break;
          }
          case 90: {
            if (readinessProbe_ == null) {
              ReadinessProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(ReadinessProbe);
            break;
          }
          case 98: {
            if (lifecycle_ == null) {
              Lifecycle = new global::K8S.Io.Api.Core.V1.Lifecycle();
            }
            input.ReadMessage(Lifecycle);
            break;
          }
          case 106: {
            TerminationMessagePath = input.ReadString();
            break;
          }
          case 114: {
            ImagePullPolicy = input.ReadString();
            break;
          }
          case 122: {
            if (securityContext_ == null) {
              SecurityContext = new global::K8S.Io.Api.Core.V1.SecurityContext();
            }
            input.ReadMessage(SecurityContext);
            break;
          }
          case 128: {
            Stdin = input.ReadBool();
            break;
          }
          case 136: {
            StdinOnce = input.ReadBool();
            break;
          }
          case 144: {
            Tty = input.ReadBool();
            break;
          }
          case 154: {
            envFrom_.AddEntriesFrom(input, _repeated_envFrom_codec);
            break;
          }
          case 162: {
            TerminationMessagePolicy = input.ReadString();
            break;
          }
          case 170: {
            volumeDevices_.AddEntriesFrom(input, _repeated_volumeDevices_codec);
            break;
          }
          case 178: {
            if (startupProbe_ == null) {
              StartupProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(StartupProbe);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Image = input.ReadString();
            break;
          }
          case 26: {
            command_.AddEntriesFrom(ref input, _repeated_command_codec);
            break;
          }
          case 34: {
            args_.AddEntriesFrom(ref input, _repeated_args_codec);
            break;
          }
          case 42: {
            WorkingDir = input.ReadString();
            break;
          }
          case 50: {
            ports_.AddEntriesFrom(ref input, _repeated_ports_codec);
            break;
          }
          case 58: {
            env_.AddEntriesFrom(ref input, _repeated_env_codec);
            break;
          }
          case 66: {
            if (resources_ == null) {
              Resources = new global::K8S.Io.Api.Core.V1.ResourceRequirements();
            }
            input.ReadMessage(Resources);
            break;
          }
          case 74: {
            volumeMounts_.AddEntriesFrom(ref input, _repeated_volumeMounts_codec);
            break;
          }
          case 82: {
            if (livenessProbe_ == null) {
              LivenessProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(LivenessProbe);
            break;
          }
          case 90: {
            if (readinessProbe_ == null) {
              ReadinessProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(ReadinessProbe);
            break;
          }
          case 98: {
            if (lifecycle_ == null) {
              Lifecycle = new global::K8S.Io.Api.Core.V1.Lifecycle();
            }
            input.ReadMessage(Lifecycle);
            break;
          }
          case 106: {
            TerminationMessagePath = input.ReadString();
            break;
          }
          case 114: {
            ImagePullPolicy = input.ReadString();
            break;
          }
          case 122: {
            if (securityContext_ == null) {
              SecurityContext = new global::K8S.Io.Api.Core.V1.SecurityContext();
            }
            input.ReadMessage(SecurityContext);
            break;
          }
          case 128: {
            Stdin = input.ReadBool();
            break;
          }
          case 136: {
            StdinOnce = input.ReadBool();
            break;
          }
          case 144: {
            Tty = input.ReadBool();
            break;
          }
          case 154: {
            envFrom_.AddEntriesFrom(ref input, _repeated_envFrom_codec);
            break;
          }
          case 162: {
            TerminationMessagePolicy = input.ReadString();
            break;
          }
          case 170: {
            volumeDevices_.AddEntriesFrom(ref input, _repeated_volumeDevices_codec);
            break;
          }
          case 178: {
            if (startupProbe_ == null) {
              StartupProbe = new global::K8S.Io.Api.Core.V1.Probe();
            }
            input.ReadMessage(StartupProbe);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents an ephemeral volume that is handled by a normal storage driver.
  /// </summary>
  public sealed partial class EphemeralVolumeSource : pb::IMessage<EphemeralVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EphemeralVolumeSource> _parser = new pb::MessageParser<EphemeralVolumeSource>(() => new EphemeralVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EphemeralVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[49]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EphemeralVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EphemeralVolumeSource(EphemeralVolumeSource other) : this() {
      volumeClaimTemplate_ = other.volumeClaimTemplate_ != null ? other.volumeClaimTemplate_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EphemeralVolumeSource Clone() {
      return new EphemeralVolumeSource(this);
    }

    /// <summary>Field number for the "volumeClaimTemplate" field.</summary>
    public const int VolumeClaimTemplateFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.PersistentVolumeClaimTemplate volumeClaimTemplate_;
    /// <summary>
    /// Will be used to create a stand-alone PVC to provision the volume.
    /// The pod in which this EphemeralVolumeSource is embedded will be the
    /// owner of the PVC, i.e. the PVC will be deleted together with the
    /// pod.  The name of the PVC will be `&lt;pod name>-&lt;volume name>` where
    /// `&lt;volume name>` is the name from the `PodSpec.Volumes` array
    /// entry. Pod validation will reject the pod if the concatenated name
    /// is not valid for a PVC (for example, too long).
    ///
    /// An existing PVC with that name that is not owned by the pod
    /// will *not* be used for the pod to avoid using an unrelated
    /// volume by mistake. Starting the pod is then blocked until
    /// the unrelated PVC is removed. If such a pre-created PVC is
    /// meant to be used by the pod, the PVC has to updated with an
    /// owner reference to the pod once the pod exists. Normally
    /// this should not be necessary, but it may be useful when
    /// manually reconstructing a broken cluster.
    ///
    /// This field is read-only and no changes will be made by Kubernetes
    /// to the PVC after it has been created.
    ///
    /// Required, must not be nil.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PersistentVolumeClaimTemplate VolumeClaimTemplate {
      get { return volumeClaimTemplate_; }
      set {
        volumeClaimTemplate_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EphemeralVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EphemeralVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(VolumeClaimTemplate, other.VolumeClaimTemplate)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (volumeClaimTemplate_ != null) hash ^= VolumeClaimTemplate.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (volumeClaimTemplate_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(VolumeClaimTemplate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (volumeClaimTemplate_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(VolumeClaimTemplate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (volumeClaimTemplate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VolumeClaimTemplate);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EphemeralVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.volumeClaimTemplate_ != null) {
        if (volumeClaimTemplate_ == null) {
          VolumeClaimTemplate = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimTemplate();
        }
        VolumeClaimTemplate.MergeFrom(other.VolumeClaimTemplate);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (volumeClaimTemplate_ == null) {
              VolumeClaimTemplate = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimTemplate();
            }
            input.ReadMessage(VolumeClaimTemplate);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (volumeClaimTemplate_ == null) {
              VolumeClaimTemplate = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimTemplate();
            }
            input.ReadMessage(VolumeClaimTemplate);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Event is a report of an event somewhere in the cluster.  Events
  /// have a limited retention time and triggers and messages may evolve
  /// with time.  Event consumers should not rely on the timing of an event
  /// with a given Reason reflecting a consistent underlying trigger, or the
  /// continued existence of events with that Reason.  Events should be
  /// treated as informative, best-effort, supplemental data.
  /// </summary>
  public sealed partial class Event : pb::IMessage<Event>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Event> _parser = new pb::MessageParser<Event>(() => new Event());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Event> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[50]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Event() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Event(Event other) : this() {
      _hasBits0 = other._hasBits0;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      involvedObject_ = other.involvedObject_ != null ? other.involvedObject_.Clone() : null;
      reason_ = other.reason_;
      message_ = other.message_;
      source_ = other.source_ != null ? other.source_.Clone() : null;
      firstTimestamp_ = other.firstTimestamp_ != null ? other.firstTimestamp_.Clone() : null;
      lastTimestamp_ = other.lastTimestamp_ != null ? other.lastTimestamp_.Clone() : null;
      count_ = other.count_;
      type_ = other.type_;
      eventTime_ = other.eventTime_ != null ? other.eventTime_.Clone() : null;
      series_ = other.series_ != null ? other.series_.Clone() : null;
      action_ = other.action_;
      related_ = other.related_ != null ? other.related_.Clone() : null;
      reportingComponent_ = other.reportingComponent_;
      reportingInstance_ = other.reportingInstance_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Event Clone() {
      return new Event(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "involvedObject" field.</summary>
    public const int InvolvedObjectFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ObjectReference involvedObject_;
    /// <summary>
    /// The object that this event is about.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ObjectReference InvolvedObject {
      get { return involvedObject_; }
      set {
        involvedObject_ = value;
      }
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 3;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// This should be a short, machine understandable string that gives the reason
    /// for the transition into the object's current status.
    /// TODO: provide exact specification for format.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 4;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// A human-readable description of the status of this operation.
    /// TODO: decide on maximum length.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "source" field.</summary>
    public const int SourceFieldNumber = 5;
    private global::K8S.Io.Api.Core.V1.EventSource source_;
    /// <summary>
    /// The component reporting this event. Should be a short machine understandable string.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.EventSource Source {
      get { return source_; }
      set {
        source_ = value;
      }
    }

    /// <summary>Field number for the "firstTimestamp" field.</summary>
    public const int FirstTimestampFieldNumber = 6;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time firstTimestamp_;
    /// <summary>
    /// The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time FirstTimestamp {
      get { return firstTimestamp_; }
      set {
        firstTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "lastTimestamp" field.</summary>
    public const int LastTimestampFieldNumber = 7;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time lastTimestamp_;
    /// <summary>
    /// The time at which the most recent occurrence of this event was recorded.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time LastTimestamp {
      get { return lastTimestamp_; }
      set {
        lastTimestamp_ = value;
      }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 8;
    private readonly static int CountDefaultValue = 0;

    private int count_;
    /// <summary>
    /// The number of times this event has occurred.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Count {
      get { if ((_hasBits0 & 1) != 0) { return count_; } else { return CountDefaultValue; } }
      set {
        _hasBits0 |= 1;
        count_ = value;
      }
    }
    /// <summary>Gets whether the "count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCount {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCount() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 9;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Type of this event (Normal, Warning), new types could be added in the future
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "eventTime" field.</summary>
    public const int EventTimeFieldNumber = 10;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.MicroTime eventTime_;
    /// <summary>
    /// Time when this Event was first observed.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.MicroTime EventTime {
      get { return eventTime_; }
      set {
        eventTime_ = value;
      }
    }

    /// <summary>Field number for the "series" field.</summary>
    public const int SeriesFieldNumber = 11;
    private global::K8S.Io.Api.Core.V1.EventSeries series_;
    /// <summary>
    /// Data about the Event series this event represents or nil if it's a singleton Event.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.EventSeries Series {
      get { return series_; }
      set {
        series_ = value;
      }
    }

    /// <summary>Field number for the "action" field.</summary>
    public const int ActionFieldNumber = 12;
    private readonly static string ActionDefaultValue = "";

    private string action_;
    /// <summary>
    /// What action was taken/failed regarding to the Regarding object.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Action {
      get { return action_ ?? ActionDefaultValue; }
      set {
        action_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "action" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAction {
      get { return action_ != null; }
    }
    /// <summary>Clears the value of the "action" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAction() {
      action_ = null;
    }

    /// <summary>Field number for the "related" field.</summary>
    public const int RelatedFieldNumber = 13;
    private global::K8S.Io.Api.Core.V1.ObjectReference related_;
    /// <summary>
    /// Optional secondary object for more complex actions.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ObjectReference Related {
      get { return related_; }
      set {
        related_ = value;
      }
    }

    /// <summary>Field number for the "reportingComponent" field.</summary>
    public const int ReportingComponentFieldNumber = 14;
    private readonly static string ReportingComponentDefaultValue = "";

    private string reportingComponent_;
    /// <summary>
    /// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ReportingComponent {
      get { return reportingComponent_ ?? ReportingComponentDefaultValue; }
      set {
        reportingComponent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reportingComponent" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReportingComponent {
      get { return reportingComponent_ != null; }
    }
    /// <summary>Clears the value of the "reportingComponent" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReportingComponent() {
      reportingComponent_ = null;
    }

    /// <summary>Field number for the "reportingInstance" field.</summary>
    public const int ReportingInstanceFieldNumber = 15;
    private readonly static string ReportingInstanceDefaultValue = "";

    private string reportingInstance_;
    /// <summary>
    /// ID of the controller instance, e.g. `kubelet-xyzf`.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ReportingInstance {
      get { return reportingInstance_ ?? ReportingInstanceDefaultValue; }
      set {
        reportingInstance_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reportingInstance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReportingInstance {
      get { return reportingInstance_ != null; }
    }
    /// <summary>Clears the value of the "reportingInstance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReportingInstance() {
      reportingInstance_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Event);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Event other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(InvolvedObject, other.InvolvedObject)) return false;
      if (Reason != other.Reason) return false;
      if (Message != other.Message) return false;
      if (!object.Equals(Source, other.Source)) return false;
      if (!object.Equals(FirstTimestamp, other.FirstTimestamp)) return false;
      if (!object.Equals(LastTimestamp, other.LastTimestamp)) return false;
      if (Count != other.Count) return false;
      if (Type != other.Type) return false;
      if (!object.Equals(EventTime, other.EventTime)) return false;
      if (!object.Equals(Series, other.Series)) return false;
      if (Action != other.Action) return false;
      if (!object.Equals(Related, other.Related)) return false;
      if (ReportingComponent != other.ReportingComponent) return false;
      if (ReportingInstance != other.ReportingInstance) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (involvedObject_ != null) hash ^= InvolvedObject.GetHashCode();
      if (HasReason) hash ^= Reason.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (source_ != null) hash ^= Source.GetHashCode();
      if (firstTimestamp_ != null) hash ^= FirstTimestamp.GetHashCode();
      if (lastTimestamp_ != null) hash ^= LastTimestamp.GetHashCode();
      if (HasCount) hash ^= Count.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (eventTime_ != null) hash ^= EventTime.GetHashCode();
      if (series_ != null) hash ^= Series.GetHashCode();
      if (HasAction) hash ^= Action.GetHashCode();
      if (related_ != null) hash ^= Related.GetHashCode();
      if (HasReportingComponent) hash ^= ReportingComponent.GetHashCode();
      if (HasReportingInstance) hash ^= ReportingInstance.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (involvedObject_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(InvolvedObject);
      }
      if (HasReason) {
        output.WriteRawTag(26);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(34);
        output.WriteString(Message);
      }
      if (source_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Source);
      }
      if (firstTimestamp_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(FirstTimestamp);
      }
      if (lastTimestamp_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(LastTimestamp);
      }
      if (HasCount) {
        output.WriteRawTag(64);
        output.WriteInt32(Count);
      }
      if (HasType) {
        output.WriteRawTag(74);
        output.WriteString(Type);
      }
      if (eventTime_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(EventTime);
      }
      if (series_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Series);
      }
      if (HasAction) {
        output.WriteRawTag(98);
        output.WriteString(Action);
      }
      if (related_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Related);
      }
      if (HasReportingComponent) {
        output.WriteRawTag(114);
        output.WriteString(ReportingComponent);
      }
      if (HasReportingInstance) {
        output.WriteRawTag(122);
        output.WriteString(ReportingInstance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (involvedObject_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(InvolvedObject);
      }
      if (HasReason) {
        output.WriteRawTag(26);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(34);
        output.WriteString(Message);
      }
      if (source_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Source);
      }
      if (firstTimestamp_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(FirstTimestamp);
      }
      if (lastTimestamp_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(LastTimestamp);
      }
      if (HasCount) {
        output.WriteRawTag(64);
        output.WriteInt32(Count);
      }
      if (HasType) {
        output.WriteRawTag(74);
        output.WriteString(Type);
      }
      if (eventTime_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(EventTime);
      }
      if (series_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Series);
      }
      if (HasAction) {
        output.WriteRawTag(98);
        output.WriteString(Action);
      }
      if (related_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Related);
      }
      if (HasReportingComponent) {
        output.WriteRawTag(114);
        output.WriteString(ReportingComponent);
      }
      if (HasReportingInstance) {
        output.WriteRawTag(122);
        output.WriteString(ReportingInstance);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (involvedObject_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InvolvedObject);
      }
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (source_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Source);
      }
      if (firstTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FirstTimestamp);
      }
      if (lastTimestamp_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastTimestamp);
      }
      if (HasCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (eventTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EventTime);
      }
      if (series_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Series);
      }
      if (HasAction) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Action);
      }
      if (related_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Related);
      }
      if (HasReportingComponent) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ReportingComponent);
      }
      if (HasReportingInstance) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ReportingInstance);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Event other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.involvedObject_ != null) {
        if (involvedObject_ == null) {
          InvolvedObject = new global::K8S.Io.Api.Core.V1.ObjectReference();
        }
        InvolvedObject.MergeFrom(other.InvolvedObject);
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.source_ != null) {
        if (source_ == null) {
          Source = new global::K8S.Io.Api.Core.V1.EventSource();
        }
        Source.MergeFrom(other.Source);
      }
      if (other.firstTimestamp_ != null) {
        if (firstTimestamp_ == null) {
          FirstTimestamp = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        FirstTimestamp.MergeFrom(other.FirstTimestamp);
      }
      if (other.lastTimestamp_ != null) {
        if (lastTimestamp_ == null) {
          LastTimestamp = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        LastTimestamp.MergeFrom(other.LastTimestamp);
      }
      if (other.HasCount) {
        Count = other.Count;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.eventTime_ != null) {
        if (eventTime_ == null) {
          EventTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.MicroTime();
        }
        EventTime.MergeFrom(other.EventTime);
      }
      if (other.series_ != null) {
        if (series_ == null) {
          Series = new global::K8S.Io.Api.Core.V1.EventSeries();
        }
        Series.MergeFrom(other.Series);
      }
      if (other.HasAction) {
        Action = other.Action;
      }
      if (other.related_ != null) {
        if (related_ == null) {
          Related = new global::K8S.Io.Api.Core.V1.ObjectReference();
        }
        Related.MergeFrom(other.Related);
      }
      if (other.HasReportingComponent) {
        ReportingComponent = other.ReportingComponent;
      }
      if (other.HasReportingInstance) {
        ReportingInstance = other.ReportingInstance;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (involvedObject_ == null) {
              InvolvedObject = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(InvolvedObject);
            break;
          }
          case 26: {
            Reason = input.ReadString();
            break;
          }
          case 34: {
            Message = input.ReadString();
            break;
          }
          case 42: {
            if (source_ == null) {
              Source = new global::K8S.Io.Api.Core.V1.EventSource();
            }
            input.ReadMessage(Source);
            break;
          }
          case 50: {
            if (firstTimestamp_ == null) {
              FirstTimestamp = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(FirstTimestamp);
            break;
          }
          case 58: {
            if (lastTimestamp_ == null) {
              LastTimestamp = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTimestamp);
            break;
          }
          case 64: {
            Count = input.ReadInt32();
            break;
          }
          case 74: {
            Type = input.ReadString();
            break;
          }
          case 82: {
            if (eventTime_ == null) {
              EventTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.MicroTime();
            }
            input.ReadMessage(EventTime);
            break;
          }
          case 90: {
            if (series_ == null) {
              Series = new global::K8S.Io.Api.Core.V1.EventSeries();
            }
            input.ReadMessage(Series);
            break;
          }
          case 98: {
            Action = input.ReadString();
            break;
          }
          case 106: {
            if (related_ == null) {
              Related = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(Related);
            break;
          }
          case 114: {
            ReportingComponent = input.ReadString();
            break;
          }
          case 122: {
            ReportingInstance = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (involvedObject_ == null) {
              InvolvedObject = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(InvolvedObject);
            break;
          }
          case 26: {
            Reason = input.ReadString();
            break;
          }
          case 34: {
            Message = input.ReadString();
            break;
          }
          case 42: {
            if (source_ == null) {
              Source = new global::K8S.Io.Api.Core.V1.EventSource();
            }
            input.ReadMessage(Source);
            break;
          }
          case 50: {
            if (firstTimestamp_ == null) {
              FirstTimestamp = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(FirstTimestamp);
            break;
          }
          case 58: {
            if (lastTimestamp_ == null) {
              LastTimestamp = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTimestamp);
            break;
          }
          case 64: {
            Count = input.ReadInt32();
            break;
          }
          case 74: {
            Type = input.ReadString();
            break;
          }
          case 82: {
            if (eventTime_ == null) {
              EventTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.MicroTime();
            }
            input.ReadMessage(EventTime);
            break;
          }
          case 90: {
            if (series_ == null) {
              Series = new global::K8S.Io.Api.Core.V1.EventSeries();
            }
            input.ReadMessage(Series);
            break;
          }
          case 98: {
            Action = input.ReadString();
            break;
          }
          case 106: {
            if (related_ == null) {
              Related = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(Related);
            break;
          }
          case 114: {
            ReportingComponent = input.ReadString();
            break;
          }
          case 122: {
            ReportingInstance = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EventList is a list of events.
  /// </summary>
  public sealed partial class EventList : pb::IMessage<EventList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EventList> _parser = new pb::MessageParser<EventList>(() => new EventList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EventList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[51]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EventList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EventList(EventList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EventList Clone() {
      return new EventList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Event> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.Event.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Event> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Event>();
    /// <summary>
    /// List of events
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Event> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EventList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EventList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EventList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EventSeries contain information on series of events, i.e. thing that was/is happening
  /// continuously for some time.
  /// </summary>
  public sealed partial class EventSeries : pb::IMessage<EventSeries>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EventSeries> _parser = new pb::MessageParser<EventSeries>(() => new EventSeries());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EventSeries> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[52]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EventSeries() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EventSeries(EventSeries other) : this() {
      _hasBits0 = other._hasBits0;
      count_ = other.count_;
      lastObservedTime_ = other.lastObservedTime_ != null ? other.lastObservedTime_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EventSeries Clone() {
      return new EventSeries(this);
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 1;
    private readonly static int CountDefaultValue = 0;

    private int count_;
    /// <summary>
    /// Number of occurrences in this series up to the last heartbeat time
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Count {
      get { if ((_hasBits0 & 1) != 0) { return count_; } else { return CountDefaultValue; } }
      set {
        _hasBits0 |= 1;
        count_ = value;
      }
    }
    /// <summary>Gets whether the "count" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCount {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "count" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCount() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "lastObservedTime" field.</summary>
    public const int LastObservedTimeFieldNumber = 2;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.MicroTime lastObservedTime_;
    /// <summary>
    /// Time of the last occurrence observed
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.MicroTime LastObservedTime {
      get { return lastObservedTime_; }
      set {
        lastObservedTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EventSeries);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EventSeries other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Count != other.Count) return false;
      if (!object.Equals(LastObservedTime, other.LastObservedTime)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCount) hash ^= Count.GetHashCode();
      if (lastObservedTime_ != null) hash ^= LastObservedTime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasCount) {
        output.WriteRawTag(8);
        output.WriteInt32(Count);
      }
      if (lastObservedTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(LastObservedTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasCount) {
        output.WriteRawTag(8);
        output.WriteInt32(Count);
      }
      if (lastObservedTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(LastObservedTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasCount) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
      }
      if (lastObservedTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastObservedTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EventSeries other) {
      if (other == null) {
        return;
      }
      if (other.HasCount) {
        Count = other.Count;
      }
      if (other.lastObservedTime_ != null) {
        if (lastObservedTime_ == null) {
          LastObservedTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.MicroTime();
        }
        LastObservedTime.MergeFrom(other.LastObservedTime);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Count = input.ReadInt32();
            break;
          }
          case 18: {
            if (lastObservedTime_ == null) {
              LastObservedTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.MicroTime();
            }
            input.ReadMessage(LastObservedTime);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Count = input.ReadInt32();
            break;
          }
          case 18: {
            if (lastObservedTime_ == null) {
              LastObservedTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.MicroTime();
            }
            input.ReadMessage(LastObservedTime);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// EventSource contains information for an event.
  /// </summary>
  public sealed partial class EventSource : pb::IMessage<EventSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<EventSource> _parser = new pb::MessageParser<EventSource>(() => new EventSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<EventSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[53]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EventSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EventSource(EventSource other) : this() {
      component_ = other.component_;
      host_ = other.host_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public EventSource Clone() {
      return new EventSource(this);
    }

    /// <summary>Field number for the "component" field.</summary>
    public const int ComponentFieldNumber = 1;
    private readonly static string ComponentDefaultValue = "";

    private string component_;
    /// <summary>
    /// Component from which the event is generated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Component {
      get { return component_ ?? ComponentDefaultValue; }
      set {
        component_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "component" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasComponent {
      get { return component_ != null; }
    }
    /// <summary>Clears the value of the "component" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearComponent() {
      component_ = null;
    }

    /// <summary>Field number for the "host" field.</summary>
    public const int HostFieldNumber = 2;
    private readonly static string HostDefaultValue = "";

    private string host_;
    /// <summary>
    /// Node name on which the event is generated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Host {
      get { return host_ ?? HostDefaultValue; }
      set {
        host_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "host" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHost {
      get { return host_ != null; }
    }
    /// <summary>Clears the value of the "host" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHost() {
      host_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as EventSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(EventSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Component != other.Component) return false;
      if (Host != other.Host) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasComponent) hash ^= Component.GetHashCode();
      if (HasHost) hash ^= Host.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasComponent) {
        output.WriteRawTag(10);
        output.WriteString(Component);
      }
      if (HasHost) {
        output.WriteRawTag(18);
        output.WriteString(Host);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasComponent) {
        output.WriteRawTag(10);
        output.WriteString(Component);
      }
      if (HasHost) {
        output.WriteRawTag(18);
        output.WriteString(Host);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasComponent) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Component);
      }
      if (HasHost) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Host);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(EventSource other) {
      if (other == null) {
        return;
      }
      if (other.HasComponent) {
        Component = other.Component;
      }
      if (other.HasHost) {
        Host = other.Host;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Component = input.ReadString();
            break;
          }
          case 18: {
            Host = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Component = input.ReadString();
            break;
          }
          case 18: {
            Host = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ExecAction describes a "run in container" action.
  /// </summary>
  public sealed partial class ExecAction : pb::IMessage<ExecAction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExecAction> _parser = new pb::MessageParser<ExecAction>(() => new ExecAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ExecAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[54]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExecAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExecAction(ExecAction other) : this() {
      command_ = other.command_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExecAction Clone() {
      return new ExecAction(this);
    }

    /// <summary>Field number for the "command" field.</summary>
    public const int CommandFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_command_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> command_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Command is the command line to execute inside the container, the working directory for the
    /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    /// a shell, you need to explicitly call out to that shell.
    /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Command {
      get { return command_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ExecAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ExecAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!command_.Equals(other.command_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= command_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      command_.WriteTo(output, _repeated_command_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      command_.WriteTo(ref output, _repeated_command_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += command_.CalculateSize(_repeated_command_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ExecAction other) {
      if (other == null) {
        return;
      }
      command_.Add(other.command_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            command_.AddEntriesFrom(input, _repeated_command_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            command_.AddEntriesFrom(ref input, _repeated_command_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Fibre Channel volume.
  /// Fibre Channel volumes can only be mounted as read/write once.
  /// Fibre Channel volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class FCVolumeSource : pb::IMessage<FCVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FCVolumeSource> _parser = new pb::MessageParser<FCVolumeSource>(() => new FCVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FCVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[55]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FCVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FCVolumeSource(FCVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      targetWWNs_ = other.targetWWNs_.Clone();
      lun_ = other.lun_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      wwids_ = other.wwids_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FCVolumeSource Clone() {
      return new FCVolumeSource(this);
    }

    /// <summary>Field number for the "targetWWNs" field.</summary>
    public const int TargetWWNsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_targetWWNs_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> targetWWNs_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional: FC target worldwide names (WWNs)
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> TargetWWNs {
      get { return targetWWNs_; }
    }

    /// <summary>Field number for the "lun" field.</summary>
    public const int LunFieldNumber = 2;
    private readonly static int LunDefaultValue = 0;

    private int lun_;
    /// <summary>
    /// Optional: FC target lun number
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Lun {
      get { if ((_hasBits0 & 1) != 0) { return lun_; } else { return LunDefaultValue; } }
      set {
        _hasBits0 |= 1;
        lun_ = value;
      }
    }
    /// <summary>Gets whether the "lun" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLun {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "lun" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLun() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 3;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 4;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 2) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "wwids" field.</summary>
    public const int WwidsFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_wwids_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> wwids_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Optional: FC volume world wide identifiers (wwids)
    /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Wwids {
      get { return wwids_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FCVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FCVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!targetWWNs_.Equals(other.targetWWNs_)) return false;
      if (Lun != other.Lun) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if(!wwids_.Equals(other.wwids_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= targetWWNs_.GetHashCode();
      if (HasLun) hash ^= Lun.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      hash ^= wwids_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      targetWWNs_.WriteTo(output, _repeated_targetWWNs_codec);
      if (HasLun) {
        output.WriteRawTag(16);
        output.WriteInt32(Lun);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      wwids_.WriteTo(output, _repeated_wwids_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      targetWWNs_.WriteTo(ref output, _repeated_targetWWNs_codec);
      if (HasLun) {
        output.WriteRawTag(16);
        output.WriteInt32(Lun);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      wwids_.WriteTo(ref output, _repeated_wwids_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += targetWWNs_.CalculateSize(_repeated_targetWWNs_codec);
      if (HasLun) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Lun);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      size += wwids_.CalculateSize(_repeated_wwids_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FCVolumeSource other) {
      if (other == null) {
        return;
      }
      targetWWNs_.Add(other.targetWWNs_);
      if (other.HasLun) {
        Lun = other.Lun;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      wwids_.Add(other.wwids_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            targetWWNs_.AddEntriesFrom(input, _repeated_targetWWNs_codec);
            break;
          }
          case 16: {
            Lun = input.ReadInt32();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 42: {
            wwids_.AddEntriesFrom(input, _repeated_wwids_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            targetWWNs_.AddEntriesFrom(ref input, _repeated_targetWWNs_codec);
            break;
          }
          case 16: {
            Lun = input.ReadInt32();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 42: {
            wwids_.AddEntriesFrom(ref input, _repeated_wwids_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// FlexPersistentVolumeSource represents a generic persistent volume resource that is
  /// provisioned/attached using an exec based plugin.
  /// </summary>
  public sealed partial class FlexPersistentVolumeSource : pb::IMessage<FlexPersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FlexPersistentVolumeSource> _parser = new pb::MessageParser<FlexPersistentVolumeSource>(() => new FlexPersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FlexPersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[56]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FlexPersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FlexPersistentVolumeSource(FlexPersistentVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      driver_ = other.driver_;
      fsType_ = other.fsType_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      readOnly_ = other.readOnly_;
      options_ = other.options_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FlexPersistentVolumeSource Clone() {
      return new FlexPersistentVolumeSource(this);
    }

    /// <summary>Field number for the "driver" field.</summary>
    public const int DriverFieldNumber = 1;
    private readonly static string DriverDefaultValue = "";

    private string driver_;
    /// <summary>
    /// Driver is the name of the driver to use for this volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Driver {
      get { return driver_ ?? DriverDefaultValue; }
      set {
        driver_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "driver" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDriver {
      get { return driver_ != null; }
    }
    /// <summary>Clears the value of the "driver" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDriver() {
      driver_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 2;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.SecretReference secretRef_;
    /// <summary>
    /// Optional: SecretRef is reference to the secret object containing
    /// sensitive information to pass to the plugin scripts. This may be
    /// empty if no secret object is specified. If the secret object
    /// contains more than one secret, all secrets are passed to the plugin
    /// scripts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 4;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "options" field.</summary>
    public const int OptionsFieldNumber = 5;
    private static readonly pbc::MapField<string, string>.Codec _map_options_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 42);
    private readonly pbc::MapField<string, string> options_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional: Extra command options if any.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> Options {
      get { return options_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FlexPersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FlexPersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Driver != other.Driver) return false;
      if (FsType != other.FsType) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (!Options.Equals(other.Options)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDriver) hash ^= Driver.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      hash ^= Options.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDriver) {
        output.WriteRawTag(10);
        output.WriteString(Driver);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      options_.WriteTo(output, _map_options_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDriver) {
        output.WriteRawTag(10);
        output.WriteString(Driver);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      options_.WriteTo(ref output, _map_options_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDriver) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Driver);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      size += options_.CalculateSize(_map_options_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FlexPersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasDriver) {
        Driver = other.Driver;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      options_.Add(other.options_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Driver = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 26: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 42: {
            options_.AddEntriesFrom(input, _map_options_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Driver = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 26: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 42: {
            options_.AddEntriesFrom(ref input, _map_options_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// FlexVolume represents a generic volume resource that is
  /// provisioned/attached using an exec based plugin.
  /// </summary>
  public sealed partial class FlexVolumeSource : pb::IMessage<FlexVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FlexVolumeSource> _parser = new pb::MessageParser<FlexVolumeSource>(() => new FlexVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FlexVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[57]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FlexVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FlexVolumeSource(FlexVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      driver_ = other.driver_;
      fsType_ = other.fsType_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      readOnly_ = other.readOnly_;
      options_ = other.options_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FlexVolumeSource Clone() {
      return new FlexVolumeSource(this);
    }

    /// <summary>Field number for the "driver" field.</summary>
    public const int DriverFieldNumber = 1;
    private readonly static string DriverDefaultValue = "";

    private string driver_;
    /// <summary>
    /// Driver is the name of the driver to use for this volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Driver {
      get { return driver_ ?? DriverDefaultValue; }
      set {
        driver_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "driver" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDriver {
      get { return driver_ != null; }
    }
    /// <summary>Clears the value of the "driver" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDriver() {
      driver_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 2;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference secretRef_;
    /// <summary>
    /// Optional: SecretRef is reference to the secret object containing
    /// sensitive information to pass to the plugin scripts. This may be
    /// empty if no secret object is specified. If the secret object
    /// contains more than one secret, all secrets are passed to the plugin
    /// scripts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 4;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Optional: Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "options" field.</summary>
    public const int OptionsFieldNumber = 5;
    private static readonly pbc::MapField<string, string>.Codec _map_options_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 42);
    private readonly pbc::MapField<string, string> options_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Optional: Extra command options if any.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> Options {
      get { return options_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FlexVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FlexVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Driver != other.Driver) return false;
      if (FsType != other.FsType) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (!Options.Equals(other.Options)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDriver) hash ^= Driver.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      hash ^= Options.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDriver) {
        output.WriteRawTag(10);
        output.WriteString(Driver);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      options_.WriteTo(output, _map_options_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDriver) {
        output.WriteRawTag(10);
        output.WriteString(Driver);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      options_.WriteTo(ref output, _map_options_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDriver) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Driver);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      size += options_.CalculateSize(_map_options_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FlexVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasDriver) {
        Driver = other.Driver;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      options_.Add(other.options_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Driver = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 26: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 42: {
            options_.AddEntriesFrom(input, _map_options_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Driver = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 26: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 42: {
            options_.AddEntriesFrom(ref input, _map_options_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Flocker volume mounted by the Flocker agent.
  /// One and only one of datasetName and datasetUUID should be set.
  /// Flocker volumes do not support ownership management or SELinux relabeling.
  /// </summary>
  public sealed partial class FlockerVolumeSource : pb::IMessage<FlockerVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FlockerVolumeSource> _parser = new pb::MessageParser<FlockerVolumeSource>(() => new FlockerVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<FlockerVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[58]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FlockerVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FlockerVolumeSource(FlockerVolumeSource other) : this() {
      datasetName_ = other.datasetName_;
      datasetUUID_ = other.datasetUUID_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public FlockerVolumeSource Clone() {
      return new FlockerVolumeSource(this);
    }

    /// <summary>Field number for the "datasetName" field.</summary>
    public const int DatasetNameFieldNumber = 1;
    private readonly static string DatasetNameDefaultValue = "";

    private string datasetName_;
    /// <summary>
    /// Name of the dataset stored as metadata -> name on the dataset for Flocker
    /// should be considered as deprecated
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DatasetName {
      get { return datasetName_ ?? DatasetNameDefaultValue; }
      set {
        datasetName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "datasetName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDatasetName {
      get { return datasetName_ != null; }
    }
    /// <summary>Clears the value of the "datasetName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDatasetName() {
      datasetName_ = null;
    }

    /// <summary>Field number for the "datasetUUID" field.</summary>
    public const int DatasetUUIDFieldNumber = 2;
    private readonly static string DatasetUUIDDefaultValue = "";

    private string datasetUUID_;
    /// <summary>
    /// UUID of the dataset. This is unique identifier of a Flocker dataset
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DatasetUUID {
      get { return datasetUUID_ ?? DatasetUUIDDefaultValue; }
      set {
        datasetUUID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "datasetUUID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDatasetUUID {
      get { return datasetUUID_ != null; }
    }
    /// <summary>Clears the value of the "datasetUUID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDatasetUUID() {
      datasetUUID_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as FlockerVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(FlockerVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DatasetName != other.DatasetName) return false;
      if (DatasetUUID != other.DatasetUUID) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasDatasetName) hash ^= DatasetName.GetHashCode();
      if (HasDatasetUUID) hash ^= DatasetUUID.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasDatasetName) {
        output.WriteRawTag(10);
        output.WriteString(DatasetName);
      }
      if (HasDatasetUUID) {
        output.WriteRawTag(18);
        output.WriteString(DatasetUUID);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasDatasetName) {
        output.WriteRawTag(10);
        output.WriteString(DatasetName);
      }
      if (HasDatasetUUID) {
        output.WriteRawTag(18);
        output.WriteString(DatasetUUID);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasDatasetName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DatasetName);
      }
      if (HasDatasetUUID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DatasetUUID);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(FlockerVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasDatasetName) {
        DatasetName = other.DatasetName;
      }
      if (other.HasDatasetUUID) {
        DatasetUUID = other.DatasetUUID;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            DatasetName = input.ReadString();
            break;
          }
          case 18: {
            DatasetUUID = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            DatasetName = input.ReadString();
            break;
          }
          case 18: {
            DatasetUUID = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Persistent Disk resource in Google Compute Engine.
  ///
  /// A GCE PD must exist before mounting to a container. The disk must
  /// also be in the same GCE project and zone as the kubelet. A GCE PD
  /// can only be mounted as read/write once or read-only many times. GCE
  /// PDs support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class GCEPersistentDiskVolumeSource : pb::IMessage<GCEPersistentDiskVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GCEPersistentDiskVolumeSource> _parser = new pb::MessageParser<GCEPersistentDiskVolumeSource>(() => new GCEPersistentDiskVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GCEPersistentDiskVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[59]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GCEPersistentDiskVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GCEPersistentDiskVolumeSource(GCEPersistentDiskVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      pdName_ = other.pdName_;
      fsType_ = other.fsType_;
      partition_ = other.partition_;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GCEPersistentDiskVolumeSource Clone() {
      return new GCEPersistentDiskVolumeSource(this);
    }

    /// <summary>Field number for the "pdName" field.</summary>
    public const int PdNameFieldNumber = 1;
    private readonly static string PdNameDefaultValue = "";

    private string pdName_;
    /// <summary>
    /// Unique name of the PD resource in GCE. Used to identify the disk in GCE.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PdName {
      get { return pdName_ ?? PdNameDefaultValue; }
      set {
        pdName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "pdName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPdName {
      get { return pdName_ != null; }
    }
    /// <summary>Clears the value of the "pdName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPdName() {
      pdName_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 2;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "partition" field.</summary>
    public const int PartitionFieldNumber = 3;
    private readonly static int PartitionDefaultValue = 0;

    private int partition_;
    /// <summary>
    /// The partition in the volume that you want to mount.
    /// If omitted, the default is to mount by volume name.
    /// Examples: For volume /dev/sda1, you specify the partition as "1".
    /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Partition {
      get { if ((_hasBits0 & 1) != 0) { return partition_; } else { return PartitionDefaultValue; } }
      set {
        _hasBits0 |= 1;
        partition_ = value;
      }
    }
    /// <summary>Gets whether the "partition" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPartition {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "partition" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPartition() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 4;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// ReadOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 2) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GCEPersistentDiskVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GCEPersistentDiskVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PdName != other.PdName) return false;
      if (FsType != other.FsType) return false;
      if (Partition != other.Partition) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPdName) hash ^= PdName.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasPartition) hash ^= Partition.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPdName) {
        output.WriteRawTag(10);
        output.WriteString(PdName);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasPartition) {
        output.WriteRawTag(24);
        output.WriteInt32(Partition);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPdName) {
        output.WriteRawTag(10);
        output.WriteString(PdName);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasPartition) {
        output.WriteRawTag(24);
        output.WriteInt32(Partition);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPdName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PdName);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasPartition) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Partition);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GCEPersistentDiskVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasPdName) {
        PdName = other.PdName;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasPartition) {
        Partition = other.Partition;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PdName = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 24: {
            Partition = input.ReadInt32();
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PdName = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 24: {
            Partition = input.ReadInt32();
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a volume that is populated with the contents of a git repository.
  /// Git repo volumes do not support ownership management.
  /// Git repo volumes support SELinux relabeling.
  ///
  /// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
  /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
  /// into the Pod's container.
  /// </summary>
  public sealed partial class GitRepoVolumeSource : pb::IMessage<GitRepoVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GitRepoVolumeSource> _parser = new pb::MessageParser<GitRepoVolumeSource>(() => new GitRepoVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GitRepoVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[60]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GitRepoVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GitRepoVolumeSource(GitRepoVolumeSource other) : this() {
      repository_ = other.repository_;
      revision_ = other.revision_;
      directory_ = other.directory_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GitRepoVolumeSource Clone() {
      return new GitRepoVolumeSource(this);
    }

    /// <summary>Field number for the "repository" field.</summary>
    public const int RepositoryFieldNumber = 1;
    private readonly static string RepositoryDefaultValue = "";

    private string repository_;
    /// <summary>
    /// Repository URL
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Repository {
      get { return repository_ ?? RepositoryDefaultValue; }
      set {
        repository_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "repository" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRepository {
      get { return repository_ != null; }
    }
    /// <summary>Clears the value of the "repository" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRepository() {
      repository_ = null;
    }

    /// <summary>Field number for the "revision" field.</summary>
    public const int RevisionFieldNumber = 2;
    private readonly static string RevisionDefaultValue = "";

    private string revision_;
    /// <summary>
    /// Commit hash for the specified revision.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Revision {
      get { return revision_ ?? RevisionDefaultValue; }
      set {
        revision_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "revision" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRevision {
      get { return revision_ != null; }
    }
    /// <summary>Clears the value of the "revision" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRevision() {
      revision_ = null;
    }

    /// <summary>Field number for the "directory" field.</summary>
    public const int DirectoryFieldNumber = 3;
    private readonly static string DirectoryDefaultValue = "";

    private string directory_;
    /// <summary>
    /// Target directory name.
    /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
    /// git repository.  Otherwise, if specified, the volume will contain the git repository in
    /// the subdirectory with the given name.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Directory {
      get { return directory_ ?? DirectoryDefaultValue; }
      set {
        directory_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "directory" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDirectory {
      get { return directory_ != null; }
    }
    /// <summary>Clears the value of the "directory" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDirectory() {
      directory_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GitRepoVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GitRepoVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Repository != other.Repository) return false;
      if (Revision != other.Revision) return false;
      if (Directory != other.Directory) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRepository) hash ^= Repository.GetHashCode();
      if (HasRevision) hash ^= Revision.GetHashCode();
      if (HasDirectory) hash ^= Directory.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasRepository) {
        output.WriteRawTag(10);
        output.WriteString(Repository);
      }
      if (HasRevision) {
        output.WriteRawTag(18);
        output.WriteString(Revision);
      }
      if (HasDirectory) {
        output.WriteRawTag(26);
        output.WriteString(Directory);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasRepository) {
        output.WriteRawTag(10);
        output.WriteString(Repository);
      }
      if (HasRevision) {
        output.WriteRawTag(18);
        output.WriteString(Revision);
      }
      if (HasDirectory) {
        output.WriteRawTag(26);
        output.WriteString(Directory);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasRepository) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Repository);
      }
      if (HasRevision) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Revision);
      }
      if (HasDirectory) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Directory);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GitRepoVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasRepository) {
        Repository = other.Repository;
      }
      if (other.HasRevision) {
        Revision = other.Revision;
      }
      if (other.HasDirectory) {
        Directory = other.Directory;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Repository = input.ReadString();
            break;
          }
          case 18: {
            Revision = input.ReadString();
            break;
          }
          case 26: {
            Directory = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Repository = input.ReadString();
            break;
          }
          case 18: {
            Revision = input.ReadString();
            break;
          }
          case 26: {
            Directory = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Glusterfs mount that lasts the lifetime of a pod.
  /// Glusterfs volumes do not support ownership management or SELinux relabeling.
  /// </summary>
  public sealed partial class GlusterfsPersistentVolumeSource : pb::IMessage<GlusterfsPersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GlusterfsPersistentVolumeSource> _parser = new pb::MessageParser<GlusterfsPersistentVolumeSource>(() => new GlusterfsPersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GlusterfsPersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[61]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GlusterfsPersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GlusterfsPersistentVolumeSource(GlusterfsPersistentVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      endpoints_ = other.endpoints_;
      path_ = other.path_;
      readOnly_ = other.readOnly_;
      endpointsNamespace_ = other.endpointsNamespace_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GlusterfsPersistentVolumeSource Clone() {
      return new GlusterfsPersistentVolumeSource(this);
    }

    /// <summary>Field number for the "endpoints" field.</summary>
    public const int EndpointsFieldNumber = 1;
    private readonly static string EndpointsDefaultValue = "";

    private string endpoints_;
    /// <summary>
    /// EndpointsName is the endpoint name that details Glusterfs topology.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Endpoints {
      get { return endpoints_ ?? EndpointsDefaultValue; }
      set {
        endpoints_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "endpoints" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEndpoints {
      get { return endpoints_ != null; }
    }
    /// <summary>Clears the value of the "endpoints" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEndpoints() {
      endpoints_ = null;
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 2;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Path is the Glusterfs volume path.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 3;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "endpointsNamespace" field.</summary>
    public const int EndpointsNamespaceFieldNumber = 4;
    private readonly static string EndpointsNamespaceDefaultValue = "";

    private string endpointsNamespace_;
    /// <summary>
    /// EndpointsNamespace is the namespace that contains Glusterfs endpoint.
    /// If this field is empty, the EndpointNamespace defaults to the same namespace as the bound PVC.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string EndpointsNamespace {
      get { return endpointsNamespace_ ?? EndpointsNamespaceDefaultValue; }
      set {
        endpointsNamespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "endpointsNamespace" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEndpointsNamespace {
      get { return endpointsNamespace_ != null; }
    }
    /// <summary>Clears the value of the "endpointsNamespace" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEndpointsNamespace() {
      endpointsNamespace_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GlusterfsPersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GlusterfsPersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Endpoints != other.Endpoints) return false;
      if (Path != other.Path) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (EndpointsNamespace != other.EndpointsNamespace) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEndpoints) hash ^= Endpoints.GetHashCode();
      if (HasPath) hash ^= Path.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (HasEndpointsNamespace) hash ^= EndpointsNamespace.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasEndpoints) {
        output.WriteRawTag(10);
        output.WriteString(Endpoints);
      }
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (HasEndpointsNamespace) {
        output.WriteRawTag(34);
        output.WriteString(EndpointsNamespace);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasEndpoints) {
        output.WriteRawTag(10);
        output.WriteString(Endpoints);
      }
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (HasEndpointsNamespace) {
        output.WriteRawTag(34);
        output.WriteString(EndpointsNamespace);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasEndpoints) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Endpoints);
      }
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (HasEndpointsNamespace) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(EndpointsNamespace);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GlusterfsPersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasEndpoints) {
        Endpoints = other.Endpoints;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.HasEndpointsNamespace) {
        EndpointsNamespace = other.EndpointsNamespace;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Endpoints = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            EndpointsNamespace = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Endpoints = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            EndpointsNamespace = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Glusterfs mount that lasts the lifetime of a pod.
  /// Glusterfs volumes do not support ownership management or SELinux relabeling.
  /// </summary>
  public sealed partial class GlusterfsVolumeSource : pb::IMessage<GlusterfsVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<GlusterfsVolumeSource> _parser = new pb::MessageParser<GlusterfsVolumeSource>(() => new GlusterfsVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<GlusterfsVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[62]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GlusterfsVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GlusterfsVolumeSource(GlusterfsVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      endpoints_ = other.endpoints_;
      path_ = other.path_;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public GlusterfsVolumeSource Clone() {
      return new GlusterfsVolumeSource(this);
    }

    /// <summary>Field number for the "endpoints" field.</summary>
    public const int EndpointsFieldNumber = 1;
    private readonly static string EndpointsDefaultValue = "";

    private string endpoints_;
    /// <summary>
    /// EndpointsName is the endpoint name that details Glusterfs topology.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Endpoints {
      get { return endpoints_ ?? EndpointsDefaultValue; }
      set {
        endpoints_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "endpoints" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEndpoints {
      get { return endpoints_ != null; }
    }
    /// <summary>Clears the value of the "endpoints" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEndpoints() {
      endpoints_ = null;
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 2;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Path is the Glusterfs volume path.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 3;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as GlusterfsVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(GlusterfsVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Endpoints != other.Endpoints) return false;
      if (Path != other.Path) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasEndpoints) hash ^= Endpoints.GetHashCode();
      if (HasPath) hash ^= Path.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasEndpoints) {
        output.WriteRawTag(10);
        output.WriteString(Endpoints);
      }
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasEndpoints) {
        output.WriteRawTag(10);
        output.WriteString(Endpoints);
      }
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasEndpoints) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Endpoints);
      }
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(GlusterfsVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasEndpoints) {
        Endpoints = other.Endpoints;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Endpoints = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Endpoints = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// HTTPGetAction describes an action based on HTTP Get requests.
  /// </summary>
  public sealed partial class HTTPGetAction : pb::IMessage<HTTPGetAction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HTTPGetAction> _parser = new pb::MessageParser<HTTPGetAction>(() => new HTTPGetAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HTTPGetAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[63]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPGetAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPGetAction(HTTPGetAction other) : this() {
      path_ = other.path_;
      port_ = other.port_ != null ? other.port_.Clone() : null;
      host_ = other.host_;
      scheme_ = other.scheme_;
      httpHeaders_ = other.httpHeaders_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPGetAction Clone() {
      return new HTTPGetAction(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Path to access on the HTTP server.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "port" field.</summary>
    public const int PortFieldNumber = 2;
    private global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString port_;
    /// <summary>
    /// Name or number of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString Port {
      get { return port_; }
      set {
        port_ = value;
      }
    }

    /// <summary>Field number for the "host" field.</summary>
    public const int HostFieldNumber = 3;
    private readonly static string HostDefaultValue = "";

    private string host_;
    /// <summary>
    /// Host name to connect to, defaults to the pod IP. You probably want to set
    /// "Host" in httpHeaders instead.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Host {
      get { return host_ ?? HostDefaultValue; }
      set {
        host_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "host" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHost {
      get { return host_ != null; }
    }
    /// <summary>Clears the value of the "host" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHost() {
      host_ = null;
    }

    /// <summary>Field number for the "scheme" field.</summary>
    public const int SchemeFieldNumber = 4;
    private readonly static string SchemeDefaultValue = "";

    private string scheme_;
    /// <summary>
    /// Scheme to use for connecting to the host.
    /// Defaults to HTTP.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Scheme {
      get { return scheme_ ?? SchemeDefaultValue; }
      set {
        scheme_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "scheme" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasScheme {
      get { return scheme_ != null; }
    }
    /// <summary>Clears the value of the "scheme" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearScheme() {
      scheme_ = null;
    }

    /// <summary>Field number for the "httpHeaders" field.</summary>
    public const int HttpHeadersFieldNumber = 5;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.HTTPHeader> _repeated_httpHeaders_codec
        = pb::FieldCodec.ForMessage(42, global::K8S.Io.Api.Core.V1.HTTPHeader.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.HTTPHeader> httpHeaders_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.HTTPHeader>();
    /// <summary>
    /// Custom headers to set in the request. HTTP allows repeated headers.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.HTTPHeader> HttpHeaders {
      get { return httpHeaders_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HTTPGetAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HTTPGetAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      if (!object.Equals(Port, other.Port)) return false;
      if (Host != other.Host) return false;
      if (Scheme != other.Scheme) return false;
      if(!httpHeaders_.Equals(other.httpHeaders_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPath) hash ^= Path.GetHashCode();
      if (port_ != null) hash ^= Port.GetHashCode();
      if (HasHost) hash ^= Host.GetHashCode();
      if (HasScheme) hash ^= Scheme.GetHashCode();
      hash ^= httpHeaders_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (port_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Port);
      }
      if (HasHost) {
        output.WriteRawTag(26);
        output.WriteString(Host);
      }
      if (HasScheme) {
        output.WriteRawTag(34);
        output.WriteString(Scheme);
      }
      httpHeaders_.WriteTo(output, _repeated_httpHeaders_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (port_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Port);
      }
      if (HasHost) {
        output.WriteRawTag(26);
        output.WriteString(Host);
      }
      if (HasScheme) {
        output.WriteRawTag(34);
        output.WriteString(Scheme);
      }
      httpHeaders_.WriteTo(ref output, _repeated_httpHeaders_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (port_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Port);
      }
      if (HasHost) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Host);
      }
      if (HasScheme) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Scheme);
      }
      size += httpHeaders_.CalculateSize(_repeated_httpHeaders_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HTTPGetAction other) {
      if (other == null) {
        return;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.port_ != null) {
        if (port_ == null) {
          Port = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
        }
        Port.MergeFrom(other.Port);
      }
      if (other.HasHost) {
        Host = other.Host;
      }
      if (other.HasScheme) {
        Scheme = other.Scheme;
      }
      httpHeaders_.Add(other.httpHeaders_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            if (port_ == null) {
              Port = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
            }
            input.ReadMessage(Port);
            break;
          }
          case 26: {
            Host = input.ReadString();
            break;
          }
          case 34: {
            Scheme = input.ReadString();
            break;
          }
          case 42: {
            httpHeaders_.AddEntriesFrom(input, _repeated_httpHeaders_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            if (port_ == null) {
              Port = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
            }
            input.ReadMessage(Port);
            break;
          }
          case 26: {
            Host = input.ReadString();
            break;
          }
          case 34: {
            Scheme = input.ReadString();
            break;
          }
          case 42: {
            httpHeaders_.AddEntriesFrom(ref input, _repeated_httpHeaders_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// HTTPHeader describes a custom header to be used in HTTP probes
  /// </summary>
  public sealed partial class HTTPHeader : pb::IMessage<HTTPHeader>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HTTPHeader> _parser = new pb::MessageParser<HTTPHeader>(() => new HTTPHeader());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HTTPHeader> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[64]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPHeader() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPHeader(HTTPHeader other) : this() {
      name_ = other.name_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPHeader Clone() {
      return new HTTPHeader(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// The header field name
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    /// <summary>
    /// The header field value
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HTTPHeader);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HTTPHeader other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HTTPHeader other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Handler defines a specific action that should be taken
  /// TODO: pass structured data to these actions, and document that data here.
  /// </summary>
  public sealed partial class Handler : pb::IMessage<Handler>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Handler> _parser = new pb::MessageParser<Handler>(() => new Handler());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Handler> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[65]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Handler() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Handler(Handler other) : this() {
      exec_ = other.exec_ != null ? other.exec_.Clone() : null;
      httpGet_ = other.httpGet_ != null ? other.httpGet_.Clone() : null;
      tcpSocket_ = other.tcpSocket_ != null ? other.tcpSocket_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Handler Clone() {
      return new Handler(this);
    }

    /// <summary>Field number for the "exec" field.</summary>
    public const int ExecFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.ExecAction exec_;
    /// <summary>
    /// One and only one of the following should be specified.
    /// Exec specifies the action to take.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ExecAction Exec {
      get { return exec_; }
      set {
        exec_ = value;
      }
    }

    /// <summary>Field number for the "httpGet" field.</summary>
    public const int HttpGetFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.HTTPGetAction httpGet_;
    /// <summary>
    /// HTTPGet specifies the http request to perform.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.HTTPGetAction HttpGet {
      get { return httpGet_; }
      set {
        httpGet_ = value;
      }
    }

    /// <summary>Field number for the "tcpSocket" field.</summary>
    public const int TcpSocketFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.TCPSocketAction tcpSocket_;
    /// <summary>
    /// TCPSocket specifies an action involving a TCP port.
    /// TCP hooks not yet supported
    /// TODO: implement a realistic TCP lifecycle hook
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.TCPSocketAction TcpSocket {
      get { return tcpSocket_; }
      set {
        tcpSocket_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Handler);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Handler other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Exec, other.Exec)) return false;
      if (!object.Equals(HttpGet, other.HttpGet)) return false;
      if (!object.Equals(TcpSocket, other.TcpSocket)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (exec_ != null) hash ^= Exec.GetHashCode();
      if (httpGet_ != null) hash ^= HttpGet.GetHashCode();
      if (tcpSocket_ != null) hash ^= TcpSocket.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (exec_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Exec);
      }
      if (httpGet_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(HttpGet);
      }
      if (tcpSocket_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TcpSocket);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (exec_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Exec);
      }
      if (httpGet_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(HttpGet);
      }
      if (tcpSocket_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TcpSocket);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (exec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Exec);
      }
      if (httpGet_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpGet);
      }
      if (tcpSocket_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TcpSocket);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Handler other) {
      if (other == null) {
        return;
      }
      if (other.exec_ != null) {
        if (exec_ == null) {
          Exec = new global::K8S.Io.Api.Core.V1.ExecAction();
        }
        Exec.MergeFrom(other.Exec);
      }
      if (other.httpGet_ != null) {
        if (httpGet_ == null) {
          HttpGet = new global::K8S.Io.Api.Core.V1.HTTPGetAction();
        }
        HttpGet.MergeFrom(other.HttpGet);
      }
      if (other.tcpSocket_ != null) {
        if (tcpSocket_ == null) {
          TcpSocket = new global::K8S.Io.Api.Core.V1.TCPSocketAction();
        }
        TcpSocket.MergeFrom(other.TcpSocket);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (exec_ == null) {
              Exec = new global::K8S.Io.Api.Core.V1.ExecAction();
            }
            input.ReadMessage(Exec);
            break;
          }
          case 18: {
            if (httpGet_ == null) {
              HttpGet = new global::K8S.Io.Api.Core.V1.HTTPGetAction();
            }
            input.ReadMessage(HttpGet);
            break;
          }
          case 26: {
            if (tcpSocket_ == null) {
              TcpSocket = new global::K8S.Io.Api.Core.V1.TCPSocketAction();
            }
            input.ReadMessage(TcpSocket);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (exec_ == null) {
              Exec = new global::K8S.Io.Api.Core.V1.ExecAction();
            }
            input.ReadMessage(Exec);
            break;
          }
          case 18: {
            if (httpGet_ == null) {
              HttpGet = new global::K8S.Io.Api.Core.V1.HTTPGetAction();
            }
            input.ReadMessage(HttpGet);
            break;
          }
          case 26: {
            if (tcpSocket_ == null) {
              TcpSocket = new global::K8S.Io.Api.Core.V1.TCPSocketAction();
            }
            input.ReadMessage(TcpSocket);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
  /// pod's hosts file.
  /// </summary>
  public sealed partial class HostAlias : pb::IMessage<HostAlias>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HostAlias> _parser = new pb::MessageParser<HostAlias>(() => new HostAlias());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HostAlias> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[66]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HostAlias() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HostAlias(HostAlias other) : this() {
      ip_ = other.ip_;
      hostnames_ = other.hostnames_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HostAlias Clone() {
      return new HostAlias(this);
    }

    /// <summary>Field number for the "ip" field.</summary>
    public const int IpFieldNumber = 1;
    private readonly static string IpDefaultValue = "";

    private string ip_;
    /// <summary>
    /// IP address of the host file entry.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Ip {
      get { return ip_ ?? IpDefaultValue; }
      set {
        ip_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ip" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIp {
      get { return ip_ != null; }
    }
    /// <summary>Clears the value of the "ip" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIp() {
      ip_ = null;
    }

    /// <summary>Field number for the "hostnames" field.</summary>
    public const int HostnamesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_hostnames_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> hostnames_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Hostnames for the above IP address.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Hostnames {
      get { return hostnames_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HostAlias);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HostAlias other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Ip != other.Ip) return false;
      if(!hostnames_.Equals(other.hostnames_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasIp) hash ^= Ip.GetHashCode();
      hash ^= hostnames_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasIp) {
        output.WriteRawTag(10);
        output.WriteString(Ip);
      }
      hostnames_.WriteTo(output, _repeated_hostnames_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasIp) {
        output.WriteRawTag(10);
        output.WriteString(Ip);
      }
      hostnames_.WriteTo(ref output, _repeated_hostnames_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasIp) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Ip);
      }
      size += hostnames_.CalculateSize(_repeated_hostnames_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HostAlias other) {
      if (other == null) {
        return;
      }
      if (other.HasIp) {
        Ip = other.Ip;
      }
      hostnames_.Add(other.hostnames_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Ip = input.ReadString();
            break;
          }
          case 18: {
            hostnames_.AddEntriesFrom(input, _repeated_hostnames_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Ip = input.ReadString();
            break;
          }
          case 18: {
            hostnames_.AddEntriesFrom(ref input, _repeated_hostnames_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a host path mapped into a pod.
  /// Host path volumes do not support ownership management or SELinux relabeling.
  /// </summary>
  public sealed partial class HostPathVolumeSource : pb::IMessage<HostPathVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HostPathVolumeSource> _parser = new pb::MessageParser<HostPathVolumeSource>(() => new HostPathVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HostPathVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[67]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HostPathVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HostPathVolumeSource(HostPathVolumeSource other) : this() {
      path_ = other.path_;
      type_ = other.type_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HostPathVolumeSource Clone() {
      return new HostPathVolumeSource(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Path of the directory on the host.
    /// If the path is a symlink, it will follow the link to the real path.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Type for HostPath Volume
    /// Defaults to ""
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HostPathVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HostPathVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      if (Type != other.Type) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPath) hash ^= Path.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (HasType) {
        output.WriteRawTag(18);
        output.WriteString(Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (HasType) {
        output.WriteRawTag(18);
        output.WriteString(Type);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HostPathVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            Type = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            Type = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ISCSIPersistentVolumeSource represents an ISCSI disk.
  /// ISCSI volumes can only be mounted as read/write once.
  /// ISCSI volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class ISCSIPersistentVolumeSource : pb::IMessage<ISCSIPersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ISCSIPersistentVolumeSource> _parser = new pb::MessageParser<ISCSIPersistentVolumeSource>(() => new ISCSIPersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ISCSIPersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[68]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ISCSIPersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ISCSIPersistentVolumeSource(ISCSIPersistentVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      targetPortal_ = other.targetPortal_;
      iqn_ = other.iqn_;
      lun_ = other.lun_;
      iscsiInterface_ = other.iscsiInterface_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      portals_ = other.portals_.Clone();
      chapAuthDiscovery_ = other.chapAuthDiscovery_;
      chapAuthSession_ = other.chapAuthSession_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      initiatorName_ = other.initiatorName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ISCSIPersistentVolumeSource Clone() {
      return new ISCSIPersistentVolumeSource(this);
    }

    /// <summary>Field number for the "targetPortal" field.</summary>
    public const int TargetPortalFieldNumber = 1;
    private readonly static string TargetPortalDefaultValue = "";

    private string targetPortal_;
    /// <summary>
    /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TargetPortal {
      get { return targetPortal_ ?? TargetPortalDefaultValue; }
      set {
        targetPortal_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "targetPortal" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTargetPortal {
      get { return targetPortal_ != null; }
    }
    /// <summary>Clears the value of the "targetPortal" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTargetPortal() {
      targetPortal_ = null;
    }

    /// <summary>Field number for the "iqn" field.</summary>
    public const int IqnFieldNumber = 2;
    private readonly static string IqnDefaultValue = "";

    private string iqn_;
    /// <summary>
    /// Target iSCSI Qualified Name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Iqn {
      get { return iqn_ ?? IqnDefaultValue; }
      set {
        iqn_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "iqn" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIqn {
      get { return iqn_ != null; }
    }
    /// <summary>Clears the value of the "iqn" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIqn() {
      iqn_ = null;
    }

    /// <summary>Field number for the "lun" field.</summary>
    public const int LunFieldNumber = 3;
    private readonly static int LunDefaultValue = 0;

    private int lun_;
    /// <summary>
    /// iSCSI Target Lun number.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Lun {
      get { if ((_hasBits0 & 1) != 0) { return lun_; } else { return LunDefaultValue; } }
      set {
        _hasBits0 |= 1;
        lun_ = value;
      }
    }
    /// <summary>Gets whether the "lun" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLun {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "lun" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLun() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "iscsiInterface" field.</summary>
    public const int IscsiInterfaceFieldNumber = 4;
    private readonly static string IscsiInterfaceDefaultValue = "";

    private string iscsiInterface_;
    /// <summary>
    /// iSCSI Interface Name that uses an iSCSI transport.
    /// Defaults to 'default' (tcp).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string IscsiInterface {
      get { return iscsiInterface_ ?? IscsiInterfaceDefaultValue; }
      set {
        iscsiInterface_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "iscsiInterface" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIscsiInterface {
      get { return iscsiInterface_ != null; }
    }
    /// <summary>Clears the value of the "iscsiInterface" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIscsiInterface() {
      iscsiInterface_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 5;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 6;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// ReadOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 2) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "portals" field.</summary>
    public const int PortalsFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_portals_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> portals_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Portals {
      get { return portals_; }
    }

    /// <summary>Field number for the "chapAuthDiscovery" field.</summary>
    public const int ChapAuthDiscoveryFieldNumber = 8;
    private readonly static bool ChapAuthDiscoveryDefaultValue = false;

    private bool chapAuthDiscovery_;
    /// <summary>
    /// whether support iSCSI Discovery CHAP authentication
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ChapAuthDiscovery {
      get { if ((_hasBits0 & 4) != 0) { return chapAuthDiscovery_; } else { return ChapAuthDiscoveryDefaultValue; } }
      set {
        _hasBits0 |= 4;
        chapAuthDiscovery_ = value;
      }
    }
    /// <summary>Gets whether the "chapAuthDiscovery" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasChapAuthDiscovery {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "chapAuthDiscovery" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearChapAuthDiscovery() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "chapAuthSession" field.</summary>
    public const int ChapAuthSessionFieldNumber = 11;
    private readonly static bool ChapAuthSessionDefaultValue = false;

    private bool chapAuthSession_;
    /// <summary>
    /// whether support iSCSI Session CHAP authentication
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ChapAuthSession {
      get { if ((_hasBits0 & 8) != 0) { return chapAuthSession_; } else { return ChapAuthSessionDefaultValue; } }
      set {
        _hasBits0 |= 8;
        chapAuthSession_ = value;
      }
    }
    /// <summary>Gets whether the "chapAuthSession" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasChapAuthSession {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "chapAuthSession" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearChapAuthSession() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 10;
    private global::K8S.Io.Api.Core.V1.SecretReference secretRef_;
    /// <summary>
    /// CHAP Secret for iSCSI target and initiator authentication
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    /// <summary>Field number for the "initiatorName" field.</summary>
    public const int InitiatorNameFieldNumber = 12;
    private readonly static string InitiatorNameDefaultValue = "";

    private string initiatorName_;
    /// <summary>
    /// Custom iSCSI Initiator Name.
    /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    /// &lt;target portal>:&lt;volume name> will be created for the connection.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string InitiatorName {
      get { return initiatorName_ ?? InitiatorNameDefaultValue; }
      set {
        initiatorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "initiatorName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInitiatorName {
      get { return initiatorName_ != null; }
    }
    /// <summary>Clears the value of the "initiatorName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInitiatorName() {
      initiatorName_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ISCSIPersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ISCSIPersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TargetPortal != other.TargetPortal) return false;
      if (Iqn != other.Iqn) return false;
      if (Lun != other.Lun) return false;
      if (IscsiInterface != other.IscsiInterface) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if(!portals_.Equals(other.portals_)) return false;
      if (ChapAuthDiscovery != other.ChapAuthDiscovery) return false;
      if (ChapAuthSession != other.ChapAuthSession) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      if (InitiatorName != other.InitiatorName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTargetPortal) hash ^= TargetPortal.GetHashCode();
      if (HasIqn) hash ^= Iqn.GetHashCode();
      if (HasLun) hash ^= Lun.GetHashCode();
      if (HasIscsiInterface) hash ^= IscsiInterface.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      hash ^= portals_.GetHashCode();
      if (HasChapAuthDiscovery) hash ^= ChapAuthDiscovery.GetHashCode();
      if (HasChapAuthSession) hash ^= ChapAuthSession.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (HasInitiatorName) hash ^= InitiatorName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTargetPortal) {
        output.WriteRawTag(10);
        output.WriteString(TargetPortal);
      }
      if (HasIqn) {
        output.WriteRawTag(18);
        output.WriteString(Iqn);
      }
      if (HasLun) {
        output.WriteRawTag(24);
        output.WriteInt32(Lun);
      }
      if (HasIscsiInterface) {
        output.WriteRawTag(34);
        output.WriteString(IscsiInterface);
      }
      if (HasFsType) {
        output.WriteRawTag(42);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(48);
        output.WriteBool(ReadOnly);
      }
      portals_.WriteTo(output, _repeated_portals_codec);
      if (HasChapAuthDiscovery) {
        output.WriteRawTag(64);
        output.WriteBool(ChapAuthDiscovery);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(SecretRef);
      }
      if (HasChapAuthSession) {
        output.WriteRawTag(88);
        output.WriteBool(ChapAuthSession);
      }
      if (HasInitiatorName) {
        output.WriteRawTag(98);
        output.WriteString(InitiatorName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTargetPortal) {
        output.WriteRawTag(10);
        output.WriteString(TargetPortal);
      }
      if (HasIqn) {
        output.WriteRawTag(18);
        output.WriteString(Iqn);
      }
      if (HasLun) {
        output.WriteRawTag(24);
        output.WriteInt32(Lun);
      }
      if (HasIscsiInterface) {
        output.WriteRawTag(34);
        output.WriteString(IscsiInterface);
      }
      if (HasFsType) {
        output.WriteRawTag(42);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(48);
        output.WriteBool(ReadOnly);
      }
      portals_.WriteTo(ref output, _repeated_portals_codec);
      if (HasChapAuthDiscovery) {
        output.WriteRawTag(64);
        output.WriteBool(ChapAuthDiscovery);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(SecretRef);
      }
      if (HasChapAuthSession) {
        output.WriteRawTag(88);
        output.WriteBool(ChapAuthSession);
      }
      if (HasInitiatorName) {
        output.WriteRawTag(98);
        output.WriteString(InitiatorName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasTargetPortal) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TargetPortal);
      }
      if (HasIqn) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Iqn);
      }
      if (HasLun) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Lun);
      }
      if (HasIscsiInterface) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(IscsiInterface);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      size += portals_.CalculateSize(_repeated_portals_codec);
      if (HasChapAuthDiscovery) {
        size += 1 + 1;
      }
      if (HasChapAuthSession) {
        size += 1 + 1;
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (HasInitiatorName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(InitiatorName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ISCSIPersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasTargetPortal) {
        TargetPortal = other.TargetPortal;
      }
      if (other.HasIqn) {
        Iqn = other.Iqn;
      }
      if (other.HasLun) {
        Lun = other.Lun;
      }
      if (other.HasIscsiInterface) {
        IscsiInterface = other.IscsiInterface;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      portals_.Add(other.portals_);
      if (other.HasChapAuthDiscovery) {
        ChapAuthDiscovery = other.ChapAuthDiscovery;
      }
      if (other.HasChapAuthSession) {
        ChapAuthSession = other.ChapAuthSession;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      if (other.HasInitiatorName) {
        InitiatorName = other.InitiatorName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            TargetPortal = input.ReadString();
            break;
          }
          case 18: {
            Iqn = input.ReadString();
            break;
          }
          case 24: {
            Lun = input.ReadInt32();
            break;
          }
          case 34: {
            IscsiInterface = input.ReadString();
            break;
          }
          case 42: {
            FsType = input.ReadString();
            break;
          }
          case 48: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 58: {
            portals_.AddEntriesFrom(input, _repeated_portals_codec);
            break;
          }
          case 64: {
            ChapAuthDiscovery = input.ReadBool();
            break;
          }
          case 82: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 88: {
            ChapAuthSession = input.ReadBool();
            break;
          }
          case 98: {
            InitiatorName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            TargetPortal = input.ReadString();
            break;
          }
          case 18: {
            Iqn = input.ReadString();
            break;
          }
          case 24: {
            Lun = input.ReadInt32();
            break;
          }
          case 34: {
            IscsiInterface = input.ReadString();
            break;
          }
          case 42: {
            FsType = input.ReadString();
            break;
          }
          case 48: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 58: {
            portals_.AddEntriesFrom(ref input, _repeated_portals_codec);
            break;
          }
          case 64: {
            ChapAuthDiscovery = input.ReadBool();
            break;
          }
          case 82: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 88: {
            ChapAuthSession = input.ReadBool();
            break;
          }
          case 98: {
            InitiatorName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents an ISCSI disk.
  /// ISCSI volumes can only be mounted as read/write once.
  /// ISCSI volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class ISCSIVolumeSource : pb::IMessage<ISCSIVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ISCSIVolumeSource> _parser = new pb::MessageParser<ISCSIVolumeSource>(() => new ISCSIVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ISCSIVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[69]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ISCSIVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ISCSIVolumeSource(ISCSIVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      targetPortal_ = other.targetPortal_;
      iqn_ = other.iqn_;
      lun_ = other.lun_;
      iscsiInterface_ = other.iscsiInterface_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      portals_ = other.portals_.Clone();
      chapAuthDiscovery_ = other.chapAuthDiscovery_;
      chapAuthSession_ = other.chapAuthSession_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      initiatorName_ = other.initiatorName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ISCSIVolumeSource Clone() {
      return new ISCSIVolumeSource(this);
    }

    /// <summary>Field number for the "targetPortal" field.</summary>
    public const int TargetPortalFieldNumber = 1;
    private readonly static string TargetPortalDefaultValue = "";

    private string targetPortal_;
    /// <summary>
    /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TargetPortal {
      get { return targetPortal_ ?? TargetPortalDefaultValue; }
      set {
        targetPortal_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "targetPortal" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTargetPortal {
      get { return targetPortal_ != null; }
    }
    /// <summary>Clears the value of the "targetPortal" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTargetPortal() {
      targetPortal_ = null;
    }

    /// <summary>Field number for the "iqn" field.</summary>
    public const int IqnFieldNumber = 2;
    private readonly static string IqnDefaultValue = "";

    private string iqn_;
    /// <summary>
    /// Target iSCSI Qualified Name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Iqn {
      get { return iqn_ ?? IqnDefaultValue; }
      set {
        iqn_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "iqn" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIqn {
      get { return iqn_ != null; }
    }
    /// <summary>Clears the value of the "iqn" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIqn() {
      iqn_ = null;
    }

    /// <summary>Field number for the "lun" field.</summary>
    public const int LunFieldNumber = 3;
    private readonly static int LunDefaultValue = 0;

    private int lun_;
    /// <summary>
    /// iSCSI Target Lun number.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Lun {
      get { if ((_hasBits0 & 1) != 0) { return lun_; } else { return LunDefaultValue; } }
      set {
        _hasBits0 |= 1;
        lun_ = value;
      }
    }
    /// <summary>Gets whether the "lun" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLun {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "lun" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLun() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "iscsiInterface" field.</summary>
    public const int IscsiInterfaceFieldNumber = 4;
    private readonly static string IscsiInterfaceDefaultValue = "";

    private string iscsiInterface_;
    /// <summary>
    /// iSCSI Interface Name that uses an iSCSI transport.
    /// Defaults to 'default' (tcp).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string IscsiInterface {
      get { return iscsiInterface_ ?? IscsiInterfaceDefaultValue; }
      set {
        iscsiInterface_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "iscsiInterface" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIscsiInterface {
      get { return iscsiInterface_ != null; }
    }
    /// <summary>Clears the value of the "iscsiInterface" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIscsiInterface() {
      iscsiInterface_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 5;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 6;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// ReadOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 2) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "portals" field.</summary>
    public const int PortalsFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_portals_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> portals_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
    /// is other than default (typically TCP ports 860 and 3260).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Portals {
      get { return portals_; }
    }

    /// <summary>Field number for the "chapAuthDiscovery" field.</summary>
    public const int ChapAuthDiscoveryFieldNumber = 8;
    private readonly static bool ChapAuthDiscoveryDefaultValue = false;

    private bool chapAuthDiscovery_;
    /// <summary>
    /// whether support iSCSI Discovery CHAP authentication
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ChapAuthDiscovery {
      get { if ((_hasBits0 & 4) != 0) { return chapAuthDiscovery_; } else { return ChapAuthDiscoveryDefaultValue; } }
      set {
        _hasBits0 |= 4;
        chapAuthDiscovery_ = value;
      }
    }
    /// <summary>Gets whether the "chapAuthDiscovery" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasChapAuthDiscovery {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "chapAuthDiscovery" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearChapAuthDiscovery() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "chapAuthSession" field.</summary>
    public const int ChapAuthSessionFieldNumber = 11;
    private readonly static bool ChapAuthSessionDefaultValue = false;

    private bool chapAuthSession_;
    /// <summary>
    /// whether support iSCSI Session CHAP authentication
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ChapAuthSession {
      get { if ((_hasBits0 & 8) != 0) { return chapAuthSession_; } else { return ChapAuthSessionDefaultValue; } }
      set {
        _hasBits0 |= 8;
        chapAuthSession_ = value;
      }
    }
    /// <summary>Gets whether the "chapAuthSession" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasChapAuthSession {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "chapAuthSession" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearChapAuthSession() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 10;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference secretRef_;
    /// <summary>
    /// CHAP Secret for iSCSI target and initiator authentication
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    /// <summary>Field number for the "initiatorName" field.</summary>
    public const int InitiatorNameFieldNumber = 12;
    private readonly static string InitiatorNameDefaultValue = "";

    private string initiatorName_;
    /// <summary>
    /// Custom iSCSI Initiator Name.
    /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
    /// &lt;target portal>:&lt;volume name> will be created for the connection.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string InitiatorName {
      get { return initiatorName_ ?? InitiatorNameDefaultValue; }
      set {
        initiatorName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "initiatorName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInitiatorName {
      get { return initiatorName_ != null; }
    }
    /// <summary>Clears the value of the "initiatorName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInitiatorName() {
      initiatorName_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ISCSIVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ISCSIVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TargetPortal != other.TargetPortal) return false;
      if (Iqn != other.Iqn) return false;
      if (Lun != other.Lun) return false;
      if (IscsiInterface != other.IscsiInterface) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if(!portals_.Equals(other.portals_)) return false;
      if (ChapAuthDiscovery != other.ChapAuthDiscovery) return false;
      if (ChapAuthSession != other.ChapAuthSession) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      if (InitiatorName != other.InitiatorName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasTargetPortal) hash ^= TargetPortal.GetHashCode();
      if (HasIqn) hash ^= Iqn.GetHashCode();
      if (HasLun) hash ^= Lun.GetHashCode();
      if (HasIscsiInterface) hash ^= IscsiInterface.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      hash ^= portals_.GetHashCode();
      if (HasChapAuthDiscovery) hash ^= ChapAuthDiscovery.GetHashCode();
      if (HasChapAuthSession) hash ^= ChapAuthSession.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (HasInitiatorName) hash ^= InitiatorName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasTargetPortal) {
        output.WriteRawTag(10);
        output.WriteString(TargetPortal);
      }
      if (HasIqn) {
        output.WriteRawTag(18);
        output.WriteString(Iqn);
      }
      if (HasLun) {
        output.WriteRawTag(24);
        output.WriteInt32(Lun);
      }
      if (HasIscsiInterface) {
        output.WriteRawTag(34);
        output.WriteString(IscsiInterface);
      }
      if (HasFsType) {
        output.WriteRawTag(42);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(48);
        output.WriteBool(ReadOnly);
      }
      portals_.WriteTo(output, _repeated_portals_codec);
      if (HasChapAuthDiscovery) {
        output.WriteRawTag(64);
        output.WriteBool(ChapAuthDiscovery);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(SecretRef);
      }
      if (HasChapAuthSession) {
        output.WriteRawTag(88);
        output.WriteBool(ChapAuthSession);
      }
      if (HasInitiatorName) {
        output.WriteRawTag(98);
        output.WriteString(InitiatorName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasTargetPortal) {
        output.WriteRawTag(10);
        output.WriteString(TargetPortal);
      }
      if (HasIqn) {
        output.WriteRawTag(18);
        output.WriteString(Iqn);
      }
      if (HasLun) {
        output.WriteRawTag(24);
        output.WriteInt32(Lun);
      }
      if (HasIscsiInterface) {
        output.WriteRawTag(34);
        output.WriteString(IscsiInterface);
      }
      if (HasFsType) {
        output.WriteRawTag(42);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(48);
        output.WriteBool(ReadOnly);
      }
      portals_.WriteTo(ref output, _repeated_portals_codec);
      if (HasChapAuthDiscovery) {
        output.WriteRawTag(64);
        output.WriteBool(ChapAuthDiscovery);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(SecretRef);
      }
      if (HasChapAuthSession) {
        output.WriteRawTag(88);
        output.WriteBool(ChapAuthSession);
      }
      if (HasInitiatorName) {
        output.WriteRawTag(98);
        output.WriteString(InitiatorName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasTargetPortal) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TargetPortal);
      }
      if (HasIqn) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Iqn);
      }
      if (HasLun) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Lun);
      }
      if (HasIscsiInterface) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(IscsiInterface);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      size += portals_.CalculateSize(_repeated_portals_codec);
      if (HasChapAuthDiscovery) {
        size += 1 + 1;
      }
      if (HasChapAuthSession) {
        size += 1 + 1;
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (HasInitiatorName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(InitiatorName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ISCSIVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasTargetPortal) {
        TargetPortal = other.TargetPortal;
      }
      if (other.HasIqn) {
        Iqn = other.Iqn;
      }
      if (other.HasLun) {
        Lun = other.Lun;
      }
      if (other.HasIscsiInterface) {
        IscsiInterface = other.IscsiInterface;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      portals_.Add(other.portals_);
      if (other.HasChapAuthDiscovery) {
        ChapAuthDiscovery = other.ChapAuthDiscovery;
      }
      if (other.HasChapAuthSession) {
        ChapAuthSession = other.ChapAuthSession;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      if (other.HasInitiatorName) {
        InitiatorName = other.InitiatorName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            TargetPortal = input.ReadString();
            break;
          }
          case 18: {
            Iqn = input.ReadString();
            break;
          }
          case 24: {
            Lun = input.ReadInt32();
            break;
          }
          case 34: {
            IscsiInterface = input.ReadString();
            break;
          }
          case 42: {
            FsType = input.ReadString();
            break;
          }
          case 48: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 58: {
            portals_.AddEntriesFrom(input, _repeated_portals_codec);
            break;
          }
          case 64: {
            ChapAuthDiscovery = input.ReadBool();
            break;
          }
          case 82: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 88: {
            ChapAuthSession = input.ReadBool();
            break;
          }
          case 98: {
            InitiatorName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            TargetPortal = input.ReadString();
            break;
          }
          case 18: {
            Iqn = input.ReadString();
            break;
          }
          case 24: {
            Lun = input.ReadInt32();
            break;
          }
          case 34: {
            IscsiInterface = input.ReadString();
            break;
          }
          case 42: {
            FsType = input.ReadString();
            break;
          }
          case 48: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 58: {
            portals_.AddEntriesFrom(ref input, _repeated_portals_codec);
            break;
          }
          case 64: {
            ChapAuthDiscovery = input.ReadBool();
            break;
          }
          case 82: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 88: {
            ChapAuthSession = input.ReadBool();
            break;
          }
          case 98: {
            InitiatorName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Maps a string key to a path within a volume.
  /// </summary>
  public sealed partial class KeyToPath : pb::IMessage<KeyToPath>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<KeyToPath> _parser = new pb::MessageParser<KeyToPath>(() => new KeyToPath());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<KeyToPath> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[70]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyToPath() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyToPath(KeyToPath other) : this() {
      _hasBits0 = other._hasBits0;
      key_ = other.key_;
      path_ = other.path_;
      mode_ = other.mode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public KeyToPath Clone() {
      return new KeyToPath(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    /// <summary>
    /// The key to project.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 2;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// The relative path of the file to map the key to.
    /// May not be an absolute path.
    /// May not contain the path element '..'.
    /// May not start with the string '..'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "mode" field.</summary>
    public const int ModeFieldNumber = 3;
    private readonly static int ModeDefaultValue = 0;

    private int mode_;
    /// <summary>
    /// Optional: mode bits used to set permissions on this file.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// If not specified, the volume defaultMode will be used.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Mode {
      get { if ((_hasBits0 & 1) != 0) { return mode_; } else { return ModeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        mode_ = value;
      }
    }
    /// <summary>Gets whether the "mode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMode {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "mode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMode() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as KeyToPath);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(KeyToPath other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Path != other.Path) return false;
      if (Mode != other.Mode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasPath) hash ^= Path.GetHashCode();
      if (HasMode) hash ^= Mode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasMode) {
        output.WriteRawTag(24);
        output.WriteInt32(Mode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasMode) {
        output.WriteRawTag(24);
        output.WriteInt32(Mode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (HasMode) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Mode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(KeyToPath other) {
      if (other == null) {
        return;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.HasMode) {
        Mode = other.Mode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 24: {
            Mode = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 24: {
            Mode = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Lifecycle describes actions that the management system should take in response to container lifecycle
  /// events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
  /// until the action is complete, unless the container process fails, in which case the handler is aborted.
  /// </summary>
  public sealed partial class Lifecycle : pb::IMessage<Lifecycle>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Lifecycle> _parser = new pb::MessageParser<Lifecycle>(() => new Lifecycle());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Lifecycle> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[71]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Lifecycle() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Lifecycle(Lifecycle other) : this() {
      postStart_ = other.postStart_ != null ? other.postStart_.Clone() : null;
      preStop_ = other.preStop_ != null ? other.preStop_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Lifecycle Clone() {
      return new Lifecycle(this);
    }

    /// <summary>Field number for the "postStart" field.</summary>
    public const int PostStartFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.Handler postStart_;
    /// <summary>
    /// PostStart is called immediately after a container is created. If the handler fails,
    /// the container is terminated and restarted according to its restart policy.
    /// Other management of the container blocks until the hook completes.
    /// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Handler PostStart {
      get { return postStart_; }
      set {
        postStart_ = value;
      }
    }

    /// <summary>Field number for the "preStop" field.</summary>
    public const int PreStopFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.Handler preStop_;
    /// <summary>
    /// PreStop is called immediately before a container is terminated due to an
    /// API request or management event such as liveness/startup probe failure,
    /// preemption, resource contention, etc. The handler is not called if the
    /// container crashes or exits. The reason for termination is passed to the
    /// handler. The Pod's termination grace period countdown begins before the
    /// PreStop hooked is executed. Regardless of the outcome of the handler, the
    /// container will eventually terminate within the Pod's termination grace
    /// period. Other management of the container blocks until the hook completes
    /// or until the termination grace period is reached.
    /// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Handler PreStop {
      get { return preStop_; }
      set {
        preStop_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Lifecycle);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Lifecycle other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(PostStart, other.PostStart)) return false;
      if (!object.Equals(PreStop, other.PreStop)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (postStart_ != null) hash ^= PostStart.GetHashCode();
      if (preStop_ != null) hash ^= PreStop.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (postStart_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PostStart);
      }
      if (preStop_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PreStop);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (postStart_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PostStart);
      }
      if (preStop_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PreStop);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (postStart_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PostStart);
      }
      if (preStop_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PreStop);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Lifecycle other) {
      if (other == null) {
        return;
      }
      if (other.postStart_ != null) {
        if (postStart_ == null) {
          PostStart = new global::K8S.Io.Api.Core.V1.Handler();
        }
        PostStart.MergeFrom(other.PostStart);
      }
      if (other.preStop_ != null) {
        if (preStop_ == null) {
          PreStop = new global::K8S.Io.Api.Core.V1.Handler();
        }
        PreStop.MergeFrom(other.PreStop);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (postStart_ == null) {
              PostStart = new global::K8S.Io.Api.Core.V1.Handler();
            }
            input.ReadMessage(PostStart);
            break;
          }
          case 18: {
            if (preStop_ == null) {
              PreStop = new global::K8S.Io.Api.Core.V1.Handler();
            }
            input.ReadMessage(PreStop);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (postStart_ == null) {
              PostStart = new global::K8S.Io.Api.Core.V1.Handler();
            }
            input.ReadMessage(PostStart);
            break;
          }
          case 18: {
            if (preStop_ == null) {
              PreStop = new global::K8S.Io.Api.Core.V1.Handler();
            }
            input.ReadMessage(PreStop);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// LimitRange sets resource usage limits for each kind of resource in a Namespace.
  /// </summary>
  public sealed partial class LimitRange : pb::IMessage<LimitRange>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LimitRange> _parser = new pb::MessageParser<LimitRange>(() => new LimitRange());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LimitRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[72]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRange(LimitRange other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRange Clone() {
      return new LimitRange(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.LimitRangeSpec spec_;
    /// <summary>
    /// Spec defines the limits enforced.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LimitRangeSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LimitRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LimitRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LimitRange other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.LimitRangeSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.LimitRangeSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.LimitRangeSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
  /// </summary>
  public sealed partial class LimitRangeItem : pb::IMessage<LimitRangeItem>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LimitRangeItem> _parser = new pb::MessageParser<LimitRangeItem>(() => new LimitRangeItem());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LimitRangeItem> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[73]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRangeItem() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRangeItem(LimitRangeItem other) : this() {
      type_ = other.type_;
      max_ = other.max_.Clone();
      min_ = other.min_.Clone();
      default_ = other.default_.Clone();
      defaultRequest_ = other.defaultRequest_.Clone();
      maxLimitRequestRatio_ = other.maxLimitRequestRatio_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRangeItem Clone() {
      return new LimitRangeItem(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Type of resource that this limit applies to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "max" field.</summary>
    public const int MaxFieldNumber = 2;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_max_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 18);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> max_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Max usage constraints on this kind by resource name.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Max {
      get { return max_; }
    }

    /// <summary>Field number for the "min" field.</summary>
    public const int MinFieldNumber = 3;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_min_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 26);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> min_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Min usage constraints on this kind by resource name.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Min {
      get { return min_; }
    }

    /// <summary>Field number for the "default" field.</summary>
    public const int DefaultFieldNumber = 4;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_default_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 34);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> default_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Default resource requirement limit value by resource name if resource limit is omitted.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Default {
      get { return default_; }
    }

    /// <summary>Field number for the "defaultRequest" field.</summary>
    public const int DefaultRequestFieldNumber = 5;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_defaultRequest_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 42);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> defaultRequest_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// DefaultRequest is the default resource requirement request value by resource name if resource request is omitted.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> DefaultRequest {
      get { return defaultRequest_; }
    }

    /// <summary>Field number for the "maxLimitRequestRatio" field.</summary>
    public const int MaxLimitRequestRatioFieldNumber = 6;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_maxLimitRequestRatio_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 50);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> maxLimitRequestRatio_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// MaxLimitRequestRatio if specified, the named resource must have a request and limit that are both non-zero where limit divided by request is less than or equal to the enumerated value; this represents the max burst for the named resource.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> MaxLimitRequestRatio {
      get { return maxLimitRequestRatio_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LimitRangeItem);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LimitRangeItem other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (!Max.Equals(other.Max)) return false;
      if (!Min.Equals(other.Min)) return false;
      if (!Default.Equals(other.Default)) return false;
      if (!DefaultRequest.Equals(other.DefaultRequest)) return false;
      if (!MaxLimitRequestRatio.Equals(other.MaxLimitRequestRatio)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      hash ^= Max.GetHashCode();
      hash ^= Min.GetHashCode();
      hash ^= Default.GetHashCode();
      hash ^= DefaultRequest.GetHashCode();
      hash ^= MaxLimitRequestRatio.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      max_.WriteTo(output, _map_max_codec);
      min_.WriteTo(output, _map_min_codec);
      default_.WriteTo(output, _map_default_codec);
      defaultRequest_.WriteTo(output, _map_defaultRequest_codec);
      maxLimitRequestRatio_.WriteTo(output, _map_maxLimitRequestRatio_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      max_.WriteTo(ref output, _map_max_codec);
      min_.WriteTo(ref output, _map_min_codec);
      default_.WriteTo(ref output, _map_default_codec);
      defaultRequest_.WriteTo(ref output, _map_defaultRequest_codec);
      maxLimitRequestRatio_.WriteTo(ref output, _map_maxLimitRequestRatio_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      size += max_.CalculateSize(_map_max_codec);
      size += min_.CalculateSize(_map_min_codec);
      size += default_.CalculateSize(_map_default_codec);
      size += defaultRequest_.CalculateSize(_map_defaultRequest_codec);
      size += maxLimitRequestRatio_.CalculateSize(_map_maxLimitRequestRatio_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LimitRangeItem other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      max_.Add(other.max_);
      min_.Add(other.min_);
      default_.Add(other.default_);
      defaultRequest_.Add(other.defaultRequest_);
      maxLimitRequestRatio_.Add(other.maxLimitRequestRatio_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            max_.AddEntriesFrom(input, _map_max_codec);
            break;
          }
          case 26: {
            min_.AddEntriesFrom(input, _map_min_codec);
            break;
          }
          case 34: {
            default_.AddEntriesFrom(input, _map_default_codec);
            break;
          }
          case 42: {
            defaultRequest_.AddEntriesFrom(input, _map_defaultRequest_codec);
            break;
          }
          case 50: {
            maxLimitRequestRatio_.AddEntriesFrom(input, _map_maxLimitRequestRatio_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            max_.AddEntriesFrom(ref input, _map_max_codec);
            break;
          }
          case 26: {
            min_.AddEntriesFrom(ref input, _map_min_codec);
            break;
          }
          case 34: {
            default_.AddEntriesFrom(ref input, _map_default_codec);
            break;
          }
          case 42: {
            defaultRequest_.AddEntriesFrom(ref input, _map_defaultRequest_codec);
            break;
          }
          case 50: {
            maxLimitRequestRatio_.AddEntriesFrom(ref input, _map_maxLimitRequestRatio_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// LimitRangeList is a list of LimitRange items.
  /// </summary>
  public sealed partial class LimitRangeList : pb::IMessage<LimitRangeList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LimitRangeList> _parser = new pb::MessageParser<LimitRangeList>(() => new LimitRangeList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LimitRangeList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[74]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRangeList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRangeList(LimitRangeList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRangeList Clone() {
      return new LimitRangeList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.LimitRange> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.LimitRange.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LimitRange> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LimitRange>();
    /// <summary>
    /// Items is a list of LimitRange objects.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LimitRange> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LimitRangeList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LimitRangeList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LimitRangeList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// LimitRangeSpec defines a min/max usage limit for resources that match on kind.
  /// </summary>
  public sealed partial class LimitRangeSpec : pb::IMessage<LimitRangeSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LimitRangeSpec> _parser = new pb::MessageParser<LimitRangeSpec>(() => new LimitRangeSpec());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LimitRangeSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[75]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRangeSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRangeSpec(LimitRangeSpec other) : this() {
      limits_ = other.limits_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LimitRangeSpec Clone() {
      return new LimitRangeSpec(this);
    }

    /// <summary>Field number for the "limits" field.</summary>
    public const int LimitsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.LimitRangeItem> _repeated_limits_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.LimitRangeItem.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LimitRangeItem> limits_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LimitRangeItem>();
    /// <summary>
    /// Limits is the list of LimitRangeItem objects that are enforced.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LimitRangeItem> Limits {
      get { return limits_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LimitRangeSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LimitRangeSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!limits_.Equals(other.limits_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= limits_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      limits_.WriteTo(output, _repeated_limits_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      limits_.WriteTo(ref output, _repeated_limits_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += limits_.CalculateSize(_repeated_limits_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LimitRangeSpec other) {
      if (other == null) {
        return;
      }
      limits_.Add(other.limits_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            limits_.AddEntriesFrom(input, _repeated_limits_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            limits_.AddEntriesFrom(ref input, _repeated_limits_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// List holds a list of objects, which may not be known by the server.
  /// </summary>
  public sealed partial class List : pb::IMessage<List>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<List> _parser = new pb::MessageParser<List>(() => new List());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<List> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[76]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public List() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public List(List other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public List Clone() {
      return new List(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Apimachinery.Pkg.Runtime.RawExtension> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Runtime.RawExtension.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Apimachinery.Pkg.Runtime.RawExtension> items_ = new pbc::RepeatedField<global::K8S.Io.Apimachinery.Pkg.Runtime.RawExtension>();
    /// <summary>
    /// List of objects
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Apimachinery.Pkg.Runtime.RawExtension> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as List);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(List other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(List other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// LoadBalancerIngress represents the status of a load-balancer ingress point:
  /// traffic intended for the service should be sent to an ingress point.
  /// </summary>
  public sealed partial class LoadBalancerIngress : pb::IMessage<LoadBalancerIngress>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LoadBalancerIngress> _parser = new pb::MessageParser<LoadBalancerIngress>(() => new LoadBalancerIngress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LoadBalancerIngress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[77]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancerIngress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancerIngress(LoadBalancerIngress other) : this() {
      ip_ = other.ip_;
      hostname_ = other.hostname_;
      ports_ = other.ports_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancerIngress Clone() {
      return new LoadBalancerIngress(this);
    }

    /// <summary>Field number for the "ip" field.</summary>
    public const int IpFieldNumber = 1;
    private readonly static string IpDefaultValue = "";

    private string ip_;
    /// <summary>
    /// IP is set for load-balancer ingress points that are IP based
    /// (typically GCE or OpenStack load-balancers)
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Ip {
      get { return ip_ ?? IpDefaultValue; }
      set {
        ip_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ip" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIp {
      get { return ip_ != null; }
    }
    /// <summary>Clears the value of the "ip" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIp() {
      ip_ = null;
    }

    /// <summary>Field number for the "hostname" field.</summary>
    public const int HostnameFieldNumber = 2;
    private readonly static string HostnameDefaultValue = "";

    private string hostname_;
    /// <summary>
    /// Hostname is set for load-balancer ingress points that are DNS based
    /// (typically AWS load-balancers)
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Hostname {
      get { return hostname_ ?? HostnameDefaultValue; }
      set {
        hostname_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hostname" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostname {
      get { return hostname_ != null; }
    }
    /// <summary>Clears the value of the "hostname" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostname() {
      hostname_ = null;
    }

    /// <summary>Field number for the "ports" field.</summary>
    public const int PortsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PortStatus> _repeated_ports_codec
        = pb::FieldCodec.ForMessage(34, global::K8S.Io.Api.Core.V1.PortStatus.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PortStatus> ports_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PortStatus>();
    /// <summary>
    /// Ports is a list of records of service ports
    /// If used, every port defined in the service should have an entry in it
    /// +listType=atomic
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PortStatus> Ports {
      get { return ports_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LoadBalancerIngress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LoadBalancerIngress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Ip != other.Ip) return false;
      if (Hostname != other.Hostname) return false;
      if(!ports_.Equals(other.ports_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasIp) hash ^= Ip.GetHashCode();
      if (HasHostname) hash ^= Hostname.GetHashCode();
      hash ^= ports_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasIp) {
        output.WriteRawTag(10);
        output.WriteString(Ip);
      }
      if (HasHostname) {
        output.WriteRawTag(18);
        output.WriteString(Hostname);
      }
      ports_.WriteTo(output, _repeated_ports_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasIp) {
        output.WriteRawTag(10);
        output.WriteString(Ip);
      }
      if (HasHostname) {
        output.WriteRawTag(18);
        output.WriteString(Hostname);
      }
      ports_.WriteTo(ref output, _repeated_ports_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasIp) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Ip);
      }
      if (HasHostname) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Hostname);
      }
      size += ports_.CalculateSize(_repeated_ports_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LoadBalancerIngress other) {
      if (other == null) {
        return;
      }
      if (other.HasIp) {
        Ip = other.Ip;
      }
      if (other.HasHostname) {
        Hostname = other.Hostname;
      }
      ports_.Add(other.ports_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Ip = input.ReadString();
            break;
          }
          case 18: {
            Hostname = input.ReadString();
            break;
          }
          case 34: {
            ports_.AddEntriesFrom(input, _repeated_ports_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Ip = input.ReadString();
            break;
          }
          case 18: {
            Hostname = input.ReadString();
            break;
          }
          case 34: {
            ports_.AddEntriesFrom(ref input, _repeated_ports_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// LoadBalancerStatus represents the status of a load-balancer.
  /// </summary>
  public sealed partial class LoadBalancerStatus : pb::IMessage<LoadBalancerStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LoadBalancerStatus> _parser = new pb::MessageParser<LoadBalancerStatus>(() => new LoadBalancerStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LoadBalancerStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[78]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancerStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancerStatus(LoadBalancerStatus other) : this() {
      ingress_ = other.ingress_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LoadBalancerStatus Clone() {
      return new LoadBalancerStatus(this);
    }

    /// <summary>Field number for the "ingress" field.</summary>
    public const int IngressFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.LoadBalancerIngress> _repeated_ingress_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.LoadBalancerIngress.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LoadBalancerIngress> ingress_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LoadBalancerIngress>();
    /// <summary>
    /// Ingress is a list containing ingress points for the load-balancer.
    /// Traffic intended for the service should be sent to these ingress points.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LoadBalancerIngress> Ingress {
      get { return ingress_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LoadBalancerStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LoadBalancerStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!ingress_.Equals(other.ingress_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= ingress_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      ingress_.WriteTo(output, _repeated_ingress_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      ingress_.WriteTo(ref output, _repeated_ingress_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += ingress_.CalculateSize(_repeated_ingress_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LoadBalancerStatus other) {
      if (other == null) {
        return;
      }
      ingress_.Add(other.ingress_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ingress_.AddEntriesFrom(input, _repeated_ingress_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ingress_.AddEntriesFrom(ref input, _repeated_ingress_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// LocalObjectReference contains enough information to let you locate the
  /// referenced object inside the same namespace.
  /// +structType=atomic
  /// </summary>
  public sealed partial class LocalObjectReference : pb::IMessage<LocalObjectReference>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LocalObjectReference> _parser = new pb::MessageParser<LocalObjectReference>(() => new LocalObjectReference());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LocalObjectReference> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[79]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalObjectReference() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalObjectReference(LocalObjectReference other) : this() {
      name_ = other.name_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalObjectReference Clone() {
      return new LocalObjectReference(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// TODO: Add other useful fields. apiVersion, kind, uid?
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LocalObjectReference);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LocalObjectReference other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LocalObjectReference other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Local represents directly-attached storage with node affinity (Beta feature)
  /// </summary>
  public sealed partial class LocalVolumeSource : pb::IMessage<LocalVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<LocalVolumeSource> _parser = new pb::MessageParser<LocalVolumeSource>(() => new LocalVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<LocalVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[80]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalVolumeSource(LocalVolumeSource other) : this() {
      path_ = other.path_;
      fsType_ = other.fsType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public LocalVolumeSource Clone() {
      return new LocalVolumeSource(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// The full path to the volume on the node.
    /// It can be either a directory or block device (disk, partition, ...).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 2;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// It applies only when the Path is a block device.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". The default value is to auto-select a fileystem if unspecified.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as LocalVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(LocalVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      if (FsType != other.FsType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPath) hash ^= Path.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(LocalVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents an NFS mount that lasts the lifetime of a pod.
  /// NFS volumes do not support ownership management or SELinux relabeling.
  /// </summary>
  public sealed partial class NFSVolumeSource : pb::IMessage<NFSVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NFSVolumeSource> _parser = new pb::MessageParser<NFSVolumeSource>(() => new NFSVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NFSVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[81]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NFSVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NFSVolumeSource(NFSVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      server_ = other.server_;
      path_ = other.path_;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NFSVolumeSource Clone() {
      return new NFSVolumeSource(this);
    }

    /// <summary>Field number for the "server" field.</summary>
    public const int ServerFieldNumber = 1;
    private readonly static string ServerDefaultValue = "";

    private string server_;
    /// <summary>
    /// Server is the hostname or IP address of the NFS server.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Server {
      get { return server_ ?? ServerDefaultValue; }
      set {
        server_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "server" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasServer {
      get { return server_ != null; }
    }
    /// <summary>Clears the value of the "server" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearServer() {
      server_ = null;
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 2;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Path that is exported by the NFS server.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 3;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// ReadOnly here will force
    /// the NFS export to be mounted with read-only permissions.
    /// Defaults to false.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NFSVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NFSVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Server != other.Server) return false;
      if (Path != other.Path) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasServer) hash ^= Server.GetHashCode();
      if (HasPath) hash ^= Path.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasServer) {
        output.WriteRawTag(10);
        output.WriteString(Server);
      }
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasServer) {
        output.WriteRawTag(10);
        output.WriteString(Server);
      }
      if (HasPath) {
        output.WriteRawTag(18);
        output.WriteString(Path);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasServer) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Server);
      }
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NFSVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasServer) {
        Server = other.Server;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Server = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Server = input.ReadString();
            break;
          }
          case 18: {
            Path = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Namespace provides a scope for Names.
  /// Use of multiple namespaces is optional.
  /// </summary>
  public sealed partial class Namespace : pb::IMessage<Namespace>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Namespace> _parser = new pb::MessageParser<Namespace>(() => new Namespace());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Namespace> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[82]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Namespace() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Namespace(Namespace other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Namespace Clone() {
      return new Namespace(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.NamespaceSpec spec_;
    /// <summary>
    /// Spec defines the behavior of the Namespace.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NamespaceSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.NamespaceStatus status_;
    /// <summary>
    /// Status describes the current status of a Namespace.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NamespaceStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Namespace);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Namespace other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Namespace other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.NamespaceSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::K8S.Io.Api.Core.V1.NamespaceStatus();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.NamespaceSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.NamespaceStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.NamespaceSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.NamespaceStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NamespaceCondition contains details about state of namespace.
  /// </summary>
  public sealed partial class NamespaceCondition : pb::IMessage<NamespaceCondition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NamespaceCondition> _parser = new pb::MessageParser<NamespaceCondition>(() => new NamespaceCondition());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NamespaceCondition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[83]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceCondition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceCondition(NamespaceCondition other) : this() {
      type_ = other.type_;
      status_ = other.status_;
      lastTransitionTime_ = other.lastTransitionTime_ != null ? other.lastTransitionTime_.Clone() : null;
      reason_ = other.reason_;
      message_ = other.message_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceCondition Clone() {
      return new NamespaceCondition(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Type of namespace controller condition.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 2;
    private readonly static string StatusDefaultValue = "";

    private string status_;
    /// <summary>
    /// Status of the condition, one of True, False, Unknown.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Status {
      get { return status_ ?? StatusDefaultValue; }
      set {
        status_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStatus {
      get { return status_ != null; }
    }
    /// <summary>Clears the value of the "status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStatus() {
      status_ = null;
    }

    /// <summary>Field number for the "lastTransitionTime" field.</summary>
    public const int LastTransitionTimeFieldNumber = 4;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time lastTransitionTime_;
    /// <summary>
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time LastTransitionTime {
      get { return lastTransitionTime_; }
      set {
        lastTransitionTime_ = value;
      }
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 5;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 6;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NamespaceCondition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NamespaceCondition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Status != other.Status) return false;
      if (!object.Equals(LastTransitionTime, other.LastTransitionTime)) return false;
      if (Reason != other.Reason) return false;
      if (Message != other.Message) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasStatus) hash ^= Status.GetHashCode();
      if (lastTransitionTime_ != null) hash ^= LastTransitionTime.GetHashCode();
      if (HasReason) hash ^= Reason.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (lastTransitionTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LastTransitionTime);
      }
      if (HasReason) {
        output.WriteRawTag(42);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(50);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (lastTransitionTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LastTransitionTime);
      }
      if (HasReason) {
        output.WriteRawTag(42);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(50);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasStatus) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Status);
      }
      if (lastTransitionTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastTransitionTime);
      }
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NamespaceCondition other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasStatus) {
        Status = other.Status;
      }
      if (other.lastTransitionTime_ != null) {
        if (lastTransitionTime_ == null) {
          LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        LastTransitionTime.MergeFrom(other.LastTransitionTime);
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 34: {
            if (lastTransitionTime_ == null) {
              LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTransitionTime);
            break;
          }
          case 42: {
            Reason = input.ReadString();
            break;
          }
          case 50: {
            Message = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 34: {
            if (lastTransitionTime_ == null) {
              LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTransitionTime);
            break;
          }
          case 42: {
            Reason = input.ReadString();
            break;
          }
          case 50: {
            Message = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NamespaceList is a list of Namespaces.
  /// </summary>
  public sealed partial class NamespaceList : pb::IMessage<NamespaceList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NamespaceList> _parser = new pb::MessageParser<NamespaceList>(() => new NamespaceList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NamespaceList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[84]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceList(NamespaceList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceList Clone() {
      return new NamespaceList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Namespace> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.Namespace.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Namespace> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Namespace>();
    /// <summary>
    /// Items is the list of Namespace objects in the list.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Namespace> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NamespaceList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NamespaceList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NamespaceList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NamespaceSpec describes the attributes on a Namespace.
  /// </summary>
  public sealed partial class NamespaceSpec : pb::IMessage<NamespaceSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NamespaceSpec> _parser = new pb::MessageParser<NamespaceSpec>(() => new NamespaceSpec());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NamespaceSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[85]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceSpec(NamespaceSpec other) : this() {
      finalizers_ = other.finalizers_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceSpec Clone() {
      return new NamespaceSpec(this);
    }

    /// <summary>Field number for the "finalizers" field.</summary>
    public const int FinalizersFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_finalizers_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> finalizers_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Finalizers is an opaque list of values that must be empty to permanently remove object from storage.
    /// More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Finalizers {
      get { return finalizers_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NamespaceSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NamespaceSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!finalizers_.Equals(other.finalizers_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= finalizers_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      finalizers_.WriteTo(output, _repeated_finalizers_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      finalizers_.WriteTo(ref output, _repeated_finalizers_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += finalizers_.CalculateSize(_repeated_finalizers_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NamespaceSpec other) {
      if (other == null) {
        return;
      }
      finalizers_.Add(other.finalizers_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            finalizers_.AddEntriesFrom(input, _repeated_finalizers_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            finalizers_.AddEntriesFrom(ref input, _repeated_finalizers_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NamespaceStatus is information about the current status of a Namespace.
  /// </summary>
  public sealed partial class NamespaceStatus : pb::IMessage<NamespaceStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NamespaceStatus> _parser = new pb::MessageParser<NamespaceStatus>(() => new NamespaceStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NamespaceStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[86]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceStatus(NamespaceStatus other) : this() {
      phase_ = other.phase_;
      conditions_ = other.conditions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NamespaceStatus Clone() {
      return new NamespaceStatus(this);
    }

    /// <summary>Field number for the "phase" field.</summary>
    public const int PhaseFieldNumber = 1;
    private readonly static string PhaseDefaultValue = "";

    private string phase_;
    /// <summary>
    /// Phase is the current lifecycle phase of the namespace.
    /// More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Phase {
      get { return phase_ ?? PhaseDefaultValue; }
      set {
        phase_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "phase" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPhase {
      get { return phase_ != null; }
    }
    /// <summary>Clears the value of the "phase" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPhase() {
      phase_ = null;
    }

    /// <summary>Field number for the "conditions" field.</summary>
    public const int ConditionsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.NamespaceCondition> _repeated_conditions_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.NamespaceCondition.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NamespaceCondition> conditions_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NamespaceCondition>();
    /// <summary>
    /// Represents the latest available observations of a namespace's current state.
    /// +optional
    /// +patchMergeKey=type
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NamespaceCondition> Conditions {
      get { return conditions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NamespaceStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NamespaceStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Phase != other.Phase) return false;
      if(!conditions_.Equals(other.conditions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPhase) hash ^= Phase.GetHashCode();
      hash ^= conditions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPhase) {
        output.WriteRawTag(10);
        output.WriteString(Phase);
      }
      conditions_.WriteTo(output, _repeated_conditions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPhase) {
        output.WriteRawTag(10);
        output.WriteString(Phase);
      }
      conditions_.WriteTo(ref output, _repeated_conditions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPhase) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Phase);
      }
      size += conditions_.CalculateSize(_repeated_conditions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NamespaceStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasPhase) {
        Phase = other.Phase;
      }
      conditions_.Add(other.conditions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Phase = input.ReadString();
            break;
          }
          case 18: {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Phase = input.ReadString();
            break;
          }
          case 18: {
            conditions_.AddEntriesFrom(ref input, _repeated_conditions_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Node is a worker node in Kubernetes.
  /// Each node will have a unique identifier in the cache (i.e. in etcd).
  /// </summary>
  public sealed partial class Node : pb::IMessage<Node>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Node> _parser = new pb::MessageParser<Node>(() => new Node());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Node> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[87]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Node() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Node(Node other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Node Clone() {
      return new Node(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.NodeSpec spec_;
    /// <summary>
    /// Spec defines the behavior of a node.
    /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.NodeStatus status_;
    /// <summary>
    /// Most recently observed status of the node.
    /// Populated by the system.
    /// Read-only.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Node);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Node other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Node other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.NodeSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::K8S.Io.Api.Core.V1.NodeStatus();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.NodeSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.NodeStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.NodeSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.NodeStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeAddress contains information for the node's address.
  /// </summary>
  public sealed partial class NodeAddress : pb::IMessage<NodeAddress>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeAddress> _parser = new pb::MessageParser<NodeAddress>(() => new NodeAddress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeAddress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[88]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAddress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAddress(NodeAddress other) : this() {
      type_ = other.type_;
      address_ = other.address_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAddress Clone() {
      return new NodeAddress(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Node address type, one of Hostname, ExternalIP or InternalIP.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 2;
    private readonly static string AddressDefaultValue = "";

    private string address_;
    /// <summary>
    /// The node address.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Address {
      get { return address_ ?? AddressDefaultValue; }
      set {
        address_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "address" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAddress {
      get { return address_ != null; }
    }
    /// <summary>Clears the value of the "address" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAddress() {
      address_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeAddress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeAddress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Address != other.Address) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasAddress) hash ^= Address.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasAddress) {
        output.WriteRawTag(18);
        output.WriteString(Address);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasAddress) {
        output.WriteRawTag(18);
        output.WriteString(Address);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasAddress) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Address);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeAddress other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasAddress) {
        Address = other.Address;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Address = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Address = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Node affinity is a group of node affinity scheduling rules.
  /// </summary>
  public sealed partial class NodeAffinity : pb::IMessage<NodeAffinity>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeAffinity> _parser = new pb::MessageParser<NodeAffinity>(() => new NodeAffinity());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeAffinity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[89]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAffinity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAffinity(NodeAffinity other) : this() {
      requiredDuringSchedulingIgnoredDuringExecution_ = other.requiredDuringSchedulingIgnoredDuringExecution_ != null ? other.requiredDuringSchedulingIgnoredDuringExecution_.Clone() : null;
      preferredDuringSchedulingIgnoredDuringExecution_ = other.preferredDuringSchedulingIgnoredDuringExecution_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeAffinity Clone() {
      return new NodeAffinity(this);
    }

    /// <summary>Field number for the "requiredDuringSchedulingIgnoredDuringExecution" field.</summary>
    public const int RequiredDuringSchedulingIgnoredDuringExecutionFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.NodeSelector requiredDuringSchedulingIgnoredDuringExecution_;
    /// <summary>
    /// If the affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to an update), the system
    /// may or may not try to eventually evict the pod from its node.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeSelector RequiredDuringSchedulingIgnoredDuringExecution {
      get { return requiredDuringSchedulingIgnoredDuringExecution_; }
      set {
        requiredDuringSchedulingIgnoredDuringExecution_ = value;
      }
    }

    /// <summary>Field number for the "preferredDuringSchedulingIgnoredDuringExecution" field.</summary>
    public const int PreferredDuringSchedulingIgnoredDuringExecutionFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PreferredSchedulingTerm> _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.PreferredSchedulingTerm.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PreferredSchedulingTerm> preferredDuringSchedulingIgnoredDuringExecution_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PreferredSchedulingTerm>();
    /// <summary>
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node matches the corresponding matchExpressions; the
    /// node(s) with the highest sum are the most preferred.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PreferredSchedulingTerm> PreferredDuringSchedulingIgnoredDuringExecution {
      get { return preferredDuringSchedulingIgnoredDuringExecution_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeAffinity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeAffinity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(RequiredDuringSchedulingIgnoredDuringExecution, other.RequiredDuringSchedulingIgnoredDuringExecution)) return false;
      if(!preferredDuringSchedulingIgnoredDuringExecution_.Equals(other.preferredDuringSchedulingIgnoredDuringExecution_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (requiredDuringSchedulingIgnoredDuringExecution_ != null) hash ^= RequiredDuringSchedulingIgnoredDuringExecution.GetHashCode();
      hash ^= preferredDuringSchedulingIgnoredDuringExecution_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (requiredDuringSchedulingIgnoredDuringExecution_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(RequiredDuringSchedulingIgnoredDuringExecution);
      }
      preferredDuringSchedulingIgnoredDuringExecution_.WriteTo(output, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (requiredDuringSchedulingIgnoredDuringExecution_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(RequiredDuringSchedulingIgnoredDuringExecution);
      }
      preferredDuringSchedulingIgnoredDuringExecution_.WriteTo(ref output, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (requiredDuringSchedulingIgnoredDuringExecution_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RequiredDuringSchedulingIgnoredDuringExecution);
      }
      size += preferredDuringSchedulingIgnoredDuringExecution_.CalculateSize(_repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeAffinity other) {
      if (other == null) {
        return;
      }
      if (other.requiredDuringSchedulingIgnoredDuringExecution_ != null) {
        if (requiredDuringSchedulingIgnoredDuringExecution_ == null) {
          RequiredDuringSchedulingIgnoredDuringExecution = new global::K8S.Io.Api.Core.V1.NodeSelector();
        }
        RequiredDuringSchedulingIgnoredDuringExecution.MergeFrom(other.RequiredDuringSchedulingIgnoredDuringExecution);
      }
      preferredDuringSchedulingIgnoredDuringExecution_.Add(other.preferredDuringSchedulingIgnoredDuringExecution_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (requiredDuringSchedulingIgnoredDuringExecution_ == null) {
              RequiredDuringSchedulingIgnoredDuringExecution = new global::K8S.Io.Api.Core.V1.NodeSelector();
            }
            input.ReadMessage(RequiredDuringSchedulingIgnoredDuringExecution);
            break;
          }
          case 18: {
            preferredDuringSchedulingIgnoredDuringExecution_.AddEntriesFrom(input, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (requiredDuringSchedulingIgnoredDuringExecution_ == null) {
              RequiredDuringSchedulingIgnoredDuringExecution = new global::K8S.Io.Api.Core.V1.NodeSelector();
            }
            input.ReadMessage(RequiredDuringSchedulingIgnoredDuringExecution);
            break;
          }
          case 18: {
            preferredDuringSchedulingIgnoredDuringExecution_.AddEntriesFrom(ref input, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeCondition contains condition information for a node.
  /// </summary>
  public sealed partial class NodeCondition : pb::IMessage<NodeCondition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeCondition> _parser = new pb::MessageParser<NodeCondition>(() => new NodeCondition());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeCondition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[90]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeCondition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeCondition(NodeCondition other) : this() {
      type_ = other.type_;
      status_ = other.status_;
      lastHeartbeatTime_ = other.lastHeartbeatTime_ != null ? other.lastHeartbeatTime_.Clone() : null;
      lastTransitionTime_ = other.lastTransitionTime_ != null ? other.lastTransitionTime_.Clone() : null;
      reason_ = other.reason_;
      message_ = other.message_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeCondition Clone() {
      return new NodeCondition(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Type of node condition.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 2;
    private readonly static string StatusDefaultValue = "";

    private string status_;
    /// <summary>
    /// Status of the condition, one of True, False, Unknown.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Status {
      get { return status_ ?? StatusDefaultValue; }
      set {
        status_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStatus {
      get { return status_ != null; }
    }
    /// <summary>Clears the value of the "status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStatus() {
      status_ = null;
    }

    /// <summary>Field number for the "lastHeartbeatTime" field.</summary>
    public const int LastHeartbeatTimeFieldNumber = 3;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time lastHeartbeatTime_;
    /// <summary>
    /// Last time we got an update on a given condition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time LastHeartbeatTime {
      get { return lastHeartbeatTime_; }
      set {
        lastHeartbeatTime_ = value;
      }
    }

    /// <summary>Field number for the "lastTransitionTime" field.</summary>
    public const int LastTransitionTimeFieldNumber = 4;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time lastTransitionTime_;
    /// <summary>
    /// Last time the condition transit from one status to another.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time LastTransitionTime {
      get { return lastTransitionTime_; }
      set {
        lastTransitionTime_ = value;
      }
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 5;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// (brief) reason for the condition's last transition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 6;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// Human readable message indicating details about last transition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeCondition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeCondition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Status != other.Status) return false;
      if (!object.Equals(LastHeartbeatTime, other.LastHeartbeatTime)) return false;
      if (!object.Equals(LastTransitionTime, other.LastTransitionTime)) return false;
      if (Reason != other.Reason) return false;
      if (Message != other.Message) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasStatus) hash ^= Status.GetHashCode();
      if (lastHeartbeatTime_ != null) hash ^= LastHeartbeatTime.GetHashCode();
      if (lastTransitionTime_ != null) hash ^= LastTransitionTime.GetHashCode();
      if (HasReason) hash ^= Reason.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (lastHeartbeatTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastHeartbeatTime);
      }
      if (lastTransitionTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LastTransitionTime);
      }
      if (HasReason) {
        output.WriteRawTag(42);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(50);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (lastHeartbeatTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastHeartbeatTime);
      }
      if (lastTransitionTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LastTransitionTime);
      }
      if (HasReason) {
        output.WriteRawTag(42);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(50);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasStatus) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Status);
      }
      if (lastHeartbeatTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastHeartbeatTime);
      }
      if (lastTransitionTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastTransitionTime);
      }
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeCondition other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasStatus) {
        Status = other.Status;
      }
      if (other.lastHeartbeatTime_ != null) {
        if (lastHeartbeatTime_ == null) {
          LastHeartbeatTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        LastHeartbeatTime.MergeFrom(other.LastHeartbeatTime);
      }
      if (other.lastTransitionTime_ != null) {
        if (lastTransitionTime_ == null) {
          LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        LastTransitionTime.MergeFrom(other.LastTransitionTime);
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 26: {
            if (lastHeartbeatTime_ == null) {
              LastHeartbeatTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastHeartbeatTime);
            break;
          }
          case 34: {
            if (lastTransitionTime_ == null) {
              LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTransitionTime);
            break;
          }
          case 42: {
            Reason = input.ReadString();
            break;
          }
          case 50: {
            Message = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 26: {
            if (lastHeartbeatTime_ == null) {
              LastHeartbeatTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastHeartbeatTime);
            break;
          }
          case 34: {
            if (lastTransitionTime_ == null) {
              LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTransitionTime);
            break;
          }
          case 42: {
            Reason = input.ReadString();
            break;
          }
          case 50: {
            Message = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil.
  /// This API is deprecated since 1.22
  /// </summary>
  public sealed partial class NodeConfigSource : pb::IMessage<NodeConfigSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeConfigSource> _parser = new pb::MessageParser<NodeConfigSource>(() => new NodeConfigSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeConfigSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[91]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeConfigSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeConfigSource(NodeConfigSource other) : this() {
      configMap_ = other.configMap_ != null ? other.configMap_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeConfigSource Clone() {
      return new NodeConfigSource(this);
    }

    /// <summary>Field number for the "configMap" field.</summary>
    public const int ConfigMapFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ConfigMapNodeConfigSource configMap_;
    /// <summary>
    /// ConfigMap is a reference to a Node's ConfigMap
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ConfigMapNodeConfigSource ConfigMap {
      get { return configMap_; }
      set {
        configMap_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeConfigSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeConfigSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ConfigMap, other.ConfigMap)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (configMap_ != null) hash ^= ConfigMap.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (configMap_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ConfigMap);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (configMap_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ConfigMap);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (configMap_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigMap);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeConfigSource other) {
      if (other == null) {
        return;
      }
      if (other.configMap_ != null) {
        if (configMap_ == null) {
          ConfigMap = new global::K8S.Io.Api.Core.V1.ConfigMapNodeConfigSource();
        }
        ConfigMap.MergeFrom(other.ConfigMap);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 18: {
            if (configMap_ == null) {
              ConfigMap = new global::K8S.Io.Api.Core.V1.ConfigMapNodeConfigSource();
            }
            input.ReadMessage(ConfigMap);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 18: {
            if (configMap_ == null) {
              ConfigMap = new global::K8S.Io.Api.Core.V1.ConfigMapNodeConfigSource();
            }
            input.ReadMessage(ConfigMap);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
  /// </summary>
  public sealed partial class NodeConfigStatus : pb::IMessage<NodeConfigStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeConfigStatus> _parser = new pb::MessageParser<NodeConfigStatus>(() => new NodeConfigStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeConfigStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[92]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeConfigStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeConfigStatus(NodeConfigStatus other) : this() {
      assigned_ = other.assigned_ != null ? other.assigned_.Clone() : null;
      active_ = other.active_ != null ? other.active_.Clone() : null;
      lastKnownGood_ = other.lastKnownGood_ != null ? other.lastKnownGood_.Clone() : null;
      error_ = other.error_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeConfigStatus Clone() {
      return new NodeConfigStatus(this);
    }

    /// <summary>Field number for the "assigned" field.</summary>
    public const int AssignedFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.NodeConfigSource assigned_;
    /// <summary>
    /// Assigned reports the checkpointed config the node will try to use.
    /// When Node.Spec.ConfigSource is updated, the node checkpoints the associated
    /// config payload to local disk, along with a record indicating intended
    /// config. The node refers to this record to choose its config checkpoint, and
    /// reports this record in Assigned. Assigned only updates in the status after
    /// the record has been checkpointed to disk. When the Kubelet is restarted,
    /// it tries to make the Assigned config the Active config by loading and
    /// validating the checkpointed payload identified by Assigned.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeConfigSource Assigned {
      get { return assigned_; }
      set {
        assigned_ = value;
      }
    }

    /// <summary>Field number for the "active" field.</summary>
    public const int ActiveFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.NodeConfigSource active_;
    /// <summary>
    /// Active reports the checkpointed config the node is actively using.
    /// Active will represent either the current version of the Assigned config,
    /// or the current LastKnownGood config, depending on whether attempting to use the
    /// Assigned config results in an error.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeConfigSource Active {
      get { return active_; }
      set {
        active_ = value;
      }
    }

    /// <summary>Field number for the "lastKnownGood" field.</summary>
    public const int LastKnownGoodFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.NodeConfigSource lastKnownGood_;
    /// <summary>
    /// LastKnownGood reports the checkpointed config the node will fall back to
    /// when it encounters an error attempting to use the Assigned config.
    /// The Assigned config becomes the LastKnownGood config when the node determines
    /// that the Assigned config is stable and correct.
    /// This is currently implemented as a 10-minute soak period starting when the local
    /// record of Assigned config is updated. If the Assigned config is Active at the end
    /// of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is
    /// reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil,
    /// because the local default config is always assumed good.
    /// You should not make assumptions about the node's method of determining config stability
    /// and correctness, as this may change or become configurable in the future.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeConfigSource LastKnownGood {
      get { return lastKnownGood_; }
      set {
        lastKnownGood_ = value;
      }
    }

    /// <summary>Field number for the "error" field.</summary>
    public const int ErrorFieldNumber = 4;
    private readonly static string ErrorDefaultValue = "";

    private string error_;
    /// <summary>
    /// Error describes any problems reconciling the Spec.ConfigSource to the Active config.
    /// Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned
    /// record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting
    /// to load or validate the Assigned config, etc.
    /// Errors may occur at different points while syncing config. Earlier errors (e.g. download or
    /// checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across
    /// Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in
    /// a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error
    /// by fixing the config assigned in Spec.ConfigSource.
    /// You can find additional information for debugging by searching the error message in the Kubelet log.
    /// Error is a human-readable description of the error state; machines can check whether or not Error
    /// is empty, but should not rely on the stability of the Error text across Kubelet versions.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Error {
      get { return error_ ?? ErrorDefaultValue; }
      set {
        error_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "error" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasError {
      get { return error_ != null; }
    }
    /// <summary>Clears the value of the "error" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearError() {
      error_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeConfigStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeConfigStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Assigned, other.Assigned)) return false;
      if (!object.Equals(Active, other.Active)) return false;
      if (!object.Equals(LastKnownGood, other.LastKnownGood)) return false;
      if (Error != other.Error) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (assigned_ != null) hash ^= Assigned.GetHashCode();
      if (active_ != null) hash ^= Active.GetHashCode();
      if (lastKnownGood_ != null) hash ^= LastKnownGood.GetHashCode();
      if (HasError) hash ^= Error.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (assigned_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Assigned);
      }
      if (active_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Active);
      }
      if (lastKnownGood_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastKnownGood);
      }
      if (HasError) {
        output.WriteRawTag(34);
        output.WriteString(Error);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (assigned_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Assigned);
      }
      if (active_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Active);
      }
      if (lastKnownGood_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastKnownGood);
      }
      if (HasError) {
        output.WriteRawTag(34);
        output.WriteString(Error);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (assigned_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Assigned);
      }
      if (active_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Active);
      }
      if (lastKnownGood_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastKnownGood);
      }
      if (HasError) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Error);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeConfigStatus other) {
      if (other == null) {
        return;
      }
      if (other.assigned_ != null) {
        if (assigned_ == null) {
          Assigned = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
        }
        Assigned.MergeFrom(other.Assigned);
      }
      if (other.active_ != null) {
        if (active_ == null) {
          Active = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
        }
        Active.MergeFrom(other.Active);
      }
      if (other.lastKnownGood_ != null) {
        if (lastKnownGood_ == null) {
          LastKnownGood = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
        }
        LastKnownGood.MergeFrom(other.LastKnownGood);
      }
      if (other.HasError) {
        Error = other.Error;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (assigned_ == null) {
              Assigned = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
            }
            input.ReadMessage(Assigned);
            break;
          }
          case 18: {
            if (active_ == null) {
              Active = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
            }
            input.ReadMessage(Active);
            break;
          }
          case 26: {
            if (lastKnownGood_ == null) {
              LastKnownGood = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
            }
            input.ReadMessage(LastKnownGood);
            break;
          }
          case 34: {
            Error = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (assigned_ == null) {
              Assigned = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
            }
            input.ReadMessage(Assigned);
            break;
          }
          case 18: {
            if (active_ == null) {
              Active = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
            }
            input.ReadMessage(Active);
            break;
          }
          case 26: {
            if (lastKnownGood_ == null) {
              LastKnownGood = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
            }
            input.ReadMessage(LastKnownGood);
            break;
          }
          case 34: {
            Error = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
  /// </summary>
  public sealed partial class NodeDaemonEndpoints : pb::IMessage<NodeDaemonEndpoints>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeDaemonEndpoints> _parser = new pb::MessageParser<NodeDaemonEndpoints>(() => new NodeDaemonEndpoints());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeDaemonEndpoints> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[93]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeDaemonEndpoints() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeDaemonEndpoints(NodeDaemonEndpoints other) : this() {
      kubeletEndpoint_ = other.kubeletEndpoint_ != null ? other.kubeletEndpoint_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeDaemonEndpoints Clone() {
      return new NodeDaemonEndpoints(this);
    }

    /// <summary>Field number for the "kubeletEndpoint" field.</summary>
    public const int KubeletEndpointFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.DaemonEndpoint kubeletEndpoint_;
    /// <summary>
    /// Endpoint on which Kubelet is listening.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.DaemonEndpoint KubeletEndpoint {
      get { return kubeletEndpoint_; }
      set {
        kubeletEndpoint_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeDaemonEndpoints);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeDaemonEndpoints other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(KubeletEndpoint, other.KubeletEndpoint)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (kubeletEndpoint_ != null) hash ^= KubeletEndpoint.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (kubeletEndpoint_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(KubeletEndpoint);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (kubeletEndpoint_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(KubeletEndpoint);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (kubeletEndpoint_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(KubeletEndpoint);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeDaemonEndpoints other) {
      if (other == null) {
        return;
      }
      if (other.kubeletEndpoint_ != null) {
        if (kubeletEndpoint_ == null) {
          KubeletEndpoint = new global::K8S.Io.Api.Core.V1.DaemonEndpoint();
        }
        KubeletEndpoint.MergeFrom(other.KubeletEndpoint);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (kubeletEndpoint_ == null) {
              KubeletEndpoint = new global::K8S.Io.Api.Core.V1.DaemonEndpoint();
            }
            input.ReadMessage(KubeletEndpoint);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (kubeletEndpoint_ == null) {
              KubeletEndpoint = new global::K8S.Io.Api.Core.V1.DaemonEndpoint();
            }
            input.ReadMessage(KubeletEndpoint);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeList is the whole list of all Nodes which have been registered with master.
  /// </summary>
  public sealed partial class NodeList : pb::IMessage<NodeList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeList> _parser = new pb::MessageParser<NodeList>(() => new NodeList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[94]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeList(NodeList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeList Clone() {
      return new NodeList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Node> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.Node.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Node> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Node>();
    /// <summary>
    /// List of nodes
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Node> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeProxyOptions is the query options to a Node's proxy call.
  /// </summary>
  public sealed partial class NodeProxyOptions : pb::IMessage<NodeProxyOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeProxyOptions> _parser = new pb::MessageParser<NodeProxyOptions>(() => new NodeProxyOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeProxyOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[95]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeProxyOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeProxyOptions(NodeProxyOptions other) : this() {
      path_ = other.path_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeProxyOptions Clone() {
      return new NodeProxyOptions(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Path is the URL path to use for the current proxy request to node.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeProxyOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeProxyOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPath) hash ^= Path.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeProxyOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeResources is an object for conveying resource information about a node.
  /// see https://kubernetes.io/docs/concepts/architecture/nodes/#capacity for more details.
  /// </summary>
  public sealed partial class NodeResources : pb::IMessage<NodeResources>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeResources> _parser = new pb::MessageParser<NodeResources>(() => new NodeResources());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeResources> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[96]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeResources() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeResources(NodeResources other) : this() {
      capacity_ = other.capacity_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeResources Clone() {
      return new NodeResources(this);
    }

    /// <summary>Field number for the "capacity" field.</summary>
    public const int CapacityFieldNumber = 1;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_capacity_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 10);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> capacity_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Capacity represents the available resources of a node
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Capacity {
      get { return capacity_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeResources);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeResources other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Capacity.Equals(other.Capacity)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Capacity.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      capacity_.WriteTo(output, _map_capacity_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      capacity_.WriteTo(ref output, _map_capacity_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += capacity_.CalculateSize(_map_capacity_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeResources other) {
      if (other == null) {
        return;
      }
      capacity_.Add(other.capacity_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            capacity_.AddEntriesFrom(input, _map_capacity_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            capacity_.AddEntriesFrom(ref input, _map_capacity_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A node selector represents the union of the results of one or more label queries
  /// over a set of nodes; that is, it represents the OR of the selectors represented
  /// by the node selector terms.
  /// +structType=atomic
  /// </summary>
  public sealed partial class NodeSelector : pb::IMessage<NodeSelector>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeSelector> _parser = new pb::MessageParser<NodeSelector>(() => new NodeSelector());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeSelector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[97]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSelector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSelector(NodeSelector other) : this() {
      nodeSelectorTerms_ = other.nodeSelectorTerms_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSelector Clone() {
      return new NodeSelector(this);
    }

    /// <summary>Field number for the "nodeSelectorTerms" field.</summary>
    public const int NodeSelectorTermsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.NodeSelectorTerm> _repeated_nodeSelectorTerms_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.NodeSelectorTerm.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeSelectorTerm> nodeSelectorTerms_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeSelectorTerm>();
    /// <summary>
    /// Required. A list of node selector terms. The terms are ORed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeSelectorTerm> NodeSelectorTerms {
      get { return nodeSelectorTerms_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeSelector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeSelector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!nodeSelectorTerms_.Equals(other.nodeSelectorTerms_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= nodeSelectorTerms_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      nodeSelectorTerms_.WriteTo(output, _repeated_nodeSelectorTerms_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      nodeSelectorTerms_.WriteTo(ref output, _repeated_nodeSelectorTerms_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += nodeSelectorTerms_.CalculateSize(_repeated_nodeSelectorTerms_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeSelector other) {
      if (other == null) {
        return;
      }
      nodeSelectorTerms_.Add(other.nodeSelectorTerms_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            nodeSelectorTerms_.AddEntriesFrom(input, _repeated_nodeSelectorTerms_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            nodeSelectorTerms_.AddEntriesFrom(ref input, _repeated_nodeSelectorTerms_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A node selector requirement is a selector that contains values, a key, and an operator
  /// that relates the key and values.
  /// </summary>
  public sealed partial class NodeSelectorRequirement : pb::IMessage<NodeSelectorRequirement>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeSelectorRequirement> _parser = new pb::MessageParser<NodeSelectorRequirement>(() => new NodeSelectorRequirement());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeSelectorRequirement> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[98]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSelectorRequirement() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSelectorRequirement(NodeSelectorRequirement other) : this() {
      key_ = other.key_;
      operator_ = other.operator_;
      values_ = other.values_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSelectorRequirement Clone() {
      return new NodeSelectorRequirement(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    /// <summary>
    /// The label key that the selector applies to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "operator" field.</summary>
    public const int OperatorFieldNumber = 2;
    private readonly static string OperatorDefaultValue = "";

    private string operator_;
    /// <summary>
    /// Represents a key's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Operator {
      get { return operator_ ?? OperatorDefaultValue; }
      set {
        operator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "operator" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOperator {
      get { return operator_ != null; }
    }
    /// <summary>Clears the value of the "operator" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOperator() {
      operator_ = null;
    }

    /// <summary>Field number for the "values" field.</summary>
    public const int ValuesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_values_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> values_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty. If the operator is Gt or Lt, the values
    /// array must have a single element, which will be interpreted as an integer.
    /// This array is replaced during a strategic merge patch.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Values {
      get { return values_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeSelectorRequirement);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeSelectorRequirement other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Operator != other.Operator) return false;
      if(!values_.Equals(other.values_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasOperator) hash ^= Operator.GetHashCode();
      hash ^= values_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasOperator) {
        output.WriteRawTag(18);
        output.WriteString(Operator);
      }
      values_.WriteTo(output, _repeated_values_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasOperator) {
        output.WriteRawTag(18);
        output.WriteString(Operator);
      }
      values_.WriteTo(ref output, _repeated_values_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (HasOperator) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Operator);
      }
      size += values_.CalculateSize(_repeated_values_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeSelectorRequirement other) {
      if (other == null) {
        return;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasOperator) {
        Operator = other.Operator;
      }
      values_.Add(other.values_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Operator = input.ReadString();
            break;
          }
          case 26: {
            values_.AddEntriesFrom(input, _repeated_values_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Operator = input.ReadString();
            break;
          }
          case 26: {
            values_.AddEntriesFrom(ref input, _repeated_values_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A null or empty node selector term matches no objects. The requirements of
  /// them are ANDed.
  /// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
  /// +structType=atomic
  /// </summary>
  public sealed partial class NodeSelectorTerm : pb::IMessage<NodeSelectorTerm>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeSelectorTerm> _parser = new pb::MessageParser<NodeSelectorTerm>(() => new NodeSelectorTerm());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeSelectorTerm> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[99]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSelectorTerm() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSelectorTerm(NodeSelectorTerm other) : this() {
      matchExpressions_ = other.matchExpressions_.Clone();
      matchFields_ = other.matchFields_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSelectorTerm Clone() {
      return new NodeSelectorTerm(this);
    }

    /// <summary>Field number for the "matchExpressions" field.</summary>
    public const int MatchExpressionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.NodeSelectorRequirement> _repeated_matchExpressions_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.NodeSelectorRequirement.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeSelectorRequirement> matchExpressions_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeSelectorRequirement>();
    /// <summary>
    /// A list of node selector requirements by node's labels.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeSelectorRequirement> MatchExpressions {
      get { return matchExpressions_; }
    }

    /// <summary>Field number for the "matchFields" field.</summary>
    public const int MatchFieldsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.NodeSelectorRequirement> _repeated_matchFields_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.NodeSelectorRequirement.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeSelectorRequirement> matchFields_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeSelectorRequirement>();
    /// <summary>
    /// A list of node selector requirements by node's fields.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeSelectorRequirement> MatchFields {
      get { return matchFields_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeSelectorTerm);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeSelectorTerm other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!matchExpressions_.Equals(other.matchExpressions_)) return false;
      if(!matchFields_.Equals(other.matchFields_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= matchExpressions_.GetHashCode();
      hash ^= matchFields_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      matchExpressions_.WriteTo(output, _repeated_matchExpressions_codec);
      matchFields_.WriteTo(output, _repeated_matchFields_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      matchExpressions_.WriteTo(ref output, _repeated_matchExpressions_codec);
      matchFields_.WriteTo(ref output, _repeated_matchFields_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += matchExpressions_.CalculateSize(_repeated_matchExpressions_codec);
      size += matchFields_.CalculateSize(_repeated_matchFields_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeSelectorTerm other) {
      if (other == null) {
        return;
      }
      matchExpressions_.Add(other.matchExpressions_);
      matchFields_.Add(other.matchFields_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            matchExpressions_.AddEntriesFrom(input, _repeated_matchExpressions_codec);
            break;
          }
          case 18: {
            matchFields_.AddEntriesFrom(input, _repeated_matchFields_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            matchExpressions_.AddEntriesFrom(ref input, _repeated_matchExpressions_codec);
            break;
          }
          case 18: {
            matchFields_.AddEntriesFrom(ref input, _repeated_matchFields_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeSpec describes the attributes that a node is created with.
  /// </summary>
  public sealed partial class NodeSpec : pb::IMessage<NodeSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeSpec> _parser = new pb::MessageParser<NodeSpec>(() => new NodeSpec());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[100]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSpec(NodeSpec other) : this() {
      _hasBits0 = other._hasBits0;
      podCIDR_ = other.podCIDR_;
      podCIDRs_ = other.podCIDRs_.Clone();
      providerID_ = other.providerID_;
      unschedulable_ = other.unschedulable_;
      taints_ = other.taints_.Clone();
      configSource_ = other.configSource_ != null ? other.configSource_.Clone() : null;
      externalID_ = other.externalID_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSpec Clone() {
      return new NodeSpec(this);
    }

    /// <summary>Field number for the "podCIDR" field.</summary>
    public const int PodCIDRFieldNumber = 1;
    private readonly static string PodCIDRDefaultValue = "";

    private string podCIDR_;
    /// <summary>
    /// PodCIDR represents the pod IP range assigned to the node.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PodCIDR {
      get { return podCIDR_ ?? PodCIDRDefaultValue; }
      set {
        podCIDR_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "podCIDR" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPodCIDR {
      get { return podCIDR_ != null; }
    }
    /// <summary>Clears the value of the "podCIDR" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPodCIDR() {
      podCIDR_ = null;
    }

    /// <summary>Field number for the "podCIDRs" field.</summary>
    public const int PodCIDRsFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_podCIDRs_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> podCIDRs_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
    /// field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
    /// each of IPv4 and IPv6.
    /// +optional
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> PodCIDRs {
      get { return podCIDRs_; }
    }

    /// <summary>Field number for the "providerID" field.</summary>
    public const int ProviderIDFieldNumber = 3;
    private readonly static string ProviderIDDefaultValue = "";

    private string providerID_;
    /// <summary>
    /// ID of the node assigned by the cloud provider in the format: &lt;ProviderName>://&lt;ProviderSpecificNodeID>
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ProviderID {
      get { return providerID_ ?? ProviderIDDefaultValue; }
      set {
        providerID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "providerID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProviderID {
      get { return providerID_ != null; }
    }
    /// <summary>Clears the value of the "providerID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProviderID() {
      providerID_ = null;
    }

    /// <summary>Field number for the "unschedulable" field.</summary>
    public const int UnschedulableFieldNumber = 4;
    private readonly static bool UnschedulableDefaultValue = false;

    private bool unschedulable_;
    /// <summary>
    /// Unschedulable controls node schedulability of new pods. By default, node is schedulable.
    /// More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Unschedulable {
      get { if ((_hasBits0 & 1) != 0) { return unschedulable_; } else { return UnschedulableDefaultValue; } }
      set {
        _hasBits0 |= 1;
        unschedulable_ = value;
      }
    }
    /// <summary>Gets whether the "unschedulable" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUnschedulable {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "unschedulable" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUnschedulable() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "taints" field.</summary>
    public const int TaintsFieldNumber = 5;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Taint> _repeated_taints_codec
        = pb::FieldCodec.ForMessage(42, global::K8S.Io.Api.Core.V1.Taint.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Taint> taints_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Taint>();
    /// <summary>
    /// If specified, the node's taints.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Taint> Taints {
      get { return taints_; }
    }

    /// <summary>Field number for the "configSource" field.</summary>
    public const int ConfigSourceFieldNumber = 6;
    private global::K8S.Io.Api.Core.V1.NodeConfigSource configSource_;
    /// <summary>
    /// Deprecated. If specified, the source of the node's configuration.
    /// The DynamicKubeletConfig feature gate must be enabled for the Kubelet to use this field.
    /// This field is deprecated as of 1.22: https://git.k8s.io/enhancements/keps/sig-node/281-dynamic-kubelet-configuration
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeConfigSource ConfigSource {
      get { return configSource_; }
      set {
        configSource_ = value;
      }
    }

    /// <summary>Field number for the "externalID" field.</summary>
    public const int ExternalIDFieldNumber = 2;
    private readonly static string ExternalIDDefaultValue = "";

    private string externalID_;
    /// <summary>
    /// Deprecated. Not all kubelets will set this field. Remove field after 1.13.
    /// see: https://issues.k8s.io/61966
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ExternalID {
      get { return externalID_ ?? ExternalIDDefaultValue; }
      set {
        externalID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "externalID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExternalID {
      get { return externalID_ != null; }
    }
    /// <summary>Clears the value of the "externalID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExternalID() {
      externalID_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PodCIDR != other.PodCIDR) return false;
      if(!podCIDRs_.Equals(other.podCIDRs_)) return false;
      if (ProviderID != other.ProviderID) return false;
      if (Unschedulable != other.Unschedulable) return false;
      if(!taints_.Equals(other.taints_)) return false;
      if (!object.Equals(ConfigSource, other.ConfigSource)) return false;
      if (ExternalID != other.ExternalID) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPodCIDR) hash ^= PodCIDR.GetHashCode();
      hash ^= podCIDRs_.GetHashCode();
      if (HasProviderID) hash ^= ProviderID.GetHashCode();
      if (HasUnschedulable) hash ^= Unschedulable.GetHashCode();
      hash ^= taints_.GetHashCode();
      if (configSource_ != null) hash ^= ConfigSource.GetHashCode();
      if (HasExternalID) hash ^= ExternalID.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPodCIDR) {
        output.WriteRawTag(10);
        output.WriteString(PodCIDR);
      }
      if (HasExternalID) {
        output.WriteRawTag(18);
        output.WriteString(ExternalID);
      }
      if (HasProviderID) {
        output.WriteRawTag(26);
        output.WriteString(ProviderID);
      }
      if (HasUnschedulable) {
        output.WriteRawTag(32);
        output.WriteBool(Unschedulable);
      }
      taints_.WriteTo(output, _repeated_taints_codec);
      if (configSource_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ConfigSource);
      }
      podCIDRs_.WriteTo(output, _repeated_podCIDRs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPodCIDR) {
        output.WriteRawTag(10);
        output.WriteString(PodCIDR);
      }
      if (HasExternalID) {
        output.WriteRawTag(18);
        output.WriteString(ExternalID);
      }
      if (HasProviderID) {
        output.WriteRawTag(26);
        output.WriteString(ProviderID);
      }
      if (HasUnschedulable) {
        output.WriteRawTag(32);
        output.WriteBool(Unschedulable);
      }
      taints_.WriteTo(ref output, _repeated_taints_codec);
      if (configSource_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(ConfigSource);
      }
      podCIDRs_.WriteTo(ref output, _repeated_podCIDRs_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPodCIDR) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PodCIDR);
      }
      size += podCIDRs_.CalculateSize(_repeated_podCIDRs_codec);
      if (HasProviderID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProviderID);
      }
      if (HasUnschedulable) {
        size += 1 + 1;
      }
      size += taints_.CalculateSize(_repeated_taints_codec);
      if (configSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigSource);
      }
      if (HasExternalID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExternalID);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeSpec other) {
      if (other == null) {
        return;
      }
      if (other.HasPodCIDR) {
        PodCIDR = other.PodCIDR;
      }
      podCIDRs_.Add(other.podCIDRs_);
      if (other.HasProviderID) {
        ProviderID = other.ProviderID;
      }
      if (other.HasUnschedulable) {
        Unschedulable = other.Unschedulable;
      }
      taints_.Add(other.taints_);
      if (other.configSource_ != null) {
        if (configSource_ == null) {
          ConfigSource = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
        }
        ConfigSource.MergeFrom(other.ConfigSource);
      }
      if (other.HasExternalID) {
        ExternalID = other.ExternalID;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PodCIDR = input.ReadString();
            break;
          }
          case 18: {
            ExternalID = input.ReadString();
            break;
          }
          case 26: {
            ProviderID = input.ReadString();
            break;
          }
          case 32: {
            Unschedulable = input.ReadBool();
            break;
          }
          case 42: {
            taints_.AddEntriesFrom(input, _repeated_taints_codec);
            break;
          }
          case 50: {
            if (configSource_ == null) {
              ConfigSource = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
            }
            input.ReadMessage(ConfigSource);
            break;
          }
          case 58: {
            podCIDRs_.AddEntriesFrom(input, _repeated_podCIDRs_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PodCIDR = input.ReadString();
            break;
          }
          case 18: {
            ExternalID = input.ReadString();
            break;
          }
          case 26: {
            ProviderID = input.ReadString();
            break;
          }
          case 32: {
            Unschedulable = input.ReadBool();
            break;
          }
          case 42: {
            taints_.AddEntriesFrom(ref input, _repeated_taints_codec);
            break;
          }
          case 50: {
            if (configSource_ == null) {
              ConfigSource = new global::K8S.Io.Api.Core.V1.NodeConfigSource();
            }
            input.ReadMessage(ConfigSource);
            break;
          }
          case 58: {
            podCIDRs_.AddEntriesFrom(ref input, _repeated_podCIDRs_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeStatus is information about the current status of a node.
  /// </summary>
  public sealed partial class NodeStatus : pb::IMessage<NodeStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeStatus> _parser = new pb::MessageParser<NodeStatus>(() => new NodeStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[101]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeStatus(NodeStatus other) : this() {
      capacity_ = other.capacity_.Clone();
      allocatable_ = other.allocatable_.Clone();
      phase_ = other.phase_;
      conditions_ = other.conditions_.Clone();
      addresses_ = other.addresses_.Clone();
      daemonEndpoints_ = other.daemonEndpoints_ != null ? other.daemonEndpoints_.Clone() : null;
      nodeInfo_ = other.nodeInfo_ != null ? other.nodeInfo_.Clone() : null;
      images_ = other.images_.Clone();
      volumesInUse_ = other.volumesInUse_.Clone();
      volumesAttached_ = other.volumesAttached_.Clone();
      config_ = other.config_ != null ? other.config_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeStatus Clone() {
      return new NodeStatus(this);
    }

    /// <summary>Field number for the "capacity" field.</summary>
    public const int CapacityFieldNumber = 1;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_capacity_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 10);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> capacity_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Capacity represents the total resources of a node.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Capacity {
      get { return capacity_; }
    }

    /// <summary>Field number for the "allocatable" field.</summary>
    public const int AllocatableFieldNumber = 2;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_allocatable_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 18);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> allocatable_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Allocatable represents the resources of a node that are available for scheduling.
    /// Defaults to Capacity.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Allocatable {
      get { return allocatable_; }
    }

    /// <summary>Field number for the "phase" field.</summary>
    public const int PhaseFieldNumber = 3;
    private readonly static string PhaseDefaultValue = "";

    private string phase_;
    /// <summary>
    /// NodePhase is the recently observed lifecycle phase of the node.
    /// More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
    /// The field is never populated, and now is deprecated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Phase {
      get { return phase_ ?? PhaseDefaultValue; }
      set {
        phase_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "phase" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPhase {
      get { return phase_ != null; }
    }
    /// <summary>Clears the value of the "phase" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPhase() {
      phase_ = null;
    }

    /// <summary>Field number for the "conditions" field.</summary>
    public const int ConditionsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.NodeCondition> _repeated_conditions_codec
        = pb::FieldCodec.ForMessage(34, global::K8S.Io.Api.Core.V1.NodeCondition.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeCondition> conditions_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeCondition>();
    /// <summary>
    /// Conditions is an array of current observed node conditions.
    /// More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
    /// +optional
    /// +patchMergeKey=type
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeCondition> Conditions {
      get { return conditions_; }
    }

    /// <summary>Field number for the "addresses" field.</summary>
    public const int AddressesFieldNumber = 5;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.NodeAddress> _repeated_addresses_codec
        = pb::FieldCodec.ForMessage(42, global::K8S.Io.Api.Core.V1.NodeAddress.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeAddress> addresses_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeAddress>();
    /// <summary>
    /// List of addresses reachable to the node.
    /// Queried from cloud provider, if available.
    /// More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
    /// Note: This field is declared as mergeable, but the merge key is not sufficiently
    /// unique, which can cause data corruption when it is merged. Callers should instead
    /// use a full-replacement patch. See http://pr.k8s.io/79391 for an example.
    /// +optional
    /// +patchMergeKey=type
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.NodeAddress> Addresses {
      get { return addresses_; }
    }

    /// <summary>Field number for the "daemonEndpoints" field.</summary>
    public const int DaemonEndpointsFieldNumber = 6;
    private global::K8S.Io.Api.Core.V1.NodeDaemonEndpoints daemonEndpoints_;
    /// <summary>
    /// Endpoints of daemons running on the Node.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeDaemonEndpoints DaemonEndpoints {
      get { return daemonEndpoints_; }
      set {
        daemonEndpoints_ = value;
      }
    }

    /// <summary>Field number for the "nodeInfo" field.</summary>
    public const int NodeInfoFieldNumber = 7;
    private global::K8S.Io.Api.Core.V1.NodeSystemInfo nodeInfo_;
    /// <summary>
    /// Set of ids/uuids to uniquely identify the node.
    /// More info: https://kubernetes.io/docs/concepts/nodes/node/#info
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeSystemInfo NodeInfo {
      get { return nodeInfo_; }
      set {
        nodeInfo_ = value;
      }
    }

    /// <summary>Field number for the "images" field.</summary>
    public const int ImagesFieldNumber = 8;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ContainerImage> _repeated_images_codec
        = pb::FieldCodec.ForMessage(66, global::K8S.Io.Api.Core.V1.ContainerImage.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerImage> images_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerImage>();
    /// <summary>
    /// List of container images on this node
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerImage> Images {
      get { return images_; }
    }

    /// <summary>Field number for the "volumesInUse" field.</summary>
    public const int VolumesInUseFieldNumber = 9;
    private static readonly pb::FieldCodec<string> _repeated_volumesInUse_codec
        = pb::FieldCodec.ForString(74);
    private readonly pbc::RepeatedField<string> volumesInUse_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of attachable volumes in use (mounted) by the node.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> VolumesInUse {
      get { return volumesInUse_; }
    }

    /// <summary>Field number for the "volumesAttached" field.</summary>
    public const int VolumesAttachedFieldNumber = 10;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.AttachedVolume> _repeated_volumesAttached_codec
        = pb::FieldCodec.ForMessage(82, global::K8S.Io.Api.Core.V1.AttachedVolume.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.AttachedVolume> volumesAttached_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.AttachedVolume>();
    /// <summary>
    /// List of volumes that are attached to the node.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.AttachedVolume> VolumesAttached {
      get { return volumesAttached_; }
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 11;
    private global::K8S.Io.Api.Core.V1.NodeConfigStatus config_;
    /// <summary>
    /// Status of the config assigned to the node via the dynamic Kubelet config feature.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeConfigStatus Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Capacity.Equals(other.Capacity)) return false;
      if (!Allocatable.Equals(other.Allocatable)) return false;
      if (Phase != other.Phase) return false;
      if(!conditions_.Equals(other.conditions_)) return false;
      if(!addresses_.Equals(other.addresses_)) return false;
      if (!object.Equals(DaemonEndpoints, other.DaemonEndpoints)) return false;
      if (!object.Equals(NodeInfo, other.NodeInfo)) return false;
      if(!images_.Equals(other.images_)) return false;
      if(!volumesInUse_.Equals(other.volumesInUse_)) return false;
      if(!volumesAttached_.Equals(other.volumesAttached_)) return false;
      if (!object.Equals(Config, other.Config)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Capacity.GetHashCode();
      hash ^= Allocatable.GetHashCode();
      if (HasPhase) hash ^= Phase.GetHashCode();
      hash ^= conditions_.GetHashCode();
      hash ^= addresses_.GetHashCode();
      if (daemonEndpoints_ != null) hash ^= DaemonEndpoints.GetHashCode();
      if (nodeInfo_ != null) hash ^= NodeInfo.GetHashCode();
      hash ^= images_.GetHashCode();
      hash ^= volumesInUse_.GetHashCode();
      hash ^= volumesAttached_.GetHashCode();
      if (config_ != null) hash ^= Config.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      capacity_.WriteTo(output, _map_capacity_codec);
      allocatable_.WriteTo(output, _map_allocatable_codec);
      if (HasPhase) {
        output.WriteRawTag(26);
        output.WriteString(Phase);
      }
      conditions_.WriteTo(output, _repeated_conditions_codec);
      addresses_.WriteTo(output, _repeated_addresses_codec);
      if (daemonEndpoints_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DaemonEndpoints);
      }
      if (nodeInfo_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(NodeInfo);
      }
      images_.WriteTo(output, _repeated_images_codec);
      volumesInUse_.WriteTo(output, _repeated_volumesInUse_codec);
      volumesAttached_.WriteTo(output, _repeated_volumesAttached_codec);
      if (config_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Config);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      capacity_.WriteTo(ref output, _map_capacity_codec);
      allocatable_.WriteTo(ref output, _map_allocatable_codec);
      if (HasPhase) {
        output.WriteRawTag(26);
        output.WriteString(Phase);
      }
      conditions_.WriteTo(ref output, _repeated_conditions_codec);
      addresses_.WriteTo(ref output, _repeated_addresses_codec);
      if (daemonEndpoints_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DaemonEndpoints);
      }
      if (nodeInfo_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(NodeInfo);
      }
      images_.WriteTo(ref output, _repeated_images_codec);
      volumesInUse_.WriteTo(ref output, _repeated_volumesInUse_codec);
      volumesAttached_.WriteTo(ref output, _repeated_volumesAttached_codec);
      if (config_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Config);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += capacity_.CalculateSize(_map_capacity_codec);
      size += allocatable_.CalculateSize(_map_allocatable_codec);
      if (HasPhase) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Phase);
      }
      size += conditions_.CalculateSize(_repeated_conditions_codec);
      size += addresses_.CalculateSize(_repeated_addresses_codec);
      if (daemonEndpoints_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DaemonEndpoints);
      }
      if (nodeInfo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NodeInfo);
      }
      size += images_.CalculateSize(_repeated_images_codec);
      size += volumesInUse_.CalculateSize(_repeated_volumesInUse_codec);
      size += volumesAttached_.CalculateSize(_repeated_volumesAttached_codec);
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeStatus other) {
      if (other == null) {
        return;
      }
      capacity_.Add(other.capacity_);
      allocatable_.Add(other.allocatable_);
      if (other.HasPhase) {
        Phase = other.Phase;
      }
      conditions_.Add(other.conditions_);
      addresses_.Add(other.addresses_);
      if (other.daemonEndpoints_ != null) {
        if (daemonEndpoints_ == null) {
          DaemonEndpoints = new global::K8S.Io.Api.Core.V1.NodeDaemonEndpoints();
        }
        DaemonEndpoints.MergeFrom(other.DaemonEndpoints);
      }
      if (other.nodeInfo_ != null) {
        if (nodeInfo_ == null) {
          NodeInfo = new global::K8S.Io.Api.Core.V1.NodeSystemInfo();
        }
        NodeInfo.MergeFrom(other.NodeInfo);
      }
      images_.Add(other.images_);
      volumesInUse_.Add(other.volumesInUse_);
      volumesAttached_.Add(other.volumesAttached_);
      if (other.config_ != null) {
        if (config_ == null) {
          Config = new global::K8S.Io.Api.Core.V1.NodeConfigStatus();
        }
        Config.MergeFrom(other.Config);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            capacity_.AddEntriesFrom(input, _map_capacity_codec);
            break;
          }
          case 18: {
            allocatable_.AddEntriesFrom(input, _map_allocatable_codec);
            break;
          }
          case 26: {
            Phase = input.ReadString();
            break;
          }
          case 34: {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
          case 42: {
            addresses_.AddEntriesFrom(input, _repeated_addresses_codec);
            break;
          }
          case 50: {
            if (daemonEndpoints_ == null) {
              DaemonEndpoints = new global::K8S.Io.Api.Core.V1.NodeDaemonEndpoints();
            }
            input.ReadMessage(DaemonEndpoints);
            break;
          }
          case 58: {
            if (nodeInfo_ == null) {
              NodeInfo = new global::K8S.Io.Api.Core.V1.NodeSystemInfo();
            }
            input.ReadMessage(NodeInfo);
            break;
          }
          case 66: {
            images_.AddEntriesFrom(input, _repeated_images_codec);
            break;
          }
          case 74: {
            volumesInUse_.AddEntriesFrom(input, _repeated_volumesInUse_codec);
            break;
          }
          case 82: {
            volumesAttached_.AddEntriesFrom(input, _repeated_volumesAttached_codec);
            break;
          }
          case 90: {
            if (config_ == null) {
              Config = new global::K8S.Io.Api.Core.V1.NodeConfigStatus();
            }
            input.ReadMessage(Config);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            capacity_.AddEntriesFrom(ref input, _map_capacity_codec);
            break;
          }
          case 18: {
            allocatable_.AddEntriesFrom(ref input, _map_allocatable_codec);
            break;
          }
          case 26: {
            Phase = input.ReadString();
            break;
          }
          case 34: {
            conditions_.AddEntriesFrom(ref input, _repeated_conditions_codec);
            break;
          }
          case 42: {
            addresses_.AddEntriesFrom(ref input, _repeated_addresses_codec);
            break;
          }
          case 50: {
            if (daemonEndpoints_ == null) {
              DaemonEndpoints = new global::K8S.Io.Api.Core.V1.NodeDaemonEndpoints();
            }
            input.ReadMessage(DaemonEndpoints);
            break;
          }
          case 58: {
            if (nodeInfo_ == null) {
              NodeInfo = new global::K8S.Io.Api.Core.V1.NodeSystemInfo();
            }
            input.ReadMessage(NodeInfo);
            break;
          }
          case 66: {
            images_.AddEntriesFrom(ref input, _repeated_images_codec);
            break;
          }
          case 74: {
            volumesInUse_.AddEntriesFrom(ref input, _repeated_volumesInUse_codec);
            break;
          }
          case 82: {
            volumesAttached_.AddEntriesFrom(ref input, _repeated_volumesAttached_codec);
            break;
          }
          case 90: {
            if (config_ == null) {
              Config = new global::K8S.Io.Api.Core.V1.NodeConfigStatus();
            }
            input.ReadMessage(Config);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
  /// </summary>
  public sealed partial class NodeSystemInfo : pb::IMessage<NodeSystemInfo>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NodeSystemInfo> _parser = new pb::MessageParser<NodeSystemInfo>(() => new NodeSystemInfo());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NodeSystemInfo> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[102]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSystemInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSystemInfo(NodeSystemInfo other) : this() {
      machineID_ = other.machineID_;
      systemUUID_ = other.systemUUID_;
      bootID_ = other.bootID_;
      kernelVersion_ = other.kernelVersion_;
      osImage_ = other.osImage_;
      containerRuntimeVersion_ = other.containerRuntimeVersion_;
      kubeletVersion_ = other.kubeletVersion_;
      kubeProxyVersion_ = other.kubeProxyVersion_;
      operatingSystem_ = other.operatingSystem_;
      architecture_ = other.architecture_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NodeSystemInfo Clone() {
      return new NodeSystemInfo(this);
    }

    /// <summary>Field number for the "machineID" field.</summary>
    public const int MachineIDFieldNumber = 1;
    private readonly static string MachineIDDefaultValue = "";

    private string machineID_;
    /// <summary>
    /// MachineID reported by the node. For unique machine identification
    /// in the cluster this field is preferred. Learn more from man(5)
    /// machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MachineID {
      get { return machineID_ ?? MachineIDDefaultValue; }
      set {
        machineID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "machineID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMachineID {
      get { return machineID_ != null; }
    }
    /// <summary>Clears the value of the "machineID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMachineID() {
      machineID_ = null;
    }

    /// <summary>Field number for the "systemUUID" field.</summary>
    public const int SystemUUIDFieldNumber = 2;
    private readonly static string SystemUUIDDefaultValue = "";

    private string systemUUID_;
    /// <summary>
    /// SystemUUID reported by the node. For unique machine identification
    /// MachineID is preferred. This field is specific to Red Hat hosts
    /// https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SystemUUID {
      get { return systemUUID_ ?? SystemUUIDDefaultValue; }
      set {
        systemUUID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "systemUUID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSystemUUID {
      get { return systemUUID_ != null; }
    }
    /// <summary>Clears the value of the "systemUUID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSystemUUID() {
      systemUUID_ = null;
    }

    /// <summary>Field number for the "bootID" field.</summary>
    public const int BootIDFieldNumber = 3;
    private readonly static string BootIDDefaultValue = "";

    private string bootID_;
    /// <summary>
    /// Boot ID reported by the node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string BootID {
      get { return bootID_ ?? BootIDDefaultValue; }
      set {
        bootID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "bootID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasBootID {
      get { return bootID_ != null; }
    }
    /// <summary>Clears the value of the "bootID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearBootID() {
      bootID_ = null;
    }

    /// <summary>Field number for the "kernelVersion" field.</summary>
    public const int KernelVersionFieldNumber = 4;
    private readonly static string KernelVersionDefaultValue = "";

    private string kernelVersion_;
    /// <summary>
    /// Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string KernelVersion {
      get { return kernelVersion_ ?? KernelVersionDefaultValue; }
      set {
        kernelVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "kernelVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKernelVersion {
      get { return kernelVersion_ != null; }
    }
    /// <summary>Clears the value of the "kernelVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKernelVersion() {
      kernelVersion_ = null;
    }

    /// <summary>Field number for the "osImage" field.</summary>
    public const int OsImageFieldNumber = 5;
    private readonly static string OsImageDefaultValue = "";

    private string osImage_;
    /// <summary>
    /// OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string OsImage {
      get { return osImage_ ?? OsImageDefaultValue; }
      set {
        osImage_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "osImage" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOsImage {
      get { return osImage_ != null; }
    }
    /// <summary>Clears the value of the "osImage" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOsImage() {
      osImage_ = null;
    }

    /// <summary>Field number for the "containerRuntimeVersion" field.</summary>
    public const int ContainerRuntimeVersionFieldNumber = 6;
    private readonly static string ContainerRuntimeVersionDefaultValue = "";

    private string containerRuntimeVersion_;
    /// <summary>
    /// ContainerRuntime Version reported by the node through runtime remote API (e.g. docker://1.5.0).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ContainerRuntimeVersion {
      get { return containerRuntimeVersion_ ?? ContainerRuntimeVersionDefaultValue; }
      set {
        containerRuntimeVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "containerRuntimeVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContainerRuntimeVersion {
      get { return containerRuntimeVersion_ != null; }
    }
    /// <summary>Clears the value of the "containerRuntimeVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContainerRuntimeVersion() {
      containerRuntimeVersion_ = null;
    }

    /// <summary>Field number for the "kubeletVersion" field.</summary>
    public const int KubeletVersionFieldNumber = 7;
    private readonly static string KubeletVersionDefaultValue = "";

    private string kubeletVersion_;
    /// <summary>
    /// Kubelet Version reported by the node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string KubeletVersion {
      get { return kubeletVersion_ ?? KubeletVersionDefaultValue; }
      set {
        kubeletVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "kubeletVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKubeletVersion {
      get { return kubeletVersion_ != null; }
    }
    /// <summary>Clears the value of the "kubeletVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKubeletVersion() {
      kubeletVersion_ = null;
    }

    /// <summary>Field number for the "kubeProxyVersion" field.</summary>
    public const int KubeProxyVersionFieldNumber = 8;
    private readonly static string KubeProxyVersionDefaultValue = "";

    private string kubeProxyVersion_;
    /// <summary>
    /// KubeProxy Version reported by the node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string KubeProxyVersion {
      get { return kubeProxyVersion_ ?? KubeProxyVersionDefaultValue; }
      set {
        kubeProxyVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "kubeProxyVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKubeProxyVersion {
      get { return kubeProxyVersion_ != null; }
    }
    /// <summary>Clears the value of the "kubeProxyVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKubeProxyVersion() {
      kubeProxyVersion_ = null;
    }

    /// <summary>Field number for the "operatingSystem" field.</summary>
    public const int OperatingSystemFieldNumber = 9;
    private readonly static string OperatingSystemDefaultValue = "";

    private string operatingSystem_;
    /// <summary>
    /// The Operating System reported by the node
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string OperatingSystem {
      get { return operatingSystem_ ?? OperatingSystemDefaultValue; }
      set {
        operatingSystem_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "operatingSystem" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOperatingSystem {
      get { return operatingSystem_ != null; }
    }
    /// <summary>Clears the value of the "operatingSystem" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOperatingSystem() {
      operatingSystem_ = null;
    }

    /// <summary>Field number for the "architecture" field.</summary>
    public const int ArchitectureFieldNumber = 10;
    private readonly static string ArchitectureDefaultValue = "";

    private string architecture_;
    /// <summary>
    /// The Architecture reported by the node
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Architecture {
      get { return architecture_ ?? ArchitectureDefaultValue; }
      set {
        architecture_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "architecture" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasArchitecture {
      get { return architecture_ != null; }
    }
    /// <summary>Clears the value of the "architecture" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearArchitecture() {
      architecture_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NodeSystemInfo);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NodeSystemInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MachineID != other.MachineID) return false;
      if (SystemUUID != other.SystemUUID) return false;
      if (BootID != other.BootID) return false;
      if (KernelVersion != other.KernelVersion) return false;
      if (OsImage != other.OsImage) return false;
      if (ContainerRuntimeVersion != other.ContainerRuntimeVersion) return false;
      if (KubeletVersion != other.KubeletVersion) return false;
      if (KubeProxyVersion != other.KubeProxyVersion) return false;
      if (OperatingSystem != other.OperatingSystem) return false;
      if (Architecture != other.Architecture) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMachineID) hash ^= MachineID.GetHashCode();
      if (HasSystemUUID) hash ^= SystemUUID.GetHashCode();
      if (HasBootID) hash ^= BootID.GetHashCode();
      if (HasKernelVersion) hash ^= KernelVersion.GetHashCode();
      if (HasOsImage) hash ^= OsImage.GetHashCode();
      if (HasContainerRuntimeVersion) hash ^= ContainerRuntimeVersion.GetHashCode();
      if (HasKubeletVersion) hash ^= KubeletVersion.GetHashCode();
      if (HasKubeProxyVersion) hash ^= KubeProxyVersion.GetHashCode();
      if (HasOperatingSystem) hash ^= OperatingSystem.GetHashCode();
      if (HasArchitecture) hash ^= Architecture.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasMachineID) {
        output.WriteRawTag(10);
        output.WriteString(MachineID);
      }
      if (HasSystemUUID) {
        output.WriteRawTag(18);
        output.WriteString(SystemUUID);
      }
      if (HasBootID) {
        output.WriteRawTag(26);
        output.WriteString(BootID);
      }
      if (HasKernelVersion) {
        output.WriteRawTag(34);
        output.WriteString(KernelVersion);
      }
      if (HasOsImage) {
        output.WriteRawTag(42);
        output.WriteString(OsImage);
      }
      if (HasContainerRuntimeVersion) {
        output.WriteRawTag(50);
        output.WriteString(ContainerRuntimeVersion);
      }
      if (HasKubeletVersion) {
        output.WriteRawTag(58);
        output.WriteString(KubeletVersion);
      }
      if (HasKubeProxyVersion) {
        output.WriteRawTag(66);
        output.WriteString(KubeProxyVersion);
      }
      if (HasOperatingSystem) {
        output.WriteRawTag(74);
        output.WriteString(OperatingSystem);
      }
      if (HasArchitecture) {
        output.WriteRawTag(82);
        output.WriteString(Architecture);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMachineID) {
        output.WriteRawTag(10);
        output.WriteString(MachineID);
      }
      if (HasSystemUUID) {
        output.WriteRawTag(18);
        output.WriteString(SystemUUID);
      }
      if (HasBootID) {
        output.WriteRawTag(26);
        output.WriteString(BootID);
      }
      if (HasKernelVersion) {
        output.WriteRawTag(34);
        output.WriteString(KernelVersion);
      }
      if (HasOsImage) {
        output.WriteRawTag(42);
        output.WriteString(OsImage);
      }
      if (HasContainerRuntimeVersion) {
        output.WriteRawTag(50);
        output.WriteString(ContainerRuntimeVersion);
      }
      if (HasKubeletVersion) {
        output.WriteRawTag(58);
        output.WriteString(KubeletVersion);
      }
      if (HasKubeProxyVersion) {
        output.WriteRawTag(66);
        output.WriteString(KubeProxyVersion);
      }
      if (HasOperatingSystem) {
        output.WriteRawTag(74);
        output.WriteString(OperatingSystem);
      }
      if (HasArchitecture) {
        output.WriteRawTag(82);
        output.WriteString(Architecture);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasMachineID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MachineID);
      }
      if (HasSystemUUID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SystemUUID);
      }
      if (HasBootID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BootID);
      }
      if (HasKernelVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(KernelVersion);
      }
      if (HasOsImage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OsImage);
      }
      if (HasContainerRuntimeVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ContainerRuntimeVersion);
      }
      if (HasKubeletVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(KubeletVersion);
      }
      if (HasKubeProxyVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(KubeProxyVersion);
      }
      if (HasOperatingSystem) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OperatingSystem);
      }
      if (HasArchitecture) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Architecture);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NodeSystemInfo other) {
      if (other == null) {
        return;
      }
      if (other.HasMachineID) {
        MachineID = other.MachineID;
      }
      if (other.HasSystemUUID) {
        SystemUUID = other.SystemUUID;
      }
      if (other.HasBootID) {
        BootID = other.BootID;
      }
      if (other.HasKernelVersion) {
        KernelVersion = other.KernelVersion;
      }
      if (other.HasOsImage) {
        OsImage = other.OsImage;
      }
      if (other.HasContainerRuntimeVersion) {
        ContainerRuntimeVersion = other.ContainerRuntimeVersion;
      }
      if (other.HasKubeletVersion) {
        KubeletVersion = other.KubeletVersion;
      }
      if (other.HasKubeProxyVersion) {
        KubeProxyVersion = other.KubeProxyVersion;
      }
      if (other.HasOperatingSystem) {
        OperatingSystem = other.OperatingSystem;
      }
      if (other.HasArchitecture) {
        Architecture = other.Architecture;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            MachineID = input.ReadString();
            break;
          }
          case 18: {
            SystemUUID = input.ReadString();
            break;
          }
          case 26: {
            BootID = input.ReadString();
            break;
          }
          case 34: {
            KernelVersion = input.ReadString();
            break;
          }
          case 42: {
            OsImage = input.ReadString();
            break;
          }
          case 50: {
            ContainerRuntimeVersion = input.ReadString();
            break;
          }
          case 58: {
            KubeletVersion = input.ReadString();
            break;
          }
          case 66: {
            KubeProxyVersion = input.ReadString();
            break;
          }
          case 74: {
            OperatingSystem = input.ReadString();
            break;
          }
          case 82: {
            Architecture = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            MachineID = input.ReadString();
            break;
          }
          case 18: {
            SystemUUID = input.ReadString();
            break;
          }
          case 26: {
            BootID = input.ReadString();
            break;
          }
          case 34: {
            KernelVersion = input.ReadString();
            break;
          }
          case 42: {
            OsImage = input.ReadString();
            break;
          }
          case 50: {
            ContainerRuntimeVersion = input.ReadString();
            break;
          }
          case 58: {
            KubeletVersion = input.ReadString();
            break;
          }
          case 66: {
            KubeProxyVersion = input.ReadString();
            break;
          }
          case 74: {
            OperatingSystem = input.ReadString();
            break;
          }
          case 82: {
            Architecture = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ObjectFieldSelector selects an APIVersioned field of an object.
  /// +structType=atomic
  /// </summary>
  public sealed partial class ObjectFieldSelector : pb::IMessage<ObjectFieldSelector>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ObjectFieldSelector> _parser = new pb::MessageParser<ObjectFieldSelector>(() => new ObjectFieldSelector());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ObjectFieldSelector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[103]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ObjectFieldSelector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ObjectFieldSelector(ObjectFieldSelector other) : this() {
      apiVersion_ = other.apiVersion_;
      fieldPath_ = other.fieldPath_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ObjectFieldSelector Clone() {
      return new ObjectFieldSelector(this);
    }

    /// <summary>Field number for the "apiVersion" field.</summary>
    public const int ApiVersionFieldNumber = 1;
    private readonly static string ApiVersionDefaultValue = "";

    private string apiVersion_;
    /// <summary>
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ApiVersion {
      get { return apiVersion_ ?? ApiVersionDefaultValue; }
      set {
        apiVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "apiVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasApiVersion {
      get { return apiVersion_ != null; }
    }
    /// <summary>Clears the value of the "apiVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearApiVersion() {
      apiVersion_ = null;
    }

    /// <summary>Field number for the "fieldPath" field.</summary>
    public const int FieldPathFieldNumber = 2;
    private readonly static string FieldPathDefaultValue = "";

    private string fieldPath_;
    /// <summary>
    /// Path of the field to select in the specified API version.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FieldPath {
      get { return fieldPath_ ?? FieldPathDefaultValue; }
      set {
        fieldPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fieldPath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFieldPath {
      get { return fieldPath_ != null; }
    }
    /// <summary>Clears the value of the "fieldPath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFieldPath() {
      fieldPath_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ObjectFieldSelector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ObjectFieldSelector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ApiVersion != other.ApiVersion) return false;
      if (FieldPath != other.FieldPath) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasApiVersion) hash ^= ApiVersion.GetHashCode();
      if (HasFieldPath) hash ^= FieldPath.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasApiVersion) {
        output.WriteRawTag(10);
        output.WriteString(ApiVersion);
      }
      if (HasFieldPath) {
        output.WriteRawTag(18);
        output.WriteString(FieldPath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasApiVersion) {
        output.WriteRawTag(10);
        output.WriteString(ApiVersion);
      }
      if (HasFieldPath) {
        output.WriteRawTag(18);
        output.WriteString(FieldPath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasApiVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ApiVersion);
      }
      if (HasFieldPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FieldPath);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ObjectFieldSelector other) {
      if (other == null) {
        return;
      }
      if (other.HasApiVersion) {
        ApiVersion = other.ApiVersion;
      }
      if (other.HasFieldPath) {
        FieldPath = other.FieldPath;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ApiVersion = input.ReadString();
            break;
          }
          case 18: {
            FieldPath = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ApiVersion = input.ReadString();
            break;
          }
          case 18: {
            FieldPath = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ObjectReference contains enough information to let you inspect or modify the referred object.
  /// ---
  /// New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.
  ///  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.
  ///  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular
  ///     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".
  ///     Those cannot be well described when embedded.
  ///  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.
  ///  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity
  ///     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple
  ///     and the version of the actual struct is irrelevant.
  ///  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type
  ///     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control.
  /// Instead of using this type, create a locally provided and used type that is well-focused on your reference.
  /// For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
  /// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
  /// +structType=atomic
  /// </summary>
  public sealed partial class ObjectReference : pb::IMessage<ObjectReference>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ObjectReference> _parser = new pb::MessageParser<ObjectReference>(() => new ObjectReference());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ObjectReference> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[104]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ObjectReference() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ObjectReference(ObjectReference other) : this() {
      kind_ = other.kind_;
      namespace_ = other.namespace_;
      name_ = other.name_;
      uid_ = other.uid_;
      apiVersion_ = other.apiVersion_;
      resourceVersion_ = other.resourceVersion_;
      fieldPath_ = other.fieldPath_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ObjectReference Clone() {
      return new ObjectReference(this);
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 1;
    private readonly static string KindDefaultValue = "";

    private string kind_;
    /// <summary>
    /// Kind of the referent.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Kind {
      get { return kind_ ?? KindDefaultValue; }
      set {
        kind_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "kind" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKind {
      get { return kind_ != null; }
    }
    /// <summary>Clears the value of the "kind" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKind() {
      kind_ = null;
    }

    /// <summary>Field number for the "namespace" field.</summary>
    public const int NamespaceFieldNumber = 2;
    private readonly static string NamespaceDefaultValue = "";

    private string namespace_;
    /// <summary>
    /// Namespace of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Namespace {
      get { return namespace_ ?? NamespaceDefaultValue; }
      set {
        namespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "namespace" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNamespace {
      get { return namespace_ != null; }
    }
    /// <summary>Clears the value of the "namespace" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNamespace() {
      namespace_ = null;
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "uid" field.</summary>
    public const int UidFieldNumber = 4;
    private readonly static string UidDefaultValue = "";

    private string uid_;
    /// <summary>
    /// UID of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Uid {
      get { return uid_ ?? UidDefaultValue; }
      set {
        uid_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "uid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUid {
      get { return uid_ != null; }
    }
    /// <summary>Clears the value of the "uid" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUid() {
      uid_ = null;
    }

    /// <summary>Field number for the "apiVersion" field.</summary>
    public const int ApiVersionFieldNumber = 5;
    private readonly static string ApiVersionDefaultValue = "";

    private string apiVersion_;
    /// <summary>
    /// API version of the referent.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ApiVersion {
      get { return apiVersion_ ?? ApiVersionDefaultValue; }
      set {
        apiVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "apiVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasApiVersion {
      get { return apiVersion_ != null; }
    }
    /// <summary>Clears the value of the "apiVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearApiVersion() {
      apiVersion_ = null;
    }

    /// <summary>Field number for the "resourceVersion" field.</summary>
    public const int ResourceVersionFieldNumber = 6;
    private readonly static string ResourceVersionDefaultValue = "";

    private string resourceVersion_;
    /// <summary>
    /// Specific resourceVersion to which this reference is made, if any.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ResourceVersion {
      get { return resourceVersion_ ?? ResourceVersionDefaultValue; }
      set {
        resourceVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "resourceVersion" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasResourceVersion {
      get { return resourceVersion_ != null; }
    }
    /// <summary>Clears the value of the "resourceVersion" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearResourceVersion() {
      resourceVersion_ = null;
    }

    /// <summary>Field number for the "fieldPath" field.</summary>
    public const int FieldPathFieldNumber = 7;
    private readonly static string FieldPathDefaultValue = "";

    private string fieldPath_;
    /// <summary>
    /// If referring to a piece of an object instead of an entire object, this string
    /// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    /// For example, if the object reference is to a container within a pod, this would take on a value like:
    /// "spec.containers{name}" (where "name" refers to the name of the container that triggered
    /// the event) or if no container name is specified "spec.containers[2]" (container with
    /// index 2 in this pod). This syntax is chosen only to have some well-defined way of
    /// referencing a part of an object.
    /// TODO: this design is not final and this field is subject to change in the future.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FieldPath {
      get { return fieldPath_ ?? FieldPathDefaultValue; }
      set {
        fieldPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fieldPath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFieldPath {
      get { return fieldPath_ != null; }
    }
    /// <summary>Clears the value of the "fieldPath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFieldPath() {
      fieldPath_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ObjectReference);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ObjectReference other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Kind != other.Kind) return false;
      if (Namespace != other.Namespace) return false;
      if (Name != other.Name) return false;
      if (Uid != other.Uid) return false;
      if (ApiVersion != other.ApiVersion) return false;
      if (ResourceVersion != other.ResourceVersion) return false;
      if (FieldPath != other.FieldPath) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasKind) hash ^= Kind.GetHashCode();
      if (HasNamespace) hash ^= Namespace.GetHashCode();
      if (HasName) hash ^= Name.GetHashCode();
      if (HasUid) hash ^= Uid.GetHashCode();
      if (HasApiVersion) hash ^= ApiVersion.GetHashCode();
      if (HasResourceVersion) hash ^= ResourceVersion.GetHashCode();
      if (HasFieldPath) hash ^= FieldPath.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasKind) {
        output.WriteRawTag(10);
        output.WriteString(Kind);
      }
      if (HasNamespace) {
        output.WriteRawTag(18);
        output.WriteString(Namespace);
      }
      if (HasName) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (HasUid) {
        output.WriteRawTag(34);
        output.WriteString(Uid);
      }
      if (HasApiVersion) {
        output.WriteRawTag(42);
        output.WriteString(ApiVersion);
      }
      if (HasResourceVersion) {
        output.WriteRawTag(50);
        output.WriteString(ResourceVersion);
      }
      if (HasFieldPath) {
        output.WriteRawTag(58);
        output.WriteString(FieldPath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasKind) {
        output.WriteRawTag(10);
        output.WriteString(Kind);
      }
      if (HasNamespace) {
        output.WriteRawTag(18);
        output.WriteString(Namespace);
      }
      if (HasName) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (HasUid) {
        output.WriteRawTag(34);
        output.WriteString(Uid);
      }
      if (HasApiVersion) {
        output.WriteRawTag(42);
        output.WriteString(ApiVersion);
      }
      if (HasResourceVersion) {
        output.WriteRawTag(50);
        output.WriteString(ResourceVersion);
      }
      if (HasFieldPath) {
        output.WriteRawTag(58);
        output.WriteString(FieldPath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasKind) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Kind);
      }
      if (HasNamespace) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Namespace);
      }
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasUid) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uid);
      }
      if (HasApiVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ApiVersion);
      }
      if (HasResourceVersion) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ResourceVersion);
      }
      if (HasFieldPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FieldPath);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ObjectReference other) {
      if (other == null) {
        return;
      }
      if (other.HasKind) {
        Kind = other.Kind;
      }
      if (other.HasNamespace) {
        Namespace = other.Namespace;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasUid) {
        Uid = other.Uid;
      }
      if (other.HasApiVersion) {
        ApiVersion = other.ApiVersion;
      }
      if (other.HasResourceVersion) {
        ResourceVersion = other.ResourceVersion;
      }
      if (other.HasFieldPath) {
        FieldPath = other.FieldPath;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Kind = input.ReadString();
            break;
          }
          case 18: {
            Namespace = input.ReadString();
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            Uid = input.ReadString();
            break;
          }
          case 42: {
            ApiVersion = input.ReadString();
            break;
          }
          case 50: {
            ResourceVersion = input.ReadString();
            break;
          }
          case 58: {
            FieldPath = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Kind = input.ReadString();
            break;
          }
          case 18: {
            Namespace = input.ReadString();
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            Uid = input.ReadString();
            break;
          }
          case 42: {
            ApiVersion = input.ReadString();
            break;
          }
          case 50: {
            ResourceVersion = input.ReadString();
            break;
          }
          case 58: {
            FieldPath = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolume (PV) is a storage resource provisioned by an administrator.
  /// It is analogous to a node.
  /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
  /// </summary>
  public sealed partial class PersistentVolume : pb::IMessage<PersistentVolume>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolume> _parser = new pb::MessageParser<PersistentVolume>(() => new PersistentVolume());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolume> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[105]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolume() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolume(PersistentVolume other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolume Clone() {
      return new PersistentVolume(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.PersistentVolumeSpec spec_;
    /// <summary>
    /// Spec defines a specification of a persistent volume owned by the cluster.
    /// Provisioned by an administrator.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PersistentVolumeSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.PersistentVolumeStatus status_;
    /// <summary>
    /// Status represents the current information/status for the persistent volume.
    /// Populated by the system.
    /// Read-only.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PersistentVolumeStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolume);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolume other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolume other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.PersistentVolumeSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::K8S.Io.Api.Core.V1.PersistentVolumeStatus();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.PersistentVolumeSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.PersistentVolumeStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.PersistentVolumeSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.PersistentVolumeStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeClaim is a user's request for and claim to a persistent volume
  /// </summary>
  public sealed partial class PersistentVolumeClaim : pb::IMessage<PersistentVolumeClaim>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeClaim> _parser = new pb::MessageParser<PersistentVolumeClaim>(() => new PersistentVolumeClaim());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeClaim> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[106]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaim() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaim(PersistentVolumeClaim other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaim Clone() {
      return new PersistentVolumeClaim(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec spec_;
    /// <summary>
    /// Spec defines the desired characteristics of a volume requested by a pod author.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.PersistentVolumeClaimStatus status_;
    /// <summary>
    /// Status represents the current information/status of a persistent volume claim.
    /// Read-only.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PersistentVolumeClaimStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeClaim);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeClaim other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeClaim other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimStatus();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeClaimCondition contails details about state of pvc
  /// </summary>
  public sealed partial class PersistentVolumeClaimCondition : pb::IMessage<PersistentVolumeClaimCondition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeClaimCondition> _parser = new pb::MessageParser<PersistentVolumeClaimCondition>(() => new PersistentVolumeClaimCondition());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeClaimCondition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[107]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimCondition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimCondition(PersistentVolumeClaimCondition other) : this() {
      type_ = other.type_;
      status_ = other.status_;
      lastProbeTime_ = other.lastProbeTime_ != null ? other.lastProbeTime_.Clone() : null;
      lastTransitionTime_ = other.lastTransitionTime_ != null ? other.lastTransitionTime_.Clone() : null;
      reason_ = other.reason_;
      message_ = other.message_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimCondition Clone() {
      return new PersistentVolumeClaimCondition(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 2;
    private readonly static string StatusDefaultValue = "";

    private string status_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Status {
      get { return status_ ?? StatusDefaultValue; }
      set {
        status_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStatus {
      get { return status_ != null; }
    }
    /// <summary>Clears the value of the "status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStatus() {
      status_ = null;
    }

    /// <summary>Field number for the "lastProbeTime" field.</summary>
    public const int LastProbeTimeFieldNumber = 3;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time lastProbeTime_;
    /// <summary>
    /// Last time we probed the condition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time LastProbeTime {
      get { return lastProbeTime_; }
      set {
        lastProbeTime_ = value;
      }
    }

    /// <summary>Field number for the "lastTransitionTime" field.</summary>
    public const int LastTransitionTimeFieldNumber = 4;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time lastTransitionTime_;
    /// <summary>
    /// Last time the condition transitioned from one status to another.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time LastTransitionTime {
      get { return lastTransitionTime_; }
      set {
        lastTransitionTime_ = value;
      }
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 5;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// Unique, this should be a short, machine understandable string that gives the reason
    /// for condition's last transition. If it reports "ResizeStarted" that means the underlying
    /// persistent volume is being resized.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 6;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// Human-readable message indicating details about last transition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeClaimCondition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeClaimCondition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Status != other.Status) return false;
      if (!object.Equals(LastProbeTime, other.LastProbeTime)) return false;
      if (!object.Equals(LastTransitionTime, other.LastTransitionTime)) return false;
      if (Reason != other.Reason) return false;
      if (Message != other.Message) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasStatus) hash ^= Status.GetHashCode();
      if (lastProbeTime_ != null) hash ^= LastProbeTime.GetHashCode();
      if (lastTransitionTime_ != null) hash ^= LastTransitionTime.GetHashCode();
      if (HasReason) hash ^= Reason.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (lastProbeTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastProbeTime);
      }
      if (lastTransitionTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LastTransitionTime);
      }
      if (HasReason) {
        output.WriteRawTag(42);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(50);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (lastProbeTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastProbeTime);
      }
      if (lastTransitionTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LastTransitionTime);
      }
      if (HasReason) {
        output.WriteRawTag(42);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(50);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasStatus) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Status);
      }
      if (lastProbeTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastProbeTime);
      }
      if (lastTransitionTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastTransitionTime);
      }
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeClaimCondition other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasStatus) {
        Status = other.Status;
      }
      if (other.lastProbeTime_ != null) {
        if (lastProbeTime_ == null) {
          LastProbeTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        LastProbeTime.MergeFrom(other.LastProbeTime);
      }
      if (other.lastTransitionTime_ != null) {
        if (lastTransitionTime_ == null) {
          LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        LastTransitionTime.MergeFrom(other.LastTransitionTime);
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 26: {
            if (lastProbeTime_ == null) {
              LastProbeTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastProbeTime);
            break;
          }
          case 34: {
            if (lastTransitionTime_ == null) {
              LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTransitionTime);
            break;
          }
          case 42: {
            Reason = input.ReadString();
            break;
          }
          case 50: {
            Message = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 26: {
            if (lastProbeTime_ == null) {
              LastProbeTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastProbeTime);
            break;
          }
          case 34: {
            if (lastTransitionTime_ == null) {
              LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTransitionTime);
            break;
          }
          case 42: {
            Reason = input.ReadString();
            break;
          }
          case 50: {
            Message = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
  /// </summary>
  public sealed partial class PersistentVolumeClaimList : pb::IMessage<PersistentVolumeClaimList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeClaimList> _parser = new pb::MessageParser<PersistentVolumeClaimList>(() => new PersistentVolumeClaimList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeClaimList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[108]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimList(PersistentVolumeClaimList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimList Clone() {
      return new PersistentVolumeClaimList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PersistentVolumeClaim> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.PersistentVolumeClaim.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PersistentVolumeClaim> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PersistentVolumeClaim>();
    /// <summary>
    /// A list of persistent volume claims.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PersistentVolumeClaim> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeClaimList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeClaimList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeClaimList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeClaimSpec describes the common attributes of storage devices
  /// and allows a Source for provider-specific attributes
  /// </summary>
  public sealed partial class PersistentVolumeClaimSpec : pb::IMessage<PersistentVolumeClaimSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeClaimSpec> _parser = new pb::MessageParser<PersistentVolumeClaimSpec>(() => new PersistentVolumeClaimSpec());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeClaimSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[109]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimSpec(PersistentVolumeClaimSpec other) : this() {
      accessModes_ = other.accessModes_.Clone();
      selector_ = other.selector_ != null ? other.selector_.Clone() : null;
      resources_ = other.resources_ != null ? other.resources_.Clone() : null;
      volumeName_ = other.volumeName_;
      storageClassName_ = other.storageClassName_;
      volumeMode_ = other.volumeMode_;
      dataSource_ = other.dataSource_ != null ? other.dataSource_.Clone() : null;
      dataSourceRef_ = other.dataSourceRef_ != null ? other.dataSourceRef_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimSpec Clone() {
      return new PersistentVolumeClaimSpec(this);
    }

    /// <summary>Field number for the "accessModes" field.</summary>
    public const int AccessModesFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_accessModes_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> accessModes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// AccessModes contains the desired access modes the volume should have.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> AccessModes {
      get { return accessModes_; }
    }

    /// <summary>Field number for the "selector" field.</summary>
    public const int SelectorFieldNumber = 4;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector selector_;
    /// <summary>
    /// A label query over volumes to consider for binding.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector Selector {
      get { return selector_; }
      set {
        selector_ = value;
      }
    }

    /// <summary>Field number for the "resources" field.</summary>
    public const int ResourcesFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ResourceRequirements resources_;
    /// <summary>
    /// Resources represents the minimum resources the volume should have.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ResourceRequirements Resources {
      get { return resources_; }
      set {
        resources_ = value;
      }
    }

    /// <summary>Field number for the "volumeName" field.</summary>
    public const int VolumeNameFieldNumber = 3;
    private readonly static string VolumeNameDefaultValue = "";

    private string volumeName_;
    /// <summary>
    /// VolumeName is the binding reference to the PersistentVolume backing this claim.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeName {
      get { return volumeName_ ?? VolumeNameDefaultValue; }
      set {
        volumeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeName {
      get { return volumeName_ != null; }
    }
    /// <summary>Clears the value of the "volumeName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeName() {
      volumeName_ = null;
    }

    /// <summary>Field number for the "storageClassName" field.</summary>
    public const int StorageClassNameFieldNumber = 5;
    private readonly static string StorageClassNameDefaultValue = "";

    private string storageClassName_;
    /// <summary>
    /// Name of the StorageClass required by the claim.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StorageClassName {
      get { return storageClassName_ ?? StorageClassNameDefaultValue; }
      set {
        storageClassName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "storageClassName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStorageClassName {
      get { return storageClassName_ != null; }
    }
    /// <summary>Clears the value of the "storageClassName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStorageClassName() {
      storageClassName_ = null;
    }

    /// <summary>Field number for the "volumeMode" field.</summary>
    public const int VolumeModeFieldNumber = 6;
    private readonly static string VolumeModeDefaultValue = "";

    private string volumeMode_;
    /// <summary>
    /// volumeMode defines what type of volume is required by the claim.
    /// Value of Filesystem is implied when not included in claim spec.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeMode {
      get { return volumeMode_ ?? VolumeModeDefaultValue; }
      set {
        volumeMode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeMode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeMode {
      get { return volumeMode_ != null; }
    }
    /// <summary>Clears the value of the "volumeMode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeMode() {
      volumeMode_ = null;
    }

    /// <summary>Field number for the "dataSource" field.</summary>
    public const int DataSourceFieldNumber = 7;
    private global::K8S.Io.Api.Core.V1.TypedLocalObjectReference dataSource_;
    /// <summary>
    /// This field can be used to specify either:
    /// * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
    /// * An existing PVC (PersistentVolumeClaim)
    /// If the provisioner or an external controller can support the specified data source,
    /// it will create a new volume based on the contents of the specified data source.
    /// If the AnyVolumeDataSource feature gate is enabled, this field will always have
    /// the same contents as the DataSourceRef field.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.TypedLocalObjectReference DataSource {
      get { return dataSource_; }
      set {
        dataSource_ = value;
      }
    }

    /// <summary>Field number for the "dataSourceRef" field.</summary>
    public const int DataSourceRefFieldNumber = 8;
    private global::K8S.Io.Api.Core.V1.TypedLocalObjectReference dataSourceRef_;
    /// <summary>
    /// Specifies the object from which to populate the volume with data, if a non-empty
    /// volume is desired. This may be any local object from a non-empty API group (non
    /// core object) or a PersistentVolumeClaim object.
    /// When this field is specified, volume binding will only succeed if the type of
    /// the specified object matches some installed volume populator or dynamic
    /// provisioner.
    /// This field will replace the functionality of the DataSource field and as such
    /// if both fields are non-empty, they must have the same value. For backwards
    /// compatibility, both fields (DataSource and DataSourceRef) will be set to the same
    /// value automatically if one of them is empty and the other is non-empty.
    /// There are two important differences between DataSource and DataSourceRef:
    /// * While DataSource only allows two specific types of objects, DataSourceRef
    ///   allows any non-core object, as well as PersistentVolumeClaim objects.
    /// * While DataSource ignores disallowed values (dropping them), DataSourceRef
    ///   preserves all values, and generates an error if a disallowed value is
    ///   specified.
    /// (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.TypedLocalObjectReference DataSourceRef {
      get { return dataSourceRef_; }
      set {
        dataSourceRef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeClaimSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeClaimSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!accessModes_.Equals(other.accessModes_)) return false;
      if (!object.Equals(Selector, other.Selector)) return false;
      if (!object.Equals(Resources, other.Resources)) return false;
      if (VolumeName != other.VolumeName) return false;
      if (StorageClassName != other.StorageClassName) return false;
      if (VolumeMode != other.VolumeMode) return false;
      if (!object.Equals(DataSource, other.DataSource)) return false;
      if (!object.Equals(DataSourceRef, other.DataSourceRef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= accessModes_.GetHashCode();
      if (selector_ != null) hash ^= Selector.GetHashCode();
      if (resources_ != null) hash ^= Resources.GetHashCode();
      if (HasVolumeName) hash ^= VolumeName.GetHashCode();
      if (HasStorageClassName) hash ^= StorageClassName.GetHashCode();
      if (HasVolumeMode) hash ^= VolumeMode.GetHashCode();
      if (dataSource_ != null) hash ^= DataSource.GetHashCode();
      if (dataSourceRef_ != null) hash ^= DataSourceRef.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      accessModes_.WriteTo(output, _repeated_accessModes_codec);
      if (resources_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Resources);
      }
      if (HasVolumeName) {
        output.WriteRawTag(26);
        output.WriteString(VolumeName);
      }
      if (selector_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Selector);
      }
      if (HasStorageClassName) {
        output.WriteRawTag(42);
        output.WriteString(StorageClassName);
      }
      if (HasVolumeMode) {
        output.WriteRawTag(50);
        output.WriteString(VolumeMode);
      }
      if (dataSource_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DataSource);
      }
      if (dataSourceRef_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(DataSourceRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      accessModes_.WriteTo(ref output, _repeated_accessModes_codec);
      if (resources_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Resources);
      }
      if (HasVolumeName) {
        output.WriteRawTag(26);
        output.WriteString(VolumeName);
      }
      if (selector_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Selector);
      }
      if (HasStorageClassName) {
        output.WriteRawTag(42);
        output.WriteString(StorageClassName);
      }
      if (HasVolumeMode) {
        output.WriteRawTag(50);
        output.WriteString(VolumeMode);
      }
      if (dataSource_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DataSource);
      }
      if (dataSourceRef_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(DataSourceRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += accessModes_.CalculateSize(_repeated_accessModes_codec);
      if (selector_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Selector);
      }
      if (resources_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Resources);
      }
      if (HasVolumeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeName);
      }
      if (HasStorageClassName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StorageClassName);
      }
      if (HasVolumeMode) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeMode);
      }
      if (dataSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DataSource);
      }
      if (dataSourceRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DataSourceRef);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeClaimSpec other) {
      if (other == null) {
        return;
      }
      accessModes_.Add(other.accessModes_);
      if (other.selector_ != null) {
        if (selector_ == null) {
          Selector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
        }
        Selector.MergeFrom(other.Selector);
      }
      if (other.resources_ != null) {
        if (resources_ == null) {
          Resources = new global::K8S.Io.Api.Core.V1.ResourceRequirements();
        }
        Resources.MergeFrom(other.Resources);
      }
      if (other.HasVolumeName) {
        VolumeName = other.VolumeName;
      }
      if (other.HasStorageClassName) {
        StorageClassName = other.StorageClassName;
      }
      if (other.HasVolumeMode) {
        VolumeMode = other.VolumeMode;
      }
      if (other.dataSource_ != null) {
        if (dataSource_ == null) {
          DataSource = new global::K8S.Io.Api.Core.V1.TypedLocalObjectReference();
        }
        DataSource.MergeFrom(other.DataSource);
      }
      if (other.dataSourceRef_ != null) {
        if (dataSourceRef_ == null) {
          DataSourceRef = new global::K8S.Io.Api.Core.V1.TypedLocalObjectReference();
        }
        DataSourceRef.MergeFrom(other.DataSourceRef);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            accessModes_.AddEntriesFrom(input, _repeated_accessModes_codec);
            break;
          }
          case 18: {
            if (resources_ == null) {
              Resources = new global::K8S.Io.Api.Core.V1.ResourceRequirements();
            }
            input.ReadMessage(Resources);
            break;
          }
          case 26: {
            VolumeName = input.ReadString();
            break;
          }
          case 34: {
            if (selector_ == null) {
              Selector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(Selector);
            break;
          }
          case 42: {
            StorageClassName = input.ReadString();
            break;
          }
          case 50: {
            VolumeMode = input.ReadString();
            break;
          }
          case 58: {
            if (dataSource_ == null) {
              DataSource = new global::K8S.Io.Api.Core.V1.TypedLocalObjectReference();
            }
            input.ReadMessage(DataSource);
            break;
          }
          case 66: {
            if (dataSourceRef_ == null) {
              DataSourceRef = new global::K8S.Io.Api.Core.V1.TypedLocalObjectReference();
            }
            input.ReadMessage(DataSourceRef);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            accessModes_.AddEntriesFrom(ref input, _repeated_accessModes_codec);
            break;
          }
          case 18: {
            if (resources_ == null) {
              Resources = new global::K8S.Io.Api.Core.V1.ResourceRequirements();
            }
            input.ReadMessage(Resources);
            break;
          }
          case 26: {
            VolumeName = input.ReadString();
            break;
          }
          case 34: {
            if (selector_ == null) {
              Selector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(Selector);
            break;
          }
          case 42: {
            StorageClassName = input.ReadString();
            break;
          }
          case 50: {
            VolumeMode = input.ReadString();
            break;
          }
          case 58: {
            if (dataSource_ == null) {
              DataSource = new global::K8S.Io.Api.Core.V1.TypedLocalObjectReference();
            }
            input.ReadMessage(DataSource);
            break;
          }
          case 66: {
            if (dataSourceRef_ == null) {
              DataSourceRef = new global::K8S.Io.Api.Core.V1.TypedLocalObjectReference();
            }
            input.ReadMessage(DataSourceRef);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeClaimStatus is the current status of a persistent volume claim.
  /// </summary>
  public sealed partial class PersistentVolumeClaimStatus : pb::IMessage<PersistentVolumeClaimStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeClaimStatus> _parser = new pb::MessageParser<PersistentVolumeClaimStatus>(() => new PersistentVolumeClaimStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeClaimStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[110]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimStatus(PersistentVolumeClaimStatus other) : this() {
      phase_ = other.phase_;
      accessModes_ = other.accessModes_.Clone();
      capacity_ = other.capacity_.Clone();
      conditions_ = other.conditions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimStatus Clone() {
      return new PersistentVolumeClaimStatus(this);
    }

    /// <summary>Field number for the "phase" field.</summary>
    public const int PhaseFieldNumber = 1;
    private readonly static string PhaseDefaultValue = "";

    private string phase_;
    /// <summary>
    /// Phase represents the current phase of PersistentVolumeClaim.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Phase {
      get { return phase_ ?? PhaseDefaultValue; }
      set {
        phase_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "phase" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPhase {
      get { return phase_ != null; }
    }
    /// <summary>Clears the value of the "phase" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPhase() {
      phase_ = null;
    }

    /// <summary>Field number for the "accessModes" field.</summary>
    public const int AccessModesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_accessModes_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> accessModes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// AccessModes contains the actual access modes the volume backing the PVC has.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> AccessModes {
      get { return accessModes_; }
    }

    /// <summary>Field number for the "capacity" field.</summary>
    public const int CapacityFieldNumber = 3;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_capacity_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 26);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> capacity_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Represents the actual resources of the underlying volume.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Capacity {
      get { return capacity_; }
    }

    /// <summary>Field number for the "conditions" field.</summary>
    public const int ConditionsFieldNumber = 4;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PersistentVolumeClaimCondition> _repeated_conditions_codec
        = pb::FieldCodec.ForMessage(34, global::K8S.Io.Api.Core.V1.PersistentVolumeClaimCondition.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PersistentVolumeClaimCondition> conditions_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PersistentVolumeClaimCondition>();
    /// <summary>
    /// Current Condition of persistent volume claim. If underlying persistent volume is being
    /// resized then the Condition will be set to 'ResizeStarted'.
    /// +optional
    /// +patchMergeKey=type
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PersistentVolumeClaimCondition> Conditions {
      get { return conditions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeClaimStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeClaimStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Phase != other.Phase) return false;
      if(!accessModes_.Equals(other.accessModes_)) return false;
      if (!Capacity.Equals(other.Capacity)) return false;
      if(!conditions_.Equals(other.conditions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPhase) hash ^= Phase.GetHashCode();
      hash ^= accessModes_.GetHashCode();
      hash ^= Capacity.GetHashCode();
      hash ^= conditions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPhase) {
        output.WriteRawTag(10);
        output.WriteString(Phase);
      }
      accessModes_.WriteTo(output, _repeated_accessModes_codec);
      capacity_.WriteTo(output, _map_capacity_codec);
      conditions_.WriteTo(output, _repeated_conditions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPhase) {
        output.WriteRawTag(10);
        output.WriteString(Phase);
      }
      accessModes_.WriteTo(ref output, _repeated_accessModes_codec);
      capacity_.WriteTo(ref output, _map_capacity_codec);
      conditions_.WriteTo(ref output, _repeated_conditions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPhase) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Phase);
      }
      size += accessModes_.CalculateSize(_repeated_accessModes_codec);
      size += capacity_.CalculateSize(_map_capacity_codec);
      size += conditions_.CalculateSize(_repeated_conditions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeClaimStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasPhase) {
        Phase = other.Phase;
      }
      accessModes_.Add(other.accessModes_);
      capacity_.Add(other.capacity_);
      conditions_.Add(other.conditions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Phase = input.ReadString();
            break;
          }
          case 18: {
            accessModes_.AddEntriesFrom(input, _repeated_accessModes_codec);
            break;
          }
          case 26: {
            capacity_.AddEntriesFrom(input, _map_capacity_codec);
            break;
          }
          case 34: {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Phase = input.ReadString();
            break;
          }
          case 18: {
            accessModes_.AddEntriesFrom(ref input, _repeated_accessModes_codec);
            break;
          }
          case 26: {
            capacity_.AddEntriesFrom(ref input, _map_capacity_codec);
            break;
          }
          case 34: {
            conditions_.AddEntriesFrom(ref input, _repeated_conditions_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeClaimTemplate is used to produce
  /// PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
  /// </summary>
  public sealed partial class PersistentVolumeClaimTemplate : pb::IMessage<PersistentVolumeClaimTemplate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeClaimTemplate> _parser = new pb::MessageParser<PersistentVolumeClaimTemplate>(() => new PersistentVolumeClaimTemplate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeClaimTemplate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[111]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimTemplate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimTemplate(PersistentVolumeClaimTemplate other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimTemplate Clone() {
      return new PersistentVolumeClaimTemplate(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// May contain labels and annotations that will be copied into the PVC
    /// when creating it. No other fields are allowed and will be rejected during
    /// validation.
    ///
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec spec_;
    /// <summary>
    /// The specification for the PersistentVolumeClaim. The entire content is
    /// copied unchanged into the PVC that gets created from this
    /// template. The same fields as in a PersistentVolumeClaim
    /// are also valid here.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeClaimTemplate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeClaimTemplate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeClaimTemplate other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
  /// This volume finds the bound PV and mounts that volume for the pod. A
  /// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
  /// type of volume that is owned by someone else (the system).
  /// </summary>
  public sealed partial class PersistentVolumeClaimVolumeSource : pb::IMessage<PersistentVolumeClaimVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeClaimVolumeSource> _parser = new pb::MessageParser<PersistentVolumeClaimVolumeSource>(() => new PersistentVolumeClaimVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeClaimVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[112]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimVolumeSource(PersistentVolumeClaimVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      claimName_ = other.claimName_;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeClaimVolumeSource Clone() {
      return new PersistentVolumeClaimVolumeSource(this);
    }

    /// <summary>Field number for the "claimName" field.</summary>
    public const int ClaimNameFieldNumber = 1;
    private readonly static string ClaimNameDefaultValue = "";

    private string claimName_;
    /// <summary>
    /// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ClaimName {
      get { return claimName_ ?? ClaimNameDefaultValue; }
      set {
        claimName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "claimName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasClaimName {
      get { return claimName_ != null; }
    }
    /// <summary>Clears the value of the "claimName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearClaimName() {
      claimName_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 2;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Will force the ReadOnly setting in VolumeMounts.
    /// Default false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeClaimVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeClaimVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ClaimName != other.ClaimName) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasClaimName) hash ^= ClaimName.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasClaimName) {
        output.WriteRawTag(10);
        output.WriteString(ClaimName);
      }
      if (HasReadOnly) {
        output.WriteRawTag(16);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasClaimName) {
        output.WriteRawTag(10);
        output.WriteString(ClaimName);
      }
      if (HasReadOnly) {
        output.WriteRawTag(16);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasClaimName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClaimName);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeClaimVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasClaimName) {
        ClaimName = other.ClaimName;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ClaimName = input.ReadString();
            break;
          }
          case 16: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ClaimName = input.ReadString();
            break;
          }
          case 16: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeList is a list of PersistentVolume items.
  /// </summary>
  public sealed partial class PersistentVolumeList : pb::IMessage<PersistentVolumeList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeList> _parser = new pb::MessageParser<PersistentVolumeList>(() => new PersistentVolumeList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[113]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeList(PersistentVolumeList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeList Clone() {
      return new PersistentVolumeList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PersistentVolume> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.PersistentVolume.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PersistentVolume> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PersistentVolume>();
    /// <summary>
    /// List of persistent volumes.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PersistentVolume> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeSource is similar to VolumeSource but meant for the
  /// administrator who creates PVs. Exactly one of its members must be set.
  /// </summary>
  public sealed partial class PersistentVolumeSource : pb::IMessage<PersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeSource> _parser = new pb::MessageParser<PersistentVolumeSource>(() => new PersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[114]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeSource(PersistentVolumeSource other) : this() {
      gcePersistentDisk_ = other.gcePersistentDisk_ != null ? other.gcePersistentDisk_.Clone() : null;
      awsElasticBlockStore_ = other.awsElasticBlockStore_ != null ? other.awsElasticBlockStore_.Clone() : null;
      hostPath_ = other.hostPath_ != null ? other.hostPath_.Clone() : null;
      glusterfs_ = other.glusterfs_ != null ? other.glusterfs_.Clone() : null;
      nfs_ = other.nfs_ != null ? other.nfs_.Clone() : null;
      rbd_ = other.rbd_ != null ? other.rbd_.Clone() : null;
      iscsi_ = other.iscsi_ != null ? other.iscsi_.Clone() : null;
      cinder_ = other.cinder_ != null ? other.cinder_.Clone() : null;
      cephfs_ = other.cephfs_ != null ? other.cephfs_.Clone() : null;
      fc_ = other.fc_ != null ? other.fc_.Clone() : null;
      flocker_ = other.flocker_ != null ? other.flocker_.Clone() : null;
      flexVolume_ = other.flexVolume_ != null ? other.flexVolume_.Clone() : null;
      azureFile_ = other.azureFile_ != null ? other.azureFile_.Clone() : null;
      vsphereVolume_ = other.vsphereVolume_ != null ? other.vsphereVolume_.Clone() : null;
      quobyte_ = other.quobyte_ != null ? other.quobyte_.Clone() : null;
      azureDisk_ = other.azureDisk_ != null ? other.azureDisk_.Clone() : null;
      photonPersistentDisk_ = other.photonPersistentDisk_ != null ? other.photonPersistentDisk_.Clone() : null;
      portworxVolume_ = other.portworxVolume_ != null ? other.portworxVolume_.Clone() : null;
      scaleIO_ = other.scaleIO_ != null ? other.scaleIO_.Clone() : null;
      local_ = other.local_ != null ? other.local_.Clone() : null;
      storageos_ = other.storageos_ != null ? other.storageos_.Clone() : null;
      csi_ = other.csi_ != null ? other.csi_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeSource Clone() {
      return new PersistentVolumeSource(this);
    }

    /// <summary>Field number for the "gcePersistentDisk" field.</summary>
    public const int GcePersistentDiskFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource gcePersistentDisk_;
    /// <summary>
    /// GCEPersistentDisk represents a GCE Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource GcePersistentDisk {
      get { return gcePersistentDisk_; }
      set {
        gcePersistentDisk_ = value;
      }
    }

    /// <summary>Field number for the "awsElasticBlockStore" field.</summary>
    public const int AwsElasticBlockStoreFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore_;
    /// <summary>
    /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource AwsElasticBlockStore {
      get { return awsElasticBlockStore_; }
      set {
        awsElasticBlockStore_ = value;
      }
    }

    /// <summary>Field number for the "hostPath" field.</summary>
    public const int HostPathFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.HostPathVolumeSource hostPath_;
    /// <summary>
    /// HostPath represents a directory on the host.
    /// Provisioned by a developer or tester.
    /// This is useful for single-node development and testing only!
    /// On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.HostPathVolumeSource HostPath {
      get { return hostPath_; }
      set {
        hostPath_ = value;
      }
    }

    /// <summary>Field number for the "glusterfs" field.</summary>
    public const int GlusterfsFieldNumber = 4;
    private global::K8S.Io.Api.Core.V1.GlusterfsPersistentVolumeSource glusterfs_;
    /// <summary>
    /// Glusterfs represents a Glusterfs volume that is attached to a host and
    /// exposed to the pod. Provisioned by an admin.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.GlusterfsPersistentVolumeSource Glusterfs {
      get { return glusterfs_; }
      set {
        glusterfs_ = value;
      }
    }

    /// <summary>Field number for the "nfs" field.</summary>
    public const int NfsFieldNumber = 5;
    private global::K8S.Io.Api.Core.V1.NFSVolumeSource nfs_;
    /// <summary>
    /// NFS represents an NFS mount on the host. Provisioned by an admin.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NFSVolumeSource Nfs {
      get { return nfs_; }
      set {
        nfs_ = value;
      }
    }

    /// <summary>Field number for the "rbd" field.</summary>
    public const int RbdFieldNumber = 6;
    private global::K8S.Io.Api.Core.V1.RBDPersistentVolumeSource rbd_;
    /// <summary>
    /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.RBDPersistentVolumeSource Rbd {
      get { return rbd_; }
      set {
        rbd_ = value;
      }
    }

    /// <summary>Field number for the "iscsi" field.</summary>
    public const int IscsiFieldNumber = 7;
    private global::K8S.Io.Api.Core.V1.ISCSIPersistentVolumeSource iscsi_;
    /// <summary>
    /// ISCSI represents an ISCSI Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ISCSIPersistentVolumeSource Iscsi {
      get { return iscsi_; }
      set {
        iscsi_ = value;
      }
    }

    /// <summary>Field number for the "cinder" field.</summary>
    public const int CinderFieldNumber = 8;
    private global::K8S.Io.Api.Core.V1.CinderPersistentVolumeSource cinder_;
    /// <summary>
    /// Cinder represents a cinder volume attached and mounted on kubelets host machine.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.CinderPersistentVolumeSource Cinder {
      get { return cinder_; }
      set {
        cinder_ = value;
      }
    }

    /// <summary>Field number for the "cephfs" field.</summary>
    public const int CephfsFieldNumber = 9;
    private global::K8S.Io.Api.Core.V1.CephFSPersistentVolumeSource cephfs_;
    /// <summary>
    /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.CephFSPersistentVolumeSource Cephfs {
      get { return cephfs_; }
      set {
        cephfs_ = value;
      }
    }

    /// <summary>Field number for the "fc" field.</summary>
    public const int FcFieldNumber = 10;
    private global::K8S.Io.Api.Core.V1.FCVolumeSource fc_;
    /// <summary>
    /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.FCVolumeSource Fc {
      get { return fc_; }
      set {
        fc_ = value;
      }
    }

    /// <summary>Field number for the "flocker" field.</summary>
    public const int FlockerFieldNumber = 11;
    private global::K8S.Io.Api.Core.V1.FlockerVolumeSource flocker_;
    /// <summary>
    /// Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.FlockerVolumeSource Flocker {
      get { return flocker_; }
      set {
        flocker_ = value;
      }
    }

    /// <summary>Field number for the "flexVolume" field.</summary>
    public const int FlexVolumeFieldNumber = 12;
    private global::K8S.Io.Api.Core.V1.FlexPersistentVolumeSource flexVolume_;
    /// <summary>
    /// FlexVolume represents a generic volume resource that is
    /// provisioned/attached using an exec based plugin.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.FlexPersistentVolumeSource FlexVolume {
      get { return flexVolume_; }
      set {
        flexVolume_ = value;
      }
    }

    /// <summary>Field number for the "azureFile" field.</summary>
    public const int AzureFileFieldNumber = 13;
    private global::K8S.Io.Api.Core.V1.AzureFilePersistentVolumeSource azureFile_;
    /// <summary>
    /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.AzureFilePersistentVolumeSource AzureFile {
      get { return azureFile_; }
      set {
        azureFile_ = value;
      }
    }

    /// <summary>Field number for the "vsphereVolume" field.</summary>
    public const int VsphereVolumeFieldNumber = 14;
    private global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource vsphereVolume_;
    /// <summary>
    /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource VsphereVolume {
      get { return vsphereVolume_; }
      set {
        vsphereVolume_ = value;
      }
    }

    /// <summary>Field number for the "quobyte" field.</summary>
    public const int QuobyteFieldNumber = 15;
    private global::K8S.Io.Api.Core.V1.QuobyteVolumeSource quobyte_;
    /// <summary>
    /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.QuobyteVolumeSource Quobyte {
      get { return quobyte_; }
      set {
        quobyte_ = value;
      }
    }

    /// <summary>Field number for the "azureDisk" field.</summary>
    public const int AzureDiskFieldNumber = 16;
    private global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource azureDisk_;
    /// <summary>
    /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource AzureDisk {
      get { return azureDisk_; }
      set {
        azureDisk_ = value;
      }
    }

    /// <summary>Field number for the "photonPersistentDisk" field.</summary>
    public const int PhotonPersistentDiskFieldNumber = 17;
    private global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource photonPersistentDisk_;
    /// <summary>
    /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource PhotonPersistentDisk {
      get { return photonPersistentDisk_; }
      set {
        photonPersistentDisk_ = value;
      }
    }

    /// <summary>Field number for the "portworxVolume" field.</summary>
    public const int PortworxVolumeFieldNumber = 18;
    private global::K8S.Io.Api.Core.V1.PortworxVolumeSource portworxVolume_;
    /// <summary>
    /// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PortworxVolumeSource PortworxVolume {
      get { return portworxVolume_; }
      set {
        portworxVolume_ = value;
      }
    }

    /// <summary>Field number for the "scaleIO" field.</summary>
    public const int ScaleIOFieldNumber = 19;
    private global::K8S.Io.Api.Core.V1.ScaleIOPersistentVolumeSource scaleIO_;
    /// <summary>
    /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ScaleIOPersistentVolumeSource ScaleIO {
      get { return scaleIO_; }
      set {
        scaleIO_ = value;
      }
    }

    /// <summary>Field number for the "local" field.</summary>
    public const int LocalFieldNumber = 20;
    private global::K8S.Io.Api.Core.V1.LocalVolumeSource local_;
    /// <summary>
    /// Local represents directly-attached storage with node affinity
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalVolumeSource Local {
      get { return local_; }
      set {
        local_ = value;
      }
    }

    /// <summary>Field number for the "storageos" field.</summary>
    public const int StorageosFieldNumber = 21;
    private global::K8S.Io.Api.Core.V1.StorageOSPersistentVolumeSource storageos_;
    /// <summary>
    /// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
    /// More info: https://examples.k8s.io/volumes/storageos/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.StorageOSPersistentVolumeSource Storageos {
      get { return storageos_; }
      set {
        storageos_ = value;
      }
    }

    /// <summary>Field number for the "csi" field.</summary>
    public const int CsiFieldNumber = 22;
    private global::K8S.Io.Api.Core.V1.CSIPersistentVolumeSource csi_;
    /// <summary>
    /// CSI represents storage that is handled by an external CSI driver (Beta feature).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.CSIPersistentVolumeSource Csi {
      get { return csi_; }
      set {
        csi_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(GcePersistentDisk, other.GcePersistentDisk)) return false;
      if (!object.Equals(AwsElasticBlockStore, other.AwsElasticBlockStore)) return false;
      if (!object.Equals(HostPath, other.HostPath)) return false;
      if (!object.Equals(Glusterfs, other.Glusterfs)) return false;
      if (!object.Equals(Nfs, other.Nfs)) return false;
      if (!object.Equals(Rbd, other.Rbd)) return false;
      if (!object.Equals(Iscsi, other.Iscsi)) return false;
      if (!object.Equals(Cinder, other.Cinder)) return false;
      if (!object.Equals(Cephfs, other.Cephfs)) return false;
      if (!object.Equals(Fc, other.Fc)) return false;
      if (!object.Equals(Flocker, other.Flocker)) return false;
      if (!object.Equals(FlexVolume, other.FlexVolume)) return false;
      if (!object.Equals(AzureFile, other.AzureFile)) return false;
      if (!object.Equals(VsphereVolume, other.VsphereVolume)) return false;
      if (!object.Equals(Quobyte, other.Quobyte)) return false;
      if (!object.Equals(AzureDisk, other.AzureDisk)) return false;
      if (!object.Equals(PhotonPersistentDisk, other.PhotonPersistentDisk)) return false;
      if (!object.Equals(PortworxVolume, other.PortworxVolume)) return false;
      if (!object.Equals(ScaleIO, other.ScaleIO)) return false;
      if (!object.Equals(Local, other.Local)) return false;
      if (!object.Equals(Storageos, other.Storageos)) return false;
      if (!object.Equals(Csi, other.Csi)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (gcePersistentDisk_ != null) hash ^= GcePersistentDisk.GetHashCode();
      if (awsElasticBlockStore_ != null) hash ^= AwsElasticBlockStore.GetHashCode();
      if (hostPath_ != null) hash ^= HostPath.GetHashCode();
      if (glusterfs_ != null) hash ^= Glusterfs.GetHashCode();
      if (nfs_ != null) hash ^= Nfs.GetHashCode();
      if (rbd_ != null) hash ^= Rbd.GetHashCode();
      if (iscsi_ != null) hash ^= Iscsi.GetHashCode();
      if (cinder_ != null) hash ^= Cinder.GetHashCode();
      if (cephfs_ != null) hash ^= Cephfs.GetHashCode();
      if (fc_ != null) hash ^= Fc.GetHashCode();
      if (flocker_ != null) hash ^= Flocker.GetHashCode();
      if (flexVolume_ != null) hash ^= FlexVolume.GetHashCode();
      if (azureFile_ != null) hash ^= AzureFile.GetHashCode();
      if (vsphereVolume_ != null) hash ^= VsphereVolume.GetHashCode();
      if (quobyte_ != null) hash ^= Quobyte.GetHashCode();
      if (azureDisk_ != null) hash ^= AzureDisk.GetHashCode();
      if (photonPersistentDisk_ != null) hash ^= PhotonPersistentDisk.GetHashCode();
      if (portworxVolume_ != null) hash ^= PortworxVolume.GetHashCode();
      if (scaleIO_ != null) hash ^= ScaleIO.GetHashCode();
      if (local_ != null) hash ^= Local.GetHashCode();
      if (storageos_ != null) hash ^= Storageos.GetHashCode();
      if (csi_ != null) hash ^= Csi.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (gcePersistentDisk_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(GcePersistentDisk);
      }
      if (awsElasticBlockStore_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AwsElasticBlockStore);
      }
      if (hostPath_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(HostPath);
      }
      if (glusterfs_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Glusterfs);
      }
      if (nfs_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Nfs);
      }
      if (rbd_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Rbd);
      }
      if (iscsi_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Iscsi);
      }
      if (cinder_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Cinder);
      }
      if (cephfs_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Cephfs);
      }
      if (fc_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(Fc);
      }
      if (flocker_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Flocker);
      }
      if (flexVolume_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(FlexVolume);
      }
      if (azureFile_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(AzureFile);
      }
      if (vsphereVolume_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(VsphereVolume);
      }
      if (quobyte_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Quobyte);
      }
      if (azureDisk_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(AzureDisk);
      }
      if (photonPersistentDisk_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(PhotonPersistentDisk);
      }
      if (portworxVolume_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(PortworxVolume);
      }
      if (scaleIO_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ScaleIO);
      }
      if (local_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(Local);
      }
      if (storageos_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(Storageos);
      }
      if (csi_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(Csi);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (gcePersistentDisk_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(GcePersistentDisk);
      }
      if (awsElasticBlockStore_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(AwsElasticBlockStore);
      }
      if (hostPath_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(HostPath);
      }
      if (glusterfs_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Glusterfs);
      }
      if (nfs_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Nfs);
      }
      if (rbd_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Rbd);
      }
      if (iscsi_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Iscsi);
      }
      if (cinder_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Cinder);
      }
      if (cephfs_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Cephfs);
      }
      if (fc_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(Fc);
      }
      if (flocker_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Flocker);
      }
      if (flexVolume_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(FlexVolume);
      }
      if (azureFile_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(AzureFile);
      }
      if (vsphereVolume_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(VsphereVolume);
      }
      if (quobyte_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Quobyte);
      }
      if (azureDisk_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(AzureDisk);
      }
      if (photonPersistentDisk_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(PhotonPersistentDisk);
      }
      if (portworxVolume_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(PortworxVolume);
      }
      if (scaleIO_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ScaleIO);
      }
      if (local_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(Local);
      }
      if (storageos_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(Storageos);
      }
      if (csi_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(Csi);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (gcePersistentDisk_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GcePersistentDisk);
      }
      if (awsElasticBlockStore_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AwsElasticBlockStore);
      }
      if (hostPath_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HostPath);
      }
      if (glusterfs_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Glusterfs);
      }
      if (nfs_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Nfs);
      }
      if (rbd_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rbd);
      }
      if (iscsi_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Iscsi);
      }
      if (cinder_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cinder);
      }
      if (cephfs_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cephfs);
      }
      if (fc_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Fc);
      }
      if (flocker_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Flocker);
      }
      if (flexVolume_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FlexVolume);
      }
      if (azureFile_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AzureFile);
      }
      if (vsphereVolume_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VsphereVolume);
      }
      if (quobyte_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Quobyte);
      }
      if (azureDisk_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(AzureDisk);
      }
      if (photonPersistentDisk_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(PhotonPersistentDisk);
      }
      if (portworxVolume_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(PortworxVolume);
      }
      if (scaleIO_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ScaleIO);
      }
      if (local_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Local);
      }
      if (storageos_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Storageos);
      }
      if (csi_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Csi);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.gcePersistentDisk_ != null) {
        if (gcePersistentDisk_ == null) {
          GcePersistentDisk = new global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource();
        }
        GcePersistentDisk.MergeFrom(other.GcePersistentDisk);
      }
      if (other.awsElasticBlockStore_ != null) {
        if (awsElasticBlockStore_ == null) {
          AwsElasticBlockStore = new global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource();
        }
        AwsElasticBlockStore.MergeFrom(other.AwsElasticBlockStore);
      }
      if (other.hostPath_ != null) {
        if (hostPath_ == null) {
          HostPath = new global::K8S.Io.Api.Core.V1.HostPathVolumeSource();
        }
        HostPath.MergeFrom(other.HostPath);
      }
      if (other.glusterfs_ != null) {
        if (glusterfs_ == null) {
          Glusterfs = new global::K8S.Io.Api.Core.V1.GlusterfsPersistentVolumeSource();
        }
        Glusterfs.MergeFrom(other.Glusterfs);
      }
      if (other.nfs_ != null) {
        if (nfs_ == null) {
          Nfs = new global::K8S.Io.Api.Core.V1.NFSVolumeSource();
        }
        Nfs.MergeFrom(other.Nfs);
      }
      if (other.rbd_ != null) {
        if (rbd_ == null) {
          Rbd = new global::K8S.Io.Api.Core.V1.RBDPersistentVolumeSource();
        }
        Rbd.MergeFrom(other.Rbd);
      }
      if (other.iscsi_ != null) {
        if (iscsi_ == null) {
          Iscsi = new global::K8S.Io.Api.Core.V1.ISCSIPersistentVolumeSource();
        }
        Iscsi.MergeFrom(other.Iscsi);
      }
      if (other.cinder_ != null) {
        if (cinder_ == null) {
          Cinder = new global::K8S.Io.Api.Core.V1.CinderPersistentVolumeSource();
        }
        Cinder.MergeFrom(other.Cinder);
      }
      if (other.cephfs_ != null) {
        if (cephfs_ == null) {
          Cephfs = new global::K8S.Io.Api.Core.V1.CephFSPersistentVolumeSource();
        }
        Cephfs.MergeFrom(other.Cephfs);
      }
      if (other.fc_ != null) {
        if (fc_ == null) {
          Fc = new global::K8S.Io.Api.Core.V1.FCVolumeSource();
        }
        Fc.MergeFrom(other.Fc);
      }
      if (other.flocker_ != null) {
        if (flocker_ == null) {
          Flocker = new global::K8S.Io.Api.Core.V1.FlockerVolumeSource();
        }
        Flocker.MergeFrom(other.Flocker);
      }
      if (other.flexVolume_ != null) {
        if (flexVolume_ == null) {
          FlexVolume = new global::K8S.Io.Api.Core.V1.FlexPersistentVolumeSource();
        }
        FlexVolume.MergeFrom(other.FlexVolume);
      }
      if (other.azureFile_ != null) {
        if (azureFile_ == null) {
          AzureFile = new global::K8S.Io.Api.Core.V1.AzureFilePersistentVolumeSource();
        }
        AzureFile.MergeFrom(other.AzureFile);
      }
      if (other.vsphereVolume_ != null) {
        if (vsphereVolume_ == null) {
          VsphereVolume = new global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource();
        }
        VsphereVolume.MergeFrom(other.VsphereVolume);
      }
      if (other.quobyte_ != null) {
        if (quobyte_ == null) {
          Quobyte = new global::K8S.Io.Api.Core.V1.QuobyteVolumeSource();
        }
        Quobyte.MergeFrom(other.Quobyte);
      }
      if (other.azureDisk_ != null) {
        if (azureDisk_ == null) {
          AzureDisk = new global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource();
        }
        AzureDisk.MergeFrom(other.AzureDisk);
      }
      if (other.photonPersistentDisk_ != null) {
        if (photonPersistentDisk_ == null) {
          PhotonPersistentDisk = new global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource();
        }
        PhotonPersistentDisk.MergeFrom(other.PhotonPersistentDisk);
      }
      if (other.portworxVolume_ != null) {
        if (portworxVolume_ == null) {
          PortworxVolume = new global::K8S.Io.Api.Core.V1.PortworxVolumeSource();
        }
        PortworxVolume.MergeFrom(other.PortworxVolume);
      }
      if (other.scaleIO_ != null) {
        if (scaleIO_ == null) {
          ScaleIO = new global::K8S.Io.Api.Core.V1.ScaleIOPersistentVolumeSource();
        }
        ScaleIO.MergeFrom(other.ScaleIO);
      }
      if (other.local_ != null) {
        if (local_ == null) {
          Local = new global::K8S.Io.Api.Core.V1.LocalVolumeSource();
        }
        Local.MergeFrom(other.Local);
      }
      if (other.storageos_ != null) {
        if (storageos_ == null) {
          Storageos = new global::K8S.Io.Api.Core.V1.StorageOSPersistentVolumeSource();
        }
        Storageos.MergeFrom(other.Storageos);
      }
      if (other.csi_ != null) {
        if (csi_ == null) {
          Csi = new global::K8S.Io.Api.Core.V1.CSIPersistentVolumeSource();
        }
        Csi.MergeFrom(other.Csi);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (gcePersistentDisk_ == null) {
              GcePersistentDisk = new global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource();
            }
            input.ReadMessage(GcePersistentDisk);
            break;
          }
          case 18: {
            if (awsElasticBlockStore_ == null) {
              AwsElasticBlockStore = new global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource();
            }
            input.ReadMessage(AwsElasticBlockStore);
            break;
          }
          case 26: {
            if (hostPath_ == null) {
              HostPath = new global::K8S.Io.Api.Core.V1.HostPathVolumeSource();
            }
            input.ReadMessage(HostPath);
            break;
          }
          case 34: {
            if (glusterfs_ == null) {
              Glusterfs = new global::K8S.Io.Api.Core.V1.GlusterfsPersistentVolumeSource();
            }
            input.ReadMessage(Glusterfs);
            break;
          }
          case 42: {
            if (nfs_ == null) {
              Nfs = new global::K8S.Io.Api.Core.V1.NFSVolumeSource();
            }
            input.ReadMessage(Nfs);
            break;
          }
          case 50: {
            if (rbd_ == null) {
              Rbd = new global::K8S.Io.Api.Core.V1.RBDPersistentVolumeSource();
            }
            input.ReadMessage(Rbd);
            break;
          }
          case 58: {
            if (iscsi_ == null) {
              Iscsi = new global::K8S.Io.Api.Core.V1.ISCSIPersistentVolumeSource();
            }
            input.ReadMessage(Iscsi);
            break;
          }
          case 66: {
            if (cinder_ == null) {
              Cinder = new global::K8S.Io.Api.Core.V1.CinderPersistentVolumeSource();
            }
            input.ReadMessage(Cinder);
            break;
          }
          case 74: {
            if (cephfs_ == null) {
              Cephfs = new global::K8S.Io.Api.Core.V1.CephFSPersistentVolumeSource();
            }
            input.ReadMessage(Cephfs);
            break;
          }
          case 82: {
            if (fc_ == null) {
              Fc = new global::K8S.Io.Api.Core.V1.FCVolumeSource();
            }
            input.ReadMessage(Fc);
            break;
          }
          case 90: {
            if (flocker_ == null) {
              Flocker = new global::K8S.Io.Api.Core.V1.FlockerVolumeSource();
            }
            input.ReadMessage(Flocker);
            break;
          }
          case 98: {
            if (flexVolume_ == null) {
              FlexVolume = new global::K8S.Io.Api.Core.V1.FlexPersistentVolumeSource();
            }
            input.ReadMessage(FlexVolume);
            break;
          }
          case 106: {
            if (azureFile_ == null) {
              AzureFile = new global::K8S.Io.Api.Core.V1.AzureFilePersistentVolumeSource();
            }
            input.ReadMessage(AzureFile);
            break;
          }
          case 114: {
            if (vsphereVolume_ == null) {
              VsphereVolume = new global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource();
            }
            input.ReadMessage(VsphereVolume);
            break;
          }
          case 122: {
            if (quobyte_ == null) {
              Quobyte = new global::K8S.Io.Api.Core.V1.QuobyteVolumeSource();
            }
            input.ReadMessage(Quobyte);
            break;
          }
          case 130: {
            if (azureDisk_ == null) {
              AzureDisk = new global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource();
            }
            input.ReadMessage(AzureDisk);
            break;
          }
          case 138: {
            if (photonPersistentDisk_ == null) {
              PhotonPersistentDisk = new global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource();
            }
            input.ReadMessage(PhotonPersistentDisk);
            break;
          }
          case 146: {
            if (portworxVolume_ == null) {
              PortworxVolume = new global::K8S.Io.Api.Core.V1.PortworxVolumeSource();
            }
            input.ReadMessage(PortworxVolume);
            break;
          }
          case 154: {
            if (scaleIO_ == null) {
              ScaleIO = new global::K8S.Io.Api.Core.V1.ScaleIOPersistentVolumeSource();
            }
            input.ReadMessage(ScaleIO);
            break;
          }
          case 162: {
            if (local_ == null) {
              Local = new global::K8S.Io.Api.Core.V1.LocalVolumeSource();
            }
            input.ReadMessage(Local);
            break;
          }
          case 170: {
            if (storageos_ == null) {
              Storageos = new global::K8S.Io.Api.Core.V1.StorageOSPersistentVolumeSource();
            }
            input.ReadMessage(Storageos);
            break;
          }
          case 178: {
            if (csi_ == null) {
              Csi = new global::K8S.Io.Api.Core.V1.CSIPersistentVolumeSource();
            }
            input.ReadMessage(Csi);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (gcePersistentDisk_ == null) {
              GcePersistentDisk = new global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource();
            }
            input.ReadMessage(GcePersistentDisk);
            break;
          }
          case 18: {
            if (awsElasticBlockStore_ == null) {
              AwsElasticBlockStore = new global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource();
            }
            input.ReadMessage(AwsElasticBlockStore);
            break;
          }
          case 26: {
            if (hostPath_ == null) {
              HostPath = new global::K8S.Io.Api.Core.V1.HostPathVolumeSource();
            }
            input.ReadMessage(HostPath);
            break;
          }
          case 34: {
            if (glusterfs_ == null) {
              Glusterfs = new global::K8S.Io.Api.Core.V1.GlusterfsPersistentVolumeSource();
            }
            input.ReadMessage(Glusterfs);
            break;
          }
          case 42: {
            if (nfs_ == null) {
              Nfs = new global::K8S.Io.Api.Core.V1.NFSVolumeSource();
            }
            input.ReadMessage(Nfs);
            break;
          }
          case 50: {
            if (rbd_ == null) {
              Rbd = new global::K8S.Io.Api.Core.V1.RBDPersistentVolumeSource();
            }
            input.ReadMessage(Rbd);
            break;
          }
          case 58: {
            if (iscsi_ == null) {
              Iscsi = new global::K8S.Io.Api.Core.V1.ISCSIPersistentVolumeSource();
            }
            input.ReadMessage(Iscsi);
            break;
          }
          case 66: {
            if (cinder_ == null) {
              Cinder = new global::K8S.Io.Api.Core.V1.CinderPersistentVolumeSource();
            }
            input.ReadMessage(Cinder);
            break;
          }
          case 74: {
            if (cephfs_ == null) {
              Cephfs = new global::K8S.Io.Api.Core.V1.CephFSPersistentVolumeSource();
            }
            input.ReadMessage(Cephfs);
            break;
          }
          case 82: {
            if (fc_ == null) {
              Fc = new global::K8S.Io.Api.Core.V1.FCVolumeSource();
            }
            input.ReadMessage(Fc);
            break;
          }
          case 90: {
            if (flocker_ == null) {
              Flocker = new global::K8S.Io.Api.Core.V1.FlockerVolumeSource();
            }
            input.ReadMessage(Flocker);
            break;
          }
          case 98: {
            if (flexVolume_ == null) {
              FlexVolume = new global::K8S.Io.Api.Core.V1.FlexPersistentVolumeSource();
            }
            input.ReadMessage(FlexVolume);
            break;
          }
          case 106: {
            if (azureFile_ == null) {
              AzureFile = new global::K8S.Io.Api.Core.V1.AzureFilePersistentVolumeSource();
            }
            input.ReadMessage(AzureFile);
            break;
          }
          case 114: {
            if (vsphereVolume_ == null) {
              VsphereVolume = new global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource();
            }
            input.ReadMessage(VsphereVolume);
            break;
          }
          case 122: {
            if (quobyte_ == null) {
              Quobyte = new global::K8S.Io.Api.Core.V1.QuobyteVolumeSource();
            }
            input.ReadMessage(Quobyte);
            break;
          }
          case 130: {
            if (azureDisk_ == null) {
              AzureDisk = new global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource();
            }
            input.ReadMessage(AzureDisk);
            break;
          }
          case 138: {
            if (photonPersistentDisk_ == null) {
              PhotonPersistentDisk = new global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource();
            }
            input.ReadMessage(PhotonPersistentDisk);
            break;
          }
          case 146: {
            if (portworxVolume_ == null) {
              PortworxVolume = new global::K8S.Io.Api.Core.V1.PortworxVolumeSource();
            }
            input.ReadMessage(PortworxVolume);
            break;
          }
          case 154: {
            if (scaleIO_ == null) {
              ScaleIO = new global::K8S.Io.Api.Core.V1.ScaleIOPersistentVolumeSource();
            }
            input.ReadMessage(ScaleIO);
            break;
          }
          case 162: {
            if (local_ == null) {
              Local = new global::K8S.Io.Api.Core.V1.LocalVolumeSource();
            }
            input.ReadMessage(Local);
            break;
          }
          case 170: {
            if (storageos_ == null) {
              Storageos = new global::K8S.Io.Api.Core.V1.StorageOSPersistentVolumeSource();
            }
            input.ReadMessage(Storageos);
            break;
          }
          case 178: {
            if (csi_ == null) {
              Csi = new global::K8S.Io.Api.Core.V1.CSIPersistentVolumeSource();
            }
            input.ReadMessage(Csi);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeSpec is the specification of a persistent volume.
  /// </summary>
  public sealed partial class PersistentVolumeSpec : pb::IMessage<PersistentVolumeSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeSpec> _parser = new pb::MessageParser<PersistentVolumeSpec>(() => new PersistentVolumeSpec());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[115]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeSpec(PersistentVolumeSpec other) : this() {
      capacity_ = other.capacity_.Clone();
      persistentVolumeSource_ = other.persistentVolumeSource_ != null ? other.persistentVolumeSource_.Clone() : null;
      accessModes_ = other.accessModes_.Clone();
      claimRef_ = other.claimRef_ != null ? other.claimRef_.Clone() : null;
      persistentVolumeReclaimPolicy_ = other.persistentVolumeReclaimPolicy_;
      storageClassName_ = other.storageClassName_;
      mountOptions_ = other.mountOptions_.Clone();
      volumeMode_ = other.volumeMode_;
      nodeAffinity_ = other.nodeAffinity_ != null ? other.nodeAffinity_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeSpec Clone() {
      return new PersistentVolumeSpec(this);
    }

    /// <summary>Field number for the "capacity" field.</summary>
    public const int CapacityFieldNumber = 1;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_capacity_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 10);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> capacity_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// A description of the persistent volume's resources and capacity.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Capacity {
      get { return capacity_; }
    }

    /// <summary>Field number for the "persistentVolumeSource" field.</summary>
    public const int PersistentVolumeSourceFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.PersistentVolumeSource persistentVolumeSource_;
    /// <summary>
    /// The actual volume backing the persistent volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PersistentVolumeSource PersistentVolumeSource {
      get { return persistentVolumeSource_; }
      set {
        persistentVolumeSource_ = value;
      }
    }

    /// <summary>Field number for the "accessModes" field.</summary>
    public const int AccessModesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_accessModes_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> accessModes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// AccessModes contains all ways the volume can be mounted.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> AccessModes {
      get { return accessModes_; }
    }

    /// <summary>Field number for the "claimRef" field.</summary>
    public const int ClaimRefFieldNumber = 4;
    private global::K8S.Io.Api.Core.V1.ObjectReference claimRef_;
    /// <summary>
    /// ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
    /// Expected to be non-nil when bound.
    /// claim.VolumeName is the authoritative bind between PV and PVC.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ObjectReference ClaimRef {
      get { return claimRef_; }
      set {
        claimRef_ = value;
      }
    }

    /// <summary>Field number for the "persistentVolumeReclaimPolicy" field.</summary>
    public const int PersistentVolumeReclaimPolicyFieldNumber = 5;
    private readonly static string PersistentVolumeReclaimPolicyDefaultValue = "";

    private string persistentVolumeReclaimPolicy_;
    /// <summary>
    /// What happens to a persistent volume when released from its claim.
    /// Valid options are Retain (default for manually created PersistentVolumes), Delete (default
    /// for dynamically provisioned PersistentVolumes), and Recycle (deprecated).
    /// Recycle must be supported by the volume plugin underlying this PersistentVolume.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PersistentVolumeReclaimPolicy {
      get { return persistentVolumeReclaimPolicy_ ?? PersistentVolumeReclaimPolicyDefaultValue; }
      set {
        persistentVolumeReclaimPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "persistentVolumeReclaimPolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPersistentVolumeReclaimPolicy {
      get { return persistentVolumeReclaimPolicy_ != null; }
    }
    /// <summary>Clears the value of the "persistentVolumeReclaimPolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPersistentVolumeReclaimPolicy() {
      persistentVolumeReclaimPolicy_ = null;
    }

    /// <summary>Field number for the "storageClassName" field.</summary>
    public const int StorageClassNameFieldNumber = 6;
    private readonly static string StorageClassNameDefaultValue = "";

    private string storageClassName_;
    /// <summary>
    /// Name of StorageClass to which this persistent volume belongs. Empty value
    /// means that this volume does not belong to any StorageClass.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StorageClassName {
      get { return storageClassName_ ?? StorageClassNameDefaultValue; }
      set {
        storageClassName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "storageClassName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStorageClassName {
      get { return storageClassName_ != null; }
    }
    /// <summary>Clears the value of the "storageClassName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStorageClassName() {
      storageClassName_ = null;
    }

    /// <summary>Field number for the "mountOptions" field.</summary>
    public const int MountOptionsFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_mountOptions_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> mountOptions_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A list of mount options, e.g. ["ro", "soft"]. Not validated - mount will
    /// simply fail if one is invalid.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> MountOptions {
      get { return mountOptions_; }
    }

    /// <summary>Field number for the "volumeMode" field.</summary>
    public const int VolumeModeFieldNumber = 8;
    private readonly static string VolumeModeDefaultValue = "";

    private string volumeMode_;
    /// <summary>
    /// volumeMode defines if a volume is intended to be used with a formatted filesystem
    /// or to remain in raw block state. Value of Filesystem is implied when not included in spec.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeMode {
      get { return volumeMode_ ?? VolumeModeDefaultValue; }
      set {
        volumeMode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeMode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeMode {
      get { return volumeMode_ != null; }
    }
    /// <summary>Clears the value of the "volumeMode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeMode() {
      volumeMode_ = null;
    }

    /// <summary>Field number for the "nodeAffinity" field.</summary>
    public const int NodeAffinityFieldNumber = 9;
    private global::K8S.Io.Api.Core.V1.VolumeNodeAffinity nodeAffinity_;
    /// <summary>
    /// NodeAffinity defines constraints that limit what nodes this volume can be accessed from.
    /// This field influences the scheduling of pods that use this volume.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.VolumeNodeAffinity NodeAffinity {
      get { return nodeAffinity_; }
      set {
        nodeAffinity_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Capacity.Equals(other.Capacity)) return false;
      if (!object.Equals(PersistentVolumeSource, other.PersistentVolumeSource)) return false;
      if(!accessModes_.Equals(other.accessModes_)) return false;
      if (!object.Equals(ClaimRef, other.ClaimRef)) return false;
      if (PersistentVolumeReclaimPolicy != other.PersistentVolumeReclaimPolicy) return false;
      if (StorageClassName != other.StorageClassName) return false;
      if(!mountOptions_.Equals(other.mountOptions_)) return false;
      if (VolumeMode != other.VolumeMode) return false;
      if (!object.Equals(NodeAffinity, other.NodeAffinity)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Capacity.GetHashCode();
      if (persistentVolumeSource_ != null) hash ^= PersistentVolumeSource.GetHashCode();
      hash ^= accessModes_.GetHashCode();
      if (claimRef_ != null) hash ^= ClaimRef.GetHashCode();
      if (HasPersistentVolumeReclaimPolicy) hash ^= PersistentVolumeReclaimPolicy.GetHashCode();
      if (HasStorageClassName) hash ^= StorageClassName.GetHashCode();
      hash ^= mountOptions_.GetHashCode();
      if (HasVolumeMode) hash ^= VolumeMode.GetHashCode();
      if (nodeAffinity_ != null) hash ^= NodeAffinity.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      capacity_.WriteTo(output, _map_capacity_codec);
      if (persistentVolumeSource_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PersistentVolumeSource);
      }
      accessModes_.WriteTo(output, _repeated_accessModes_codec);
      if (claimRef_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ClaimRef);
      }
      if (HasPersistentVolumeReclaimPolicy) {
        output.WriteRawTag(42);
        output.WriteString(PersistentVolumeReclaimPolicy);
      }
      if (HasStorageClassName) {
        output.WriteRawTag(50);
        output.WriteString(StorageClassName);
      }
      mountOptions_.WriteTo(output, _repeated_mountOptions_codec);
      if (HasVolumeMode) {
        output.WriteRawTag(66);
        output.WriteString(VolumeMode);
      }
      if (nodeAffinity_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(NodeAffinity);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      capacity_.WriteTo(ref output, _map_capacity_codec);
      if (persistentVolumeSource_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PersistentVolumeSource);
      }
      accessModes_.WriteTo(ref output, _repeated_accessModes_codec);
      if (claimRef_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ClaimRef);
      }
      if (HasPersistentVolumeReclaimPolicy) {
        output.WriteRawTag(42);
        output.WriteString(PersistentVolumeReclaimPolicy);
      }
      if (HasStorageClassName) {
        output.WriteRawTag(50);
        output.WriteString(StorageClassName);
      }
      mountOptions_.WriteTo(ref output, _repeated_mountOptions_codec);
      if (HasVolumeMode) {
        output.WriteRawTag(66);
        output.WriteString(VolumeMode);
      }
      if (nodeAffinity_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(NodeAffinity);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += capacity_.CalculateSize(_map_capacity_codec);
      if (persistentVolumeSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PersistentVolumeSource);
      }
      size += accessModes_.CalculateSize(_repeated_accessModes_codec);
      if (claimRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClaimRef);
      }
      if (HasPersistentVolumeReclaimPolicy) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PersistentVolumeReclaimPolicy);
      }
      if (HasStorageClassName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StorageClassName);
      }
      size += mountOptions_.CalculateSize(_repeated_mountOptions_codec);
      if (HasVolumeMode) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeMode);
      }
      if (nodeAffinity_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NodeAffinity);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeSpec other) {
      if (other == null) {
        return;
      }
      capacity_.Add(other.capacity_);
      if (other.persistentVolumeSource_ != null) {
        if (persistentVolumeSource_ == null) {
          PersistentVolumeSource = new global::K8S.Io.Api.Core.V1.PersistentVolumeSource();
        }
        PersistentVolumeSource.MergeFrom(other.PersistentVolumeSource);
      }
      accessModes_.Add(other.accessModes_);
      if (other.claimRef_ != null) {
        if (claimRef_ == null) {
          ClaimRef = new global::K8S.Io.Api.Core.V1.ObjectReference();
        }
        ClaimRef.MergeFrom(other.ClaimRef);
      }
      if (other.HasPersistentVolumeReclaimPolicy) {
        PersistentVolumeReclaimPolicy = other.PersistentVolumeReclaimPolicy;
      }
      if (other.HasStorageClassName) {
        StorageClassName = other.StorageClassName;
      }
      mountOptions_.Add(other.mountOptions_);
      if (other.HasVolumeMode) {
        VolumeMode = other.VolumeMode;
      }
      if (other.nodeAffinity_ != null) {
        if (nodeAffinity_ == null) {
          NodeAffinity = new global::K8S.Io.Api.Core.V1.VolumeNodeAffinity();
        }
        NodeAffinity.MergeFrom(other.NodeAffinity);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            capacity_.AddEntriesFrom(input, _map_capacity_codec);
            break;
          }
          case 18: {
            if (persistentVolumeSource_ == null) {
              PersistentVolumeSource = new global::K8S.Io.Api.Core.V1.PersistentVolumeSource();
            }
            input.ReadMessage(PersistentVolumeSource);
            break;
          }
          case 26: {
            accessModes_.AddEntriesFrom(input, _repeated_accessModes_codec);
            break;
          }
          case 34: {
            if (claimRef_ == null) {
              ClaimRef = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(ClaimRef);
            break;
          }
          case 42: {
            PersistentVolumeReclaimPolicy = input.ReadString();
            break;
          }
          case 50: {
            StorageClassName = input.ReadString();
            break;
          }
          case 58: {
            mountOptions_.AddEntriesFrom(input, _repeated_mountOptions_codec);
            break;
          }
          case 66: {
            VolumeMode = input.ReadString();
            break;
          }
          case 74: {
            if (nodeAffinity_ == null) {
              NodeAffinity = new global::K8S.Io.Api.Core.V1.VolumeNodeAffinity();
            }
            input.ReadMessage(NodeAffinity);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            capacity_.AddEntriesFrom(ref input, _map_capacity_codec);
            break;
          }
          case 18: {
            if (persistentVolumeSource_ == null) {
              PersistentVolumeSource = new global::K8S.Io.Api.Core.V1.PersistentVolumeSource();
            }
            input.ReadMessage(PersistentVolumeSource);
            break;
          }
          case 26: {
            accessModes_.AddEntriesFrom(ref input, _repeated_accessModes_codec);
            break;
          }
          case 34: {
            if (claimRef_ == null) {
              ClaimRef = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(ClaimRef);
            break;
          }
          case 42: {
            PersistentVolumeReclaimPolicy = input.ReadString();
            break;
          }
          case 50: {
            StorageClassName = input.ReadString();
            break;
          }
          case 58: {
            mountOptions_.AddEntriesFrom(ref input, _repeated_mountOptions_codec);
            break;
          }
          case 66: {
            VolumeMode = input.ReadString();
            break;
          }
          case 74: {
            if (nodeAffinity_ == null) {
              NodeAffinity = new global::K8S.Io.Api.Core.V1.VolumeNodeAffinity();
            }
            input.ReadMessage(NodeAffinity);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PersistentVolumeStatus is the current status of a persistent volume.
  /// </summary>
  public sealed partial class PersistentVolumeStatus : pb::IMessage<PersistentVolumeStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PersistentVolumeStatus> _parser = new pb::MessageParser<PersistentVolumeStatus>(() => new PersistentVolumeStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PersistentVolumeStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[116]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeStatus(PersistentVolumeStatus other) : this() {
      phase_ = other.phase_;
      message_ = other.message_;
      reason_ = other.reason_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PersistentVolumeStatus Clone() {
      return new PersistentVolumeStatus(this);
    }

    /// <summary>Field number for the "phase" field.</summary>
    public const int PhaseFieldNumber = 1;
    private readonly static string PhaseDefaultValue = "";

    private string phase_;
    /// <summary>
    /// Phase indicates if a volume is available, bound to a claim, or released by a claim.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Phase {
      get { return phase_ ?? PhaseDefaultValue; }
      set {
        phase_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "phase" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPhase {
      get { return phase_ != null; }
    }
    /// <summary>Clears the value of the "phase" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPhase() {
      phase_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 2;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// A human-readable message indicating details about why the volume is in this state.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 3;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// Reason is a brief CamelCase string that describes any failure and is meant
    /// for machine parsing and tidy display in the CLI.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PersistentVolumeStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PersistentVolumeStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Phase != other.Phase) return false;
      if (Message != other.Message) return false;
      if (Reason != other.Reason) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPhase) hash ^= Phase.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (HasReason) hash ^= Reason.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPhase) {
        output.WriteRawTag(10);
        output.WriteString(Phase);
      }
      if (HasMessage) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      if (HasReason) {
        output.WriteRawTag(26);
        output.WriteString(Reason);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPhase) {
        output.WriteRawTag(10);
        output.WriteString(Phase);
      }
      if (HasMessage) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      if (HasReason) {
        output.WriteRawTag(26);
        output.WriteString(Reason);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPhase) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Phase);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PersistentVolumeStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasPhase) {
        Phase = other.Phase;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Phase = input.ReadString();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
          case 26: {
            Reason = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Phase = input.ReadString();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
          case 26: {
            Reason = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Photon Controller persistent disk resource.
  /// </summary>
  public sealed partial class PhotonPersistentDiskVolumeSource : pb::IMessage<PhotonPersistentDiskVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PhotonPersistentDiskVolumeSource> _parser = new pb::MessageParser<PhotonPersistentDiskVolumeSource>(() => new PhotonPersistentDiskVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PhotonPersistentDiskVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[117]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PhotonPersistentDiskVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PhotonPersistentDiskVolumeSource(PhotonPersistentDiskVolumeSource other) : this() {
      pdID_ = other.pdID_;
      fsType_ = other.fsType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PhotonPersistentDiskVolumeSource Clone() {
      return new PhotonPersistentDiskVolumeSource(this);
    }

    /// <summary>Field number for the "pdID" field.</summary>
    public const int PdIDFieldNumber = 1;
    private readonly static string PdIDDefaultValue = "";

    private string pdID_;
    /// <summary>
    /// ID that identifies Photon Controller persistent disk
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PdID {
      get { return pdID_ ?? PdIDDefaultValue; }
      set {
        pdID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "pdID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPdID {
      get { return pdID_ != null; }
    }
    /// <summary>Clears the value of the "pdID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPdID() {
      pdID_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 2;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PhotonPersistentDiskVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PhotonPersistentDiskVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PdID != other.PdID) return false;
      if (FsType != other.FsType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPdID) hash ^= PdID.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPdID) {
        output.WriteRawTag(10);
        output.WriteString(PdID);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPdID) {
        output.WriteRawTag(10);
        output.WriteString(PdID);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPdID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PdID);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PhotonPersistentDiskVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasPdID) {
        PdID = other.PdID;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PdID = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            PdID = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Pod is a collection of containers that can run on a host. This resource is created
  /// by clients and scheduled onto hosts.
  /// </summary>
  public sealed partial class Pod : pb::IMessage<Pod>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Pod> _parser = new pb::MessageParser<Pod>(() => new Pod());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Pod> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[118]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Pod() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Pod(Pod other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Pod Clone() {
      return new Pod(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.PodSpec spec_;
    /// <summary>
    /// Specification of the desired behavior of the pod.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.PodStatus status_;
    /// <summary>
    /// Most recently observed status of the pod.
    /// This data may not be up to date.
    /// Populated by the system.
    /// Read-only.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Pod);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Pod other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Pod other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.PodSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::K8S.Io.Api.Core.V1.PodStatus();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.PodSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.PodStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.PodSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.PodStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Pod affinity is a group of inter pod affinity scheduling rules.
  /// </summary>
  public sealed partial class PodAffinity : pb::IMessage<PodAffinity>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodAffinity> _parser = new pb::MessageParser<PodAffinity>(() => new PodAffinity());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodAffinity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[119]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAffinity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAffinity(PodAffinity other) : this() {
      requiredDuringSchedulingIgnoredDuringExecution_ = other.requiredDuringSchedulingIgnoredDuringExecution_.Clone();
      preferredDuringSchedulingIgnoredDuringExecution_ = other.preferredDuringSchedulingIgnoredDuringExecution_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAffinity Clone() {
      return new PodAffinity(this);
    }

    /// <summary>Field number for the "requiredDuringSchedulingIgnoredDuringExecution" field.</summary>
    public const int RequiredDuringSchedulingIgnoredDuringExecutionFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PodAffinityTerm> _repeated_requiredDuringSchedulingIgnoredDuringExecution_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.PodAffinityTerm.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodAffinityTerm> requiredDuringSchedulingIgnoredDuringExecution_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodAffinityTerm>();
    /// <summary>
    /// If the affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to a pod label update), the
    /// system may or may not try to eventually evict the pod from its node.
    /// When there are multiple elements, the lists of nodes corresponding to each
    /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodAffinityTerm> RequiredDuringSchedulingIgnoredDuringExecution {
      get { return requiredDuringSchedulingIgnoredDuringExecution_; }
    }

    /// <summary>Field number for the "preferredDuringSchedulingIgnoredDuringExecution" field.</summary>
    public const int PreferredDuringSchedulingIgnoredDuringExecutionFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm> _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm> preferredDuringSchedulingIgnoredDuringExecution_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm>();
    /// <summary>
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    /// node(s) with the highest sum are the most preferred.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm> PreferredDuringSchedulingIgnoredDuringExecution {
      get { return preferredDuringSchedulingIgnoredDuringExecution_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodAffinity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodAffinity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!requiredDuringSchedulingIgnoredDuringExecution_.Equals(other.requiredDuringSchedulingIgnoredDuringExecution_)) return false;
      if(!preferredDuringSchedulingIgnoredDuringExecution_.Equals(other.preferredDuringSchedulingIgnoredDuringExecution_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= requiredDuringSchedulingIgnoredDuringExecution_.GetHashCode();
      hash ^= preferredDuringSchedulingIgnoredDuringExecution_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      requiredDuringSchedulingIgnoredDuringExecution_.WriteTo(output, _repeated_requiredDuringSchedulingIgnoredDuringExecution_codec);
      preferredDuringSchedulingIgnoredDuringExecution_.WriteTo(output, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      requiredDuringSchedulingIgnoredDuringExecution_.WriteTo(ref output, _repeated_requiredDuringSchedulingIgnoredDuringExecution_codec);
      preferredDuringSchedulingIgnoredDuringExecution_.WriteTo(ref output, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += requiredDuringSchedulingIgnoredDuringExecution_.CalculateSize(_repeated_requiredDuringSchedulingIgnoredDuringExecution_codec);
      size += preferredDuringSchedulingIgnoredDuringExecution_.CalculateSize(_repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodAffinity other) {
      if (other == null) {
        return;
      }
      requiredDuringSchedulingIgnoredDuringExecution_.Add(other.requiredDuringSchedulingIgnoredDuringExecution_);
      preferredDuringSchedulingIgnoredDuringExecution_.Add(other.preferredDuringSchedulingIgnoredDuringExecution_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            requiredDuringSchedulingIgnoredDuringExecution_.AddEntriesFrom(input, _repeated_requiredDuringSchedulingIgnoredDuringExecution_codec);
            break;
          }
          case 18: {
            preferredDuringSchedulingIgnoredDuringExecution_.AddEntriesFrom(input, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            requiredDuringSchedulingIgnoredDuringExecution_.AddEntriesFrom(ref input, _repeated_requiredDuringSchedulingIgnoredDuringExecution_codec);
            break;
          }
          case 18: {
            preferredDuringSchedulingIgnoredDuringExecution_.AddEntriesFrom(ref input, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Defines a set of pods (namely those matching the labelSelector
  /// relative to the given namespace(s)) that this pod should be
  /// co-located (affinity) or not co-located (anti-affinity) with,
  /// where co-located is defined as running on a node whose value of
  /// the label with key &lt;topologyKey> matches that of any node on which
  /// a pod of the set of pods is running
  /// </summary>
  public sealed partial class PodAffinityTerm : pb::IMessage<PodAffinityTerm>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodAffinityTerm> _parser = new pb::MessageParser<PodAffinityTerm>(() => new PodAffinityTerm());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodAffinityTerm> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[120]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAffinityTerm() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAffinityTerm(PodAffinityTerm other) : this() {
      labelSelector_ = other.labelSelector_ != null ? other.labelSelector_.Clone() : null;
      namespaces_ = other.namespaces_.Clone();
      topologyKey_ = other.topologyKey_;
      namespaceSelector_ = other.namespaceSelector_ != null ? other.namespaceSelector_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAffinityTerm Clone() {
      return new PodAffinityTerm(this);
    }

    /// <summary>Field number for the "labelSelector" field.</summary>
    public const int LabelSelectorFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector labelSelector_;
    /// <summary>
    /// A label query over a set of resources, in this case pods.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector LabelSelector {
      get { return labelSelector_; }
      set {
        labelSelector_ = value;
      }
    }

    /// <summary>Field number for the "namespaces" field.</summary>
    public const int NamespacesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_namespaces_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> namespaces_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// namespaces specifies a static list of namespace names that the term applies to.
    /// The term is applied to the union of the namespaces listed in this field
    /// and the ones selected by namespaceSelector.
    /// null or empty namespaces list and null namespaceSelector means "this pod's namespace"
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Namespaces {
      get { return namespaces_; }
    }

    /// <summary>Field number for the "topologyKey" field.</summary>
    public const int TopologyKeyFieldNumber = 3;
    private readonly static string TopologyKeyDefaultValue = "";

    private string topologyKey_;
    /// <summary>
    /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
    /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
    /// whose value of the label with key topologyKey matches that of any node on which any of the
    /// selected pods is running.
    /// Empty topologyKey is not allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TopologyKey {
      get { return topologyKey_ ?? TopologyKeyDefaultValue; }
      set {
        topologyKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "topologyKey" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTopologyKey {
      get { return topologyKey_ != null; }
    }
    /// <summary>Clears the value of the "topologyKey" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTopologyKey() {
      topologyKey_ = null;
    }

    /// <summary>Field number for the "namespaceSelector" field.</summary>
    public const int NamespaceSelectorFieldNumber = 4;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector namespaceSelector_;
    /// <summary>
    /// A label query over the set of namespaces that the term applies to.
    /// The term is applied to the union of the namespaces selected by this field
    /// and the ones listed in the namespaces field.
    /// null selector and null or empty namespaces list means "this pod's namespace".
    /// An empty selector ({}) matches all namespaces.
    /// This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector NamespaceSelector {
      get { return namespaceSelector_; }
      set {
        namespaceSelector_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodAffinityTerm);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodAffinityTerm other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LabelSelector, other.LabelSelector)) return false;
      if(!namespaces_.Equals(other.namespaces_)) return false;
      if (TopologyKey != other.TopologyKey) return false;
      if (!object.Equals(NamespaceSelector, other.NamespaceSelector)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (labelSelector_ != null) hash ^= LabelSelector.GetHashCode();
      hash ^= namespaces_.GetHashCode();
      if (HasTopologyKey) hash ^= TopologyKey.GetHashCode();
      if (namespaceSelector_ != null) hash ^= NamespaceSelector.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (labelSelector_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LabelSelector);
      }
      namespaces_.WriteTo(output, _repeated_namespaces_codec);
      if (HasTopologyKey) {
        output.WriteRawTag(26);
        output.WriteString(TopologyKey);
      }
      if (namespaceSelector_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(NamespaceSelector);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (labelSelector_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LabelSelector);
      }
      namespaces_.WriteTo(ref output, _repeated_namespaces_codec);
      if (HasTopologyKey) {
        output.WriteRawTag(26);
        output.WriteString(TopologyKey);
      }
      if (namespaceSelector_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(NamespaceSelector);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (labelSelector_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LabelSelector);
      }
      size += namespaces_.CalculateSize(_repeated_namespaces_codec);
      if (HasTopologyKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TopologyKey);
      }
      if (namespaceSelector_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NamespaceSelector);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodAffinityTerm other) {
      if (other == null) {
        return;
      }
      if (other.labelSelector_ != null) {
        if (labelSelector_ == null) {
          LabelSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
        }
        LabelSelector.MergeFrom(other.LabelSelector);
      }
      namespaces_.Add(other.namespaces_);
      if (other.HasTopologyKey) {
        TopologyKey = other.TopologyKey;
      }
      if (other.namespaceSelector_ != null) {
        if (namespaceSelector_ == null) {
          NamespaceSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
        }
        NamespaceSelector.MergeFrom(other.NamespaceSelector);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (labelSelector_ == null) {
              LabelSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(LabelSelector);
            break;
          }
          case 18: {
            namespaces_.AddEntriesFrom(input, _repeated_namespaces_codec);
            break;
          }
          case 26: {
            TopologyKey = input.ReadString();
            break;
          }
          case 34: {
            if (namespaceSelector_ == null) {
              NamespaceSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(NamespaceSelector);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (labelSelector_ == null) {
              LabelSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(LabelSelector);
            break;
          }
          case 18: {
            namespaces_.AddEntriesFrom(ref input, _repeated_namespaces_codec);
            break;
          }
          case 26: {
            TopologyKey = input.ReadString();
            break;
          }
          case 34: {
            if (namespaceSelector_ == null) {
              NamespaceSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(NamespaceSelector);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
  /// </summary>
  public sealed partial class PodAntiAffinity : pb::IMessage<PodAntiAffinity>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodAntiAffinity> _parser = new pb::MessageParser<PodAntiAffinity>(() => new PodAntiAffinity());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodAntiAffinity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[121]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAntiAffinity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAntiAffinity(PodAntiAffinity other) : this() {
      requiredDuringSchedulingIgnoredDuringExecution_ = other.requiredDuringSchedulingIgnoredDuringExecution_.Clone();
      preferredDuringSchedulingIgnoredDuringExecution_ = other.preferredDuringSchedulingIgnoredDuringExecution_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAntiAffinity Clone() {
      return new PodAntiAffinity(this);
    }

    /// <summary>Field number for the "requiredDuringSchedulingIgnoredDuringExecution" field.</summary>
    public const int RequiredDuringSchedulingIgnoredDuringExecutionFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PodAffinityTerm> _repeated_requiredDuringSchedulingIgnoredDuringExecution_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.PodAffinityTerm.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodAffinityTerm> requiredDuringSchedulingIgnoredDuringExecution_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodAffinityTerm>();
    /// <summary>
    /// If the anti-affinity requirements specified by this field are not met at
    /// scheduling time, the pod will not be scheduled onto the node.
    /// If the anti-affinity requirements specified by this field cease to be met
    /// at some point during pod execution (e.g. due to a pod label update), the
    /// system may or may not try to eventually evict the pod from its node.
    /// When there are multiple elements, the lists of nodes corresponding to each
    /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodAffinityTerm> RequiredDuringSchedulingIgnoredDuringExecution {
      get { return requiredDuringSchedulingIgnoredDuringExecution_; }
    }

    /// <summary>Field number for the "preferredDuringSchedulingIgnoredDuringExecution" field.</summary>
    public const int PreferredDuringSchedulingIgnoredDuringExecutionFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm> _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm> preferredDuringSchedulingIgnoredDuringExecution_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm>();
    /// <summary>
    /// The scheduler will prefer to schedule pods to nodes that satisfy
    /// the anti-affinity expressions specified by this field, but it may choose
    /// a node that violates one or more of the expressions. The node that is
    /// most preferred is the one with the greatest sum of weights, i.e.
    /// for each node that meets all of the scheduling requirements (resource
    /// request, requiredDuringScheduling anti-affinity expressions, etc.),
    /// compute a sum by iterating through the elements of this field and adding
    /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
    /// node(s) with the highest sum are the most preferred.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.WeightedPodAffinityTerm> PreferredDuringSchedulingIgnoredDuringExecution {
      get { return preferredDuringSchedulingIgnoredDuringExecution_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodAntiAffinity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodAntiAffinity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!requiredDuringSchedulingIgnoredDuringExecution_.Equals(other.requiredDuringSchedulingIgnoredDuringExecution_)) return false;
      if(!preferredDuringSchedulingIgnoredDuringExecution_.Equals(other.preferredDuringSchedulingIgnoredDuringExecution_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= requiredDuringSchedulingIgnoredDuringExecution_.GetHashCode();
      hash ^= preferredDuringSchedulingIgnoredDuringExecution_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      requiredDuringSchedulingIgnoredDuringExecution_.WriteTo(output, _repeated_requiredDuringSchedulingIgnoredDuringExecution_codec);
      preferredDuringSchedulingIgnoredDuringExecution_.WriteTo(output, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      requiredDuringSchedulingIgnoredDuringExecution_.WriteTo(ref output, _repeated_requiredDuringSchedulingIgnoredDuringExecution_codec);
      preferredDuringSchedulingIgnoredDuringExecution_.WriteTo(ref output, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += requiredDuringSchedulingIgnoredDuringExecution_.CalculateSize(_repeated_requiredDuringSchedulingIgnoredDuringExecution_codec);
      size += preferredDuringSchedulingIgnoredDuringExecution_.CalculateSize(_repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodAntiAffinity other) {
      if (other == null) {
        return;
      }
      requiredDuringSchedulingIgnoredDuringExecution_.Add(other.requiredDuringSchedulingIgnoredDuringExecution_);
      preferredDuringSchedulingIgnoredDuringExecution_.Add(other.preferredDuringSchedulingIgnoredDuringExecution_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            requiredDuringSchedulingIgnoredDuringExecution_.AddEntriesFrom(input, _repeated_requiredDuringSchedulingIgnoredDuringExecution_codec);
            break;
          }
          case 18: {
            preferredDuringSchedulingIgnoredDuringExecution_.AddEntriesFrom(input, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            requiredDuringSchedulingIgnoredDuringExecution_.AddEntriesFrom(ref input, _repeated_requiredDuringSchedulingIgnoredDuringExecution_codec);
            break;
          }
          case 18: {
            preferredDuringSchedulingIgnoredDuringExecution_.AddEntriesFrom(ref input, _repeated_preferredDuringSchedulingIgnoredDuringExecution_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodAttachOptions is the query options to a Pod's remote attach call.
  /// ---
  /// TODO: merge w/ PodExecOptions below for stdin, stdout, etc
  /// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
  /// </summary>
  public sealed partial class PodAttachOptions : pb::IMessage<PodAttachOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodAttachOptions> _parser = new pb::MessageParser<PodAttachOptions>(() => new PodAttachOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodAttachOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[122]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAttachOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAttachOptions(PodAttachOptions other) : this() {
      _hasBits0 = other._hasBits0;
      stdin_ = other.stdin_;
      stdout_ = other.stdout_;
      stderr_ = other.stderr_;
      tty_ = other.tty_;
      container_ = other.container_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodAttachOptions Clone() {
      return new PodAttachOptions(this);
    }

    /// <summary>Field number for the "stdin" field.</summary>
    public const int StdinFieldNumber = 1;
    private readonly static bool StdinDefaultValue = false;

    private bool stdin_;
    /// <summary>
    /// Stdin if true, redirects the standard input stream of the pod for this call.
    /// Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Stdin {
      get { if ((_hasBits0 & 1) != 0) { return stdin_; } else { return StdinDefaultValue; } }
      set {
        _hasBits0 |= 1;
        stdin_ = value;
      }
    }
    /// <summary>Gets whether the "stdin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStdin {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "stdin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStdin() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "stdout" field.</summary>
    public const int StdoutFieldNumber = 2;
    private readonly static bool StdoutDefaultValue = false;

    private bool stdout_;
    /// <summary>
    /// Stdout if true indicates that stdout is to be redirected for the attach call.
    /// Defaults to true.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Stdout {
      get { if ((_hasBits0 & 2) != 0) { return stdout_; } else { return StdoutDefaultValue; } }
      set {
        _hasBits0 |= 2;
        stdout_ = value;
      }
    }
    /// <summary>Gets whether the "stdout" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStdout {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "stdout" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStdout() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "stderr" field.</summary>
    public const int StderrFieldNumber = 3;
    private readonly static bool StderrDefaultValue = false;

    private bool stderr_;
    /// <summary>
    /// Stderr if true indicates that stderr is to be redirected for the attach call.
    /// Defaults to true.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Stderr {
      get { if ((_hasBits0 & 4) != 0) { return stderr_; } else { return StderrDefaultValue; } }
      set {
        _hasBits0 |= 4;
        stderr_ = value;
      }
    }
    /// <summary>Gets whether the "stderr" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStderr {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "stderr" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStderr() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "tty" field.</summary>
    public const int TtyFieldNumber = 4;
    private readonly static bool TtyDefaultValue = false;

    private bool tty_;
    /// <summary>
    /// TTY if true indicates that a tty will be allocated for the attach call.
    /// This is passed through the container runtime so the tty
    /// is allocated on the worker node by the container runtime.
    /// Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Tty {
      get { if ((_hasBits0 & 8) != 0) { return tty_; } else { return TtyDefaultValue; } }
      set {
        _hasBits0 |= 8;
        tty_ = value;
      }
    }
    /// <summary>Gets whether the "tty" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTty {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "tty" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTty() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "container" field.</summary>
    public const int ContainerFieldNumber = 5;
    private readonly static string ContainerDefaultValue = "";

    private string container_;
    /// <summary>
    /// The container in which to execute the command.
    /// Defaults to only container if there is only one container in the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Container {
      get { return container_ ?? ContainerDefaultValue; }
      set {
        container_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "container" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContainer {
      get { return container_ != null; }
    }
    /// <summary>Clears the value of the "container" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContainer() {
      container_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodAttachOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodAttachOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Stdin != other.Stdin) return false;
      if (Stdout != other.Stdout) return false;
      if (Stderr != other.Stderr) return false;
      if (Tty != other.Tty) return false;
      if (Container != other.Container) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasStdin) hash ^= Stdin.GetHashCode();
      if (HasStdout) hash ^= Stdout.GetHashCode();
      if (HasStderr) hash ^= Stderr.GetHashCode();
      if (HasTty) hash ^= Tty.GetHashCode();
      if (HasContainer) hash ^= Container.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasStdin) {
        output.WriteRawTag(8);
        output.WriteBool(Stdin);
      }
      if (HasStdout) {
        output.WriteRawTag(16);
        output.WriteBool(Stdout);
      }
      if (HasStderr) {
        output.WriteRawTag(24);
        output.WriteBool(Stderr);
      }
      if (HasTty) {
        output.WriteRawTag(32);
        output.WriteBool(Tty);
      }
      if (HasContainer) {
        output.WriteRawTag(42);
        output.WriteString(Container);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasStdin) {
        output.WriteRawTag(8);
        output.WriteBool(Stdin);
      }
      if (HasStdout) {
        output.WriteRawTag(16);
        output.WriteBool(Stdout);
      }
      if (HasStderr) {
        output.WriteRawTag(24);
        output.WriteBool(Stderr);
      }
      if (HasTty) {
        output.WriteRawTag(32);
        output.WriteBool(Tty);
      }
      if (HasContainer) {
        output.WriteRawTag(42);
        output.WriteString(Container);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasStdin) {
        size += 1 + 1;
      }
      if (HasStdout) {
        size += 1 + 1;
      }
      if (HasStderr) {
        size += 1 + 1;
      }
      if (HasTty) {
        size += 1 + 1;
      }
      if (HasContainer) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Container);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodAttachOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasStdin) {
        Stdin = other.Stdin;
      }
      if (other.HasStdout) {
        Stdout = other.Stdout;
      }
      if (other.HasStderr) {
        Stderr = other.Stderr;
      }
      if (other.HasTty) {
        Tty = other.Tty;
      }
      if (other.HasContainer) {
        Container = other.Container;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Stdin = input.ReadBool();
            break;
          }
          case 16: {
            Stdout = input.ReadBool();
            break;
          }
          case 24: {
            Stderr = input.ReadBool();
            break;
          }
          case 32: {
            Tty = input.ReadBool();
            break;
          }
          case 42: {
            Container = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Stdin = input.ReadBool();
            break;
          }
          case 16: {
            Stdout = input.ReadBool();
            break;
          }
          case 24: {
            Stderr = input.ReadBool();
            break;
          }
          case 32: {
            Tty = input.ReadBool();
            break;
          }
          case 42: {
            Container = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodCondition contains details for the current condition of this pod.
  /// </summary>
  public sealed partial class PodCondition : pb::IMessage<PodCondition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodCondition> _parser = new pb::MessageParser<PodCondition>(() => new PodCondition());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodCondition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[123]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodCondition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodCondition(PodCondition other) : this() {
      type_ = other.type_;
      status_ = other.status_;
      lastProbeTime_ = other.lastProbeTime_ != null ? other.lastProbeTime_.Clone() : null;
      lastTransitionTime_ = other.lastTransitionTime_ != null ? other.lastTransitionTime_.Clone() : null;
      reason_ = other.reason_;
      message_ = other.message_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodCondition Clone() {
      return new PodCondition(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Type is the type of the condition.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 2;
    private readonly static string StatusDefaultValue = "";

    private string status_;
    /// <summary>
    /// Status is the status of the condition.
    /// Can be True, False, Unknown.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Status {
      get { return status_ ?? StatusDefaultValue; }
      set {
        status_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStatus {
      get { return status_ != null; }
    }
    /// <summary>Clears the value of the "status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStatus() {
      status_ = null;
    }

    /// <summary>Field number for the "lastProbeTime" field.</summary>
    public const int LastProbeTimeFieldNumber = 3;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time lastProbeTime_;
    /// <summary>
    /// Last time we probed the condition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time LastProbeTime {
      get { return lastProbeTime_; }
      set {
        lastProbeTime_ = value;
      }
    }

    /// <summary>Field number for the "lastTransitionTime" field.</summary>
    public const int LastTransitionTimeFieldNumber = 4;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time lastTransitionTime_;
    /// <summary>
    /// Last time the condition transitioned from one status to another.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time LastTransitionTime {
      get { return lastTransitionTime_; }
      set {
        lastTransitionTime_ = value;
      }
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 5;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// Unique, one-word, CamelCase reason for the condition's last transition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 6;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// Human-readable message indicating details about last transition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodCondition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodCondition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Status != other.Status) return false;
      if (!object.Equals(LastProbeTime, other.LastProbeTime)) return false;
      if (!object.Equals(LastTransitionTime, other.LastTransitionTime)) return false;
      if (Reason != other.Reason) return false;
      if (Message != other.Message) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasStatus) hash ^= Status.GetHashCode();
      if (lastProbeTime_ != null) hash ^= LastProbeTime.GetHashCode();
      if (lastTransitionTime_ != null) hash ^= LastTransitionTime.GetHashCode();
      if (HasReason) hash ^= Reason.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (lastProbeTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastProbeTime);
      }
      if (lastTransitionTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LastTransitionTime);
      }
      if (HasReason) {
        output.WriteRawTag(42);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(50);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (lastProbeTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastProbeTime);
      }
      if (lastTransitionTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LastTransitionTime);
      }
      if (HasReason) {
        output.WriteRawTag(42);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(50);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasStatus) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Status);
      }
      if (lastProbeTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastProbeTime);
      }
      if (lastTransitionTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastTransitionTime);
      }
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodCondition other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasStatus) {
        Status = other.Status;
      }
      if (other.lastProbeTime_ != null) {
        if (lastProbeTime_ == null) {
          LastProbeTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        LastProbeTime.MergeFrom(other.LastProbeTime);
      }
      if (other.lastTransitionTime_ != null) {
        if (lastTransitionTime_ == null) {
          LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        LastTransitionTime.MergeFrom(other.LastTransitionTime);
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 26: {
            if (lastProbeTime_ == null) {
              LastProbeTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastProbeTime);
            break;
          }
          case 34: {
            if (lastTransitionTime_ == null) {
              LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTransitionTime);
            break;
          }
          case 42: {
            Reason = input.ReadString();
            break;
          }
          case 50: {
            Message = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 26: {
            if (lastProbeTime_ == null) {
              LastProbeTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastProbeTime);
            break;
          }
          case 34: {
            if (lastTransitionTime_ == null) {
              LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTransitionTime);
            break;
          }
          case 42: {
            Reason = input.ReadString();
            break;
          }
          case 50: {
            Message = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodDNSConfig defines the DNS parameters of a pod in addition to
  /// those generated from DNSPolicy.
  /// </summary>
  public sealed partial class PodDNSConfig : pb::IMessage<PodDNSConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodDNSConfig> _parser = new pb::MessageParser<PodDNSConfig>(() => new PodDNSConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodDNSConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[124]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodDNSConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodDNSConfig(PodDNSConfig other) : this() {
      nameservers_ = other.nameservers_.Clone();
      searches_ = other.searches_.Clone();
      options_ = other.options_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodDNSConfig Clone() {
      return new PodDNSConfig(this);
    }

    /// <summary>Field number for the "nameservers" field.</summary>
    public const int NameserversFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_nameservers_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> nameservers_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A list of DNS name server IP addresses.
    /// This will be appended to the base nameservers generated from DNSPolicy.
    /// Duplicated nameservers will be removed.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Nameservers {
      get { return nameservers_; }
    }

    /// <summary>Field number for the "searches" field.</summary>
    public const int SearchesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_searches_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> searches_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A list of DNS search domains for host-name lookup.
    /// This will be appended to the base search paths generated from DNSPolicy.
    /// Duplicated search paths will be removed.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Searches {
      get { return searches_; }
    }

    /// <summary>Field number for the "options" field.</summary>
    public const int OptionsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PodDNSConfigOption> _repeated_options_codec
        = pb::FieldCodec.ForMessage(26, global::K8S.Io.Api.Core.V1.PodDNSConfigOption.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodDNSConfigOption> options_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodDNSConfigOption>();
    /// <summary>
    /// A list of DNS resolver options.
    /// This will be merged with the base options generated from DNSPolicy.
    /// Duplicated entries will be removed. Resolution options given in Options
    /// will override those that appear in the base DNSPolicy.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodDNSConfigOption> Options {
      get { return options_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodDNSConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodDNSConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!nameservers_.Equals(other.nameservers_)) return false;
      if(!searches_.Equals(other.searches_)) return false;
      if(!options_.Equals(other.options_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= nameservers_.GetHashCode();
      hash ^= searches_.GetHashCode();
      hash ^= options_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      nameservers_.WriteTo(output, _repeated_nameservers_codec);
      searches_.WriteTo(output, _repeated_searches_codec);
      options_.WriteTo(output, _repeated_options_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      nameservers_.WriteTo(ref output, _repeated_nameservers_codec);
      searches_.WriteTo(ref output, _repeated_searches_codec);
      options_.WriteTo(ref output, _repeated_options_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += nameservers_.CalculateSize(_repeated_nameservers_codec);
      size += searches_.CalculateSize(_repeated_searches_codec);
      size += options_.CalculateSize(_repeated_options_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodDNSConfig other) {
      if (other == null) {
        return;
      }
      nameservers_.Add(other.nameservers_);
      searches_.Add(other.searches_);
      options_.Add(other.options_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            nameservers_.AddEntriesFrom(input, _repeated_nameservers_codec);
            break;
          }
          case 18: {
            searches_.AddEntriesFrom(input, _repeated_searches_codec);
            break;
          }
          case 26: {
            options_.AddEntriesFrom(input, _repeated_options_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            nameservers_.AddEntriesFrom(ref input, _repeated_nameservers_codec);
            break;
          }
          case 18: {
            searches_.AddEntriesFrom(ref input, _repeated_searches_codec);
            break;
          }
          case 26: {
            options_.AddEntriesFrom(ref input, _repeated_options_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodDNSConfigOption defines DNS resolver options of a pod.
  /// </summary>
  public sealed partial class PodDNSConfigOption : pb::IMessage<PodDNSConfigOption>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodDNSConfigOption> _parser = new pb::MessageParser<PodDNSConfigOption>(() => new PodDNSConfigOption());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodDNSConfigOption> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[125]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodDNSConfigOption() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodDNSConfigOption(PodDNSConfigOption other) : this() {
      name_ = other.name_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodDNSConfigOption Clone() {
      return new PodDNSConfigOption(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    /// <summary>
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodDNSConfigOption);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodDNSConfigOption other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodDNSConfigOption other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodExecOptions is the query options to a Pod's remote exec call.
  /// ---
  /// TODO: This is largely identical to PodAttachOptions above, make sure they stay in sync and see about merging
  /// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
  /// </summary>
  public sealed partial class PodExecOptions : pb::IMessage<PodExecOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodExecOptions> _parser = new pb::MessageParser<PodExecOptions>(() => new PodExecOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodExecOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[126]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodExecOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodExecOptions(PodExecOptions other) : this() {
      _hasBits0 = other._hasBits0;
      stdin_ = other.stdin_;
      stdout_ = other.stdout_;
      stderr_ = other.stderr_;
      tty_ = other.tty_;
      container_ = other.container_;
      command_ = other.command_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodExecOptions Clone() {
      return new PodExecOptions(this);
    }

    /// <summary>Field number for the "stdin" field.</summary>
    public const int StdinFieldNumber = 1;
    private readonly static bool StdinDefaultValue = false;

    private bool stdin_;
    /// <summary>
    /// Redirect the standard input stream of the pod for this call.
    /// Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Stdin {
      get { if ((_hasBits0 & 1) != 0) { return stdin_; } else { return StdinDefaultValue; } }
      set {
        _hasBits0 |= 1;
        stdin_ = value;
      }
    }
    /// <summary>Gets whether the "stdin" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStdin {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "stdin" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStdin() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "stdout" field.</summary>
    public const int StdoutFieldNumber = 2;
    private readonly static bool StdoutDefaultValue = false;

    private bool stdout_;
    /// <summary>
    /// Redirect the standard output stream of the pod for this call.
    /// Defaults to true.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Stdout {
      get { if ((_hasBits0 & 2) != 0) { return stdout_; } else { return StdoutDefaultValue; } }
      set {
        _hasBits0 |= 2;
        stdout_ = value;
      }
    }
    /// <summary>Gets whether the "stdout" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStdout {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "stdout" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStdout() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "stderr" field.</summary>
    public const int StderrFieldNumber = 3;
    private readonly static bool StderrDefaultValue = false;

    private bool stderr_;
    /// <summary>
    /// Redirect the standard error stream of the pod for this call.
    /// Defaults to true.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Stderr {
      get { if ((_hasBits0 & 4) != 0) { return stderr_; } else { return StderrDefaultValue; } }
      set {
        _hasBits0 |= 4;
        stderr_ = value;
      }
    }
    /// <summary>Gets whether the "stderr" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStderr {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "stderr" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStderr() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "tty" field.</summary>
    public const int TtyFieldNumber = 4;
    private readonly static bool TtyDefaultValue = false;

    private bool tty_;
    /// <summary>
    /// TTY if true indicates that a tty will be allocated for the exec call.
    /// Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Tty {
      get { if ((_hasBits0 & 8) != 0) { return tty_; } else { return TtyDefaultValue; } }
      set {
        _hasBits0 |= 8;
        tty_ = value;
      }
    }
    /// <summary>Gets whether the "tty" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTty {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "tty" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTty() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "container" field.</summary>
    public const int ContainerFieldNumber = 5;
    private readonly static string ContainerDefaultValue = "";

    private string container_;
    /// <summary>
    /// Container in which to execute the command.
    /// Defaults to only container if there is only one container in the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Container {
      get { return container_ ?? ContainerDefaultValue; }
      set {
        container_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "container" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContainer {
      get { return container_ != null; }
    }
    /// <summary>Clears the value of the "container" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContainer() {
      container_ = null;
    }

    /// <summary>Field number for the "command" field.</summary>
    public const int CommandFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_command_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> command_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Command is the remote command to execute. argv array. Not executed within a shell.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Command {
      get { return command_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodExecOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodExecOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Stdin != other.Stdin) return false;
      if (Stdout != other.Stdout) return false;
      if (Stderr != other.Stderr) return false;
      if (Tty != other.Tty) return false;
      if (Container != other.Container) return false;
      if(!command_.Equals(other.command_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasStdin) hash ^= Stdin.GetHashCode();
      if (HasStdout) hash ^= Stdout.GetHashCode();
      if (HasStderr) hash ^= Stderr.GetHashCode();
      if (HasTty) hash ^= Tty.GetHashCode();
      if (HasContainer) hash ^= Container.GetHashCode();
      hash ^= command_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasStdin) {
        output.WriteRawTag(8);
        output.WriteBool(Stdin);
      }
      if (HasStdout) {
        output.WriteRawTag(16);
        output.WriteBool(Stdout);
      }
      if (HasStderr) {
        output.WriteRawTag(24);
        output.WriteBool(Stderr);
      }
      if (HasTty) {
        output.WriteRawTag(32);
        output.WriteBool(Tty);
      }
      if (HasContainer) {
        output.WriteRawTag(42);
        output.WriteString(Container);
      }
      command_.WriteTo(output, _repeated_command_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasStdin) {
        output.WriteRawTag(8);
        output.WriteBool(Stdin);
      }
      if (HasStdout) {
        output.WriteRawTag(16);
        output.WriteBool(Stdout);
      }
      if (HasStderr) {
        output.WriteRawTag(24);
        output.WriteBool(Stderr);
      }
      if (HasTty) {
        output.WriteRawTag(32);
        output.WriteBool(Tty);
      }
      if (HasContainer) {
        output.WriteRawTag(42);
        output.WriteString(Container);
      }
      command_.WriteTo(ref output, _repeated_command_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasStdin) {
        size += 1 + 1;
      }
      if (HasStdout) {
        size += 1 + 1;
      }
      if (HasStderr) {
        size += 1 + 1;
      }
      if (HasTty) {
        size += 1 + 1;
      }
      if (HasContainer) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Container);
      }
      size += command_.CalculateSize(_repeated_command_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodExecOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasStdin) {
        Stdin = other.Stdin;
      }
      if (other.HasStdout) {
        Stdout = other.Stdout;
      }
      if (other.HasStderr) {
        Stderr = other.Stderr;
      }
      if (other.HasTty) {
        Tty = other.Tty;
      }
      if (other.HasContainer) {
        Container = other.Container;
      }
      command_.Add(other.command_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Stdin = input.ReadBool();
            break;
          }
          case 16: {
            Stdout = input.ReadBool();
            break;
          }
          case 24: {
            Stderr = input.ReadBool();
            break;
          }
          case 32: {
            Tty = input.ReadBool();
            break;
          }
          case 42: {
            Container = input.ReadString();
            break;
          }
          case 50: {
            command_.AddEntriesFrom(input, _repeated_command_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Stdin = input.ReadBool();
            break;
          }
          case 16: {
            Stdout = input.ReadBool();
            break;
          }
          case 24: {
            Stderr = input.ReadBool();
            break;
          }
          case 32: {
            Tty = input.ReadBool();
            break;
          }
          case 42: {
            Container = input.ReadString();
            break;
          }
          case 50: {
            command_.AddEntriesFrom(ref input, _repeated_command_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IP address information for entries in the (plural) PodIPs field.
  /// Each entry includes:
  ///    IP: An IP address allocated to the pod. Routable at least within the cluster.
  /// </summary>
  public sealed partial class PodIP : pb::IMessage<PodIP>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodIP> _parser = new pb::MessageParser<PodIP>(() => new PodIP());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodIP> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[127]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodIP() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodIP(PodIP other) : this() {
      ip_ = other.ip_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodIP Clone() {
      return new PodIP(this);
    }

    /// <summary>Field number for the "ip" field.</summary>
    public const int IpFieldNumber = 1;
    private readonly static string IpDefaultValue = "";

    private string ip_;
    /// <summary>
    /// ip is an IP address (IPv4 or IPv6) assigned to the pod
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Ip {
      get { return ip_ ?? IpDefaultValue; }
      set {
        ip_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ip" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIp {
      get { return ip_ != null; }
    }
    /// <summary>Clears the value of the "ip" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIp() {
      ip_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodIP);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodIP other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Ip != other.Ip) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasIp) hash ^= Ip.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasIp) {
        output.WriteRawTag(10);
        output.WriteString(Ip);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasIp) {
        output.WriteRawTag(10);
        output.WriteString(Ip);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasIp) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Ip);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodIP other) {
      if (other == null) {
        return;
      }
      if (other.HasIp) {
        Ip = other.Ip;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Ip = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Ip = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodList is a list of Pods.
  /// </summary>
  public sealed partial class PodList : pb::IMessage<PodList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodList> _parser = new pb::MessageParser<PodList>(() => new PodList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[128]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodList(PodList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodList Clone() {
      return new PodList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Pod> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.Pod.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Pod> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Pod>();
    /// <summary>
    /// List of pods.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Pod> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodLogOptions is the query options for a Pod's logs REST call.
  /// </summary>
  public sealed partial class PodLogOptions : pb::IMessage<PodLogOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodLogOptions> _parser = new pb::MessageParser<PodLogOptions>(() => new PodLogOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodLogOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[129]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodLogOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodLogOptions(PodLogOptions other) : this() {
      _hasBits0 = other._hasBits0;
      container_ = other.container_;
      follow_ = other.follow_;
      previous_ = other.previous_;
      sinceSeconds_ = other.sinceSeconds_;
      sinceTime_ = other.sinceTime_ != null ? other.sinceTime_.Clone() : null;
      timestamps_ = other.timestamps_;
      tailLines_ = other.tailLines_;
      limitBytes_ = other.limitBytes_;
      insecureSkipTLSVerifyBackend_ = other.insecureSkipTLSVerifyBackend_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodLogOptions Clone() {
      return new PodLogOptions(this);
    }

    /// <summary>Field number for the "container" field.</summary>
    public const int ContainerFieldNumber = 1;
    private readonly static string ContainerDefaultValue = "";

    private string container_;
    /// <summary>
    /// The container for which to stream logs. Defaults to only container if there is one container in the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Container {
      get { return container_ ?? ContainerDefaultValue; }
      set {
        container_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "container" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContainer {
      get { return container_ != null; }
    }
    /// <summary>Clears the value of the "container" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContainer() {
      container_ = null;
    }

    /// <summary>Field number for the "follow" field.</summary>
    public const int FollowFieldNumber = 2;
    private readonly static bool FollowDefaultValue = false;

    private bool follow_;
    /// <summary>
    /// Follow the log stream of the pod. Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Follow {
      get { if ((_hasBits0 & 1) != 0) { return follow_; } else { return FollowDefaultValue; } }
      set {
        _hasBits0 |= 1;
        follow_ = value;
      }
    }
    /// <summary>Gets whether the "follow" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFollow {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "follow" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFollow() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "previous" field.</summary>
    public const int PreviousFieldNumber = 3;
    private readonly static bool PreviousDefaultValue = false;

    private bool previous_;
    /// <summary>
    /// Return previous terminated container logs. Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Previous {
      get { if ((_hasBits0 & 2) != 0) { return previous_; } else { return PreviousDefaultValue; } }
      set {
        _hasBits0 |= 2;
        previous_ = value;
      }
    }
    /// <summary>Gets whether the "previous" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPrevious {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "previous" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPrevious() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "sinceSeconds" field.</summary>
    public const int SinceSecondsFieldNumber = 4;
    private readonly static long SinceSecondsDefaultValue = 0L;

    private long sinceSeconds_;
    /// <summary>
    /// A relative time in seconds before the current time from which to show logs. If this value
    /// precedes the time a pod was started, only logs since the pod start will be returned.
    /// If this value is in the future, no logs will be returned.
    /// Only one of sinceSeconds or sinceTime may be specified.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long SinceSeconds {
      get { if ((_hasBits0 & 4) != 0) { return sinceSeconds_; } else { return SinceSecondsDefaultValue; } }
      set {
        _hasBits0 |= 4;
        sinceSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "sinceSeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSinceSeconds {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "sinceSeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSinceSeconds() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "sinceTime" field.</summary>
    public const int SinceTimeFieldNumber = 5;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time sinceTime_;
    /// <summary>
    /// An RFC3339 timestamp from which to show logs. If this value
    /// precedes the time a pod was started, only logs since the pod start will be returned.
    /// If this value is in the future, no logs will be returned.
    /// Only one of sinceSeconds or sinceTime may be specified.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time SinceTime {
      get { return sinceTime_; }
      set {
        sinceTime_ = value;
      }
    }

    /// <summary>Field number for the "timestamps" field.</summary>
    public const int TimestampsFieldNumber = 6;
    private readonly static bool TimestampsDefaultValue = false;

    private bool timestamps_;
    /// <summary>
    /// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
    /// of log output. Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Timestamps {
      get { if ((_hasBits0 & 8) != 0) { return timestamps_; } else { return TimestampsDefaultValue; } }
      set {
        _hasBits0 |= 8;
        timestamps_ = value;
      }
    }
    /// <summary>Gets whether the "timestamps" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTimestamps {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "timestamps" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTimestamps() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "tailLines" field.</summary>
    public const int TailLinesFieldNumber = 7;
    private readonly static long TailLinesDefaultValue = 0L;

    private long tailLines_;
    /// <summary>
    /// If set, the number of lines from the end of the logs to show. If not specified,
    /// logs are shown from the creation of the container or sinceSeconds or sinceTime
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TailLines {
      get { if ((_hasBits0 & 16) != 0) { return tailLines_; } else { return TailLinesDefaultValue; } }
      set {
        _hasBits0 |= 16;
        tailLines_ = value;
      }
    }
    /// <summary>Gets whether the "tailLines" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTailLines {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "tailLines" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTailLines() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "limitBytes" field.</summary>
    public const int LimitBytesFieldNumber = 8;
    private readonly static long LimitBytesDefaultValue = 0L;

    private long limitBytes_;
    /// <summary>
    /// If set, the number of bytes to read from the server before terminating the
    /// log output. This may not display a complete final line of logging, and may return
    /// slightly more or slightly less than the specified limit.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long LimitBytes {
      get { if ((_hasBits0 & 32) != 0) { return limitBytes_; } else { return LimitBytesDefaultValue; } }
      set {
        _hasBits0 |= 32;
        limitBytes_ = value;
      }
    }
    /// <summary>Gets whether the "limitBytes" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLimitBytes {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "limitBytes" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLimitBytes() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "insecureSkipTLSVerifyBackend" field.</summary>
    public const int InsecureSkipTLSVerifyBackendFieldNumber = 9;
    private readonly static bool InsecureSkipTLSVerifyBackendDefaultValue = false;

    private bool insecureSkipTLSVerifyBackend_;
    /// <summary>
    /// insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
    /// serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
    /// and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
    /// kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
    /// connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
    /// the actual log data coming from the real kubelet).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool InsecureSkipTLSVerifyBackend {
      get { if ((_hasBits0 & 64) != 0) { return insecureSkipTLSVerifyBackend_; } else { return InsecureSkipTLSVerifyBackendDefaultValue; } }
      set {
        _hasBits0 |= 64;
        insecureSkipTLSVerifyBackend_ = value;
      }
    }
    /// <summary>Gets whether the "insecureSkipTLSVerifyBackend" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInsecureSkipTLSVerifyBackend {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "insecureSkipTLSVerifyBackend" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInsecureSkipTLSVerifyBackend() {
      _hasBits0 &= ~64;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodLogOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodLogOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Container != other.Container) return false;
      if (Follow != other.Follow) return false;
      if (Previous != other.Previous) return false;
      if (SinceSeconds != other.SinceSeconds) return false;
      if (!object.Equals(SinceTime, other.SinceTime)) return false;
      if (Timestamps != other.Timestamps) return false;
      if (TailLines != other.TailLines) return false;
      if (LimitBytes != other.LimitBytes) return false;
      if (InsecureSkipTLSVerifyBackend != other.InsecureSkipTLSVerifyBackend) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasContainer) hash ^= Container.GetHashCode();
      if (HasFollow) hash ^= Follow.GetHashCode();
      if (HasPrevious) hash ^= Previous.GetHashCode();
      if (HasSinceSeconds) hash ^= SinceSeconds.GetHashCode();
      if (sinceTime_ != null) hash ^= SinceTime.GetHashCode();
      if (HasTimestamps) hash ^= Timestamps.GetHashCode();
      if (HasTailLines) hash ^= TailLines.GetHashCode();
      if (HasLimitBytes) hash ^= LimitBytes.GetHashCode();
      if (HasInsecureSkipTLSVerifyBackend) hash ^= InsecureSkipTLSVerifyBackend.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasContainer) {
        output.WriteRawTag(10);
        output.WriteString(Container);
      }
      if (HasFollow) {
        output.WriteRawTag(16);
        output.WriteBool(Follow);
      }
      if (HasPrevious) {
        output.WriteRawTag(24);
        output.WriteBool(Previous);
      }
      if (HasSinceSeconds) {
        output.WriteRawTag(32);
        output.WriteInt64(SinceSeconds);
      }
      if (sinceTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SinceTime);
      }
      if (HasTimestamps) {
        output.WriteRawTag(48);
        output.WriteBool(Timestamps);
      }
      if (HasTailLines) {
        output.WriteRawTag(56);
        output.WriteInt64(TailLines);
      }
      if (HasLimitBytes) {
        output.WriteRawTag(64);
        output.WriteInt64(LimitBytes);
      }
      if (HasInsecureSkipTLSVerifyBackend) {
        output.WriteRawTag(72);
        output.WriteBool(InsecureSkipTLSVerifyBackend);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasContainer) {
        output.WriteRawTag(10);
        output.WriteString(Container);
      }
      if (HasFollow) {
        output.WriteRawTag(16);
        output.WriteBool(Follow);
      }
      if (HasPrevious) {
        output.WriteRawTag(24);
        output.WriteBool(Previous);
      }
      if (HasSinceSeconds) {
        output.WriteRawTag(32);
        output.WriteInt64(SinceSeconds);
      }
      if (sinceTime_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SinceTime);
      }
      if (HasTimestamps) {
        output.WriteRawTag(48);
        output.WriteBool(Timestamps);
      }
      if (HasTailLines) {
        output.WriteRawTag(56);
        output.WriteInt64(TailLines);
      }
      if (HasLimitBytes) {
        output.WriteRawTag(64);
        output.WriteInt64(LimitBytes);
      }
      if (HasInsecureSkipTLSVerifyBackend) {
        output.WriteRawTag(72);
        output.WriteBool(InsecureSkipTLSVerifyBackend);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasContainer) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Container);
      }
      if (HasFollow) {
        size += 1 + 1;
      }
      if (HasPrevious) {
        size += 1 + 1;
      }
      if (HasSinceSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(SinceSeconds);
      }
      if (sinceTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SinceTime);
      }
      if (HasTimestamps) {
        size += 1 + 1;
      }
      if (HasTailLines) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TailLines);
      }
      if (HasLimitBytes) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LimitBytes);
      }
      if (HasInsecureSkipTLSVerifyBackend) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodLogOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasContainer) {
        Container = other.Container;
      }
      if (other.HasFollow) {
        Follow = other.Follow;
      }
      if (other.HasPrevious) {
        Previous = other.Previous;
      }
      if (other.HasSinceSeconds) {
        SinceSeconds = other.SinceSeconds;
      }
      if (other.sinceTime_ != null) {
        if (sinceTime_ == null) {
          SinceTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        SinceTime.MergeFrom(other.SinceTime);
      }
      if (other.HasTimestamps) {
        Timestamps = other.Timestamps;
      }
      if (other.HasTailLines) {
        TailLines = other.TailLines;
      }
      if (other.HasLimitBytes) {
        LimitBytes = other.LimitBytes;
      }
      if (other.HasInsecureSkipTLSVerifyBackend) {
        InsecureSkipTLSVerifyBackend = other.InsecureSkipTLSVerifyBackend;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Container = input.ReadString();
            break;
          }
          case 16: {
            Follow = input.ReadBool();
            break;
          }
          case 24: {
            Previous = input.ReadBool();
            break;
          }
          case 32: {
            SinceSeconds = input.ReadInt64();
            break;
          }
          case 42: {
            if (sinceTime_ == null) {
              SinceTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(SinceTime);
            break;
          }
          case 48: {
            Timestamps = input.ReadBool();
            break;
          }
          case 56: {
            TailLines = input.ReadInt64();
            break;
          }
          case 64: {
            LimitBytes = input.ReadInt64();
            break;
          }
          case 72: {
            InsecureSkipTLSVerifyBackend = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Container = input.ReadString();
            break;
          }
          case 16: {
            Follow = input.ReadBool();
            break;
          }
          case 24: {
            Previous = input.ReadBool();
            break;
          }
          case 32: {
            SinceSeconds = input.ReadInt64();
            break;
          }
          case 42: {
            if (sinceTime_ == null) {
              SinceTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(SinceTime);
            break;
          }
          case 48: {
            Timestamps = input.ReadBool();
            break;
          }
          case 56: {
            TailLines = input.ReadInt64();
            break;
          }
          case 64: {
            LimitBytes = input.ReadInt64();
            break;
          }
          case 72: {
            InsecureSkipTLSVerifyBackend = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodPortForwardOptions is the query options to a Pod's port forward call
  /// when using WebSockets.
  /// The `port` query parameter must specify the port or
  /// ports (comma separated) to forward over.
  /// Port forwarding over SPDY does not use these options. It requires the port
  /// to be passed in the `port` header as part of request.
  /// </summary>
  public sealed partial class PodPortForwardOptions : pb::IMessage<PodPortForwardOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodPortForwardOptions> _parser = new pb::MessageParser<PodPortForwardOptions>(() => new PodPortForwardOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodPortForwardOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[130]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodPortForwardOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodPortForwardOptions(PodPortForwardOptions other) : this() {
      ports_ = other.ports_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodPortForwardOptions Clone() {
      return new PodPortForwardOptions(this);
    }

    /// <summary>Field number for the "ports" field.</summary>
    public const int PortsFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_ports_codec
        = pb::FieldCodec.ForInt32(8);
    private readonly pbc::RepeatedField<int> ports_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// List of ports to forward
    /// Required when using WebSockets
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> Ports {
      get { return ports_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodPortForwardOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodPortForwardOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!ports_.Equals(other.ports_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= ports_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      ports_.WriteTo(output, _repeated_ports_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      ports_.WriteTo(ref output, _repeated_ports_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += ports_.CalculateSize(_repeated_ports_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodPortForwardOptions other) {
      if (other == null) {
        return;
      }
      ports_.Add(other.ports_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            ports_.AddEntriesFrom(input, _repeated_ports_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            ports_.AddEntriesFrom(ref input, _repeated_ports_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodProxyOptions is the query options to a Pod's proxy call.
  /// </summary>
  public sealed partial class PodProxyOptions : pb::IMessage<PodProxyOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodProxyOptions> _parser = new pb::MessageParser<PodProxyOptions>(() => new PodProxyOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodProxyOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[131]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodProxyOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodProxyOptions(PodProxyOptions other) : this() {
      path_ = other.path_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodProxyOptions Clone() {
      return new PodProxyOptions(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Path is the URL path to use for the current proxy request to pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodProxyOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodProxyOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPath) hash ^= Path.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodProxyOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodReadinessGate contains the reference to a pod condition
  /// </summary>
  public sealed partial class PodReadinessGate : pb::IMessage<PodReadinessGate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodReadinessGate> _parser = new pb::MessageParser<PodReadinessGate>(() => new PodReadinessGate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodReadinessGate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[132]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodReadinessGate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodReadinessGate(PodReadinessGate other) : this() {
      conditionType_ = other.conditionType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodReadinessGate Clone() {
      return new PodReadinessGate(this);
    }

    /// <summary>Field number for the "conditionType" field.</summary>
    public const int ConditionTypeFieldNumber = 1;
    private readonly static string ConditionTypeDefaultValue = "";

    private string conditionType_;
    /// <summary>
    /// ConditionType refers to a condition in the pod's condition list with matching type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ConditionType {
      get { return conditionType_ ?? ConditionTypeDefaultValue; }
      set {
        conditionType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "conditionType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasConditionType {
      get { return conditionType_ != null; }
    }
    /// <summary>Clears the value of the "conditionType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearConditionType() {
      conditionType_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodReadinessGate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodReadinessGate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ConditionType != other.ConditionType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasConditionType) hash ^= ConditionType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasConditionType) {
        output.WriteRawTag(10);
        output.WriteString(ConditionType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasConditionType) {
        output.WriteRawTag(10);
        output.WriteString(ConditionType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasConditionType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ConditionType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodReadinessGate other) {
      if (other == null) {
        return;
      }
      if (other.HasConditionType) {
        ConditionType = other.ConditionType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ConditionType = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ConditionType = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodSecurityContext holds pod-level security attributes and common container settings.
  /// Some fields are also present in container.securityContext.  Field values of
  /// container.securityContext take precedence over field values of PodSecurityContext.
  /// </summary>
  public sealed partial class PodSecurityContext : pb::IMessage<PodSecurityContext>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodSecurityContext> _parser = new pb::MessageParser<PodSecurityContext>(() => new PodSecurityContext());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodSecurityContext> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[133]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodSecurityContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodSecurityContext(PodSecurityContext other) : this() {
      _hasBits0 = other._hasBits0;
      seLinuxOptions_ = other.seLinuxOptions_ != null ? other.seLinuxOptions_.Clone() : null;
      windowsOptions_ = other.windowsOptions_ != null ? other.windowsOptions_.Clone() : null;
      runAsUser_ = other.runAsUser_;
      runAsGroup_ = other.runAsGroup_;
      runAsNonRoot_ = other.runAsNonRoot_;
      supplementalGroups_ = other.supplementalGroups_.Clone();
      fsGroup_ = other.fsGroup_;
      sysctls_ = other.sysctls_.Clone();
      fsGroupChangePolicy_ = other.fsGroupChangePolicy_;
      seccompProfile_ = other.seccompProfile_ != null ? other.seccompProfile_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodSecurityContext Clone() {
      return new PodSecurityContext(this);
    }

    /// <summary>Field number for the "seLinuxOptions" field.</summary>
    public const int SeLinuxOptionsFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.SELinuxOptions seLinuxOptions_;
    /// <summary>
    /// The SELinux context to be applied to all containers.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in SecurityContext.  If set in
    /// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
    /// takes precedence for that container.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SELinuxOptions SeLinuxOptions {
      get { return seLinuxOptions_; }
      set {
        seLinuxOptions_ = value;
      }
    }

    /// <summary>Field number for the "windowsOptions" field.</summary>
    public const int WindowsOptionsFieldNumber = 8;
    private global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions windowsOptions_;
    /// <summary>
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options within a container's SecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions WindowsOptions {
      get { return windowsOptions_; }
      set {
        windowsOptions_ = value;
      }
    }

    /// <summary>Field number for the "runAsUser" field.</summary>
    public const int RunAsUserFieldNumber = 2;
    private readonly static long RunAsUserDefaultValue = 0L;

    private long runAsUser_;
    /// <summary>
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in SecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence
    /// for that container.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RunAsUser {
      get { if ((_hasBits0 & 1) != 0) { return runAsUser_; } else { return RunAsUserDefaultValue; } }
      set {
        _hasBits0 |= 1;
        runAsUser_ = value;
      }
    }
    /// <summary>Gets whether the "runAsUser" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRunAsUser {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "runAsUser" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRunAsUser() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "runAsGroup" field.</summary>
    public const int RunAsGroupFieldNumber = 6;
    private readonly static long RunAsGroupDefaultValue = 0L;

    private long runAsGroup_;
    /// <summary>
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in SecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence
    /// for that container.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RunAsGroup {
      get { if ((_hasBits0 & 8) != 0) { return runAsGroup_; } else { return RunAsGroupDefaultValue; } }
      set {
        _hasBits0 |= 8;
        runAsGroup_ = value;
      }
    }
    /// <summary>Gets whether the "runAsGroup" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRunAsGroup {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "runAsGroup" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRunAsGroup() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "runAsNonRoot" field.</summary>
    public const int RunAsNonRootFieldNumber = 3;
    private readonly static bool RunAsNonRootDefaultValue = false;

    private bool runAsNonRoot_;
    /// <summary>
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in SecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RunAsNonRoot {
      get { if ((_hasBits0 & 2) != 0) { return runAsNonRoot_; } else { return RunAsNonRootDefaultValue; } }
      set {
        _hasBits0 |= 2;
        runAsNonRoot_ = value;
      }
    }
    /// <summary>Gets whether the "runAsNonRoot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRunAsNonRoot {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "runAsNonRoot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRunAsNonRoot() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "supplementalGroups" field.</summary>
    public const int SupplementalGroupsFieldNumber = 4;
    private static readonly pb::FieldCodec<long> _repeated_supplementalGroups_codec
        = pb::FieldCodec.ForInt64(32);
    private readonly pbc::RepeatedField<long> supplementalGroups_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// A list of groups applied to the first process run in each container, in addition
    /// to the container's primary GID.  If unspecified, no groups will be added to
    /// any container.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> SupplementalGroups {
      get { return supplementalGroups_; }
    }

    /// <summary>Field number for the "fsGroup" field.</summary>
    public const int FsGroupFieldNumber = 5;
    private readonly static long FsGroupDefaultValue = 0L;

    private long fsGroup_;
    /// <summary>
    /// A special supplemental group that applies to all containers in a pod.
    /// Some volume types allow the Kubelet to change the ownership of that volume
    /// to be owned by the pod:
    ///
    /// 1. The owning GID will be the FSGroup
    /// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
    /// 3. The permission bits are OR'd with rw-rw----
    ///
    /// If unset, the Kubelet will not modify the ownership and permissions of any volume.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long FsGroup {
      get { if ((_hasBits0 & 4) != 0) { return fsGroup_; } else { return FsGroupDefaultValue; } }
      set {
        _hasBits0 |= 4;
        fsGroup_ = value;
      }
    }
    /// <summary>Gets whether the "fsGroup" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsGroup {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "fsGroup" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsGroup() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "sysctls" field.</summary>
    public const int SysctlsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Sysctl> _repeated_sysctls_codec
        = pb::FieldCodec.ForMessage(58, global::K8S.Io.Api.Core.V1.Sysctl.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Sysctl> sysctls_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Sysctl>();
    /// <summary>
    /// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
    /// sysctls (by the container runtime) might fail to launch.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Sysctl> Sysctls {
      get { return sysctls_; }
    }

    /// <summary>Field number for the "fsGroupChangePolicy" field.</summary>
    public const int FsGroupChangePolicyFieldNumber = 9;
    private readonly static string FsGroupChangePolicyDefaultValue = "";

    private string fsGroupChangePolicy_;
    /// <summary>
    /// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
    /// before being exposed inside Pod. This field will only apply to
    /// volume types which support fsGroup based ownership(and permissions).
    /// It will have no effect on ephemeral volume types such as: secret, configmaps
    /// and emptydir.
    /// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsGroupChangePolicy {
      get { return fsGroupChangePolicy_ ?? FsGroupChangePolicyDefaultValue; }
      set {
        fsGroupChangePolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsGroupChangePolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsGroupChangePolicy {
      get { return fsGroupChangePolicy_ != null; }
    }
    /// <summary>Clears the value of the "fsGroupChangePolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsGroupChangePolicy() {
      fsGroupChangePolicy_ = null;
    }

    /// <summary>Field number for the "seccompProfile" field.</summary>
    public const int SeccompProfileFieldNumber = 10;
    private global::K8S.Io.Api.Core.V1.SeccompProfile seccompProfile_;
    /// <summary>
    /// The seccomp options to use by the containers in this pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SeccompProfile SeccompProfile {
      get { return seccompProfile_; }
      set {
        seccompProfile_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodSecurityContext);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodSecurityContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SeLinuxOptions, other.SeLinuxOptions)) return false;
      if (!object.Equals(WindowsOptions, other.WindowsOptions)) return false;
      if (RunAsUser != other.RunAsUser) return false;
      if (RunAsGroup != other.RunAsGroup) return false;
      if (RunAsNonRoot != other.RunAsNonRoot) return false;
      if(!supplementalGroups_.Equals(other.supplementalGroups_)) return false;
      if (FsGroup != other.FsGroup) return false;
      if(!sysctls_.Equals(other.sysctls_)) return false;
      if (FsGroupChangePolicy != other.FsGroupChangePolicy) return false;
      if (!object.Equals(SeccompProfile, other.SeccompProfile)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (seLinuxOptions_ != null) hash ^= SeLinuxOptions.GetHashCode();
      if (windowsOptions_ != null) hash ^= WindowsOptions.GetHashCode();
      if (HasRunAsUser) hash ^= RunAsUser.GetHashCode();
      if (HasRunAsGroup) hash ^= RunAsGroup.GetHashCode();
      if (HasRunAsNonRoot) hash ^= RunAsNonRoot.GetHashCode();
      hash ^= supplementalGroups_.GetHashCode();
      if (HasFsGroup) hash ^= FsGroup.GetHashCode();
      hash ^= sysctls_.GetHashCode();
      if (HasFsGroupChangePolicy) hash ^= FsGroupChangePolicy.GetHashCode();
      if (seccompProfile_ != null) hash ^= SeccompProfile.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (seLinuxOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SeLinuxOptions);
      }
      if (HasRunAsUser) {
        output.WriteRawTag(16);
        output.WriteInt64(RunAsUser);
      }
      if (HasRunAsNonRoot) {
        output.WriteRawTag(24);
        output.WriteBool(RunAsNonRoot);
      }
      supplementalGroups_.WriteTo(output, _repeated_supplementalGroups_codec);
      if (HasFsGroup) {
        output.WriteRawTag(40);
        output.WriteInt64(FsGroup);
      }
      if (HasRunAsGroup) {
        output.WriteRawTag(48);
        output.WriteInt64(RunAsGroup);
      }
      sysctls_.WriteTo(output, _repeated_sysctls_codec);
      if (windowsOptions_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(WindowsOptions);
      }
      if (HasFsGroupChangePolicy) {
        output.WriteRawTag(74);
        output.WriteString(FsGroupChangePolicy);
      }
      if (seccompProfile_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(SeccompProfile);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (seLinuxOptions_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SeLinuxOptions);
      }
      if (HasRunAsUser) {
        output.WriteRawTag(16);
        output.WriteInt64(RunAsUser);
      }
      if (HasRunAsNonRoot) {
        output.WriteRawTag(24);
        output.WriteBool(RunAsNonRoot);
      }
      supplementalGroups_.WriteTo(ref output, _repeated_supplementalGroups_codec);
      if (HasFsGroup) {
        output.WriteRawTag(40);
        output.WriteInt64(FsGroup);
      }
      if (HasRunAsGroup) {
        output.WriteRawTag(48);
        output.WriteInt64(RunAsGroup);
      }
      sysctls_.WriteTo(ref output, _repeated_sysctls_codec);
      if (windowsOptions_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(WindowsOptions);
      }
      if (HasFsGroupChangePolicy) {
        output.WriteRawTag(74);
        output.WriteString(FsGroupChangePolicy);
      }
      if (seccompProfile_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(SeccompProfile);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (seLinuxOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SeLinuxOptions);
      }
      if (windowsOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WindowsOptions);
      }
      if (HasRunAsUser) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RunAsUser);
      }
      if (HasRunAsGroup) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RunAsGroup);
      }
      if (HasRunAsNonRoot) {
        size += 1 + 1;
      }
      size += supplementalGroups_.CalculateSize(_repeated_supplementalGroups_codec);
      if (HasFsGroup) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(FsGroup);
      }
      size += sysctls_.CalculateSize(_repeated_sysctls_codec);
      if (HasFsGroupChangePolicy) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsGroupChangePolicy);
      }
      if (seccompProfile_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SeccompProfile);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodSecurityContext other) {
      if (other == null) {
        return;
      }
      if (other.seLinuxOptions_ != null) {
        if (seLinuxOptions_ == null) {
          SeLinuxOptions = new global::K8S.Io.Api.Core.V1.SELinuxOptions();
        }
        SeLinuxOptions.MergeFrom(other.SeLinuxOptions);
      }
      if (other.windowsOptions_ != null) {
        if (windowsOptions_ == null) {
          WindowsOptions = new global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions();
        }
        WindowsOptions.MergeFrom(other.WindowsOptions);
      }
      if (other.HasRunAsUser) {
        RunAsUser = other.RunAsUser;
      }
      if (other.HasRunAsGroup) {
        RunAsGroup = other.RunAsGroup;
      }
      if (other.HasRunAsNonRoot) {
        RunAsNonRoot = other.RunAsNonRoot;
      }
      supplementalGroups_.Add(other.supplementalGroups_);
      if (other.HasFsGroup) {
        FsGroup = other.FsGroup;
      }
      sysctls_.Add(other.sysctls_);
      if (other.HasFsGroupChangePolicy) {
        FsGroupChangePolicy = other.FsGroupChangePolicy;
      }
      if (other.seccompProfile_ != null) {
        if (seccompProfile_ == null) {
          SeccompProfile = new global::K8S.Io.Api.Core.V1.SeccompProfile();
        }
        SeccompProfile.MergeFrom(other.SeccompProfile);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (seLinuxOptions_ == null) {
              SeLinuxOptions = new global::K8S.Io.Api.Core.V1.SELinuxOptions();
            }
            input.ReadMessage(SeLinuxOptions);
            break;
          }
          case 16: {
            RunAsUser = input.ReadInt64();
            break;
          }
          case 24: {
            RunAsNonRoot = input.ReadBool();
            break;
          }
          case 34:
          case 32: {
            supplementalGroups_.AddEntriesFrom(input, _repeated_supplementalGroups_codec);
            break;
          }
          case 40: {
            FsGroup = input.ReadInt64();
            break;
          }
          case 48: {
            RunAsGroup = input.ReadInt64();
            break;
          }
          case 58: {
            sysctls_.AddEntriesFrom(input, _repeated_sysctls_codec);
            break;
          }
          case 66: {
            if (windowsOptions_ == null) {
              WindowsOptions = new global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions();
            }
            input.ReadMessage(WindowsOptions);
            break;
          }
          case 74: {
            FsGroupChangePolicy = input.ReadString();
            break;
          }
          case 82: {
            if (seccompProfile_ == null) {
              SeccompProfile = new global::K8S.Io.Api.Core.V1.SeccompProfile();
            }
            input.ReadMessage(SeccompProfile);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (seLinuxOptions_ == null) {
              SeLinuxOptions = new global::K8S.Io.Api.Core.V1.SELinuxOptions();
            }
            input.ReadMessage(SeLinuxOptions);
            break;
          }
          case 16: {
            RunAsUser = input.ReadInt64();
            break;
          }
          case 24: {
            RunAsNonRoot = input.ReadBool();
            break;
          }
          case 34:
          case 32: {
            supplementalGroups_.AddEntriesFrom(ref input, _repeated_supplementalGroups_codec);
            break;
          }
          case 40: {
            FsGroup = input.ReadInt64();
            break;
          }
          case 48: {
            RunAsGroup = input.ReadInt64();
            break;
          }
          case 58: {
            sysctls_.AddEntriesFrom(ref input, _repeated_sysctls_codec);
            break;
          }
          case 66: {
            if (windowsOptions_ == null) {
              WindowsOptions = new global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions();
            }
            input.ReadMessage(WindowsOptions);
            break;
          }
          case 74: {
            FsGroupChangePolicy = input.ReadString();
            break;
          }
          case 82: {
            if (seccompProfile_ == null) {
              SeccompProfile = new global::K8S.Io.Api.Core.V1.SeccompProfile();
            }
            input.ReadMessage(SeccompProfile);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes the class of pods that should avoid this node.
  /// Exactly one field should be set.
  /// </summary>
  public sealed partial class PodSignature : pb::IMessage<PodSignature>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodSignature> _parser = new pb::MessageParser<PodSignature>(() => new PodSignature());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodSignature> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[134]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodSignature() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodSignature(PodSignature other) : this() {
      podController_ = other.podController_ != null ? other.podController_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodSignature Clone() {
      return new PodSignature(this);
    }

    /// <summary>Field number for the "podController" field.</summary>
    public const int PodControllerFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.OwnerReference podController_;
    /// <summary>
    /// Reference to controller whose pods should avoid this node.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.OwnerReference PodController {
      get { return podController_; }
      set {
        podController_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodSignature);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodSignature other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(PodController, other.PodController)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (podController_ != null) hash ^= PodController.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (podController_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PodController);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (podController_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PodController);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (podController_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PodController);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodSignature other) {
      if (other == null) {
        return;
      }
      if (other.podController_ != null) {
        if (podController_ == null) {
          PodController = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.OwnerReference();
        }
        PodController.MergeFrom(other.PodController);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (podController_ == null) {
              PodController = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.OwnerReference();
            }
            input.ReadMessage(PodController);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (podController_ == null) {
              PodController = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.OwnerReference();
            }
            input.ReadMessage(PodController);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodSpec is a description of a pod.
  /// </summary>
  public sealed partial class PodSpec : pb::IMessage<PodSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodSpec> _parser = new pb::MessageParser<PodSpec>(() => new PodSpec());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[135]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodSpec(PodSpec other) : this() {
      _hasBits0 = other._hasBits0;
      volumes_ = other.volumes_.Clone();
      initContainers_ = other.initContainers_.Clone();
      containers_ = other.containers_.Clone();
      ephemeralContainers_ = other.ephemeralContainers_.Clone();
      restartPolicy_ = other.restartPolicy_;
      terminationGracePeriodSeconds_ = other.terminationGracePeriodSeconds_;
      activeDeadlineSeconds_ = other.activeDeadlineSeconds_;
      dnsPolicy_ = other.dnsPolicy_;
      nodeSelector_ = other.nodeSelector_.Clone();
      serviceAccountName_ = other.serviceAccountName_;
      serviceAccount_ = other.serviceAccount_;
      automountServiceAccountToken_ = other.automountServiceAccountToken_;
      nodeName_ = other.nodeName_;
      hostNetwork_ = other.hostNetwork_;
      hostPID_ = other.hostPID_;
      hostIPC_ = other.hostIPC_;
      shareProcessNamespace_ = other.shareProcessNamespace_;
      securityContext_ = other.securityContext_ != null ? other.securityContext_.Clone() : null;
      imagePullSecrets_ = other.imagePullSecrets_.Clone();
      hostname_ = other.hostname_;
      subdomain_ = other.subdomain_;
      affinity_ = other.affinity_ != null ? other.affinity_.Clone() : null;
      schedulerName_ = other.schedulerName_;
      tolerations_ = other.tolerations_.Clone();
      hostAliases_ = other.hostAliases_.Clone();
      priorityClassName_ = other.priorityClassName_;
      priority_ = other.priority_;
      dnsConfig_ = other.dnsConfig_ != null ? other.dnsConfig_.Clone() : null;
      readinessGates_ = other.readinessGates_.Clone();
      runtimeClassName_ = other.runtimeClassName_;
      enableServiceLinks_ = other.enableServiceLinks_;
      preemptionPolicy_ = other.preemptionPolicy_;
      overhead_ = other.overhead_.Clone();
      topologySpreadConstraints_ = other.topologySpreadConstraints_.Clone();
      setHostnameAsFQDN_ = other.setHostnameAsFQDN_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodSpec Clone() {
      return new PodSpec(this);
    }

    /// <summary>Field number for the "volumes" field.</summary>
    public const int VolumesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Volume> _repeated_volumes_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.Volume.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Volume> volumes_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Volume>();
    /// <summary>
    /// List of volumes that can be mounted by containers belonging to the pod.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes
    /// +optional
    /// +patchMergeKey=name
    /// +patchStrategy=merge,retainKeys
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Volume> Volumes {
      get { return volumes_; }
    }

    /// <summary>Field number for the "initContainers" field.</summary>
    public const int InitContainersFieldNumber = 20;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Container> _repeated_initContainers_codec
        = pb::FieldCodec.ForMessage(162, global::K8S.Io.Api.Core.V1.Container.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Container> initContainers_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Container>();
    /// <summary>
    /// List of initialization containers belonging to the pod.
    /// Init containers are executed in order prior to containers being started. If any
    /// init container fails, the pod is considered to have failed and is handled according
    /// to its restartPolicy. The name for an init container or normal container must be
    /// unique among all containers.
    /// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
    /// The resourceRequirements of an init container are taken into account during scheduling
    /// by finding the highest request/limit for each resource type, and then using the max of
    /// of that value or the sum of the normal containers. Limits are applied to init containers
    /// in a similar fashion.
    /// Init containers cannot currently be added or removed.
    /// Cannot be updated.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
    /// +patchMergeKey=name
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Container> InitContainers {
      get { return initContainers_; }
    }

    /// <summary>Field number for the "containers" field.</summary>
    public const int ContainersFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Container> _repeated_containers_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.Container.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Container> containers_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Container>();
    /// <summary>
    /// List of containers belonging to the pod.
    /// Containers cannot currently be added or removed.
    /// There must be at least one container in a Pod.
    /// Cannot be updated.
    /// +patchMergeKey=name
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Container> Containers {
      get { return containers_; }
    }

    /// <summary>Field number for the "ephemeralContainers" field.</summary>
    public const int EphemeralContainersFieldNumber = 34;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.EphemeralContainer> _repeated_ephemeralContainers_codec
        = pb::FieldCodec.ForMessage(274, global::K8S.Io.Api.Core.V1.EphemeralContainer.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EphemeralContainer> ephemeralContainers_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EphemeralContainer>();
    /// <summary>
    /// List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
    /// pod to perform user-initiated actions such as debugging. This list cannot be specified when
    /// creating a pod, and it cannot be modified by updating the pod spec. In order to add an
    /// ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
    /// This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.
    /// +optional
    /// +patchMergeKey=name
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.EphemeralContainer> EphemeralContainers {
      get { return ephemeralContainers_; }
    }

    /// <summary>Field number for the "restartPolicy" field.</summary>
    public const int RestartPolicyFieldNumber = 3;
    private readonly static string RestartPolicyDefaultValue = "";

    private string restartPolicy_;
    /// <summary>
    /// Restart policy for all containers within the pod.
    /// One of Always, OnFailure, Never.
    /// Default to Always.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RestartPolicy {
      get { return restartPolicy_ ?? RestartPolicyDefaultValue; }
      set {
        restartPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "restartPolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRestartPolicy {
      get { return restartPolicy_ != null; }
    }
    /// <summary>Clears the value of the "restartPolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRestartPolicy() {
      restartPolicy_ = null;
    }

    /// <summary>Field number for the "terminationGracePeriodSeconds" field.</summary>
    public const int TerminationGracePeriodSecondsFieldNumber = 4;
    private readonly static long TerminationGracePeriodSecondsDefaultValue = 0L;

    private long terminationGracePeriodSeconds_;
    /// <summary>
    /// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// If this value is nil, the default grace period will be used instead.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// Defaults to 30 seconds.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TerminationGracePeriodSeconds {
      get { if ((_hasBits0 & 1) != 0) { return terminationGracePeriodSeconds_; } else { return TerminationGracePeriodSecondsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        terminationGracePeriodSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "terminationGracePeriodSeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTerminationGracePeriodSeconds {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "terminationGracePeriodSeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTerminationGracePeriodSeconds() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "activeDeadlineSeconds" field.</summary>
    public const int ActiveDeadlineSecondsFieldNumber = 5;
    private readonly static long ActiveDeadlineSecondsDefaultValue = 0L;

    private long activeDeadlineSeconds_;
    /// <summary>
    /// Optional duration in seconds the pod may be active on the node relative to
    /// StartTime before the system will actively try to mark it failed and kill associated containers.
    /// Value must be a positive integer.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ActiveDeadlineSeconds {
      get { if ((_hasBits0 & 2) != 0) { return activeDeadlineSeconds_; } else { return ActiveDeadlineSecondsDefaultValue; } }
      set {
        _hasBits0 |= 2;
        activeDeadlineSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "activeDeadlineSeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasActiveDeadlineSeconds {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "activeDeadlineSeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearActiveDeadlineSeconds() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "dnsPolicy" field.</summary>
    public const int DnsPolicyFieldNumber = 6;
    private readonly static string DnsPolicyDefaultValue = "";

    private string dnsPolicy_;
    /// <summary>
    /// Set DNS policy for the pod.
    /// Defaults to "ClusterFirst".
    /// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
    /// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
    /// To have DNS options set along with hostNetwork, you have to specify DNS policy
    /// explicitly to 'ClusterFirstWithHostNet'.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DnsPolicy {
      get { return dnsPolicy_ ?? DnsPolicyDefaultValue; }
      set {
        dnsPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "dnsPolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDnsPolicy {
      get { return dnsPolicy_ != null; }
    }
    /// <summary>Clears the value of the "dnsPolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDnsPolicy() {
      dnsPolicy_ = null;
    }

    /// <summary>Field number for the "nodeSelector" field.</summary>
    public const int NodeSelectorFieldNumber = 7;
    private static readonly pbc::MapField<string, string>.Codec _map_nodeSelector_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 58);
    private readonly pbc::MapField<string, string> nodeSelector_ = new pbc::MapField<string, string>();
    /// <summary>
    /// NodeSelector is a selector which must be true for the pod to fit on a node.
    /// Selector which must match a node's labels for the pod to be scheduled on that node.
    /// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
    /// +optional
    /// +mapType=atomic
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> NodeSelector {
      get { return nodeSelector_; }
    }

    /// <summary>Field number for the "serviceAccountName" field.</summary>
    public const int ServiceAccountNameFieldNumber = 8;
    private readonly static string ServiceAccountNameDefaultValue = "";

    private string serviceAccountName_;
    /// <summary>
    /// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
    /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ServiceAccountName {
      get { return serviceAccountName_ ?? ServiceAccountNameDefaultValue; }
      set {
        serviceAccountName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "serviceAccountName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasServiceAccountName {
      get { return serviceAccountName_ != null; }
    }
    /// <summary>Clears the value of the "serviceAccountName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearServiceAccountName() {
      serviceAccountName_ = null;
    }

    /// <summary>Field number for the "serviceAccount" field.</summary>
    public const int ServiceAccountFieldNumber = 9;
    private readonly static string ServiceAccountDefaultValue = "";

    private string serviceAccount_;
    /// <summary>
    /// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
    /// Deprecated: Use serviceAccountName instead.
    /// +k8s:conversion-gen=false
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ServiceAccount {
      get { return serviceAccount_ ?? ServiceAccountDefaultValue; }
      set {
        serviceAccount_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "serviceAccount" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasServiceAccount {
      get { return serviceAccount_ != null; }
    }
    /// <summary>Clears the value of the "serviceAccount" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearServiceAccount() {
      serviceAccount_ = null;
    }

    /// <summary>Field number for the "automountServiceAccountToken" field.</summary>
    public const int AutomountServiceAccountTokenFieldNumber = 21;
    private readonly static bool AutomountServiceAccountTokenDefaultValue = false;

    private bool automountServiceAccountToken_;
    /// <summary>
    /// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AutomountServiceAccountToken {
      get { if ((_hasBits0 & 32) != 0) { return automountServiceAccountToken_; } else { return AutomountServiceAccountTokenDefaultValue; } }
      set {
        _hasBits0 |= 32;
        automountServiceAccountToken_ = value;
      }
    }
    /// <summary>Gets whether the "automountServiceAccountToken" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAutomountServiceAccountToken {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "automountServiceAccountToken" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAutomountServiceAccountToken() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "nodeName" field.</summary>
    public const int NodeNameFieldNumber = 10;
    private readonly static string NodeNameDefaultValue = "";

    private string nodeName_;
    /// <summary>
    /// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
    /// the scheduler simply schedules this pod onto that node, assuming that it fits resource
    /// requirements.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string NodeName {
      get { return nodeName_ ?? NodeNameDefaultValue; }
      set {
        nodeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "nodeName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodeName {
      get { return nodeName_ != null; }
    }
    /// <summary>Clears the value of the "nodeName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodeName() {
      nodeName_ = null;
    }

    /// <summary>Field number for the "hostNetwork" field.</summary>
    public const int HostNetworkFieldNumber = 11;
    private readonly static bool HostNetworkDefaultValue = false;

    private bool hostNetwork_;
    /// <summary>
    /// Host networking requested for this pod. Use the host's network namespace.
    /// If this option is set, the ports that will be used must be specified.
    /// Default to false.
    /// +k8s:conversion-gen=false
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HostNetwork {
      get { if ((_hasBits0 & 4) != 0) { return hostNetwork_; } else { return HostNetworkDefaultValue; } }
      set {
        _hasBits0 |= 4;
        hostNetwork_ = value;
      }
    }
    /// <summary>Gets whether the "hostNetwork" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostNetwork {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "hostNetwork" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostNetwork() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "hostPID" field.</summary>
    public const int HostPIDFieldNumber = 12;
    private readonly static bool HostPIDDefaultValue = false;

    private bool hostPID_;
    /// <summary>
    /// Use the host's pid namespace.
    /// Optional: Default to false.
    /// +k8s:conversion-gen=false
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HostPID {
      get { if ((_hasBits0 & 8) != 0) { return hostPID_; } else { return HostPIDDefaultValue; } }
      set {
        _hasBits0 |= 8;
        hostPID_ = value;
      }
    }
    /// <summary>Gets whether the "hostPID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostPID {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "hostPID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostPID() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "hostIPC" field.</summary>
    public const int HostIPCFieldNumber = 13;
    private readonly static bool HostIPCDefaultValue = false;

    private bool hostIPC_;
    /// <summary>
    /// Use the host's ipc namespace.
    /// Optional: Default to false.
    /// +k8s:conversion-gen=false
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HostIPC {
      get { if ((_hasBits0 & 16) != 0) { return hostIPC_; } else { return HostIPCDefaultValue; } }
      set {
        _hasBits0 |= 16;
        hostIPC_ = value;
      }
    }
    /// <summary>Gets whether the "hostIPC" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostIPC {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "hostIPC" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostIPC() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "shareProcessNamespace" field.</summary>
    public const int ShareProcessNamespaceFieldNumber = 27;
    private readonly static bool ShareProcessNamespaceDefaultValue = false;

    private bool shareProcessNamespace_;
    /// <summary>
    /// Share a single process namespace between all of the containers in a pod.
    /// When this is set containers will be able to view and signal processes from other containers
    /// in the same pod, and the first process in each container will not be assigned PID 1.
    /// HostPID and ShareProcessNamespace cannot both be set.
    /// Optional: Default to false.
    /// +k8s:conversion-gen=false
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ShareProcessNamespace {
      get { if ((_hasBits0 & 128) != 0) { return shareProcessNamespace_; } else { return ShareProcessNamespaceDefaultValue; } }
      set {
        _hasBits0 |= 128;
        shareProcessNamespace_ = value;
      }
    }
    /// <summary>Gets whether the "shareProcessNamespace" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasShareProcessNamespace {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "shareProcessNamespace" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearShareProcessNamespace() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "securityContext" field.</summary>
    public const int SecurityContextFieldNumber = 14;
    private global::K8S.Io.Api.Core.V1.PodSecurityContext securityContext_;
    /// <summary>
    /// SecurityContext holds pod-level security attributes and common container settings.
    /// Optional: Defaults to empty.  See type description for default values of each field.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodSecurityContext SecurityContext {
      get { return securityContext_; }
      set {
        securityContext_ = value;
      }
    }

    /// <summary>Field number for the "imagePullSecrets" field.</summary>
    public const int ImagePullSecretsFieldNumber = 15;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.LocalObjectReference> _repeated_imagePullSecrets_codec
        = pb::FieldCodec.ForMessage(122, global::K8S.Io.Api.Core.V1.LocalObjectReference.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LocalObjectReference> imagePullSecrets_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LocalObjectReference>();
    /// <summary>
    /// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
    /// If specified, these secrets will be passed to individual puller implementations for them to use. For example,
    /// in the case of docker, only DockerConfig type secrets are honored.
    /// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
    /// +optional
    /// +patchMergeKey=name
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LocalObjectReference> ImagePullSecrets {
      get { return imagePullSecrets_; }
    }

    /// <summary>Field number for the "hostname" field.</summary>
    public const int HostnameFieldNumber = 16;
    private readonly static string HostnameDefaultValue = "";

    private string hostname_;
    /// <summary>
    /// Specifies the hostname of the Pod
    /// If not specified, the pod's hostname will be set to a system-defined value.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Hostname {
      get { return hostname_ ?? HostnameDefaultValue; }
      set {
        hostname_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hostname" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostname {
      get { return hostname_ != null; }
    }
    /// <summary>Clears the value of the "hostname" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostname() {
      hostname_ = null;
    }

    /// <summary>Field number for the "subdomain" field.</summary>
    public const int SubdomainFieldNumber = 17;
    private readonly static string SubdomainDefaultValue = "";

    private string subdomain_;
    /// <summary>
    /// If specified, the fully qualified Pod hostname will be "&lt;hostname>.&lt;subdomain>.&lt;pod namespace>.svc.&lt;cluster domain>".
    /// If not specified, the pod will not have a domainname at all.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Subdomain {
      get { return subdomain_ ?? SubdomainDefaultValue; }
      set {
        subdomain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "subdomain" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSubdomain {
      get { return subdomain_ != null; }
    }
    /// <summary>Clears the value of the "subdomain" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSubdomain() {
      subdomain_ = null;
    }

    /// <summary>Field number for the "affinity" field.</summary>
    public const int AffinityFieldNumber = 18;
    private global::K8S.Io.Api.Core.V1.Affinity affinity_;
    /// <summary>
    /// If specified, the pod's scheduling constraints
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Affinity Affinity {
      get { return affinity_; }
      set {
        affinity_ = value;
      }
    }

    /// <summary>Field number for the "schedulerName" field.</summary>
    public const int SchedulerNameFieldNumber = 19;
    private readonly static string SchedulerNameDefaultValue = "";

    private string schedulerName_;
    /// <summary>
    /// If specified, the pod will be dispatched by specified scheduler.
    /// If not specified, the pod will be dispatched by default scheduler.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SchedulerName {
      get { return schedulerName_ ?? SchedulerNameDefaultValue; }
      set {
        schedulerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "schedulerName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSchedulerName {
      get { return schedulerName_ != null; }
    }
    /// <summary>Clears the value of the "schedulerName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSchedulerName() {
      schedulerName_ = null;
    }

    /// <summary>Field number for the "tolerations" field.</summary>
    public const int TolerationsFieldNumber = 22;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Toleration> _repeated_tolerations_codec
        = pb::FieldCodec.ForMessage(178, global::K8S.Io.Api.Core.V1.Toleration.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Toleration> tolerations_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Toleration>();
    /// <summary>
    /// If specified, the pod's tolerations.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Toleration> Tolerations {
      get { return tolerations_; }
    }

    /// <summary>Field number for the "hostAliases" field.</summary>
    public const int HostAliasesFieldNumber = 23;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.HostAlias> _repeated_hostAliases_codec
        = pb::FieldCodec.ForMessage(186, global::K8S.Io.Api.Core.V1.HostAlias.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.HostAlias> hostAliases_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.HostAlias>();
    /// <summary>
    /// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
    /// file if specified. This is only valid for non-hostNetwork pods.
    /// +optional
    /// +patchMergeKey=ip
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.HostAlias> HostAliases {
      get { return hostAliases_; }
    }

    /// <summary>Field number for the "priorityClassName" field.</summary>
    public const int PriorityClassNameFieldNumber = 24;
    private readonly static string PriorityClassNameDefaultValue = "";

    private string priorityClassName_;
    /// <summary>
    /// If specified, indicates the pod's priority. "system-node-critical" and
    /// "system-cluster-critical" are two special keywords which indicate the
    /// highest priorities with the former being the highest priority. Any other
    /// name must be defined by creating a PriorityClass object with that name.
    /// If not specified, the pod priority will be default or zero if there is no
    /// default.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PriorityClassName {
      get { return priorityClassName_ ?? PriorityClassNameDefaultValue; }
      set {
        priorityClassName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "priorityClassName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPriorityClassName {
      get { return priorityClassName_ != null; }
    }
    /// <summary>Clears the value of the "priorityClassName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPriorityClassName() {
      priorityClassName_ = null;
    }

    /// <summary>Field number for the "priority" field.</summary>
    public const int PriorityFieldNumber = 25;
    private readonly static int PriorityDefaultValue = 0;

    private int priority_;
    /// <summary>
    /// The priority value. Various system components use this field to find the
    /// priority of the pod. When Priority Admission Controller is enabled, it
    /// prevents users from setting this field. The admission controller populates
    /// this field from PriorityClassName.
    /// The higher the value, the higher the priority.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Priority {
      get { if ((_hasBits0 & 64) != 0) { return priority_; } else { return PriorityDefaultValue; } }
      set {
        _hasBits0 |= 64;
        priority_ = value;
      }
    }
    /// <summary>Gets whether the "priority" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPriority {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "priority" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPriority() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "dnsConfig" field.</summary>
    public const int DnsConfigFieldNumber = 26;
    private global::K8S.Io.Api.Core.V1.PodDNSConfig dnsConfig_;
    /// <summary>
    /// Specifies the DNS parameters of a pod.
    /// Parameters specified here will be merged to the generated DNS
    /// configuration based on DNSPolicy.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodDNSConfig DnsConfig {
      get { return dnsConfig_; }
      set {
        dnsConfig_ = value;
      }
    }

    /// <summary>Field number for the "readinessGates" field.</summary>
    public const int ReadinessGatesFieldNumber = 28;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PodReadinessGate> _repeated_readinessGates_codec
        = pb::FieldCodec.ForMessage(226, global::K8S.Io.Api.Core.V1.PodReadinessGate.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodReadinessGate> readinessGates_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodReadinessGate>();
    /// <summary>
    /// If specified, all readiness gates will be evaluated for pod readiness.
    /// A pod is ready when all its containers are ready AND
    /// all conditions specified in the readiness gates have status equal to "True"
    /// More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodReadinessGate> ReadinessGates {
      get { return readinessGates_; }
    }

    /// <summary>Field number for the "runtimeClassName" field.</summary>
    public const int RuntimeClassNameFieldNumber = 29;
    private readonly static string RuntimeClassNameDefaultValue = "";

    private string runtimeClassName_;
    /// <summary>
    /// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
    /// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
    /// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
    /// empty definition that uses the default runtime handler.
    /// More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
    /// This is a beta feature as of Kubernetes v1.14.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RuntimeClassName {
      get { return runtimeClassName_ ?? RuntimeClassNameDefaultValue; }
      set {
        runtimeClassName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "runtimeClassName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRuntimeClassName {
      get { return runtimeClassName_ != null; }
    }
    /// <summary>Clears the value of the "runtimeClassName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRuntimeClassName() {
      runtimeClassName_ = null;
    }

    /// <summary>Field number for the "enableServiceLinks" field.</summary>
    public const int EnableServiceLinksFieldNumber = 30;
    private readonly static bool EnableServiceLinksDefaultValue = false;

    private bool enableServiceLinks_;
    /// <summary>
    /// EnableServiceLinks indicates whether information about services should be injected into pod's
    /// environment variables, matching the syntax of Docker links.
    /// Optional: Defaults to true.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EnableServiceLinks {
      get { if ((_hasBits0 & 256) != 0) { return enableServiceLinks_; } else { return EnableServiceLinksDefaultValue; } }
      set {
        _hasBits0 |= 256;
        enableServiceLinks_ = value;
      }
    }
    /// <summary>Gets whether the "enableServiceLinks" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEnableServiceLinks {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "enableServiceLinks" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEnableServiceLinks() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "preemptionPolicy" field.</summary>
    public const int PreemptionPolicyFieldNumber = 31;
    private readonly static string PreemptionPolicyDefaultValue = "";

    private string preemptionPolicy_;
    /// <summary>
    /// PreemptionPolicy is the Policy for preempting pods with lower priority.
    /// One of Never, PreemptLowerPriority.
    /// Defaults to PreemptLowerPriority if unset.
    /// This field is beta-level, gated by the NonPreemptingPriority feature-gate.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PreemptionPolicy {
      get { return preemptionPolicy_ ?? PreemptionPolicyDefaultValue; }
      set {
        preemptionPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "preemptionPolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPreemptionPolicy {
      get { return preemptionPolicy_ != null; }
    }
    /// <summary>Clears the value of the "preemptionPolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPreemptionPolicy() {
      preemptionPolicy_ = null;
    }

    /// <summary>Field number for the "overhead" field.</summary>
    public const int OverheadFieldNumber = 32;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_overhead_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 258);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> overhead_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
    /// This field will be autopopulated at admission time by the RuntimeClass admission controller. If
    /// the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
    /// The RuntimeClass admission controller will reject Pod create requests which have the overhead already
    /// set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
    /// defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
    /// More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
    /// This field is beta-level as of Kubernetes v1.18, and is only honored by servers that enable the PodOverhead feature.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Overhead {
      get { return overhead_; }
    }

    /// <summary>Field number for the "topologySpreadConstraints" field.</summary>
    public const int TopologySpreadConstraintsFieldNumber = 33;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.TopologySpreadConstraint> _repeated_topologySpreadConstraints_codec
        = pb::FieldCodec.ForMessage(266, global::K8S.Io.Api.Core.V1.TopologySpreadConstraint.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.TopologySpreadConstraint> topologySpreadConstraints_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.TopologySpreadConstraint>();
    /// <summary>
    /// TopologySpreadConstraints describes how a group of pods ought to spread across topology
    /// domains. Scheduler will schedule pods in a way which abides by the constraints.
    /// All topologySpreadConstraints are ANDed.
    /// +optional
    /// +patchMergeKey=topologyKey
    /// +patchStrategy=merge
    /// +listType=map
    /// +listMapKey=topologyKey
    /// +listMapKey=whenUnsatisfiable
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.TopologySpreadConstraint> TopologySpreadConstraints {
      get { return topologySpreadConstraints_; }
    }

    /// <summary>Field number for the "setHostnameAsFQDN" field.</summary>
    public const int SetHostnameAsFQDNFieldNumber = 35;
    private readonly static bool SetHostnameAsFQDNDefaultValue = false;

    private bool setHostnameAsFQDN_;
    /// <summary>
    /// If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
    /// In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
    /// In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
    /// If a pod does not have FQDN, this has no effect.
    /// Default to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SetHostnameAsFQDN {
      get { if ((_hasBits0 & 512) != 0) { return setHostnameAsFQDN_; } else { return SetHostnameAsFQDNDefaultValue; } }
      set {
        _hasBits0 |= 512;
        setHostnameAsFQDN_ = value;
      }
    }
    /// <summary>Gets whether the "setHostnameAsFQDN" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSetHostnameAsFQDN {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "setHostnameAsFQDN" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSetHostnameAsFQDN() {
      _hasBits0 &= ~512;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!volumes_.Equals(other.volumes_)) return false;
      if(!initContainers_.Equals(other.initContainers_)) return false;
      if(!containers_.Equals(other.containers_)) return false;
      if(!ephemeralContainers_.Equals(other.ephemeralContainers_)) return false;
      if (RestartPolicy != other.RestartPolicy) return false;
      if (TerminationGracePeriodSeconds != other.TerminationGracePeriodSeconds) return false;
      if (ActiveDeadlineSeconds != other.ActiveDeadlineSeconds) return false;
      if (DnsPolicy != other.DnsPolicy) return false;
      if (!NodeSelector.Equals(other.NodeSelector)) return false;
      if (ServiceAccountName != other.ServiceAccountName) return false;
      if (ServiceAccount != other.ServiceAccount) return false;
      if (AutomountServiceAccountToken != other.AutomountServiceAccountToken) return false;
      if (NodeName != other.NodeName) return false;
      if (HostNetwork != other.HostNetwork) return false;
      if (HostPID != other.HostPID) return false;
      if (HostIPC != other.HostIPC) return false;
      if (ShareProcessNamespace != other.ShareProcessNamespace) return false;
      if (!object.Equals(SecurityContext, other.SecurityContext)) return false;
      if(!imagePullSecrets_.Equals(other.imagePullSecrets_)) return false;
      if (Hostname != other.Hostname) return false;
      if (Subdomain != other.Subdomain) return false;
      if (!object.Equals(Affinity, other.Affinity)) return false;
      if (SchedulerName != other.SchedulerName) return false;
      if(!tolerations_.Equals(other.tolerations_)) return false;
      if(!hostAliases_.Equals(other.hostAliases_)) return false;
      if (PriorityClassName != other.PriorityClassName) return false;
      if (Priority != other.Priority) return false;
      if (!object.Equals(DnsConfig, other.DnsConfig)) return false;
      if(!readinessGates_.Equals(other.readinessGates_)) return false;
      if (RuntimeClassName != other.RuntimeClassName) return false;
      if (EnableServiceLinks != other.EnableServiceLinks) return false;
      if (PreemptionPolicy != other.PreemptionPolicy) return false;
      if (!Overhead.Equals(other.Overhead)) return false;
      if(!topologySpreadConstraints_.Equals(other.topologySpreadConstraints_)) return false;
      if (SetHostnameAsFQDN != other.SetHostnameAsFQDN) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= volumes_.GetHashCode();
      hash ^= initContainers_.GetHashCode();
      hash ^= containers_.GetHashCode();
      hash ^= ephemeralContainers_.GetHashCode();
      if (HasRestartPolicy) hash ^= RestartPolicy.GetHashCode();
      if (HasTerminationGracePeriodSeconds) hash ^= TerminationGracePeriodSeconds.GetHashCode();
      if (HasActiveDeadlineSeconds) hash ^= ActiveDeadlineSeconds.GetHashCode();
      if (HasDnsPolicy) hash ^= DnsPolicy.GetHashCode();
      hash ^= NodeSelector.GetHashCode();
      if (HasServiceAccountName) hash ^= ServiceAccountName.GetHashCode();
      if (HasServiceAccount) hash ^= ServiceAccount.GetHashCode();
      if (HasAutomountServiceAccountToken) hash ^= AutomountServiceAccountToken.GetHashCode();
      if (HasNodeName) hash ^= NodeName.GetHashCode();
      if (HasHostNetwork) hash ^= HostNetwork.GetHashCode();
      if (HasHostPID) hash ^= HostPID.GetHashCode();
      if (HasHostIPC) hash ^= HostIPC.GetHashCode();
      if (HasShareProcessNamespace) hash ^= ShareProcessNamespace.GetHashCode();
      if (securityContext_ != null) hash ^= SecurityContext.GetHashCode();
      hash ^= imagePullSecrets_.GetHashCode();
      if (HasHostname) hash ^= Hostname.GetHashCode();
      if (HasSubdomain) hash ^= Subdomain.GetHashCode();
      if (affinity_ != null) hash ^= Affinity.GetHashCode();
      if (HasSchedulerName) hash ^= SchedulerName.GetHashCode();
      hash ^= tolerations_.GetHashCode();
      hash ^= hostAliases_.GetHashCode();
      if (HasPriorityClassName) hash ^= PriorityClassName.GetHashCode();
      if (HasPriority) hash ^= Priority.GetHashCode();
      if (dnsConfig_ != null) hash ^= DnsConfig.GetHashCode();
      hash ^= readinessGates_.GetHashCode();
      if (HasRuntimeClassName) hash ^= RuntimeClassName.GetHashCode();
      if (HasEnableServiceLinks) hash ^= EnableServiceLinks.GetHashCode();
      if (HasPreemptionPolicy) hash ^= PreemptionPolicy.GetHashCode();
      hash ^= Overhead.GetHashCode();
      hash ^= topologySpreadConstraints_.GetHashCode();
      if (HasSetHostnameAsFQDN) hash ^= SetHostnameAsFQDN.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      volumes_.WriteTo(output, _repeated_volumes_codec);
      containers_.WriteTo(output, _repeated_containers_codec);
      if (HasRestartPolicy) {
        output.WriteRawTag(26);
        output.WriteString(RestartPolicy);
      }
      if (HasTerminationGracePeriodSeconds) {
        output.WriteRawTag(32);
        output.WriteInt64(TerminationGracePeriodSeconds);
      }
      if (HasActiveDeadlineSeconds) {
        output.WriteRawTag(40);
        output.WriteInt64(ActiveDeadlineSeconds);
      }
      if (HasDnsPolicy) {
        output.WriteRawTag(50);
        output.WriteString(DnsPolicy);
      }
      nodeSelector_.WriteTo(output, _map_nodeSelector_codec);
      if (HasServiceAccountName) {
        output.WriteRawTag(66);
        output.WriteString(ServiceAccountName);
      }
      if (HasServiceAccount) {
        output.WriteRawTag(74);
        output.WriteString(ServiceAccount);
      }
      if (HasNodeName) {
        output.WriteRawTag(82);
        output.WriteString(NodeName);
      }
      if (HasHostNetwork) {
        output.WriteRawTag(88);
        output.WriteBool(HostNetwork);
      }
      if (HasHostPID) {
        output.WriteRawTag(96);
        output.WriteBool(HostPID);
      }
      if (HasHostIPC) {
        output.WriteRawTag(104);
        output.WriteBool(HostIPC);
      }
      if (securityContext_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(SecurityContext);
      }
      imagePullSecrets_.WriteTo(output, _repeated_imagePullSecrets_codec);
      if (HasHostname) {
        output.WriteRawTag(130, 1);
        output.WriteString(Hostname);
      }
      if (HasSubdomain) {
        output.WriteRawTag(138, 1);
        output.WriteString(Subdomain);
      }
      if (affinity_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(Affinity);
      }
      if (HasSchedulerName) {
        output.WriteRawTag(154, 1);
        output.WriteString(SchedulerName);
      }
      initContainers_.WriteTo(output, _repeated_initContainers_codec);
      if (HasAutomountServiceAccountToken) {
        output.WriteRawTag(168, 1);
        output.WriteBool(AutomountServiceAccountToken);
      }
      tolerations_.WriteTo(output, _repeated_tolerations_codec);
      hostAliases_.WriteTo(output, _repeated_hostAliases_codec);
      if (HasPriorityClassName) {
        output.WriteRawTag(194, 1);
        output.WriteString(PriorityClassName);
      }
      if (HasPriority) {
        output.WriteRawTag(200, 1);
        output.WriteInt32(Priority);
      }
      if (dnsConfig_ != null) {
        output.WriteRawTag(210, 1);
        output.WriteMessage(DnsConfig);
      }
      if (HasShareProcessNamespace) {
        output.WriteRawTag(216, 1);
        output.WriteBool(ShareProcessNamespace);
      }
      readinessGates_.WriteTo(output, _repeated_readinessGates_codec);
      if (HasRuntimeClassName) {
        output.WriteRawTag(234, 1);
        output.WriteString(RuntimeClassName);
      }
      if (HasEnableServiceLinks) {
        output.WriteRawTag(240, 1);
        output.WriteBool(EnableServiceLinks);
      }
      if (HasPreemptionPolicy) {
        output.WriteRawTag(250, 1);
        output.WriteString(PreemptionPolicy);
      }
      overhead_.WriteTo(output, _map_overhead_codec);
      topologySpreadConstraints_.WriteTo(output, _repeated_topologySpreadConstraints_codec);
      ephemeralContainers_.WriteTo(output, _repeated_ephemeralContainers_codec);
      if (HasSetHostnameAsFQDN) {
        output.WriteRawTag(152, 2);
        output.WriteBool(SetHostnameAsFQDN);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      volumes_.WriteTo(ref output, _repeated_volumes_codec);
      containers_.WriteTo(ref output, _repeated_containers_codec);
      if (HasRestartPolicy) {
        output.WriteRawTag(26);
        output.WriteString(RestartPolicy);
      }
      if (HasTerminationGracePeriodSeconds) {
        output.WriteRawTag(32);
        output.WriteInt64(TerminationGracePeriodSeconds);
      }
      if (HasActiveDeadlineSeconds) {
        output.WriteRawTag(40);
        output.WriteInt64(ActiveDeadlineSeconds);
      }
      if (HasDnsPolicy) {
        output.WriteRawTag(50);
        output.WriteString(DnsPolicy);
      }
      nodeSelector_.WriteTo(ref output, _map_nodeSelector_codec);
      if (HasServiceAccountName) {
        output.WriteRawTag(66);
        output.WriteString(ServiceAccountName);
      }
      if (HasServiceAccount) {
        output.WriteRawTag(74);
        output.WriteString(ServiceAccount);
      }
      if (HasNodeName) {
        output.WriteRawTag(82);
        output.WriteString(NodeName);
      }
      if (HasHostNetwork) {
        output.WriteRawTag(88);
        output.WriteBool(HostNetwork);
      }
      if (HasHostPID) {
        output.WriteRawTag(96);
        output.WriteBool(HostPID);
      }
      if (HasHostIPC) {
        output.WriteRawTag(104);
        output.WriteBool(HostIPC);
      }
      if (securityContext_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(SecurityContext);
      }
      imagePullSecrets_.WriteTo(ref output, _repeated_imagePullSecrets_codec);
      if (HasHostname) {
        output.WriteRawTag(130, 1);
        output.WriteString(Hostname);
      }
      if (HasSubdomain) {
        output.WriteRawTag(138, 1);
        output.WriteString(Subdomain);
      }
      if (affinity_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(Affinity);
      }
      if (HasSchedulerName) {
        output.WriteRawTag(154, 1);
        output.WriteString(SchedulerName);
      }
      initContainers_.WriteTo(ref output, _repeated_initContainers_codec);
      if (HasAutomountServiceAccountToken) {
        output.WriteRawTag(168, 1);
        output.WriteBool(AutomountServiceAccountToken);
      }
      tolerations_.WriteTo(ref output, _repeated_tolerations_codec);
      hostAliases_.WriteTo(ref output, _repeated_hostAliases_codec);
      if (HasPriorityClassName) {
        output.WriteRawTag(194, 1);
        output.WriteString(PriorityClassName);
      }
      if (HasPriority) {
        output.WriteRawTag(200, 1);
        output.WriteInt32(Priority);
      }
      if (dnsConfig_ != null) {
        output.WriteRawTag(210, 1);
        output.WriteMessage(DnsConfig);
      }
      if (HasShareProcessNamespace) {
        output.WriteRawTag(216, 1);
        output.WriteBool(ShareProcessNamespace);
      }
      readinessGates_.WriteTo(ref output, _repeated_readinessGates_codec);
      if (HasRuntimeClassName) {
        output.WriteRawTag(234, 1);
        output.WriteString(RuntimeClassName);
      }
      if (HasEnableServiceLinks) {
        output.WriteRawTag(240, 1);
        output.WriteBool(EnableServiceLinks);
      }
      if (HasPreemptionPolicy) {
        output.WriteRawTag(250, 1);
        output.WriteString(PreemptionPolicy);
      }
      overhead_.WriteTo(ref output, _map_overhead_codec);
      topologySpreadConstraints_.WriteTo(ref output, _repeated_topologySpreadConstraints_codec);
      ephemeralContainers_.WriteTo(ref output, _repeated_ephemeralContainers_codec);
      if (HasSetHostnameAsFQDN) {
        output.WriteRawTag(152, 2);
        output.WriteBool(SetHostnameAsFQDN);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += volumes_.CalculateSize(_repeated_volumes_codec);
      size += initContainers_.CalculateSize(_repeated_initContainers_codec);
      size += containers_.CalculateSize(_repeated_containers_codec);
      size += ephemeralContainers_.CalculateSize(_repeated_ephemeralContainers_codec);
      if (HasRestartPolicy) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RestartPolicy);
      }
      if (HasTerminationGracePeriodSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TerminationGracePeriodSeconds);
      }
      if (HasActiveDeadlineSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ActiveDeadlineSeconds);
      }
      if (HasDnsPolicy) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DnsPolicy);
      }
      size += nodeSelector_.CalculateSize(_map_nodeSelector_codec);
      if (HasServiceAccountName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceAccountName);
      }
      if (HasServiceAccount) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceAccount);
      }
      if (HasAutomountServiceAccountToken) {
        size += 2 + 1;
      }
      if (HasNodeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NodeName);
      }
      if (HasHostNetwork) {
        size += 1 + 1;
      }
      if (HasHostPID) {
        size += 1 + 1;
      }
      if (HasHostIPC) {
        size += 1 + 1;
      }
      if (HasShareProcessNamespace) {
        size += 2 + 1;
      }
      if (securityContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecurityContext);
      }
      size += imagePullSecrets_.CalculateSize(_repeated_imagePullSecrets_codec);
      if (HasHostname) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Hostname);
      }
      if (HasSubdomain) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Subdomain);
      }
      if (affinity_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Affinity);
      }
      if (HasSchedulerName) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(SchedulerName);
      }
      size += tolerations_.CalculateSize(_repeated_tolerations_codec);
      size += hostAliases_.CalculateSize(_repeated_hostAliases_codec);
      if (HasPriorityClassName) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(PriorityClassName);
      }
      if (HasPriority) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Priority);
      }
      if (dnsConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DnsConfig);
      }
      size += readinessGates_.CalculateSize(_repeated_readinessGates_codec);
      if (HasRuntimeClassName) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(RuntimeClassName);
      }
      if (HasEnableServiceLinks) {
        size += 2 + 1;
      }
      if (HasPreemptionPolicy) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(PreemptionPolicy);
      }
      size += overhead_.CalculateSize(_map_overhead_codec);
      size += topologySpreadConstraints_.CalculateSize(_repeated_topologySpreadConstraints_codec);
      if (HasSetHostnameAsFQDN) {
        size += 2 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodSpec other) {
      if (other == null) {
        return;
      }
      volumes_.Add(other.volumes_);
      initContainers_.Add(other.initContainers_);
      containers_.Add(other.containers_);
      ephemeralContainers_.Add(other.ephemeralContainers_);
      if (other.HasRestartPolicy) {
        RestartPolicy = other.RestartPolicy;
      }
      if (other.HasTerminationGracePeriodSeconds) {
        TerminationGracePeriodSeconds = other.TerminationGracePeriodSeconds;
      }
      if (other.HasActiveDeadlineSeconds) {
        ActiveDeadlineSeconds = other.ActiveDeadlineSeconds;
      }
      if (other.HasDnsPolicy) {
        DnsPolicy = other.DnsPolicy;
      }
      nodeSelector_.Add(other.nodeSelector_);
      if (other.HasServiceAccountName) {
        ServiceAccountName = other.ServiceAccountName;
      }
      if (other.HasServiceAccount) {
        ServiceAccount = other.ServiceAccount;
      }
      if (other.HasAutomountServiceAccountToken) {
        AutomountServiceAccountToken = other.AutomountServiceAccountToken;
      }
      if (other.HasNodeName) {
        NodeName = other.NodeName;
      }
      if (other.HasHostNetwork) {
        HostNetwork = other.HostNetwork;
      }
      if (other.HasHostPID) {
        HostPID = other.HostPID;
      }
      if (other.HasHostIPC) {
        HostIPC = other.HostIPC;
      }
      if (other.HasShareProcessNamespace) {
        ShareProcessNamespace = other.ShareProcessNamespace;
      }
      if (other.securityContext_ != null) {
        if (securityContext_ == null) {
          SecurityContext = new global::K8S.Io.Api.Core.V1.PodSecurityContext();
        }
        SecurityContext.MergeFrom(other.SecurityContext);
      }
      imagePullSecrets_.Add(other.imagePullSecrets_);
      if (other.HasHostname) {
        Hostname = other.Hostname;
      }
      if (other.HasSubdomain) {
        Subdomain = other.Subdomain;
      }
      if (other.affinity_ != null) {
        if (affinity_ == null) {
          Affinity = new global::K8S.Io.Api.Core.V1.Affinity();
        }
        Affinity.MergeFrom(other.Affinity);
      }
      if (other.HasSchedulerName) {
        SchedulerName = other.SchedulerName;
      }
      tolerations_.Add(other.tolerations_);
      hostAliases_.Add(other.hostAliases_);
      if (other.HasPriorityClassName) {
        PriorityClassName = other.PriorityClassName;
      }
      if (other.HasPriority) {
        Priority = other.Priority;
      }
      if (other.dnsConfig_ != null) {
        if (dnsConfig_ == null) {
          DnsConfig = new global::K8S.Io.Api.Core.V1.PodDNSConfig();
        }
        DnsConfig.MergeFrom(other.DnsConfig);
      }
      readinessGates_.Add(other.readinessGates_);
      if (other.HasRuntimeClassName) {
        RuntimeClassName = other.RuntimeClassName;
      }
      if (other.HasEnableServiceLinks) {
        EnableServiceLinks = other.EnableServiceLinks;
      }
      if (other.HasPreemptionPolicy) {
        PreemptionPolicy = other.PreemptionPolicy;
      }
      overhead_.Add(other.overhead_);
      topologySpreadConstraints_.Add(other.topologySpreadConstraints_);
      if (other.HasSetHostnameAsFQDN) {
        SetHostnameAsFQDN = other.SetHostnameAsFQDN;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            volumes_.AddEntriesFrom(input, _repeated_volumes_codec);
            break;
          }
          case 18: {
            containers_.AddEntriesFrom(input, _repeated_containers_codec);
            break;
          }
          case 26: {
            RestartPolicy = input.ReadString();
            break;
          }
          case 32: {
            TerminationGracePeriodSeconds = input.ReadInt64();
            break;
          }
          case 40: {
            ActiveDeadlineSeconds = input.ReadInt64();
            break;
          }
          case 50: {
            DnsPolicy = input.ReadString();
            break;
          }
          case 58: {
            nodeSelector_.AddEntriesFrom(input, _map_nodeSelector_codec);
            break;
          }
          case 66: {
            ServiceAccountName = input.ReadString();
            break;
          }
          case 74: {
            ServiceAccount = input.ReadString();
            break;
          }
          case 82: {
            NodeName = input.ReadString();
            break;
          }
          case 88: {
            HostNetwork = input.ReadBool();
            break;
          }
          case 96: {
            HostPID = input.ReadBool();
            break;
          }
          case 104: {
            HostIPC = input.ReadBool();
            break;
          }
          case 114: {
            if (securityContext_ == null) {
              SecurityContext = new global::K8S.Io.Api.Core.V1.PodSecurityContext();
            }
            input.ReadMessage(SecurityContext);
            break;
          }
          case 122: {
            imagePullSecrets_.AddEntriesFrom(input, _repeated_imagePullSecrets_codec);
            break;
          }
          case 130: {
            Hostname = input.ReadString();
            break;
          }
          case 138: {
            Subdomain = input.ReadString();
            break;
          }
          case 146: {
            if (affinity_ == null) {
              Affinity = new global::K8S.Io.Api.Core.V1.Affinity();
            }
            input.ReadMessage(Affinity);
            break;
          }
          case 154: {
            SchedulerName = input.ReadString();
            break;
          }
          case 162: {
            initContainers_.AddEntriesFrom(input, _repeated_initContainers_codec);
            break;
          }
          case 168: {
            AutomountServiceAccountToken = input.ReadBool();
            break;
          }
          case 178: {
            tolerations_.AddEntriesFrom(input, _repeated_tolerations_codec);
            break;
          }
          case 186: {
            hostAliases_.AddEntriesFrom(input, _repeated_hostAliases_codec);
            break;
          }
          case 194: {
            PriorityClassName = input.ReadString();
            break;
          }
          case 200: {
            Priority = input.ReadInt32();
            break;
          }
          case 210: {
            if (dnsConfig_ == null) {
              DnsConfig = new global::K8S.Io.Api.Core.V1.PodDNSConfig();
            }
            input.ReadMessage(DnsConfig);
            break;
          }
          case 216: {
            ShareProcessNamespace = input.ReadBool();
            break;
          }
          case 226: {
            readinessGates_.AddEntriesFrom(input, _repeated_readinessGates_codec);
            break;
          }
          case 234: {
            RuntimeClassName = input.ReadString();
            break;
          }
          case 240: {
            EnableServiceLinks = input.ReadBool();
            break;
          }
          case 250: {
            PreemptionPolicy = input.ReadString();
            break;
          }
          case 258: {
            overhead_.AddEntriesFrom(input, _map_overhead_codec);
            break;
          }
          case 266: {
            topologySpreadConstraints_.AddEntriesFrom(input, _repeated_topologySpreadConstraints_codec);
            break;
          }
          case 274: {
            ephemeralContainers_.AddEntriesFrom(input, _repeated_ephemeralContainers_codec);
            break;
          }
          case 280: {
            SetHostnameAsFQDN = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            volumes_.AddEntriesFrom(ref input, _repeated_volumes_codec);
            break;
          }
          case 18: {
            containers_.AddEntriesFrom(ref input, _repeated_containers_codec);
            break;
          }
          case 26: {
            RestartPolicy = input.ReadString();
            break;
          }
          case 32: {
            TerminationGracePeriodSeconds = input.ReadInt64();
            break;
          }
          case 40: {
            ActiveDeadlineSeconds = input.ReadInt64();
            break;
          }
          case 50: {
            DnsPolicy = input.ReadString();
            break;
          }
          case 58: {
            nodeSelector_.AddEntriesFrom(ref input, _map_nodeSelector_codec);
            break;
          }
          case 66: {
            ServiceAccountName = input.ReadString();
            break;
          }
          case 74: {
            ServiceAccount = input.ReadString();
            break;
          }
          case 82: {
            NodeName = input.ReadString();
            break;
          }
          case 88: {
            HostNetwork = input.ReadBool();
            break;
          }
          case 96: {
            HostPID = input.ReadBool();
            break;
          }
          case 104: {
            HostIPC = input.ReadBool();
            break;
          }
          case 114: {
            if (securityContext_ == null) {
              SecurityContext = new global::K8S.Io.Api.Core.V1.PodSecurityContext();
            }
            input.ReadMessage(SecurityContext);
            break;
          }
          case 122: {
            imagePullSecrets_.AddEntriesFrom(ref input, _repeated_imagePullSecrets_codec);
            break;
          }
          case 130: {
            Hostname = input.ReadString();
            break;
          }
          case 138: {
            Subdomain = input.ReadString();
            break;
          }
          case 146: {
            if (affinity_ == null) {
              Affinity = new global::K8S.Io.Api.Core.V1.Affinity();
            }
            input.ReadMessage(Affinity);
            break;
          }
          case 154: {
            SchedulerName = input.ReadString();
            break;
          }
          case 162: {
            initContainers_.AddEntriesFrom(ref input, _repeated_initContainers_codec);
            break;
          }
          case 168: {
            AutomountServiceAccountToken = input.ReadBool();
            break;
          }
          case 178: {
            tolerations_.AddEntriesFrom(ref input, _repeated_tolerations_codec);
            break;
          }
          case 186: {
            hostAliases_.AddEntriesFrom(ref input, _repeated_hostAliases_codec);
            break;
          }
          case 194: {
            PriorityClassName = input.ReadString();
            break;
          }
          case 200: {
            Priority = input.ReadInt32();
            break;
          }
          case 210: {
            if (dnsConfig_ == null) {
              DnsConfig = new global::K8S.Io.Api.Core.V1.PodDNSConfig();
            }
            input.ReadMessage(DnsConfig);
            break;
          }
          case 216: {
            ShareProcessNamespace = input.ReadBool();
            break;
          }
          case 226: {
            readinessGates_.AddEntriesFrom(ref input, _repeated_readinessGates_codec);
            break;
          }
          case 234: {
            RuntimeClassName = input.ReadString();
            break;
          }
          case 240: {
            EnableServiceLinks = input.ReadBool();
            break;
          }
          case 250: {
            PreemptionPolicy = input.ReadString();
            break;
          }
          case 258: {
            overhead_.AddEntriesFrom(ref input, _map_overhead_codec);
            break;
          }
          case 266: {
            topologySpreadConstraints_.AddEntriesFrom(ref input, _repeated_topologySpreadConstraints_codec);
            break;
          }
          case 274: {
            ephemeralContainers_.AddEntriesFrom(ref input, _repeated_ephemeralContainers_codec);
            break;
          }
          case 280: {
            SetHostnameAsFQDN = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodStatus represents information about the status of a pod. Status may trail the actual
  /// state of a system, especially if the node that hosts the pod cannot contact the control
  /// plane.
  /// </summary>
  public sealed partial class PodStatus : pb::IMessage<PodStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodStatus> _parser = new pb::MessageParser<PodStatus>(() => new PodStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[136]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodStatus(PodStatus other) : this() {
      phase_ = other.phase_;
      conditions_ = other.conditions_.Clone();
      message_ = other.message_;
      reason_ = other.reason_;
      nominatedNodeName_ = other.nominatedNodeName_;
      hostIP_ = other.hostIP_;
      podIP_ = other.podIP_;
      podIPs_ = other.podIPs_.Clone();
      startTime_ = other.startTime_ != null ? other.startTime_.Clone() : null;
      initContainerStatuses_ = other.initContainerStatuses_.Clone();
      containerStatuses_ = other.containerStatuses_.Clone();
      qosClass_ = other.qosClass_;
      ephemeralContainerStatuses_ = other.ephemeralContainerStatuses_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodStatus Clone() {
      return new PodStatus(this);
    }

    /// <summary>Field number for the "phase" field.</summary>
    public const int PhaseFieldNumber = 1;
    private readonly static string PhaseDefaultValue = "";

    private string phase_;
    /// <summary>
    /// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
    /// The conditions array, the reason and message fields, and the individual container status
    /// arrays contain more detail about the pod's status.
    /// There are five possible phase values:
    ///
    /// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
    /// container images has not been created. This includes time before being scheduled as
    /// well as time spent downloading images over the network, which could take a while.
    /// Running: The pod has been bound to a node, and all of the containers have been created.
    /// At least one container is still running, or is in the process of starting or restarting.
    /// Succeeded: All containers in the pod have terminated in success, and will not be restarted.
    /// Failed: All containers in the pod have terminated, and at least one container has
    /// terminated in failure. The container either exited with non-zero status or was terminated
    /// by the system.
    /// Unknown: For some reason the state of the pod could not be obtained, typically due to an
    /// error in communicating with the host of the pod.
    ///
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Phase {
      get { return phase_ ?? PhaseDefaultValue; }
      set {
        phase_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "phase" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPhase {
      get { return phase_ != null; }
    }
    /// <summary>Clears the value of the "phase" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPhase() {
      phase_ = null;
    }

    /// <summary>Field number for the "conditions" field.</summary>
    public const int ConditionsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PodCondition> _repeated_conditions_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.PodCondition.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodCondition> conditions_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodCondition>();
    /// <summary>
    /// Current service state of pod.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
    /// +optional
    /// +patchMergeKey=type
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodCondition> Conditions {
      get { return conditions_; }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 3;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// A human readable message indicating details about why the pod is in this condition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 4;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// A brief CamelCase message indicating details about why the pod is in this state.
    /// e.g. 'Evicted'
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    /// <summary>Field number for the "nominatedNodeName" field.</summary>
    public const int NominatedNodeNameFieldNumber = 11;
    private readonly static string NominatedNodeNameDefaultValue = "";

    private string nominatedNodeName_;
    /// <summary>
    /// nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
    /// scheduled right away as preemption victims receive their graceful termination periods.
    /// This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
    /// to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
    /// give the resources on this node to a higher priority pod that is created after preemption.
    /// As a result, this field may be different than PodSpec.nodeName when the pod is
    /// scheduled.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string NominatedNodeName {
      get { return nominatedNodeName_ ?? NominatedNodeNameDefaultValue; }
      set {
        nominatedNodeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "nominatedNodeName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNominatedNodeName {
      get { return nominatedNodeName_ != null; }
    }
    /// <summary>Clears the value of the "nominatedNodeName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNominatedNodeName() {
      nominatedNodeName_ = null;
    }

    /// <summary>Field number for the "hostIP" field.</summary>
    public const int HostIPFieldNumber = 5;
    private readonly static string HostIPDefaultValue = "";

    private string hostIP_;
    /// <summary>
    /// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string HostIP {
      get { return hostIP_ ?? HostIPDefaultValue; }
      set {
        hostIP_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "hostIP" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostIP {
      get { return hostIP_ != null; }
    }
    /// <summary>Clears the value of the "hostIP" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostIP() {
      hostIP_ = null;
    }

    /// <summary>Field number for the "podIP" field.</summary>
    public const int PodIPFieldNumber = 6;
    private readonly static string PodIPDefaultValue = "";

    private string podIP_;
    /// <summary>
    /// IP address allocated to the pod. Routable at least within the cluster.
    /// Empty if not yet allocated.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PodIP {
      get { return podIP_ ?? PodIPDefaultValue; }
      set {
        podIP_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "podIP" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPodIP {
      get { return podIP_ != null; }
    }
    /// <summary>Clears the value of the "podIP" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPodIP() {
      podIP_ = null;
    }

    /// <summary>Field number for the "podIPs" field.</summary>
    public const int PodIPsFieldNumber = 12;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PodIP> _repeated_podIPs_codec
        = pb::FieldCodec.ForMessage(98, global::K8S.Io.Api.Core.V1.PodIP.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodIP> podIPs_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodIP>();
    /// <summary>
    /// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
    /// match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
    /// is empty if no IPs have been allocated yet.
    /// +optional
    /// +patchStrategy=merge
    /// +patchMergeKey=ip
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodIP> PodIPs {
      get { return podIPs_; }
    }

    /// <summary>Field number for the "startTime" field.</summary>
    public const int StartTimeFieldNumber = 7;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time startTime_;
    /// <summary>
    /// RFC 3339 date and time at which the object was acknowledged by the Kubelet.
    /// This is before the Kubelet pulled the container image(s) for the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time StartTime {
      get { return startTime_; }
      set {
        startTime_ = value;
      }
    }

    /// <summary>Field number for the "initContainerStatuses" field.</summary>
    public const int InitContainerStatusesFieldNumber = 10;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ContainerStatus> _repeated_initContainerStatuses_codec
        = pb::FieldCodec.ForMessage(82, global::K8S.Io.Api.Core.V1.ContainerStatus.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerStatus> initContainerStatuses_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerStatus>();
    /// <summary>
    /// The list has one entry per init container in the manifest. The most recent successful
    /// init container will have ready = true, the most recently started container will have
    /// startTime set.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerStatus> InitContainerStatuses {
      get { return initContainerStatuses_; }
    }

    /// <summary>Field number for the "containerStatuses" field.</summary>
    public const int ContainerStatusesFieldNumber = 8;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ContainerStatus> _repeated_containerStatuses_codec
        = pb::FieldCodec.ForMessage(66, global::K8S.Io.Api.Core.V1.ContainerStatus.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerStatus> containerStatuses_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerStatus>();
    /// <summary>
    /// The list has one entry per container in the manifest. Each entry is currently the output
    /// of `docker inspect`.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerStatus> ContainerStatuses {
      get { return containerStatuses_; }
    }

    /// <summary>Field number for the "qosClass" field.</summary>
    public const int QosClassFieldNumber = 9;
    private readonly static string QosClassDefaultValue = "";

    private string qosClass_;
    /// <summary>
    /// The Quality of Service (QOS) classification assigned to the pod based on resource requirements
    /// See PodQOSClass type for available QOS classes
    /// More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string QosClass {
      get { return qosClass_ ?? QosClassDefaultValue; }
      set {
        qosClass_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "qosClass" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasQosClass {
      get { return qosClass_ != null; }
    }
    /// <summary>Clears the value of the "qosClass" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearQosClass() {
      qosClass_ = null;
    }

    /// <summary>Field number for the "ephemeralContainerStatuses" field.</summary>
    public const int EphemeralContainerStatusesFieldNumber = 13;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ContainerStatus> _repeated_ephemeralContainerStatuses_codec
        = pb::FieldCodec.ForMessage(106, global::K8S.Io.Api.Core.V1.ContainerStatus.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerStatus> ephemeralContainerStatuses_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerStatus>();
    /// <summary>
    /// Status for any ephemeral containers that have run in this pod.
    /// This field is alpha-level and is only populated by servers that enable the EphemeralContainers feature.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ContainerStatus> EphemeralContainerStatuses {
      get { return ephemeralContainerStatuses_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Phase != other.Phase) return false;
      if(!conditions_.Equals(other.conditions_)) return false;
      if (Message != other.Message) return false;
      if (Reason != other.Reason) return false;
      if (NominatedNodeName != other.NominatedNodeName) return false;
      if (HostIP != other.HostIP) return false;
      if (PodIP != other.PodIP) return false;
      if(!podIPs_.Equals(other.podIPs_)) return false;
      if (!object.Equals(StartTime, other.StartTime)) return false;
      if(!initContainerStatuses_.Equals(other.initContainerStatuses_)) return false;
      if(!containerStatuses_.Equals(other.containerStatuses_)) return false;
      if (QosClass != other.QosClass) return false;
      if(!ephemeralContainerStatuses_.Equals(other.ephemeralContainerStatuses_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPhase) hash ^= Phase.GetHashCode();
      hash ^= conditions_.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (HasReason) hash ^= Reason.GetHashCode();
      if (HasNominatedNodeName) hash ^= NominatedNodeName.GetHashCode();
      if (HasHostIP) hash ^= HostIP.GetHashCode();
      if (HasPodIP) hash ^= PodIP.GetHashCode();
      hash ^= podIPs_.GetHashCode();
      if (startTime_ != null) hash ^= StartTime.GetHashCode();
      hash ^= initContainerStatuses_.GetHashCode();
      hash ^= containerStatuses_.GetHashCode();
      if (HasQosClass) hash ^= QosClass.GetHashCode();
      hash ^= ephemeralContainerStatuses_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPhase) {
        output.WriteRawTag(10);
        output.WriteString(Phase);
      }
      conditions_.WriteTo(output, _repeated_conditions_codec);
      if (HasMessage) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (HasReason) {
        output.WriteRawTag(34);
        output.WriteString(Reason);
      }
      if (HasHostIP) {
        output.WriteRawTag(42);
        output.WriteString(HostIP);
      }
      if (HasPodIP) {
        output.WriteRawTag(50);
        output.WriteString(PodIP);
      }
      if (startTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(StartTime);
      }
      containerStatuses_.WriteTo(output, _repeated_containerStatuses_codec);
      if (HasQosClass) {
        output.WriteRawTag(74);
        output.WriteString(QosClass);
      }
      initContainerStatuses_.WriteTo(output, _repeated_initContainerStatuses_codec);
      if (HasNominatedNodeName) {
        output.WriteRawTag(90);
        output.WriteString(NominatedNodeName);
      }
      podIPs_.WriteTo(output, _repeated_podIPs_codec);
      ephemeralContainerStatuses_.WriteTo(output, _repeated_ephemeralContainerStatuses_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPhase) {
        output.WriteRawTag(10);
        output.WriteString(Phase);
      }
      conditions_.WriteTo(ref output, _repeated_conditions_codec);
      if (HasMessage) {
        output.WriteRawTag(26);
        output.WriteString(Message);
      }
      if (HasReason) {
        output.WriteRawTag(34);
        output.WriteString(Reason);
      }
      if (HasHostIP) {
        output.WriteRawTag(42);
        output.WriteString(HostIP);
      }
      if (HasPodIP) {
        output.WriteRawTag(50);
        output.WriteString(PodIP);
      }
      if (startTime_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(StartTime);
      }
      containerStatuses_.WriteTo(ref output, _repeated_containerStatuses_codec);
      if (HasQosClass) {
        output.WriteRawTag(74);
        output.WriteString(QosClass);
      }
      initContainerStatuses_.WriteTo(ref output, _repeated_initContainerStatuses_codec);
      if (HasNominatedNodeName) {
        output.WriteRawTag(90);
        output.WriteString(NominatedNodeName);
      }
      podIPs_.WriteTo(ref output, _repeated_podIPs_codec);
      ephemeralContainerStatuses_.WriteTo(ref output, _repeated_ephemeralContainerStatuses_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPhase) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Phase);
      }
      size += conditions_.CalculateSize(_repeated_conditions_codec);
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (HasNominatedNodeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NominatedNodeName);
      }
      if (HasHostIP) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HostIP);
      }
      if (HasPodIP) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PodIP);
      }
      size += podIPs_.CalculateSize(_repeated_podIPs_codec);
      if (startTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
      }
      size += initContainerStatuses_.CalculateSize(_repeated_initContainerStatuses_codec);
      size += containerStatuses_.CalculateSize(_repeated_containerStatuses_codec);
      if (HasQosClass) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(QosClass);
      }
      size += ephemeralContainerStatuses_.CalculateSize(_repeated_ephemeralContainerStatuses_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasPhase) {
        Phase = other.Phase;
      }
      conditions_.Add(other.conditions_);
      if (other.HasMessage) {
        Message = other.Message;
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      if (other.HasNominatedNodeName) {
        NominatedNodeName = other.NominatedNodeName;
      }
      if (other.HasHostIP) {
        HostIP = other.HostIP;
      }
      if (other.HasPodIP) {
        PodIP = other.PodIP;
      }
      podIPs_.Add(other.podIPs_);
      if (other.startTime_ != null) {
        if (startTime_ == null) {
          StartTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        StartTime.MergeFrom(other.StartTime);
      }
      initContainerStatuses_.Add(other.initContainerStatuses_);
      containerStatuses_.Add(other.containerStatuses_);
      if (other.HasQosClass) {
        QosClass = other.QosClass;
      }
      ephemeralContainerStatuses_.Add(other.ephemeralContainerStatuses_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Phase = input.ReadString();
            break;
          }
          case 18: {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            Reason = input.ReadString();
            break;
          }
          case 42: {
            HostIP = input.ReadString();
            break;
          }
          case 50: {
            PodIP = input.ReadString();
            break;
          }
          case 58: {
            if (startTime_ == null) {
              StartTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(StartTime);
            break;
          }
          case 66: {
            containerStatuses_.AddEntriesFrom(input, _repeated_containerStatuses_codec);
            break;
          }
          case 74: {
            QosClass = input.ReadString();
            break;
          }
          case 82: {
            initContainerStatuses_.AddEntriesFrom(input, _repeated_initContainerStatuses_codec);
            break;
          }
          case 90: {
            NominatedNodeName = input.ReadString();
            break;
          }
          case 98: {
            podIPs_.AddEntriesFrom(input, _repeated_podIPs_codec);
            break;
          }
          case 106: {
            ephemeralContainerStatuses_.AddEntriesFrom(input, _repeated_ephemeralContainerStatuses_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Phase = input.ReadString();
            break;
          }
          case 18: {
            conditions_.AddEntriesFrom(ref input, _repeated_conditions_codec);
            break;
          }
          case 26: {
            Message = input.ReadString();
            break;
          }
          case 34: {
            Reason = input.ReadString();
            break;
          }
          case 42: {
            HostIP = input.ReadString();
            break;
          }
          case 50: {
            PodIP = input.ReadString();
            break;
          }
          case 58: {
            if (startTime_ == null) {
              StartTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(StartTime);
            break;
          }
          case 66: {
            containerStatuses_.AddEntriesFrom(ref input, _repeated_containerStatuses_codec);
            break;
          }
          case 74: {
            QosClass = input.ReadString();
            break;
          }
          case 82: {
            initContainerStatuses_.AddEntriesFrom(ref input, _repeated_initContainerStatuses_codec);
            break;
          }
          case 90: {
            NominatedNodeName = input.ReadString();
            break;
          }
          case 98: {
            podIPs_.AddEntriesFrom(ref input, _repeated_podIPs_codec);
            break;
          }
          case 106: {
            ephemeralContainerStatuses_.AddEntriesFrom(ref input, _repeated_ephemeralContainerStatuses_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodStatusResult is a wrapper for PodStatus returned by kubelet that can be encode/decoded
  /// </summary>
  public sealed partial class PodStatusResult : pb::IMessage<PodStatusResult>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodStatusResult> _parser = new pb::MessageParser<PodStatusResult>(() => new PodStatusResult());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodStatusResult> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[137]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodStatusResult() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodStatusResult(PodStatusResult other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodStatusResult Clone() {
      return new PodStatusResult(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.PodStatus status_;
    /// <summary>
    /// Most recently observed status of the pod.
    /// This data may not be up to date.
    /// Populated by the system.
    /// Read-only.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodStatusResult);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodStatusResult other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (status_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (status_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodStatusResult other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::K8S.Io.Api.Core.V1.PodStatus();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.PodStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.PodStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodTemplate describes a template for creating copies of a predefined pod.
  /// </summary>
  public sealed partial class PodTemplate : pb::IMessage<PodTemplate>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodTemplate> _parser = new pb::MessageParser<PodTemplate>(() => new PodTemplate());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodTemplate> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[138]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodTemplate() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodTemplate(PodTemplate other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      template_ = other.template_ != null ? other.template_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodTemplate Clone() {
      return new PodTemplate(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "template" field.</summary>
    public const int TemplateFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.PodTemplateSpec template_;
    /// <summary>
    /// Template defines the pods that will be created from this pod template.
    /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodTemplateSpec Template {
      get { return template_; }
      set {
        template_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodTemplate);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodTemplate other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Template, other.Template)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (template_ != null) hash ^= Template.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (template_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Template);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (template_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Template);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (template_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Template);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodTemplate other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.template_ != null) {
        if (template_ == null) {
          Template = new global::K8S.Io.Api.Core.V1.PodTemplateSpec();
        }
        Template.MergeFrom(other.Template);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (template_ == null) {
              Template = new global::K8S.Io.Api.Core.V1.PodTemplateSpec();
            }
            input.ReadMessage(Template);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (template_ == null) {
              Template = new global::K8S.Io.Api.Core.V1.PodTemplateSpec();
            }
            input.ReadMessage(Template);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodTemplateList is a list of PodTemplates.
  /// </summary>
  public sealed partial class PodTemplateList : pb::IMessage<PodTemplateList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodTemplateList> _parser = new pb::MessageParser<PodTemplateList>(() => new PodTemplateList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodTemplateList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[139]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodTemplateList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodTemplateList(PodTemplateList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodTemplateList Clone() {
      return new PodTemplateList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.PodTemplate> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.PodTemplate.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodTemplate> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodTemplate>();
    /// <summary>
    /// List of pod templates
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.PodTemplate> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodTemplateList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodTemplateList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodTemplateList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PodTemplateSpec describes the data a pod should have when created from a template
  /// </summary>
  public sealed partial class PodTemplateSpec : pb::IMessage<PodTemplateSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PodTemplateSpec> _parser = new pb::MessageParser<PodTemplateSpec>(() => new PodTemplateSpec());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PodTemplateSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[140]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodTemplateSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodTemplateSpec(PodTemplateSpec other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PodTemplateSpec Clone() {
      return new PodTemplateSpec(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.PodSpec spec_;
    /// <summary>
    /// Specification of the desired behavior of the pod.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PodTemplateSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PodTemplateSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PodTemplateSpec other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.PodSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.PodSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.PodSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class PortStatus : pb::IMessage<PortStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PortStatus> _parser = new pb::MessageParser<PortStatus>(() => new PortStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PortStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[141]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PortStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PortStatus(PortStatus other) : this() {
      _hasBits0 = other._hasBits0;
      port_ = other.port_;
      protocol_ = other.protocol_;
      error_ = other.error_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PortStatus Clone() {
      return new PortStatus(this);
    }

    /// <summary>Field number for the "port" field.</summary>
    public const int PortFieldNumber = 1;
    private readonly static int PortDefaultValue = 0;

    private int port_;
    /// <summary>
    /// Port is the port number of the service port of which status is recorded here
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Port {
      get { if ((_hasBits0 & 1) != 0) { return port_; } else { return PortDefaultValue; } }
      set {
        _hasBits0 |= 1;
        port_ = value;
      }
    }
    /// <summary>Gets whether the "port" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPort {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "port" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPort() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 2;
    private readonly static string ProtocolDefaultValue = "";

    private string protocol_;
    /// <summary>
    /// Protocol is the protocol of the service port of which status is recorded here
    /// The supported values are: "TCP", "UDP", "SCTP"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Protocol {
      get { return protocol_ ?? ProtocolDefaultValue; }
      set {
        protocol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "protocol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProtocol {
      get { return protocol_ != null; }
    }
    /// <summary>Clears the value of the "protocol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProtocol() {
      protocol_ = null;
    }

    /// <summary>Field number for the "error" field.</summary>
    public const int ErrorFieldNumber = 3;
    private readonly static string ErrorDefaultValue = "";

    private string error_;
    /// <summary>
    /// Error is to record the problem with the service port
    /// The format of the error shall comply with the following rules:
    /// - built-in error values shall be specified in this file and those shall use
    ///   CamelCase names
    /// - cloud provider specific error values must have names that comply with the
    ///   format foo.example.com/CamelCase.
    /// ---
    /// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    /// +optional
    /// +kubebuilder:validation:Required
    /// +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
    /// +kubebuilder:validation:MaxLength=316
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Error {
      get { return error_ ?? ErrorDefaultValue; }
      set {
        error_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "error" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasError {
      get { return error_ != null; }
    }
    /// <summary>Clears the value of the "error" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearError() {
      error_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PortStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PortStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Port != other.Port) return false;
      if (Protocol != other.Protocol) return false;
      if (Error != other.Error) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPort) hash ^= Port.GetHashCode();
      if (HasProtocol) hash ^= Protocol.GetHashCode();
      if (HasError) hash ^= Error.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPort) {
        output.WriteRawTag(8);
        output.WriteInt32(Port);
      }
      if (HasProtocol) {
        output.WriteRawTag(18);
        output.WriteString(Protocol);
      }
      if (HasError) {
        output.WriteRawTag(26);
        output.WriteString(Error);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPort) {
        output.WriteRawTag(8);
        output.WriteInt32(Port);
      }
      if (HasProtocol) {
        output.WriteRawTag(18);
        output.WriteString(Protocol);
      }
      if (HasError) {
        output.WriteRawTag(26);
        output.WriteString(Error);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPort) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Port);
      }
      if (HasProtocol) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Protocol);
      }
      if (HasError) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Error);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PortStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasPort) {
        Port = other.Port;
      }
      if (other.HasProtocol) {
        Protocol = other.Protocol;
      }
      if (other.HasError) {
        Error = other.Error;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Port = input.ReadInt32();
            break;
          }
          case 18: {
            Protocol = input.ReadString();
            break;
          }
          case 26: {
            Error = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Port = input.ReadInt32();
            break;
          }
          case 18: {
            Protocol = input.ReadString();
            break;
          }
          case 26: {
            Error = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// PortworxVolumeSource represents a Portworx volume resource.
  /// </summary>
  public sealed partial class PortworxVolumeSource : pb::IMessage<PortworxVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PortworxVolumeSource> _parser = new pb::MessageParser<PortworxVolumeSource>(() => new PortworxVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PortworxVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[142]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PortworxVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PortworxVolumeSource(PortworxVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      volumeID_ = other.volumeID_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PortworxVolumeSource Clone() {
      return new PortworxVolumeSource(this);
    }

    /// <summary>Field number for the "volumeID" field.</summary>
    public const int VolumeIDFieldNumber = 1;
    private readonly static string VolumeIDDefaultValue = "";

    private string volumeID_;
    /// <summary>
    /// VolumeID uniquely identifies a Portworx volume
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeID {
      get { return volumeID_ ?? VolumeIDDefaultValue; }
      set {
        volumeID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeID {
      get { return volumeID_ != null; }
    }
    /// <summary>Clears the value of the "volumeID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeID() {
      volumeID_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 2;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// FSType represents the filesystem type to mount
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 3;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PortworxVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PortworxVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeID != other.VolumeID) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasVolumeID) hash ^= VolumeID.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasVolumeID) {
        output.WriteRawTag(10);
        output.WriteString(VolumeID);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasVolumeID) {
        output.WriteRawTag(10);
        output.WriteString(VolumeID);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasVolumeID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeID);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PortworxVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasVolumeID) {
        VolumeID = other.VolumeID;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeID = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            VolumeID = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
  /// +k8s:openapi-gen=false
  /// </summary>
  public sealed partial class Preconditions : pb::IMessage<Preconditions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Preconditions> _parser = new pb::MessageParser<Preconditions>(() => new Preconditions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Preconditions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[143]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Preconditions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Preconditions(Preconditions other) : this() {
      uid_ = other.uid_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Preconditions Clone() {
      return new Preconditions(this);
    }

    /// <summary>Field number for the "uid" field.</summary>
    public const int UidFieldNumber = 1;
    private readonly static string UidDefaultValue = "";

    private string uid_;
    /// <summary>
    /// Specifies the target UID.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Uid {
      get { return uid_ ?? UidDefaultValue; }
      set {
        uid_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "uid" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUid {
      get { return uid_ != null; }
    }
    /// <summary>Clears the value of the "uid" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUid() {
      uid_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Preconditions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Preconditions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Uid != other.Uid) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasUid) hash ^= Uid.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasUid) {
        output.WriteRawTag(10);
        output.WriteString(Uid);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasUid) {
        output.WriteRawTag(10);
        output.WriteString(Uid);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasUid) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Uid);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Preconditions other) {
      if (other == null) {
        return;
      }
      if (other.HasUid) {
        Uid = other.Uid;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Uid = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Uid = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Describes a class of pods that should avoid this node.
  /// </summary>
  public sealed partial class PreferAvoidPodsEntry : pb::IMessage<PreferAvoidPodsEntry>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PreferAvoidPodsEntry> _parser = new pb::MessageParser<PreferAvoidPodsEntry>(() => new PreferAvoidPodsEntry());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PreferAvoidPodsEntry> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[144]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PreferAvoidPodsEntry() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PreferAvoidPodsEntry(PreferAvoidPodsEntry other) : this() {
      podSignature_ = other.podSignature_ != null ? other.podSignature_.Clone() : null;
      evictionTime_ = other.evictionTime_ != null ? other.evictionTime_.Clone() : null;
      reason_ = other.reason_;
      message_ = other.message_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PreferAvoidPodsEntry Clone() {
      return new PreferAvoidPodsEntry(this);
    }

    /// <summary>Field number for the "podSignature" field.</summary>
    public const int PodSignatureFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.PodSignature podSignature_;
    /// <summary>
    /// The class of pods.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodSignature PodSignature {
      get { return podSignature_; }
      set {
        podSignature_ = value;
      }
    }

    /// <summary>Field number for the "evictionTime" field.</summary>
    public const int EvictionTimeFieldNumber = 2;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time evictionTime_;
    /// <summary>
    /// Time at which this entry was added to the list.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time EvictionTime {
      get { return evictionTime_; }
      set {
        evictionTime_ = value;
      }
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 3;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// (brief) reason why this entry was added to the list.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 4;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// Human readable message indicating why this entry was added to the list.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PreferAvoidPodsEntry);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PreferAvoidPodsEntry other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(PodSignature, other.PodSignature)) return false;
      if (!object.Equals(EvictionTime, other.EvictionTime)) return false;
      if (Reason != other.Reason) return false;
      if (Message != other.Message) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (podSignature_ != null) hash ^= PodSignature.GetHashCode();
      if (evictionTime_ != null) hash ^= EvictionTime.GetHashCode();
      if (HasReason) hash ^= Reason.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (podSignature_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PodSignature);
      }
      if (evictionTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(EvictionTime);
      }
      if (HasReason) {
        output.WriteRawTag(26);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(34);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (podSignature_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PodSignature);
      }
      if (evictionTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(EvictionTime);
      }
      if (HasReason) {
        output.WriteRawTag(26);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(34);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (podSignature_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PodSignature);
      }
      if (evictionTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EvictionTime);
      }
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PreferAvoidPodsEntry other) {
      if (other == null) {
        return;
      }
      if (other.podSignature_ != null) {
        if (podSignature_ == null) {
          PodSignature = new global::K8S.Io.Api.Core.V1.PodSignature();
        }
        PodSignature.MergeFrom(other.PodSignature);
      }
      if (other.evictionTime_ != null) {
        if (evictionTime_ == null) {
          EvictionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        EvictionTime.MergeFrom(other.EvictionTime);
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (podSignature_ == null) {
              PodSignature = new global::K8S.Io.Api.Core.V1.PodSignature();
            }
            input.ReadMessage(PodSignature);
            break;
          }
          case 18: {
            if (evictionTime_ == null) {
              EvictionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(EvictionTime);
            break;
          }
          case 26: {
            Reason = input.ReadString();
            break;
          }
          case 34: {
            Message = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (podSignature_ == null) {
              PodSignature = new global::K8S.Io.Api.Core.V1.PodSignature();
            }
            input.ReadMessage(PodSignature);
            break;
          }
          case 18: {
            if (evictionTime_ == null) {
              EvictionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(EvictionTime);
            break;
          }
          case 26: {
            Reason = input.ReadString();
            break;
          }
          case 34: {
            Message = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// An empty preferred scheduling term matches all objects with implicit weight 0
  /// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
  /// </summary>
  public sealed partial class PreferredSchedulingTerm : pb::IMessage<PreferredSchedulingTerm>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PreferredSchedulingTerm> _parser = new pb::MessageParser<PreferredSchedulingTerm>(() => new PreferredSchedulingTerm());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PreferredSchedulingTerm> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[145]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PreferredSchedulingTerm() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PreferredSchedulingTerm(PreferredSchedulingTerm other) : this() {
      _hasBits0 = other._hasBits0;
      weight_ = other.weight_;
      preference_ = other.preference_ != null ? other.preference_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PreferredSchedulingTerm Clone() {
      return new PreferredSchedulingTerm(this);
    }

    /// <summary>Field number for the "weight" field.</summary>
    public const int WeightFieldNumber = 1;
    private readonly static int WeightDefaultValue = 0;

    private int weight_;
    /// <summary>
    /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Weight {
      get { if ((_hasBits0 & 1) != 0) { return weight_; } else { return WeightDefaultValue; } }
      set {
        _hasBits0 |= 1;
        weight_ = value;
      }
    }
    /// <summary>Gets whether the "weight" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWeight {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "weight" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWeight() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "preference" field.</summary>
    public const int PreferenceFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.NodeSelectorTerm preference_;
    /// <summary>
    /// A node selector term, associated with the corresponding weight.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeSelectorTerm Preference {
      get { return preference_; }
      set {
        preference_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PreferredSchedulingTerm);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PreferredSchedulingTerm other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Weight != other.Weight) return false;
      if (!object.Equals(Preference, other.Preference)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasWeight) hash ^= Weight.GetHashCode();
      if (preference_ != null) hash ^= Preference.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasWeight) {
        output.WriteRawTag(8);
        output.WriteInt32(Weight);
      }
      if (preference_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Preference);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasWeight) {
        output.WriteRawTag(8);
        output.WriteInt32(Weight);
      }
      if (preference_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Preference);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasWeight) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Weight);
      }
      if (preference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Preference);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PreferredSchedulingTerm other) {
      if (other == null) {
        return;
      }
      if (other.HasWeight) {
        Weight = other.Weight;
      }
      if (other.preference_ != null) {
        if (preference_ == null) {
          Preference = new global::K8S.Io.Api.Core.V1.NodeSelectorTerm();
        }
        Preference.MergeFrom(other.Preference);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Weight = input.ReadInt32();
            break;
          }
          case 18: {
            if (preference_ == null) {
              Preference = new global::K8S.Io.Api.Core.V1.NodeSelectorTerm();
            }
            input.ReadMessage(Preference);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Weight = input.ReadInt32();
            break;
          }
          case 18: {
            if (preference_ == null) {
              Preference = new global::K8S.Io.Api.Core.V1.NodeSelectorTerm();
            }
            input.ReadMessage(Preference);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Probe describes a health check to be performed against a container to determine whether it is
  /// alive or ready to receive traffic.
  /// </summary>
  public sealed partial class Probe : pb::IMessage<Probe>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Probe> _parser = new pb::MessageParser<Probe>(() => new Probe());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Probe> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[146]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Probe() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Probe(Probe other) : this() {
      _hasBits0 = other._hasBits0;
      handler_ = other.handler_ != null ? other.handler_.Clone() : null;
      initialDelaySeconds_ = other.initialDelaySeconds_;
      timeoutSeconds_ = other.timeoutSeconds_;
      periodSeconds_ = other.periodSeconds_;
      successThreshold_ = other.successThreshold_;
      failureThreshold_ = other.failureThreshold_;
      terminationGracePeriodSeconds_ = other.terminationGracePeriodSeconds_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Probe Clone() {
      return new Probe(this);
    }

    /// <summary>Field number for the "handler" field.</summary>
    public const int HandlerFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.Handler handler_;
    /// <summary>
    /// The action taken to determine the health of a container
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Handler Handler {
      get { return handler_; }
      set {
        handler_ = value;
      }
    }

    /// <summary>Field number for the "initialDelaySeconds" field.</summary>
    public const int InitialDelaySecondsFieldNumber = 2;
    private readonly static int InitialDelaySecondsDefaultValue = 0;

    private int initialDelaySeconds_;
    /// <summary>
    /// Number of seconds after the container has started before liveness probes are initiated.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int InitialDelaySeconds {
      get { if ((_hasBits0 & 1) != 0) { return initialDelaySeconds_; } else { return InitialDelaySecondsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        initialDelaySeconds_ = value;
      }
    }
    /// <summary>Gets whether the "initialDelaySeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInitialDelaySeconds {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "initialDelaySeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInitialDelaySeconds() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "timeoutSeconds" field.</summary>
    public const int TimeoutSecondsFieldNumber = 3;
    private readonly static int TimeoutSecondsDefaultValue = 0;

    private int timeoutSeconds_;
    /// <summary>
    /// Number of seconds after which the probe times out.
    /// Defaults to 1 second. Minimum value is 1.
    /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int TimeoutSeconds {
      get { if ((_hasBits0 & 2) != 0) { return timeoutSeconds_; } else { return TimeoutSecondsDefaultValue; } }
      set {
        _hasBits0 |= 2;
        timeoutSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "timeoutSeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTimeoutSeconds {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "timeoutSeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTimeoutSeconds() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "periodSeconds" field.</summary>
    public const int PeriodSecondsFieldNumber = 4;
    private readonly static int PeriodSecondsDefaultValue = 0;

    private int periodSeconds_;
    /// <summary>
    /// How often (in seconds) to perform the probe.
    /// Default to 10 seconds. Minimum value is 1.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int PeriodSeconds {
      get { if ((_hasBits0 & 4) != 0) { return periodSeconds_; } else { return PeriodSecondsDefaultValue; } }
      set {
        _hasBits0 |= 4;
        periodSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "periodSeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPeriodSeconds {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "periodSeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPeriodSeconds() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "successThreshold" field.</summary>
    public const int SuccessThresholdFieldNumber = 5;
    private readonly static int SuccessThresholdDefaultValue = 0;

    private int successThreshold_;
    /// <summary>
    /// Minimum consecutive successes for the probe to be considered successful after having failed.
    /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int SuccessThreshold {
      get { if ((_hasBits0 & 8) != 0) { return successThreshold_; } else { return SuccessThresholdDefaultValue; } }
      set {
        _hasBits0 |= 8;
        successThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "successThreshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSuccessThreshold {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "successThreshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSuccessThreshold() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "failureThreshold" field.</summary>
    public const int FailureThresholdFieldNumber = 6;
    private readonly static int FailureThresholdDefaultValue = 0;

    private int failureThreshold_;
    /// <summary>
    /// Minimum consecutive failures for the probe to be considered failed after having succeeded.
    /// Defaults to 3. Minimum value is 1.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int FailureThreshold {
      get { if ((_hasBits0 & 16) != 0) { return failureThreshold_; } else { return FailureThresholdDefaultValue; } }
      set {
        _hasBits0 |= 16;
        failureThreshold_ = value;
      }
    }
    /// <summary>Gets whether the "failureThreshold" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFailureThreshold {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "failureThreshold" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFailureThreshold() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "terminationGracePeriodSeconds" field.</summary>
    public const int TerminationGracePeriodSecondsFieldNumber = 7;
    private readonly static long TerminationGracePeriodSecondsDefaultValue = 0L;

    private long terminationGracePeriodSeconds_;
    /// <summary>
    /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    /// The grace period is the duration in seconds after the processes running in the pod are sent
    /// a termination signal and the time when the processes are forcibly halted with a kill signal.
    /// Set this value longer than the expected cleanup time for your process.
    /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
    /// value overrides the value provided by the pod spec.
    /// Value must be non-negative integer. The value zero indicates stop immediately via
    /// the kill signal (no opportunity to shut down).
    /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
    /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TerminationGracePeriodSeconds {
      get { if ((_hasBits0 & 32) != 0) { return terminationGracePeriodSeconds_; } else { return TerminationGracePeriodSecondsDefaultValue; } }
      set {
        _hasBits0 |= 32;
        terminationGracePeriodSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "terminationGracePeriodSeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTerminationGracePeriodSeconds {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "terminationGracePeriodSeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTerminationGracePeriodSeconds() {
      _hasBits0 &= ~32;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Probe);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Probe other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Handler, other.Handler)) return false;
      if (InitialDelaySeconds != other.InitialDelaySeconds) return false;
      if (TimeoutSeconds != other.TimeoutSeconds) return false;
      if (PeriodSeconds != other.PeriodSeconds) return false;
      if (SuccessThreshold != other.SuccessThreshold) return false;
      if (FailureThreshold != other.FailureThreshold) return false;
      if (TerminationGracePeriodSeconds != other.TerminationGracePeriodSeconds) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (handler_ != null) hash ^= Handler.GetHashCode();
      if (HasInitialDelaySeconds) hash ^= InitialDelaySeconds.GetHashCode();
      if (HasTimeoutSeconds) hash ^= TimeoutSeconds.GetHashCode();
      if (HasPeriodSeconds) hash ^= PeriodSeconds.GetHashCode();
      if (HasSuccessThreshold) hash ^= SuccessThreshold.GetHashCode();
      if (HasFailureThreshold) hash ^= FailureThreshold.GetHashCode();
      if (HasTerminationGracePeriodSeconds) hash ^= TerminationGracePeriodSeconds.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (handler_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Handler);
      }
      if (HasInitialDelaySeconds) {
        output.WriteRawTag(16);
        output.WriteInt32(InitialDelaySeconds);
      }
      if (HasTimeoutSeconds) {
        output.WriteRawTag(24);
        output.WriteInt32(TimeoutSeconds);
      }
      if (HasPeriodSeconds) {
        output.WriteRawTag(32);
        output.WriteInt32(PeriodSeconds);
      }
      if (HasSuccessThreshold) {
        output.WriteRawTag(40);
        output.WriteInt32(SuccessThreshold);
      }
      if (HasFailureThreshold) {
        output.WriteRawTag(48);
        output.WriteInt32(FailureThreshold);
      }
      if (HasTerminationGracePeriodSeconds) {
        output.WriteRawTag(56);
        output.WriteInt64(TerminationGracePeriodSeconds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (handler_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Handler);
      }
      if (HasInitialDelaySeconds) {
        output.WriteRawTag(16);
        output.WriteInt32(InitialDelaySeconds);
      }
      if (HasTimeoutSeconds) {
        output.WriteRawTag(24);
        output.WriteInt32(TimeoutSeconds);
      }
      if (HasPeriodSeconds) {
        output.WriteRawTag(32);
        output.WriteInt32(PeriodSeconds);
      }
      if (HasSuccessThreshold) {
        output.WriteRawTag(40);
        output.WriteInt32(SuccessThreshold);
      }
      if (HasFailureThreshold) {
        output.WriteRawTag(48);
        output.WriteInt32(FailureThreshold);
      }
      if (HasTerminationGracePeriodSeconds) {
        output.WriteRawTag(56);
        output.WriteInt64(TerminationGracePeriodSeconds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (handler_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Handler);
      }
      if (HasInitialDelaySeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(InitialDelaySeconds);
      }
      if (HasTimeoutSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TimeoutSeconds);
      }
      if (HasPeriodSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PeriodSeconds);
      }
      if (HasSuccessThreshold) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SuccessThreshold);
      }
      if (HasFailureThreshold) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(FailureThreshold);
      }
      if (HasTerminationGracePeriodSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TerminationGracePeriodSeconds);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Probe other) {
      if (other == null) {
        return;
      }
      if (other.handler_ != null) {
        if (handler_ == null) {
          Handler = new global::K8S.Io.Api.Core.V1.Handler();
        }
        Handler.MergeFrom(other.Handler);
      }
      if (other.HasInitialDelaySeconds) {
        InitialDelaySeconds = other.InitialDelaySeconds;
      }
      if (other.HasTimeoutSeconds) {
        TimeoutSeconds = other.TimeoutSeconds;
      }
      if (other.HasPeriodSeconds) {
        PeriodSeconds = other.PeriodSeconds;
      }
      if (other.HasSuccessThreshold) {
        SuccessThreshold = other.SuccessThreshold;
      }
      if (other.HasFailureThreshold) {
        FailureThreshold = other.FailureThreshold;
      }
      if (other.HasTerminationGracePeriodSeconds) {
        TerminationGracePeriodSeconds = other.TerminationGracePeriodSeconds;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (handler_ == null) {
              Handler = new global::K8S.Io.Api.Core.V1.Handler();
            }
            input.ReadMessage(Handler);
            break;
          }
          case 16: {
            InitialDelaySeconds = input.ReadInt32();
            break;
          }
          case 24: {
            TimeoutSeconds = input.ReadInt32();
            break;
          }
          case 32: {
            PeriodSeconds = input.ReadInt32();
            break;
          }
          case 40: {
            SuccessThreshold = input.ReadInt32();
            break;
          }
          case 48: {
            FailureThreshold = input.ReadInt32();
            break;
          }
          case 56: {
            TerminationGracePeriodSeconds = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (handler_ == null) {
              Handler = new global::K8S.Io.Api.Core.V1.Handler();
            }
            input.ReadMessage(Handler);
            break;
          }
          case 16: {
            InitialDelaySeconds = input.ReadInt32();
            break;
          }
          case 24: {
            TimeoutSeconds = input.ReadInt32();
            break;
          }
          case 32: {
            PeriodSeconds = input.ReadInt32();
            break;
          }
          case 40: {
            SuccessThreshold = input.ReadInt32();
            break;
          }
          case 48: {
            FailureThreshold = input.ReadInt32();
            break;
          }
          case 56: {
            TerminationGracePeriodSeconds = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a projected volume source
  /// </summary>
  public sealed partial class ProjectedVolumeSource : pb::IMessage<ProjectedVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ProjectedVolumeSource> _parser = new pb::MessageParser<ProjectedVolumeSource>(() => new ProjectedVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ProjectedVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[147]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProjectedVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProjectedVolumeSource(ProjectedVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      sources_ = other.sources_.Clone();
      defaultMode_ = other.defaultMode_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ProjectedVolumeSource Clone() {
      return new ProjectedVolumeSource(this);
    }

    /// <summary>Field number for the "sources" field.</summary>
    public const int SourcesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.VolumeProjection> _repeated_sources_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.VolumeProjection.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeProjection> sources_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeProjection>();
    /// <summary>
    /// list of volume projections
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.VolumeProjection> Sources {
      get { return sources_; }
    }

    /// <summary>Field number for the "defaultMode" field.</summary>
    public const int DefaultModeFieldNumber = 2;
    private readonly static int DefaultModeDefaultValue = 0;

    private int defaultMode_;
    /// <summary>
    /// Mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int DefaultMode {
      get { if ((_hasBits0 & 1) != 0) { return defaultMode_; } else { return DefaultModeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        defaultMode_ = value;
      }
    }
    /// <summary>Gets whether the "defaultMode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDefaultMode {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "defaultMode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDefaultMode() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ProjectedVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ProjectedVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!sources_.Equals(other.sources_)) return false;
      if (DefaultMode != other.DefaultMode) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= sources_.GetHashCode();
      if (HasDefaultMode) hash ^= DefaultMode.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      sources_.WriteTo(output, _repeated_sources_codec);
      if (HasDefaultMode) {
        output.WriteRawTag(16);
        output.WriteInt32(DefaultMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      sources_.WriteTo(ref output, _repeated_sources_codec);
      if (HasDefaultMode) {
        output.WriteRawTag(16);
        output.WriteInt32(DefaultMode);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += sources_.CalculateSize(_repeated_sources_codec);
      if (HasDefaultMode) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DefaultMode);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ProjectedVolumeSource other) {
      if (other == null) {
        return;
      }
      sources_.Add(other.sources_);
      if (other.HasDefaultMode) {
        DefaultMode = other.DefaultMode;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            sources_.AddEntriesFrom(input, _repeated_sources_codec);
            break;
          }
          case 16: {
            DefaultMode = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            sources_.AddEntriesFrom(ref input, _repeated_sources_codec);
            break;
          }
          case 16: {
            DefaultMode = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Quobyte mount that lasts the lifetime of a pod.
  /// Quobyte volumes do not support ownership management or SELinux relabeling.
  /// </summary>
  public sealed partial class QuobyteVolumeSource : pb::IMessage<QuobyteVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<QuobyteVolumeSource> _parser = new pb::MessageParser<QuobyteVolumeSource>(() => new QuobyteVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<QuobyteVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[148]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QuobyteVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QuobyteVolumeSource(QuobyteVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      registry_ = other.registry_;
      volume_ = other.volume_;
      readOnly_ = other.readOnly_;
      user_ = other.user_;
      group_ = other.group_;
      tenant_ = other.tenant_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public QuobyteVolumeSource Clone() {
      return new QuobyteVolumeSource(this);
    }

    /// <summary>Field number for the "registry" field.</summary>
    public const int RegistryFieldNumber = 1;
    private readonly static string RegistryDefaultValue = "";

    private string registry_;
    /// <summary>
    /// Registry represents a single or multiple Quobyte Registry services
    /// specified as a string as host:port pair (multiple entries are separated with commas)
    /// which acts as the central registry for volumes
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Registry {
      get { return registry_ ?? RegistryDefaultValue; }
      set {
        registry_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "registry" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRegistry {
      get { return registry_ != null; }
    }
    /// <summary>Clears the value of the "registry" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRegistry() {
      registry_ = null;
    }

    /// <summary>Field number for the "volume" field.</summary>
    public const int VolumeFieldNumber = 2;
    private readonly static string VolumeDefaultValue = "";

    private string volume_;
    /// <summary>
    /// Volume is a string that references an already created Quobyte volume by name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Volume {
      get { return volume_ ?? VolumeDefaultValue; }
      set {
        volume_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volume" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolume {
      get { return volume_ != null; }
    }
    /// <summary>Clears the value of the "volume" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolume() {
      volume_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 3;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
    /// Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "user" field.</summary>
    public const int UserFieldNumber = 4;
    private readonly static string UserDefaultValue = "";

    private string user_;
    /// <summary>
    /// User to map volume access to
    /// Defaults to serivceaccount user
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string User {
      get { return user_ ?? UserDefaultValue; }
      set {
        user_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "user" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUser {
      get { return user_ != null; }
    }
    /// <summary>Clears the value of the "user" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUser() {
      user_ = null;
    }

    /// <summary>Field number for the "group" field.</summary>
    public const int GroupFieldNumber = 5;
    private readonly static string GroupDefaultValue = "";

    private string group_;
    /// <summary>
    /// Group to map volume access to
    /// Default is no group
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Group {
      get { return group_ ?? GroupDefaultValue; }
      set {
        group_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "group" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGroup {
      get { return group_ != null; }
    }
    /// <summary>Clears the value of the "group" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGroup() {
      group_ = null;
    }

    /// <summary>Field number for the "tenant" field.</summary>
    public const int TenantFieldNumber = 6;
    private readonly static string TenantDefaultValue = "";

    private string tenant_;
    /// <summary>
    /// Tenant owning the given Quobyte volume in the Backend
    /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Tenant {
      get { return tenant_ ?? TenantDefaultValue; }
      set {
        tenant_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "tenant" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTenant {
      get { return tenant_ != null; }
    }
    /// <summary>Clears the value of the "tenant" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTenant() {
      tenant_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as QuobyteVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(QuobyteVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Registry != other.Registry) return false;
      if (Volume != other.Volume) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (User != other.User) return false;
      if (Group != other.Group) return false;
      if (Tenant != other.Tenant) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRegistry) hash ^= Registry.GetHashCode();
      if (HasVolume) hash ^= Volume.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (HasUser) hash ^= User.GetHashCode();
      if (HasGroup) hash ^= Group.GetHashCode();
      if (HasTenant) hash ^= Tenant.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasRegistry) {
        output.WriteRawTag(10);
        output.WriteString(Registry);
      }
      if (HasVolume) {
        output.WriteRawTag(18);
        output.WriteString(Volume);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (HasUser) {
        output.WriteRawTag(34);
        output.WriteString(User);
      }
      if (HasGroup) {
        output.WriteRawTag(42);
        output.WriteString(Group);
      }
      if (HasTenant) {
        output.WriteRawTag(50);
        output.WriteString(Tenant);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasRegistry) {
        output.WriteRawTag(10);
        output.WriteString(Registry);
      }
      if (HasVolume) {
        output.WriteRawTag(18);
        output.WriteString(Volume);
      }
      if (HasReadOnly) {
        output.WriteRawTag(24);
        output.WriteBool(ReadOnly);
      }
      if (HasUser) {
        output.WriteRawTag(34);
        output.WriteString(User);
      }
      if (HasGroup) {
        output.WriteRawTag(42);
        output.WriteString(Group);
      }
      if (HasTenant) {
        output.WriteRawTag(50);
        output.WriteString(Tenant);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasRegistry) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Registry);
      }
      if (HasVolume) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Volume);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (HasUser) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(User);
      }
      if (HasGroup) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Group);
      }
      if (HasTenant) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Tenant);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(QuobyteVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasRegistry) {
        Registry = other.Registry;
      }
      if (other.HasVolume) {
        Volume = other.Volume;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.HasUser) {
        User = other.User;
      }
      if (other.HasGroup) {
        Group = other.Group;
      }
      if (other.HasTenant) {
        Tenant = other.Tenant;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Registry = input.ReadString();
            break;
          }
          case 18: {
            Volume = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            User = input.ReadString();
            break;
          }
          case 42: {
            Group = input.ReadString();
            break;
          }
          case 50: {
            Tenant = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Registry = input.ReadString();
            break;
          }
          case 18: {
            Volume = input.ReadString();
            break;
          }
          case 24: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 34: {
            User = input.ReadString();
            break;
          }
          case 42: {
            Group = input.ReadString();
            break;
          }
          case 50: {
            Tenant = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Rados Block Device mount that lasts the lifetime of a pod.
  /// RBD volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class RBDPersistentVolumeSource : pb::IMessage<RBDPersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RBDPersistentVolumeSource> _parser = new pb::MessageParser<RBDPersistentVolumeSource>(() => new RBDPersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RBDPersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[149]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBDPersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBDPersistentVolumeSource(RBDPersistentVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      monitors_ = other.monitors_.Clone();
      image_ = other.image_;
      fsType_ = other.fsType_;
      pool_ = other.pool_;
      user_ = other.user_;
      keyring_ = other.keyring_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBDPersistentVolumeSource Clone() {
      return new RBDPersistentVolumeSource(this);
    }

    /// <summary>Field number for the "monitors" field.</summary>
    public const int MonitorsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_monitors_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> monitors_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A collection of Ceph monitors.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Monitors {
      get { return monitors_; }
    }

    /// <summary>Field number for the "image" field.</summary>
    public const int ImageFieldNumber = 2;
    private readonly static string ImageDefaultValue = "";

    private string image_;
    /// <summary>
    /// The rados image name.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Image {
      get { return image_ ?? ImageDefaultValue; }
      set {
        image_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "image" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImage {
      get { return image_ != null; }
    }
    /// <summary>Clears the value of the "image" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImage() {
      image_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 3;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "pool" field.</summary>
    public const int PoolFieldNumber = 4;
    private readonly static string PoolDefaultValue = "";

    private string pool_;
    /// <summary>
    /// The rados pool name.
    /// Default is rbd.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Pool {
      get { return pool_ ?? PoolDefaultValue; }
      set {
        pool_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "pool" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPool {
      get { return pool_ != null; }
    }
    /// <summary>Clears the value of the "pool" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPool() {
      pool_ = null;
    }

    /// <summary>Field number for the "user" field.</summary>
    public const int UserFieldNumber = 5;
    private readonly static string UserDefaultValue = "";

    private string user_;
    /// <summary>
    /// The rados user name.
    /// Default is admin.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string User {
      get { return user_ ?? UserDefaultValue; }
      set {
        user_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "user" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUser {
      get { return user_ != null; }
    }
    /// <summary>Clears the value of the "user" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUser() {
      user_ = null;
    }

    /// <summary>Field number for the "keyring" field.</summary>
    public const int KeyringFieldNumber = 6;
    private readonly static string KeyringDefaultValue = "";

    private string keyring_;
    /// <summary>
    /// Keyring is the path to key ring for RBDUser.
    /// Default is /etc/ceph/keyring.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Keyring {
      get { return keyring_ ?? KeyringDefaultValue; }
      set {
        keyring_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "keyring" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKeyring {
      get { return keyring_ != null; }
    }
    /// <summary>Clears the value of the "keyring" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKeyring() {
      keyring_ = null;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 7;
    private global::K8S.Io.Api.Core.V1.SecretReference secretRef_;
    /// <summary>
    /// SecretRef is name of the authentication secret for RBDUser. If provided
    /// overrides keyring.
    /// Default is nil.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 8;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// ReadOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RBDPersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RBDPersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!monitors_.Equals(other.monitors_)) return false;
      if (Image != other.Image) return false;
      if (FsType != other.FsType) return false;
      if (Pool != other.Pool) return false;
      if (User != other.User) return false;
      if (Keyring != other.Keyring) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= monitors_.GetHashCode();
      if (HasImage) hash ^= Image.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasPool) hash ^= Pool.GetHashCode();
      if (HasUser) hash ^= User.GetHashCode();
      if (HasKeyring) hash ^= Keyring.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      monitors_.WriteTo(output, _repeated_monitors_codec);
      if (HasImage) {
        output.WriteRawTag(18);
        output.WriteString(Image);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      if (HasPool) {
        output.WriteRawTag(34);
        output.WriteString(Pool);
      }
      if (HasUser) {
        output.WriteRawTag(42);
        output.WriteString(User);
      }
      if (HasKeyring) {
        output.WriteRawTag(50);
        output.WriteString(Keyring);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(64);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      monitors_.WriteTo(ref output, _repeated_monitors_codec);
      if (HasImage) {
        output.WriteRawTag(18);
        output.WriteString(Image);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      if (HasPool) {
        output.WriteRawTag(34);
        output.WriteString(Pool);
      }
      if (HasUser) {
        output.WriteRawTag(42);
        output.WriteString(User);
      }
      if (HasKeyring) {
        output.WriteRawTag(50);
        output.WriteString(Keyring);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(64);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += monitors_.CalculateSize(_repeated_monitors_codec);
      if (HasImage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Image);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasPool) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Pool);
      }
      if (HasUser) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(User);
      }
      if (HasKeyring) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Keyring);
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RBDPersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      monitors_.Add(other.monitors_);
      if (other.HasImage) {
        Image = other.Image;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasPool) {
        Pool = other.Pool;
      }
      if (other.HasUser) {
        User = other.User;
      }
      if (other.HasKeyring) {
        Keyring = other.Keyring;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            monitors_.AddEntriesFrom(input, _repeated_monitors_codec);
            break;
          }
          case 18: {
            Image = input.ReadString();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 34: {
            Pool = input.ReadString();
            break;
          }
          case 42: {
            User = input.ReadString();
            break;
          }
          case 50: {
            Keyring = input.ReadString();
            break;
          }
          case 58: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 64: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            monitors_.AddEntriesFrom(ref input, _repeated_monitors_codec);
            break;
          }
          case 18: {
            Image = input.ReadString();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 34: {
            Pool = input.ReadString();
            break;
          }
          case 42: {
            User = input.ReadString();
            break;
          }
          case 50: {
            Keyring = input.ReadString();
            break;
          }
          case 58: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 64: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a Rados Block Device mount that lasts the lifetime of a pod.
  /// RBD volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class RBDVolumeSource : pb::IMessage<RBDVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RBDVolumeSource> _parser = new pb::MessageParser<RBDVolumeSource>(() => new RBDVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RBDVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[150]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBDVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBDVolumeSource(RBDVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      monitors_ = other.monitors_.Clone();
      image_ = other.image_;
      fsType_ = other.fsType_;
      pool_ = other.pool_;
      user_ = other.user_;
      keyring_ = other.keyring_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RBDVolumeSource Clone() {
      return new RBDVolumeSource(this);
    }

    /// <summary>Field number for the "monitors" field.</summary>
    public const int MonitorsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_monitors_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> monitors_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A collection of Ceph monitors.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Monitors {
      get { return monitors_; }
    }

    /// <summary>Field number for the "image" field.</summary>
    public const int ImageFieldNumber = 2;
    private readonly static string ImageDefaultValue = "";

    private string image_;
    /// <summary>
    /// The rados image name.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Image {
      get { return image_ ?? ImageDefaultValue; }
      set {
        image_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "image" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImage {
      get { return image_ != null; }
    }
    /// <summary>Clears the value of the "image" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImage() {
      image_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 3;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type of the volume that you want to mount.
    /// Tip: Ensure that the filesystem type is supported by the host operating system.
    /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
    /// TODO: how do we prevent errors in the filesystem from compromising the machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "pool" field.</summary>
    public const int PoolFieldNumber = 4;
    private readonly static string PoolDefaultValue = "";

    private string pool_;
    /// <summary>
    /// The rados pool name.
    /// Default is rbd.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Pool {
      get { return pool_ ?? PoolDefaultValue; }
      set {
        pool_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "pool" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPool {
      get { return pool_ != null; }
    }
    /// <summary>Clears the value of the "pool" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPool() {
      pool_ = null;
    }

    /// <summary>Field number for the "user" field.</summary>
    public const int UserFieldNumber = 5;
    private readonly static string UserDefaultValue = "";

    private string user_;
    /// <summary>
    /// The rados user name.
    /// Default is admin.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string User {
      get { return user_ ?? UserDefaultValue; }
      set {
        user_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "user" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUser {
      get { return user_ != null; }
    }
    /// <summary>Clears the value of the "user" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUser() {
      user_ = null;
    }

    /// <summary>Field number for the "keyring" field.</summary>
    public const int KeyringFieldNumber = 6;
    private readonly static string KeyringDefaultValue = "";

    private string keyring_;
    /// <summary>
    /// Keyring is the path to key ring for RBDUser.
    /// Default is /etc/ceph/keyring.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Keyring {
      get { return keyring_ ?? KeyringDefaultValue; }
      set {
        keyring_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "keyring" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKeyring {
      get { return keyring_ != null; }
    }
    /// <summary>Clears the value of the "keyring" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKeyring() {
      keyring_ = null;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 7;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference secretRef_;
    /// <summary>
    /// SecretRef is name of the authentication secret for RBDUser. If provided
    /// overrides keyring.
    /// Default is nil.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 8;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// ReadOnly here will force the ReadOnly setting in VolumeMounts.
    /// Defaults to false.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RBDVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RBDVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!monitors_.Equals(other.monitors_)) return false;
      if (Image != other.Image) return false;
      if (FsType != other.FsType) return false;
      if (Pool != other.Pool) return false;
      if (User != other.User) return false;
      if (Keyring != other.Keyring) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= monitors_.GetHashCode();
      if (HasImage) hash ^= Image.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasPool) hash ^= Pool.GetHashCode();
      if (HasUser) hash ^= User.GetHashCode();
      if (HasKeyring) hash ^= Keyring.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      monitors_.WriteTo(output, _repeated_monitors_codec);
      if (HasImage) {
        output.WriteRawTag(18);
        output.WriteString(Image);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      if (HasPool) {
        output.WriteRawTag(34);
        output.WriteString(Pool);
      }
      if (HasUser) {
        output.WriteRawTag(42);
        output.WriteString(User);
      }
      if (HasKeyring) {
        output.WriteRawTag(50);
        output.WriteString(Keyring);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(64);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      monitors_.WriteTo(ref output, _repeated_monitors_codec);
      if (HasImage) {
        output.WriteRawTag(18);
        output.WriteString(Image);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      if (HasPool) {
        output.WriteRawTag(34);
        output.WriteString(Pool);
      }
      if (HasUser) {
        output.WriteRawTag(42);
        output.WriteString(User);
      }
      if (HasKeyring) {
        output.WriteRawTag(50);
        output.WriteString(Keyring);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(SecretRef);
      }
      if (HasReadOnly) {
        output.WriteRawTag(64);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += monitors_.CalculateSize(_repeated_monitors_codec);
      if (HasImage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Image);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasPool) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Pool);
      }
      if (HasUser) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(User);
      }
      if (HasKeyring) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Keyring);
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RBDVolumeSource other) {
      if (other == null) {
        return;
      }
      monitors_.Add(other.monitors_);
      if (other.HasImage) {
        Image = other.Image;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasPool) {
        Pool = other.Pool;
      }
      if (other.HasUser) {
        User = other.User;
      }
      if (other.HasKeyring) {
        Keyring = other.Keyring;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            monitors_.AddEntriesFrom(input, _repeated_monitors_codec);
            break;
          }
          case 18: {
            Image = input.ReadString();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 34: {
            Pool = input.ReadString();
            break;
          }
          case 42: {
            User = input.ReadString();
            break;
          }
          case 50: {
            Keyring = input.ReadString();
            break;
          }
          case 58: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 64: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            monitors_.AddEntriesFrom(ref input, _repeated_monitors_codec);
            break;
          }
          case 18: {
            Image = input.ReadString();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 34: {
            Pool = input.ReadString();
            break;
          }
          case 42: {
            User = input.ReadString();
            break;
          }
          case 50: {
            Keyring = input.ReadString();
            break;
          }
          case 58: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 64: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// RangeAllocation is not a public type.
  /// </summary>
  public sealed partial class RangeAllocation : pb::IMessage<RangeAllocation>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<RangeAllocation> _parser = new pb::MessageParser<RangeAllocation>(() => new RangeAllocation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<RangeAllocation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[151]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RangeAllocation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RangeAllocation(RangeAllocation other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      range_ = other.range_;
      data_ = other.data_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public RangeAllocation Clone() {
      return new RangeAllocation(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "range" field.</summary>
    public const int RangeFieldNumber = 2;
    private readonly static string RangeDefaultValue = "";

    private string range_;
    /// <summary>
    /// Range is string that identifies the range represented by 'data'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Range {
      get { return range_ ?? RangeDefaultValue; }
      set {
        range_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "range" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRange {
      get { return range_ != null; }
    }
    /// <summary>Clears the value of the "range" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRange() {
      range_ = null;
    }

    /// <summary>Field number for the "data" field.</summary>
    public const int DataFieldNumber = 3;
    private readonly static pb::ByteString DataDefaultValue = pb::ByteString.Empty;

    private pb::ByteString data_;
    /// <summary>
    /// Data is a bit array containing all allocated addresses in the previous segment.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString Data {
      get { return data_ ?? DataDefaultValue; }
      set {
        data_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "data" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasData {
      get { return data_ != null; }
    }
    /// <summary>Clears the value of the "data" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearData() {
      data_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as RangeAllocation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(RangeAllocation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (Range != other.Range) return false;
      if (Data != other.Data) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (HasRange) hash ^= Range.GetHashCode();
      if (HasData) hash ^= Data.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (HasRange) {
        output.WriteRawTag(18);
        output.WriteString(Range);
      }
      if (HasData) {
        output.WriteRawTag(26);
        output.WriteBytes(Data);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (HasRange) {
        output.WriteRawTag(18);
        output.WriteString(Range);
      }
      if (HasData) {
        output.WriteRawTag(26);
        output.WriteBytes(Data);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (HasRange) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Range);
      }
      if (HasData) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Data);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(RangeAllocation other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.HasRange) {
        Range = other.Range;
      }
      if (other.HasData) {
        Data = other.Data;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            Range = input.ReadString();
            break;
          }
          case 26: {
            Data = input.ReadBytes();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            Range = input.ReadString();
            break;
          }
          case 26: {
            Data = input.ReadBytes();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ReplicationController represents the configuration of a replication controller.
  /// </summary>
  public sealed partial class ReplicationController : pb::IMessage<ReplicationController>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ReplicationController> _parser = new pb::MessageParser<ReplicationController>(() => new ReplicationController());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ReplicationController> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[152]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationController() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationController(ReplicationController other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationController Clone() {
      return new ReplicationController(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// If the Labels of a ReplicationController are empty, they are defaulted to
    /// be the same as the Pod(s) that the replication controller manages.
    /// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ReplicationControllerSpec spec_;
    /// <summary>
    /// Spec defines the specification of the desired behavior of the replication controller.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ReplicationControllerSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.ReplicationControllerStatus status_;
    /// <summary>
    /// Status is the most recently observed status of the replication controller.
    /// This data may be out of date by some window of time.
    /// Populated by the system.
    /// Read-only.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ReplicationControllerStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ReplicationController);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ReplicationController other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ReplicationController other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.ReplicationControllerSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::K8S.Io.Api.Core.V1.ReplicationControllerStatus();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.ReplicationControllerSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.ReplicationControllerStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.ReplicationControllerSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.ReplicationControllerStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ReplicationControllerCondition describes the state of a replication controller at a certain point.
  /// </summary>
  public sealed partial class ReplicationControllerCondition : pb::IMessage<ReplicationControllerCondition>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ReplicationControllerCondition> _parser = new pb::MessageParser<ReplicationControllerCondition>(() => new ReplicationControllerCondition());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ReplicationControllerCondition> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[153]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerCondition() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerCondition(ReplicationControllerCondition other) : this() {
      type_ = other.type_;
      status_ = other.status_;
      lastTransitionTime_ = other.lastTransitionTime_ != null ? other.lastTransitionTime_.Clone() : null;
      reason_ = other.reason_;
      message_ = other.message_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerCondition Clone() {
      return new ReplicationControllerCondition(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Type of replication controller condition.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 2;
    private readonly static string StatusDefaultValue = "";

    private string status_;
    /// <summary>
    /// Status of the condition, one of True, False, Unknown.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Status {
      get { return status_ ?? StatusDefaultValue; }
      set {
        status_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "status" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStatus {
      get { return status_ != null; }
    }
    /// <summary>Clears the value of the "status" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStatus() {
      status_ = null;
    }

    /// <summary>Field number for the "lastTransitionTime" field.</summary>
    public const int LastTransitionTimeFieldNumber = 3;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time lastTransitionTime_;
    /// <summary>
    /// The last time the condition transitioned from one status to another.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time LastTransitionTime {
      get { return lastTransitionTime_; }
      set {
        lastTransitionTime_ = value;
      }
    }

    /// <summary>Field number for the "reason" field.</summary>
    public const int ReasonFieldNumber = 4;
    private readonly static string ReasonDefaultValue = "";

    private string reason_;
    /// <summary>
    /// The reason for the condition's last transition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Reason {
      get { return reason_ ?? ReasonDefaultValue; }
      set {
        reason_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "reason" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReason {
      get { return reason_ != null; }
    }
    /// <summary>Clears the value of the "reason" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReason() {
      reason_ = null;
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 5;
    private readonly static string MessageDefaultValue = "";

    private string message_;
    /// <summary>
    /// A human readable message indicating details about the transition.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Message {
      get { return message_ ?? MessageDefaultValue; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "message" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMessage {
      get { return message_ != null; }
    }
    /// <summary>Clears the value of the "message" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMessage() {
      message_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ReplicationControllerCondition);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ReplicationControllerCondition other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Status != other.Status) return false;
      if (!object.Equals(LastTransitionTime, other.LastTransitionTime)) return false;
      if (Reason != other.Reason) return false;
      if (Message != other.Message) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasStatus) hash ^= Status.GetHashCode();
      if (lastTransitionTime_ != null) hash ^= LastTransitionTime.GetHashCode();
      if (HasReason) hash ^= Reason.GetHashCode();
      if (HasMessage) hash ^= Message.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (lastTransitionTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastTransitionTime);
      }
      if (HasReason) {
        output.WriteRawTag(34);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(42);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasStatus) {
        output.WriteRawTag(18);
        output.WriteString(Status);
      }
      if (lastTransitionTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(LastTransitionTime);
      }
      if (HasReason) {
        output.WriteRawTag(34);
        output.WriteString(Reason);
      }
      if (HasMessage) {
        output.WriteRawTag(42);
        output.WriteString(Message);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasStatus) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Status);
      }
      if (lastTransitionTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LastTransitionTime);
      }
      if (HasReason) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Reason);
      }
      if (HasMessage) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ReplicationControllerCondition other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasStatus) {
        Status = other.Status;
      }
      if (other.lastTransitionTime_ != null) {
        if (lastTransitionTime_ == null) {
          LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        LastTransitionTime.MergeFrom(other.LastTransitionTime);
      }
      if (other.HasReason) {
        Reason = other.Reason;
      }
      if (other.HasMessage) {
        Message = other.Message;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 26: {
            if (lastTransitionTime_ == null) {
              LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTransitionTime);
            break;
          }
          case 34: {
            Reason = input.ReadString();
            break;
          }
          case 42: {
            Message = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            Status = input.ReadString();
            break;
          }
          case 26: {
            if (lastTransitionTime_ == null) {
              LastTransitionTime = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(LastTransitionTime);
            break;
          }
          case 34: {
            Reason = input.ReadString();
            break;
          }
          case 42: {
            Message = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ReplicationControllerList is a collection of replication controllers.
  /// </summary>
  public sealed partial class ReplicationControllerList : pb::IMessage<ReplicationControllerList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ReplicationControllerList> _parser = new pb::MessageParser<ReplicationControllerList>(() => new ReplicationControllerList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ReplicationControllerList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[154]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerList(ReplicationControllerList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerList Clone() {
      return new ReplicationControllerList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ReplicationController> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.ReplicationController.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ReplicationController> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ReplicationController>();
    /// <summary>
    /// List of replication controllers.
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ReplicationController> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ReplicationControllerList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ReplicationControllerList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ReplicationControllerList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ReplicationControllerSpec is the specification of a replication controller.
  /// </summary>
  public sealed partial class ReplicationControllerSpec : pb::IMessage<ReplicationControllerSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ReplicationControllerSpec> _parser = new pb::MessageParser<ReplicationControllerSpec>(() => new ReplicationControllerSpec());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ReplicationControllerSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[155]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerSpec(ReplicationControllerSpec other) : this() {
      _hasBits0 = other._hasBits0;
      replicas_ = other.replicas_;
      minReadySeconds_ = other.minReadySeconds_;
      selector_ = other.selector_.Clone();
      template_ = other.template_ != null ? other.template_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerSpec Clone() {
      return new ReplicationControllerSpec(this);
    }

    /// <summary>Field number for the "replicas" field.</summary>
    public const int ReplicasFieldNumber = 1;
    private readonly static int ReplicasDefaultValue = 0;

    private int replicas_;
    /// <summary>
    /// Replicas is the number of desired replicas.
    /// This is a pointer to distinguish between explicit zero and unspecified.
    /// Defaults to 1.
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Replicas {
      get { if ((_hasBits0 & 1) != 0) { return replicas_; } else { return ReplicasDefaultValue; } }
      set {
        _hasBits0 |= 1;
        replicas_ = value;
      }
    }
    /// <summary>Gets whether the "replicas" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReplicas {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "replicas" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReplicas() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "minReadySeconds" field.</summary>
    public const int MinReadySecondsFieldNumber = 4;
    private readonly static int MinReadySecondsDefaultValue = 0;

    private int minReadySeconds_;
    /// <summary>
    /// Minimum number of seconds for which a newly created pod should be ready
    /// without any of its container crashing, for it to be considered available.
    /// Defaults to 0 (pod will be considered available as soon as it is ready)
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MinReadySeconds {
      get { if ((_hasBits0 & 2) != 0) { return minReadySeconds_; } else { return MinReadySecondsDefaultValue; } }
      set {
        _hasBits0 |= 2;
        minReadySeconds_ = value;
      }
    }
    /// <summary>Gets whether the "minReadySeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMinReadySeconds {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "minReadySeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMinReadySeconds() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "selector" field.</summary>
    public const int SelectorFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_selector_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 18);
    private readonly pbc::MapField<string, string> selector_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Selector is a label query over pods that should match the Replicas count.
    /// If Selector is empty, it is defaulted to the labels present on the Pod template.
    /// Label keys and values that must match in order to be controlled by this replication
    /// controller, if empty defaulted to labels on Pod template.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
    /// +optional
    /// +mapType=atomic
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> Selector {
      get { return selector_; }
    }

    /// <summary>Field number for the "template" field.</summary>
    public const int TemplateFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.PodTemplateSpec template_;
    /// <summary>
    /// Template is the object that describes the pod that will be created if
    /// insufficient replicas are detected. This takes precedence over a TemplateRef.
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodTemplateSpec Template {
      get { return template_; }
      set {
        template_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ReplicationControllerSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ReplicationControllerSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Replicas != other.Replicas) return false;
      if (MinReadySeconds != other.MinReadySeconds) return false;
      if (!Selector.Equals(other.Selector)) return false;
      if (!object.Equals(Template, other.Template)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasReplicas) hash ^= Replicas.GetHashCode();
      if (HasMinReadySeconds) hash ^= MinReadySeconds.GetHashCode();
      hash ^= Selector.GetHashCode();
      if (template_ != null) hash ^= Template.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasReplicas) {
        output.WriteRawTag(8);
        output.WriteInt32(Replicas);
      }
      selector_.WriteTo(output, _map_selector_codec);
      if (template_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Template);
      }
      if (HasMinReadySeconds) {
        output.WriteRawTag(32);
        output.WriteInt32(MinReadySeconds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasReplicas) {
        output.WriteRawTag(8);
        output.WriteInt32(Replicas);
      }
      selector_.WriteTo(ref output, _map_selector_codec);
      if (template_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Template);
      }
      if (HasMinReadySeconds) {
        output.WriteRawTag(32);
        output.WriteInt32(MinReadySeconds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasReplicas) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Replicas);
      }
      if (HasMinReadySeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinReadySeconds);
      }
      size += selector_.CalculateSize(_map_selector_codec);
      if (template_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Template);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ReplicationControllerSpec other) {
      if (other == null) {
        return;
      }
      if (other.HasReplicas) {
        Replicas = other.Replicas;
      }
      if (other.HasMinReadySeconds) {
        MinReadySeconds = other.MinReadySeconds;
      }
      selector_.Add(other.selector_);
      if (other.template_ != null) {
        if (template_ == null) {
          Template = new global::K8S.Io.Api.Core.V1.PodTemplateSpec();
        }
        Template.MergeFrom(other.Template);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Replicas = input.ReadInt32();
            break;
          }
          case 18: {
            selector_.AddEntriesFrom(input, _map_selector_codec);
            break;
          }
          case 26: {
            if (template_ == null) {
              Template = new global::K8S.Io.Api.Core.V1.PodTemplateSpec();
            }
            input.ReadMessage(Template);
            break;
          }
          case 32: {
            MinReadySeconds = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Replicas = input.ReadInt32();
            break;
          }
          case 18: {
            selector_.AddEntriesFrom(ref input, _map_selector_codec);
            break;
          }
          case 26: {
            if (template_ == null) {
              Template = new global::K8S.Io.Api.Core.V1.PodTemplateSpec();
            }
            input.ReadMessage(Template);
            break;
          }
          case 32: {
            MinReadySeconds = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ReplicationControllerStatus represents the current status of a replication
  /// controller.
  /// </summary>
  public sealed partial class ReplicationControllerStatus : pb::IMessage<ReplicationControllerStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ReplicationControllerStatus> _parser = new pb::MessageParser<ReplicationControllerStatus>(() => new ReplicationControllerStatus());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ReplicationControllerStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[156]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerStatus(ReplicationControllerStatus other) : this() {
      _hasBits0 = other._hasBits0;
      replicas_ = other.replicas_;
      fullyLabeledReplicas_ = other.fullyLabeledReplicas_;
      readyReplicas_ = other.readyReplicas_;
      availableReplicas_ = other.availableReplicas_;
      observedGeneration_ = other.observedGeneration_;
      conditions_ = other.conditions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ReplicationControllerStatus Clone() {
      return new ReplicationControllerStatus(this);
    }

    /// <summary>Field number for the "replicas" field.</summary>
    public const int ReplicasFieldNumber = 1;
    private readonly static int ReplicasDefaultValue = 0;

    private int replicas_;
    /// <summary>
    /// Replicas is the most recently oberved number of replicas.
    /// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Replicas {
      get { if ((_hasBits0 & 1) != 0) { return replicas_; } else { return ReplicasDefaultValue; } }
      set {
        _hasBits0 |= 1;
        replicas_ = value;
      }
    }
    /// <summary>Gets whether the "replicas" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReplicas {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "replicas" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReplicas() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "fullyLabeledReplicas" field.</summary>
    public const int FullyLabeledReplicasFieldNumber = 2;
    private readonly static int FullyLabeledReplicasDefaultValue = 0;

    private int fullyLabeledReplicas_;
    /// <summary>
    /// The number of pods that have labels matching the labels of the pod template of the replication controller.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int FullyLabeledReplicas {
      get { if ((_hasBits0 & 2) != 0) { return fullyLabeledReplicas_; } else { return FullyLabeledReplicasDefaultValue; } }
      set {
        _hasBits0 |= 2;
        fullyLabeledReplicas_ = value;
      }
    }
    /// <summary>Gets whether the "fullyLabeledReplicas" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFullyLabeledReplicas {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "fullyLabeledReplicas" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFullyLabeledReplicas() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "readyReplicas" field.</summary>
    public const int ReadyReplicasFieldNumber = 4;
    private readonly static int ReadyReplicasDefaultValue = 0;

    private int readyReplicas_;
    /// <summary>
    /// The number of ready replicas for this replication controller.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int ReadyReplicas {
      get { if ((_hasBits0 & 8) != 0) { return readyReplicas_; } else { return ReadyReplicasDefaultValue; } }
      set {
        _hasBits0 |= 8;
        readyReplicas_ = value;
      }
    }
    /// <summary>Gets whether the "readyReplicas" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadyReplicas {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "readyReplicas" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadyReplicas() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "availableReplicas" field.</summary>
    public const int AvailableReplicasFieldNumber = 5;
    private readonly static int AvailableReplicasDefaultValue = 0;

    private int availableReplicas_;
    /// <summary>
    /// The number of available replicas (ready for at least minReadySeconds) for this replication controller.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int AvailableReplicas {
      get { if ((_hasBits0 & 16) != 0) { return availableReplicas_; } else { return AvailableReplicasDefaultValue; } }
      set {
        _hasBits0 |= 16;
        availableReplicas_ = value;
      }
    }
    /// <summary>Gets whether the "availableReplicas" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAvailableReplicas {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "availableReplicas" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAvailableReplicas() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "observedGeneration" field.</summary>
    public const int ObservedGenerationFieldNumber = 3;
    private readonly static long ObservedGenerationDefaultValue = 0L;

    private long observedGeneration_;
    /// <summary>
    /// ObservedGeneration reflects the generation of the most recently observed replication controller.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ObservedGeneration {
      get { if ((_hasBits0 & 4) != 0) { return observedGeneration_; } else { return ObservedGenerationDefaultValue; } }
      set {
        _hasBits0 |= 4;
        observedGeneration_ = value;
      }
    }
    /// <summary>Gets whether the "observedGeneration" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasObservedGeneration {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "observedGeneration" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearObservedGeneration() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "conditions" field.</summary>
    public const int ConditionsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ReplicationControllerCondition> _repeated_conditions_codec
        = pb::FieldCodec.ForMessage(50, global::K8S.Io.Api.Core.V1.ReplicationControllerCondition.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ReplicationControllerCondition> conditions_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ReplicationControllerCondition>();
    /// <summary>
    /// Represents the latest available observations of a replication controller's current state.
    /// +optional
    /// +patchMergeKey=type
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ReplicationControllerCondition> Conditions {
      get { return conditions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ReplicationControllerStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ReplicationControllerStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Replicas != other.Replicas) return false;
      if (FullyLabeledReplicas != other.FullyLabeledReplicas) return false;
      if (ReadyReplicas != other.ReadyReplicas) return false;
      if (AvailableReplicas != other.AvailableReplicas) return false;
      if (ObservedGeneration != other.ObservedGeneration) return false;
      if(!conditions_.Equals(other.conditions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasReplicas) hash ^= Replicas.GetHashCode();
      if (HasFullyLabeledReplicas) hash ^= FullyLabeledReplicas.GetHashCode();
      if (HasReadyReplicas) hash ^= ReadyReplicas.GetHashCode();
      if (HasAvailableReplicas) hash ^= AvailableReplicas.GetHashCode();
      if (HasObservedGeneration) hash ^= ObservedGeneration.GetHashCode();
      hash ^= conditions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasReplicas) {
        output.WriteRawTag(8);
        output.WriteInt32(Replicas);
      }
      if (HasFullyLabeledReplicas) {
        output.WriteRawTag(16);
        output.WriteInt32(FullyLabeledReplicas);
      }
      if (HasObservedGeneration) {
        output.WriteRawTag(24);
        output.WriteInt64(ObservedGeneration);
      }
      if (HasReadyReplicas) {
        output.WriteRawTag(32);
        output.WriteInt32(ReadyReplicas);
      }
      if (HasAvailableReplicas) {
        output.WriteRawTag(40);
        output.WriteInt32(AvailableReplicas);
      }
      conditions_.WriteTo(output, _repeated_conditions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasReplicas) {
        output.WriteRawTag(8);
        output.WriteInt32(Replicas);
      }
      if (HasFullyLabeledReplicas) {
        output.WriteRawTag(16);
        output.WriteInt32(FullyLabeledReplicas);
      }
      if (HasObservedGeneration) {
        output.WriteRawTag(24);
        output.WriteInt64(ObservedGeneration);
      }
      if (HasReadyReplicas) {
        output.WriteRawTag(32);
        output.WriteInt32(ReadyReplicas);
      }
      if (HasAvailableReplicas) {
        output.WriteRawTag(40);
        output.WriteInt32(AvailableReplicas);
      }
      conditions_.WriteTo(ref output, _repeated_conditions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasReplicas) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Replicas);
      }
      if (HasFullyLabeledReplicas) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(FullyLabeledReplicas);
      }
      if (HasReadyReplicas) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ReadyReplicas);
      }
      if (HasAvailableReplicas) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(AvailableReplicas);
      }
      if (HasObservedGeneration) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ObservedGeneration);
      }
      size += conditions_.CalculateSize(_repeated_conditions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ReplicationControllerStatus other) {
      if (other == null) {
        return;
      }
      if (other.HasReplicas) {
        Replicas = other.Replicas;
      }
      if (other.HasFullyLabeledReplicas) {
        FullyLabeledReplicas = other.FullyLabeledReplicas;
      }
      if (other.HasReadyReplicas) {
        ReadyReplicas = other.ReadyReplicas;
      }
      if (other.HasAvailableReplicas) {
        AvailableReplicas = other.AvailableReplicas;
      }
      if (other.HasObservedGeneration) {
        ObservedGeneration = other.ObservedGeneration;
      }
      conditions_.Add(other.conditions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Replicas = input.ReadInt32();
            break;
          }
          case 16: {
            FullyLabeledReplicas = input.ReadInt32();
            break;
          }
          case 24: {
            ObservedGeneration = input.ReadInt64();
            break;
          }
          case 32: {
            ReadyReplicas = input.ReadInt32();
            break;
          }
          case 40: {
            AvailableReplicas = input.ReadInt32();
            break;
          }
          case 50: {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Replicas = input.ReadInt32();
            break;
          }
          case 16: {
            FullyLabeledReplicas = input.ReadInt32();
            break;
          }
          case 24: {
            ObservedGeneration = input.ReadInt64();
            break;
          }
          case 32: {
            ReadyReplicas = input.ReadInt32();
            break;
          }
          case 40: {
            AvailableReplicas = input.ReadInt32();
            break;
          }
          case 50: {
            conditions_.AddEntriesFrom(ref input, _repeated_conditions_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ResourceFieldSelector represents container resources (cpu, memory) and their output format
  /// +structType=atomic
  /// </summary>
  public sealed partial class ResourceFieldSelector : pb::IMessage<ResourceFieldSelector>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ResourceFieldSelector> _parser = new pb::MessageParser<ResourceFieldSelector>(() => new ResourceFieldSelector());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ResourceFieldSelector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[157]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceFieldSelector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceFieldSelector(ResourceFieldSelector other) : this() {
      containerName_ = other.containerName_;
      resource_ = other.resource_;
      divisor_ = other.divisor_ != null ? other.divisor_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceFieldSelector Clone() {
      return new ResourceFieldSelector(this);
    }

    /// <summary>Field number for the "containerName" field.</summary>
    public const int ContainerNameFieldNumber = 1;
    private readonly static string ContainerNameDefaultValue = "";

    private string containerName_;
    /// <summary>
    /// Container name: required for volumes, optional for env vars
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ContainerName {
      get { return containerName_ ?? ContainerNameDefaultValue; }
      set {
        containerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "containerName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasContainerName {
      get { return containerName_ != null; }
    }
    /// <summary>Clears the value of the "containerName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearContainerName() {
      containerName_ = null;
    }

    /// <summary>Field number for the "resource" field.</summary>
    public const int ResourceFieldNumber = 2;
    private readonly static string ResourceDefaultValue = "";

    private string resource_;
    /// <summary>
    /// Required: resource to select
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Resource {
      get { return resource_ ?? ResourceDefaultValue; }
      set {
        resource_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "resource" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasResource {
      get { return resource_ != null; }
    }
    /// <summary>Clears the value of the "resource" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearResource() {
      resource_ = null;
    }

    /// <summary>Field number for the "divisor" field.</summary>
    public const int DivisorFieldNumber = 3;
    private global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity divisor_;
    /// <summary>
    /// Specifies the output format of the exposed resources, defaults to "1"
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity Divisor {
      get { return divisor_; }
      set {
        divisor_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ResourceFieldSelector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ResourceFieldSelector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ContainerName != other.ContainerName) return false;
      if (Resource != other.Resource) return false;
      if (!object.Equals(Divisor, other.Divisor)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasContainerName) hash ^= ContainerName.GetHashCode();
      if (HasResource) hash ^= Resource.GetHashCode();
      if (divisor_ != null) hash ^= Divisor.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasContainerName) {
        output.WriteRawTag(10);
        output.WriteString(ContainerName);
      }
      if (HasResource) {
        output.WriteRawTag(18);
        output.WriteString(Resource);
      }
      if (divisor_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Divisor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasContainerName) {
        output.WriteRawTag(10);
        output.WriteString(ContainerName);
      }
      if (HasResource) {
        output.WriteRawTag(18);
        output.WriteString(Resource);
      }
      if (divisor_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Divisor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasContainerName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ContainerName);
      }
      if (HasResource) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Resource);
      }
      if (divisor_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Divisor);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ResourceFieldSelector other) {
      if (other == null) {
        return;
      }
      if (other.HasContainerName) {
        ContainerName = other.ContainerName;
      }
      if (other.HasResource) {
        Resource = other.Resource;
      }
      if (other.divisor_ != null) {
        if (divisor_ == null) {
          Divisor = new global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity();
        }
        Divisor.MergeFrom(other.Divisor);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ContainerName = input.ReadString();
            break;
          }
          case 18: {
            Resource = input.ReadString();
            break;
          }
          case 26: {
            if (divisor_ == null) {
              Divisor = new global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity();
            }
            input.ReadMessage(Divisor);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ContainerName = input.ReadString();
            break;
          }
          case 18: {
            Resource = input.ReadString();
            break;
          }
          case 26: {
            if (divisor_ == null) {
              Divisor = new global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity();
            }
            input.ReadMessage(Divisor);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ResourceQuota sets aggregate quota restrictions enforced per namespace
  /// </summary>
  public sealed partial class ResourceQuota : pb::IMessage<ResourceQuota>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ResourceQuota> _parser = new pb::MessageParser<ResourceQuota>(() => new ResourceQuota());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ResourceQuota> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[158]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuota() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuota(ResourceQuota other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuota Clone() {
      return new ResourceQuota(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ResourceQuotaSpec spec_;
    /// <summary>
    /// Spec defines the desired quota.
    /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ResourceQuotaSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.ResourceQuotaStatus status_;
    /// <summary>
    /// Status defines the actual enforced quota and its current usage.
    /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ResourceQuotaStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ResourceQuota);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ResourceQuota other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ResourceQuota other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.ResourceQuotaSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::K8S.Io.Api.Core.V1.ResourceQuotaStatus();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.ResourceQuotaSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.ResourceQuotaStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.ResourceQuotaSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.ResourceQuotaStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ResourceQuotaList is a list of ResourceQuota items.
  /// </summary>
  public sealed partial class ResourceQuotaList : pb::IMessage<ResourceQuotaList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ResourceQuotaList> _parser = new pb::MessageParser<ResourceQuotaList>(() => new ResourceQuotaList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ResourceQuotaList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[159]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuotaList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuotaList(ResourceQuotaList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuotaList Clone() {
      return new ResourceQuotaList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ResourceQuota> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.ResourceQuota.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ResourceQuota> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ResourceQuota>();
    /// <summary>
    /// Items is a list of ResourceQuota objects.
    /// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ResourceQuota> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ResourceQuotaList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ResourceQuotaList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ResourceQuotaList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
  /// </summary>
  public sealed partial class ResourceQuotaSpec : pb::IMessage<ResourceQuotaSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ResourceQuotaSpec> _parser = new pb::MessageParser<ResourceQuotaSpec>(() => new ResourceQuotaSpec());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ResourceQuotaSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[160]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuotaSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuotaSpec(ResourceQuotaSpec other) : this() {
      hard_ = other.hard_.Clone();
      scopes_ = other.scopes_.Clone();
      scopeSelector_ = other.scopeSelector_ != null ? other.scopeSelector_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuotaSpec Clone() {
      return new ResourceQuotaSpec(this);
    }

    /// <summary>Field number for the "hard" field.</summary>
    public const int HardFieldNumber = 1;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_hard_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 10);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> hard_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// hard is the set of desired hard limits for each named resource.
    /// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Hard {
      get { return hard_; }
    }

    /// <summary>Field number for the "scopes" field.</summary>
    public const int ScopesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_scopes_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> scopes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A collection of filters that must match each object tracked by a quota.
    /// If not specified, the quota matches all objects.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Scopes {
      get { return scopes_; }
    }

    /// <summary>Field number for the "scopeSelector" field.</summary>
    public const int ScopeSelectorFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.ScopeSelector scopeSelector_;
    /// <summary>
    /// scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota
    /// but expressed using ScopeSelectorOperator in combination with possible values.
    /// For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ScopeSelector ScopeSelector {
      get { return scopeSelector_; }
      set {
        scopeSelector_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ResourceQuotaSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ResourceQuotaSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Hard.Equals(other.Hard)) return false;
      if(!scopes_.Equals(other.scopes_)) return false;
      if (!object.Equals(ScopeSelector, other.ScopeSelector)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Hard.GetHashCode();
      hash ^= scopes_.GetHashCode();
      if (scopeSelector_ != null) hash ^= ScopeSelector.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      hard_.WriteTo(output, _map_hard_codec);
      scopes_.WriteTo(output, _repeated_scopes_codec);
      if (scopeSelector_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ScopeSelector);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      hard_.WriteTo(ref output, _map_hard_codec);
      scopes_.WriteTo(ref output, _repeated_scopes_codec);
      if (scopeSelector_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ScopeSelector);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += hard_.CalculateSize(_map_hard_codec);
      size += scopes_.CalculateSize(_repeated_scopes_codec);
      if (scopeSelector_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScopeSelector);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ResourceQuotaSpec other) {
      if (other == null) {
        return;
      }
      hard_.Add(other.hard_);
      scopes_.Add(other.scopes_);
      if (other.scopeSelector_ != null) {
        if (scopeSelector_ == null) {
          ScopeSelector = new global::K8S.Io.Api.Core.V1.ScopeSelector();
        }
        ScopeSelector.MergeFrom(other.ScopeSelector);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            hard_.AddEntriesFrom(input, _map_hard_codec);
            break;
          }
          case 18: {
            scopes_.AddEntriesFrom(input, _repeated_scopes_codec);
            break;
          }
          case 26: {
            if (scopeSelector_ == null) {
              ScopeSelector = new global::K8S.Io.Api.Core.V1.ScopeSelector();
            }
            input.ReadMessage(ScopeSelector);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            hard_.AddEntriesFrom(ref input, _map_hard_codec);
            break;
          }
          case 18: {
            scopes_.AddEntriesFrom(ref input, _repeated_scopes_codec);
            break;
          }
          case 26: {
            if (scopeSelector_ == null) {
              ScopeSelector = new global::K8S.Io.Api.Core.V1.ScopeSelector();
            }
            input.ReadMessage(ScopeSelector);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ResourceQuotaStatus defines the enforced hard limits and observed use.
  /// </summary>
  public sealed partial class ResourceQuotaStatus : pb::IMessage<ResourceQuotaStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ResourceQuotaStatus> _parser = new pb::MessageParser<ResourceQuotaStatus>(() => new ResourceQuotaStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ResourceQuotaStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[161]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuotaStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuotaStatus(ResourceQuotaStatus other) : this() {
      hard_ = other.hard_.Clone();
      used_ = other.used_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceQuotaStatus Clone() {
      return new ResourceQuotaStatus(this);
    }

    /// <summary>Field number for the "hard" field.</summary>
    public const int HardFieldNumber = 1;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_hard_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 10);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> hard_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Hard is the set of enforced hard limits for each named resource.
    /// More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Hard {
      get { return hard_; }
    }

    /// <summary>Field number for the "used" field.</summary>
    public const int UsedFieldNumber = 2;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_used_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 18);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> used_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Used is the current observed total usage of the resource in the namespace.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Used {
      get { return used_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ResourceQuotaStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ResourceQuotaStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Hard.Equals(other.Hard)) return false;
      if (!Used.Equals(other.Used)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Hard.GetHashCode();
      hash ^= Used.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      hard_.WriteTo(output, _map_hard_codec);
      used_.WriteTo(output, _map_used_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      hard_.WriteTo(ref output, _map_hard_codec);
      used_.WriteTo(ref output, _map_used_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += hard_.CalculateSize(_map_hard_codec);
      size += used_.CalculateSize(_map_used_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ResourceQuotaStatus other) {
      if (other == null) {
        return;
      }
      hard_.Add(other.hard_);
      used_.Add(other.used_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            hard_.AddEntriesFrom(input, _map_hard_codec);
            break;
          }
          case 18: {
            used_.AddEntriesFrom(input, _map_used_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            hard_.AddEntriesFrom(ref input, _map_hard_codec);
            break;
          }
          case 18: {
            used_.AddEntriesFrom(ref input, _map_used_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ResourceRequirements describes the compute resource requirements.
  /// </summary>
  public sealed partial class ResourceRequirements : pb::IMessage<ResourceRequirements>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ResourceRequirements> _parser = new pb::MessageParser<ResourceRequirements>(() => new ResourceRequirements());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ResourceRequirements> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[162]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceRequirements() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceRequirements(ResourceRequirements other) : this() {
      limits_ = other.limits_.Clone();
      requests_ = other.requests_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceRequirements Clone() {
      return new ResourceRequirements(this);
    }

    /// <summary>Field number for the "limits" field.</summary>
    public const int LimitsFieldNumber = 1;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_limits_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 10);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> limits_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Limits describes the maximum amount of compute resources allowed.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Limits {
      get { return limits_; }
    }

    /// <summary>Field number for the "requests" field.</summary>
    public const int RequestsFieldNumber = 2;
    private static readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec _map_requests_codec
        = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser), 18);
    private readonly pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> requests_ = new pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity>();
    /// <summary>
    /// Requests describes the minimum amount of compute resources required.
    /// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    /// otherwise to an implementation-defined value.
    /// More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity> Requests {
      get { return requests_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ResourceRequirements);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ResourceRequirements other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Limits.Equals(other.Limits)) return false;
      if (!Requests.Equals(other.Requests)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Limits.GetHashCode();
      hash ^= Requests.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      limits_.WriteTo(output, _map_limits_codec);
      requests_.WriteTo(output, _map_requests_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      limits_.WriteTo(ref output, _map_limits_codec);
      requests_.WriteTo(ref output, _map_requests_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += limits_.CalculateSize(_map_limits_codec);
      size += requests_.CalculateSize(_map_requests_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ResourceRequirements other) {
      if (other == null) {
        return;
      }
      limits_.Add(other.limits_);
      requests_.Add(other.requests_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            limits_.AddEntriesFrom(input, _map_limits_codec);
            break;
          }
          case 18: {
            requests_.AddEntriesFrom(input, _map_requests_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            limits_.AddEntriesFrom(ref input, _map_limits_codec);
            break;
          }
          case 18: {
            requests_.AddEntriesFrom(ref input, _map_requests_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SELinuxOptions are the labels to be applied to the container
  /// </summary>
  public sealed partial class SELinuxOptions : pb::IMessage<SELinuxOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SELinuxOptions> _parser = new pb::MessageParser<SELinuxOptions>(() => new SELinuxOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SELinuxOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[163]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SELinuxOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SELinuxOptions(SELinuxOptions other) : this() {
      user_ = other.user_;
      role_ = other.role_;
      type_ = other.type_;
      level_ = other.level_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SELinuxOptions Clone() {
      return new SELinuxOptions(this);
    }

    /// <summary>Field number for the "user" field.</summary>
    public const int UserFieldNumber = 1;
    private readonly static string UserDefaultValue = "";

    private string user_;
    /// <summary>
    /// User is a SELinux user label that applies to the container.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string User {
      get { return user_ ?? UserDefaultValue; }
      set {
        user_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "user" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasUser {
      get { return user_ != null; }
    }
    /// <summary>Clears the value of the "user" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearUser() {
      user_ = null;
    }

    /// <summary>Field number for the "role" field.</summary>
    public const int RoleFieldNumber = 2;
    private readonly static string RoleDefaultValue = "";

    private string role_;
    /// <summary>
    /// Role is a SELinux role label that applies to the container.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Role {
      get { return role_ ?? RoleDefaultValue; }
      set {
        role_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "role" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRole {
      get { return role_ != null; }
    }
    /// <summary>Clears the value of the "role" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRole() {
      role_ = null;
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 3;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Type is a SELinux type label that applies to the container.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "level" field.</summary>
    public const int LevelFieldNumber = 4;
    private readonly static string LevelDefaultValue = "";

    private string level_;
    /// <summary>
    /// Level is SELinux level label that applies to the container.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Level {
      get { return level_ ?? LevelDefaultValue; }
      set {
        level_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "level" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLevel {
      get { return level_ != null; }
    }
    /// <summary>Clears the value of the "level" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLevel() {
      level_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SELinuxOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SELinuxOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (User != other.User) return false;
      if (Role != other.Role) return false;
      if (Type != other.Type) return false;
      if (Level != other.Level) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasUser) hash ^= User.GetHashCode();
      if (HasRole) hash ^= Role.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (HasLevel) hash ^= Level.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasUser) {
        output.WriteRawTag(10);
        output.WriteString(User);
      }
      if (HasRole) {
        output.WriteRawTag(18);
        output.WriteString(Role);
      }
      if (HasType) {
        output.WriteRawTag(26);
        output.WriteString(Type);
      }
      if (HasLevel) {
        output.WriteRawTag(34);
        output.WriteString(Level);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasUser) {
        output.WriteRawTag(10);
        output.WriteString(User);
      }
      if (HasRole) {
        output.WriteRawTag(18);
        output.WriteString(Role);
      }
      if (HasType) {
        output.WriteRawTag(26);
        output.WriteString(Type);
      }
      if (HasLevel) {
        output.WriteRawTag(34);
        output.WriteString(Level);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasUser) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(User);
      }
      if (HasRole) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Role);
      }
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasLevel) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Level);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SELinuxOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasUser) {
        User = other.User;
      }
      if (other.HasRole) {
        Role = other.Role;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasLevel) {
        Level = other.Level;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            User = input.ReadString();
            break;
          }
          case 18: {
            Role = input.ReadString();
            break;
          }
          case 26: {
            Type = input.ReadString();
            break;
          }
          case 34: {
            Level = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            User = input.ReadString();
            break;
          }
          case 18: {
            Role = input.ReadString();
            break;
          }
          case 26: {
            Type = input.ReadString();
            break;
          }
          case 34: {
            Level = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
  /// </summary>
  public sealed partial class ScaleIOPersistentVolumeSource : pb::IMessage<ScaleIOPersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScaleIOPersistentVolumeSource> _parser = new pb::MessageParser<ScaleIOPersistentVolumeSource>(() => new ScaleIOPersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScaleIOPersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[164]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScaleIOPersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScaleIOPersistentVolumeSource(ScaleIOPersistentVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      gateway_ = other.gateway_;
      system_ = other.system_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      sslEnabled_ = other.sslEnabled_;
      protectionDomain_ = other.protectionDomain_;
      storagePool_ = other.storagePool_;
      storageMode_ = other.storageMode_;
      volumeName_ = other.volumeName_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScaleIOPersistentVolumeSource Clone() {
      return new ScaleIOPersistentVolumeSource(this);
    }

    /// <summary>Field number for the "gateway" field.</summary>
    public const int GatewayFieldNumber = 1;
    private readonly static string GatewayDefaultValue = "";

    private string gateway_;
    /// <summary>
    /// The host address of the ScaleIO API Gateway.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Gateway {
      get { return gateway_ ?? GatewayDefaultValue; }
      set {
        gateway_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gateway" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGateway {
      get { return gateway_ != null; }
    }
    /// <summary>Clears the value of the "gateway" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGateway() {
      gateway_ = null;
    }

    /// <summary>Field number for the "system" field.</summary>
    public const int SystemFieldNumber = 2;
    private readonly static string SystemDefaultValue = "";

    private string system_;
    /// <summary>
    /// The name of the storage system as configured in ScaleIO.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string System {
      get { return system_ ?? SystemDefaultValue; }
      set {
        system_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "system" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSystem {
      get { return system_ != null; }
    }
    /// <summary>Clears the value of the "system" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSystem() {
      system_ = null;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.SecretReference secretRef_;
    /// <summary>
    /// SecretRef references to the secret for ScaleIO user and other
    /// sensitive information. If this is not provided, Login operation will fail.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    /// <summary>Field number for the "sslEnabled" field.</summary>
    public const int SslEnabledFieldNumber = 4;
    private readonly static bool SslEnabledDefaultValue = false;

    private bool sslEnabled_;
    /// <summary>
    /// Flag to enable/disable SSL communication with Gateway, default false
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SslEnabled {
      get { if ((_hasBits0 & 1) != 0) { return sslEnabled_; } else { return SslEnabledDefaultValue; } }
      set {
        _hasBits0 |= 1;
        sslEnabled_ = value;
      }
    }
    /// <summary>Gets whether the "sslEnabled" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSslEnabled {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "sslEnabled" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSslEnabled() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "protectionDomain" field.</summary>
    public const int ProtectionDomainFieldNumber = 5;
    private readonly static string ProtectionDomainDefaultValue = "";

    private string protectionDomain_;
    /// <summary>
    /// The name of the ScaleIO Protection Domain for the configured storage.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ProtectionDomain {
      get { return protectionDomain_ ?? ProtectionDomainDefaultValue; }
      set {
        protectionDomain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "protectionDomain" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProtectionDomain {
      get { return protectionDomain_ != null; }
    }
    /// <summary>Clears the value of the "protectionDomain" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProtectionDomain() {
      protectionDomain_ = null;
    }

    /// <summary>Field number for the "storagePool" field.</summary>
    public const int StoragePoolFieldNumber = 6;
    private readonly static string StoragePoolDefaultValue = "";

    private string storagePool_;
    /// <summary>
    /// The ScaleIO Storage Pool associated with the protection domain.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StoragePool {
      get { return storagePool_ ?? StoragePoolDefaultValue; }
      set {
        storagePool_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "storagePool" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStoragePool {
      get { return storagePool_ != null; }
    }
    /// <summary>Clears the value of the "storagePool" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStoragePool() {
      storagePool_ = null;
    }

    /// <summary>Field number for the "storageMode" field.</summary>
    public const int StorageModeFieldNumber = 7;
    private readonly static string StorageModeDefaultValue = "";

    private string storageMode_;
    /// <summary>
    /// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    /// Default is ThinProvisioned.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StorageMode {
      get { return storageMode_ ?? StorageModeDefaultValue; }
      set {
        storageMode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "storageMode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStorageMode {
      get { return storageMode_ != null; }
    }
    /// <summary>Clears the value of the "storageMode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStorageMode() {
      storageMode_ = null;
    }

    /// <summary>Field number for the "volumeName" field.</summary>
    public const int VolumeNameFieldNumber = 8;
    private readonly static string VolumeNameDefaultValue = "";

    private string volumeName_;
    /// <summary>
    /// The name of a volume already created in the ScaleIO system
    /// that is associated with this volume source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeName {
      get { return volumeName_ ?? VolumeNameDefaultValue; }
      set {
        volumeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeName {
      get { return volumeName_ != null; }
    }
    /// <summary>Clears the value of the "volumeName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeName() {
      volumeName_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 9;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs".
    /// Default is "xfs"
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 10;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 2) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScaleIOPersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScaleIOPersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Gateway != other.Gateway) return false;
      if (System != other.System) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      if (SslEnabled != other.SslEnabled) return false;
      if (ProtectionDomain != other.ProtectionDomain) return false;
      if (StoragePool != other.StoragePool) return false;
      if (StorageMode != other.StorageMode) return false;
      if (VolumeName != other.VolumeName) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasGateway) hash ^= Gateway.GetHashCode();
      if (HasSystem) hash ^= System.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (HasSslEnabled) hash ^= SslEnabled.GetHashCode();
      if (HasProtectionDomain) hash ^= ProtectionDomain.GetHashCode();
      if (HasStoragePool) hash ^= StoragePool.GetHashCode();
      if (HasStorageMode) hash ^= StorageMode.GetHashCode();
      if (HasVolumeName) hash ^= VolumeName.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasGateway) {
        output.WriteRawTag(10);
        output.WriteString(Gateway);
      }
      if (HasSystem) {
        output.WriteRawTag(18);
        output.WriteString(System);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SecretRef);
      }
      if (HasSslEnabled) {
        output.WriteRawTag(32);
        output.WriteBool(SslEnabled);
      }
      if (HasProtectionDomain) {
        output.WriteRawTag(42);
        output.WriteString(ProtectionDomain);
      }
      if (HasStoragePool) {
        output.WriteRawTag(50);
        output.WriteString(StoragePool);
      }
      if (HasStorageMode) {
        output.WriteRawTag(58);
        output.WriteString(StorageMode);
      }
      if (HasVolumeName) {
        output.WriteRawTag(66);
        output.WriteString(VolumeName);
      }
      if (HasFsType) {
        output.WriteRawTag(74);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(80);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasGateway) {
        output.WriteRawTag(10);
        output.WriteString(Gateway);
      }
      if (HasSystem) {
        output.WriteRawTag(18);
        output.WriteString(System);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SecretRef);
      }
      if (HasSslEnabled) {
        output.WriteRawTag(32);
        output.WriteBool(SslEnabled);
      }
      if (HasProtectionDomain) {
        output.WriteRawTag(42);
        output.WriteString(ProtectionDomain);
      }
      if (HasStoragePool) {
        output.WriteRawTag(50);
        output.WriteString(StoragePool);
      }
      if (HasStorageMode) {
        output.WriteRawTag(58);
        output.WriteString(StorageMode);
      }
      if (HasVolumeName) {
        output.WriteRawTag(66);
        output.WriteString(VolumeName);
      }
      if (HasFsType) {
        output.WriteRawTag(74);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(80);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasGateway) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Gateway);
      }
      if (HasSystem) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(System);
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (HasSslEnabled) {
        size += 1 + 1;
      }
      if (HasProtectionDomain) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProtectionDomain);
      }
      if (HasStoragePool) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StoragePool);
      }
      if (HasStorageMode) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StorageMode);
      }
      if (HasVolumeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeName);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScaleIOPersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasGateway) {
        Gateway = other.Gateway;
      }
      if (other.HasSystem) {
        System = other.System;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      if (other.HasSslEnabled) {
        SslEnabled = other.SslEnabled;
      }
      if (other.HasProtectionDomain) {
        ProtectionDomain = other.ProtectionDomain;
      }
      if (other.HasStoragePool) {
        StoragePool = other.StoragePool;
      }
      if (other.HasStorageMode) {
        StorageMode = other.StorageMode;
      }
      if (other.HasVolumeName) {
        VolumeName = other.VolumeName;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Gateway = input.ReadString();
            break;
          }
          case 18: {
            System = input.ReadString();
            break;
          }
          case 26: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 32: {
            SslEnabled = input.ReadBool();
            break;
          }
          case 42: {
            ProtectionDomain = input.ReadString();
            break;
          }
          case 50: {
            StoragePool = input.ReadString();
            break;
          }
          case 58: {
            StorageMode = input.ReadString();
            break;
          }
          case 66: {
            VolumeName = input.ReadString();
            break;
          }
          case 74: {
            FsType = input.ReadString();
            break;
          }
          case 80: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Gateway = input.ReadString();
            break;
          }
          case 18: {
            System = input.ReadString();
            break;
          }
          case 26: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.SecretReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 32: {
            SslEnabled = input.ReadBool();
            break;
          }
          case 42: {
            ProtectionDomain = input.ReadString();
            break;
          }
          case 50: {
            StoragePool = input.ReadString();
            break;
          }
          case 58: {
            StorageMode = input.ReadString();
            break;
          }
          case 66: {
            VolumeName = input.ReadString();
            break;
          }
          case 74: {
            FsType = input.ReadString();
            break;
          }
          case 80: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ScaleIOVolumeSource represents a persistent ScaleIO volume
  /// </summary>
  public sealed partial class ScaleIOVolumeSource : pb::IMessage<ScaleIOVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScaleIOVolumeSource> _parser = new pb::MessageParser<ScaleIOVolumeSource>(() => new ScaleIOVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScaleIOVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[165]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScaleIOVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScaleIOVolumeSource(ScaleIOVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      gateway_ = other.gateway_;
      system_ = other.system_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      sslEnabled_ = other.sslEnabled_;
      protectionDomain_ = other.protectionDomain_;
      storagePool_ = other.storagePool_;
      storageMode_ = other.storageMode_;
      volumeName_ = other.volumeName_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScaleIOVolumeSource Clone() {
      return new ScaleIOVolumeSource(this);
    }

    /// <summary>Field number for the "gateway" field.</summary>
    public const int GatewayFieldNumber = 1;
    private readonly static string GatewayDefaultValue = "";

    private string gateway_;
    /// <summary>
    /// The host address of the ScaleIO API Gateway.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Gateway {
      get { return gateway_ ?? GatewayDefaultValue; }
      set {
        gateway_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gateway" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGateway {
      get { return gateway_ != null; }
    }
    /// <summary>Clears the value of the "gateway" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGateway() {
      gateway_ = null;
    }

    /// <summary>Field number for the "system" field.</summary>
    public const int SystemFieldNumber = 2;
    private readonly static string SystemDefaultValue = "";

    private string system_;
    /// <summary>
    /// The name of the storage system as configured in ScaleIO.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string System {
      get { return system_ ?? SystemDefaultValue; }
      set {
        system_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "system" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSystem {
      get { return system_ != null; }
    }
    /// <summary>Clears the value of the "system" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSystem() {
      system_ = null;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference secretRef_;
    /// <summary>
    /// SecretRef references to the secret for ScaleIO user and other
    /// sensitive information. If this is not provided, Login operation will fail.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    /// <summary>Field number for the "sslEnabled" field.</summary>
    public const int SslEnabledFieldNumber = 4;
    private readonly static bool SslEnabledDefaultValue = false;

    private bool sslEnabled_;
    /// <summary>
    /// Flag to enable/disable SSL communication with Gateway, default false
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool SslEnabled {
      get { if ((_hasBits0 & 1) != 0) { return sslEnabled_; } else { return SslEnabledDefaultValue; } }
      set {
        _hasBits0 |= 1;
        sslEnabled_ = value;
      }
    }
    /// <summary>Gets whether the "sslEnabled" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSslEnabled {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "sslEnabled" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSslEnabled() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "protectionDomain" field.</summary>
    public const int ProtectionDomainFieldNumber = 5;
    private readonly static string ProtectionDomainDefaultValue = "";

    private string protectionDomain_;
    /// <summary>
    /// The name of the ScaleIO Protection Domain for the configured storage.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ProtectionDomain {
      get { return protectionDomain_ ?? ProtectionDomainDefaultValue; }
      set {
        protectionDomain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "protectionDomain" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProtectionDomain {
      get { return protectionDomain_ != null; }
    }
    /// <summary>Clears the value of the "protectionDomain" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProtectionDomain() {
      protectionDomain_ = null;
    }

    /// <summary>Field number for the "storagePool" field.</summary>
    public const int StoragePoolFieldNumber = 6;
    private readonly static string StoragePoolDefaultValue = "";

    private string storagePool_;
    /// <summary>
    /// The ScaleIO Storage Pool associated with the protection domain.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StoragePool {
      get { return storagePool_ ?? StoragePoolDefaultValue; }
      set {
        storagePool_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "storagePool" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStoragePool {
      get { return storagePool_ != null; }
    }
    /// <summary>Clears the value of the "storagePool" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStoragePool() {
      storagePool_ = null;
    }

    /// <summary>Field number for the "storageMode" field.</summary>
    public const int StorageModeFieldNumber = 7;
    private readonly static string StorageModeDefaultValue = "";

    private string storageMode_;
    /// <summary>
    /// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
    /// Default is ThinProvisioned.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StorageMode {
      get { return storageMode_ ?? StorageModeDefaultValue; }
      set {
        storageMode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "storageMode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStorageMode {
      get { return storageMode_ != null; }
    }
    /// <summary>Clears the value of the "storageMode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStorageMode() {
      storageMode_ = null;
    }

    /// <summary>Field number for the "volumeName" field.</summary>
    public const int VolumeNameFieldNumber = 8;
    private readonly static string VolumeNameDefaultValue = "";

    private string volumeName_;
    /// <summary>
    /// The name of a volume already created in the ScaleIO system
    /// that is associated with this volume source.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeName {
      get { return volumeName_ ?? VolumeNameDefaultValue; }
      set {
        volumeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeName {
      get { return volumeName_ != null; }
    }
    /// <summary>Clears the value of the "volumeName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeName() {
      volumeName_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 9;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs".
    /// Default is "xfs".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 10;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 2) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 2;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScaleIOVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScaleIOVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Gateway != other.Gateway) return false;
      if (System != other.System) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      if (SslEnabled != other.SslEnabled) return false;
      if (ProtectionDomain != other.ProtectionDomain) return false;
      if (StoragePool != other.StoragePool) return false;
      if (StorageMode != other.StorageMode) return false;
      if (VolumeName != other.VolumeName) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasGateway) hash ^= Gateway.GetHashCode();
      if (HasSystem) hash ^= System.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (HasSslEnabled) hash ^= SslEnabled.GetHashCode();
      if (HasProtectionDomain) hash ^= ProtectionDomain.GetHashCode();
      if (HasStoragePool) hash ^= StoragePool.GetHashCode();
      if (HasStorageMode) hash ^= StorageMode.GetHashCode();
      if (HasVolumeName) hash ^= VolumeName.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasGateway) {
        output.WriteRawTag(10);
        output.WriteString(Gateway);
      }
      if (HasSystem) {
        output.WriteRawTag(18);
        output.WriteString(System);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SecretRef);
      }
      if (HasSslEnabled) {
        output.WriteRawTag(32);
        output.WriteBool(SslEnabled);
      }
      if (HasProtectionDomain) {
        output.WriteRawTag(42);
        output.WriteString(ProtectionDomain);
      }
      if (HasStoragePool) {
        output.WriteRawTag(50);
        output.WriteString(StoragePool);
      }
      if (HasStorageMode) {
        output.WriteRawTag(58);
        output.WriteString(StorageMode);
      }
      if (HasVolumeName) {
        output.WriteRawTag(66);
        output.WriteString(VolumeName);
      }
      if (HasFsType) {
        output.WriteRawTag(74);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(80);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasGateway) {
        output.WriteRawTag(10);
        output.WriteString(Gateway);
      }
      if (HasSystem) {
        output.WriteRawTag(18);
        output.WriteString(System);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SecretRef);
      }
      if (HasSslEnabled) {
        output.WriteRawTag(32);
        output.WriteBool(SslEnabled);
      }
      if (HasProtectionDomain) {
        output.WriteRawTag(42);
        output.WriteString(ProtectionDomain);
      }
      if (HasStoragePool) {
        output.WriteRawTag(50);
        output.WriteString(StoragePool);
      }
      if (HasStorageMode) {
        output.WriteRawTag(58);
        output.WriteString(StorageMode);
      }
      if (HasVolumeName) {
        output.WriteRawTag(66);
        output.WriteString(VolumeName);
      }
      if (HasFsType) {
        output.WriteRawTag(74);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(80);
        output.WriteBool(ReadOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasGateway) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Gateway);
      }
      if (HasSystem) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(System);
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (HasSslEnabled) {
        size += 1 + 1;
      }
      if (HasProtectionDomain) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProtectionDomain);
      }
      if (HasStoragePool) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StoragePool);
      }
      if (HasStorageMode) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StorageMode);
      }
      if (HasVolumeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeName);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScaleIOVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasGateway) {
        Gateway = other.Gateway;
      }
      if (other.HasSystem) {
        System = other.System;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      if (other.HasSslEnabled) {
        SslEnabled = other.SslEnabled;
      }
      if (other.HasProtectionDomain) {
        ProtectionDomain = other.ProtectionDomain;
      }
      if (other.HasStoragePool) {
        StoragePool = other.StoragePool;
      }
      if (other.HasStorageMode) {
        StorageMode = other.StorageMode;
      }
      if (other.HasVolumeName) {
        VolumeName = other.VolumeName;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Gateway = input.ReadString();
            break;
          }
          case 18: {
            System = input.ReadString();
            break;
          }
          case 26: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 32: {
            SslEnabled = input.ReadBool();
            break;
          }
          case 42: {
            ProtectionDomain = input.ReadString();
            break;
          }
          case 50: {
            StoragePool = input.ReadString();
            break;
          }
          case 58: {
            StorageMode = input.ReadString();
            break;
          }
          case 66: {
            VolumeName = input.ReadString();
            break;
          }
          case 74: {
            FsType = input.ReadString();
            break;
          }
          case 80: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Gateway = input.ReadString();
            break;
          }
          case 18: {
            System = input.ReadString();
            break;
          }
          case 26: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
          case 32: {
            SslEnabled = input.ReadBool();
            break;
          }
          case 42: {
            ProtectionDomain = input.ReadString();
            break;
          }
          case 50: {
            StoragePool = input.ReadString();
            break;
          }
          case 58: {
            StorageMode = input.ReadString();
            break;
          }
          case 66: {
            VolumeName = input.ReadString();
            break;
          }
          case 74: {
            FsType = input.ReadString();
            break;
          }
          case 80: {
            ReadOnly = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A scope selector represents the AND of the selectors represented
  /// by the scoped-resource selector requirements.
  /// +structType=atomic
  /// </summary>
  public sealed partial class ScopeSelector : pb::IMessage<ScopeSelector>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScopeSelector> _parser = new pb::MessageParser<ScopeSelector>(() => new ScopeSelector());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScopeSelector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[166]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopeSelector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopeSelector(ScopeSelector other) : this() {
      matchExpressions_ = other.matchExpressions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopeSelector Clone() {
      return new ScopeSelector(this);
    }

    /// <summary>Field number for the "matchExpressions" field.</summary>
    public const int MatchExpressionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ScopedResourceSelectorRequirement> _repeated_matchExpressions_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.ScopedResourceSelectorRequirement.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ScopedResourceSelectorRequirement> matchExpressions_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ScopedResourceSelectorRequirement>();
    /// <summary>
    /// A list of scope selector requirements by scope of the resources.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ScopedResourceSelectorRequirement> MatchExpressions {
      get { return matchExpressions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScopeSelector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScopeSelector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!matchExpressions_.Equals(other.matchExpressions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= matchExpressions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      matchExpressions_.WriteTo(output, _repeated_matchExpressions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      matchExpressions_.WriteTo(ref output, _repeated_matchExpressions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += matchExpressions_.CalculateSize(_repeated_matchExpressions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScopeSelector other) {
      if (other == null) {
        return;
      }
      matchExpressions_.Add(other.matchExpressions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            matchExpressions_.AddEntriesFrom(input, _repeated_matchExpressions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            matchExpressions_.AddEntriesFrom(ref input, _repeated_matchExpressions_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator
  /// that relates the scope name and values.
  /// </summary>
  public sealed partial class ScopedResourceSelectorRequirement : pb::IMessage<ScopedResourceSelectorRequirement>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScopedResourceSelectorRequirement> _parser = new pb::MessageParser<ScopedResourceSelectorRequirement>(() => new ScopedResourceSelectorRequirement());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScopedResourceSelectorRequirement> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[167]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedResourceSelectorRequirement() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedResourceSelectorRequirement(ScopedResourceSelectorRequirement other) : this() {
      scopeName_ = other.scopeName_;
      operator_ = other.operator_;
      values_ = other.values_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopedResourceSelectorRequirement Clone() {
      return new ScopedResourceSelectorRequirement(this);
    }

    /// <summary>Field number for the "scopeName" field.</summary>
    public const int ScopeNameFieldNumber = 1;
    private readonly static string ScopeNameDefaultValue = "";

    private string scopeName_;
    /// <summary>
    /// The name of the scope that the selector applies to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ScopeName {
      get { return scopeName_ ?? ScopeNameDefaultValue; }
      set {
        scopeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "scopeName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasScopeName {
      get { return scopeName_ != null; }
    }
    /// <summary>Clears the value of the "scopeName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearScopeName() {
      scopeName_ = null;
    }

    /// <summary>Field number for the "operator" field.</summary>
    public const int OperatorFieldNumber = 2;
    private readonly static string OperatorDefaultValue = "";

    private string operator_;
    /// <summary>
    /// Represents a scope's relationship to a set of values.
    /// Valid operators are In, NotIn, Exists, DoesNotExist.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Operator {
      get { return operator_ ?? OperatorDefaultValue; }
      set {
        operator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "operator" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOperator {
      get { return operator_ != null; }
    }
    /// <summary>Clears the value of the "operator" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOperator() {
      operator_ = null;
    }

    /// <summary>Field number for the "values" field.</summary>
    public const int ValuesFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_values_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> values_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An array of string values. If the operator is In or NotIn,
    /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
    /// the values array must be empty.
    /// This array is replaced during a strategic merge patch.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Values {
      get { return values_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScopedResourceSelectorRequirement);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScopedResourceSelectorRequirement other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ScopeName != other.ScopeName) return false;
      if (Operator != other.Operator) return false;
      if(!values_.Equals(other.values_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasScopeName) hash ^= ScopeName.GetHashCode();
      if (HasOperator) hash ^= Operator.GetHashCode();
      hash ^= values_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasScopeName) {
        output.WriteRawTag(10);
        output.WriteString(ScopeName);
      }
      if (HasOperator) {
        output.WriteRawTag(18);
        output.WriteString(Operator);
      }
      values_.WriteTo(output, _repeated_values_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasScopeName) {
        output.WriteRawTag(10);
        output.WriteString(ScopeName);
      }
      if (HasOperator) {
        output.WriteRawTag(18);
        output.WriteString(Operator);
      }
      values_.WriteTo(ref output, _repeated_values_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasScopeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ScopeName);
      }
      if (HasOperator) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Operator);
      }
      size += values_.CalculateSize(_repeated_values_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScopedResourceSelectorRequirement other) {
      if (other == null) {
        return;
      }
      if (other.HasScopeName) {
        ScopeName = other.ScopeName;
      }
      if (other.HasOperator) {
        Operator = other.Operator;
      }
      values_.Add(other.values_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ScopeName = input.ReadString();
            break;
          }
          case 18: {
            Operator = input.ReadString();
            break;
          }
          case 26: {
            values_.AddEntriesFrom(input, _repeated_values_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ScopeName = input.ReadString();
            break;
          }
          case 18: {
            Operator = input.ReadString();
            break;
          }
          case 26: {
            values_.AddEntriesFrom(ref input, _repeated_values_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SeccompProfile defines a pod/container's seccomp profile settings.
  /// Only one profile source may be set.
  /// +union
  /// </summary>
  public sealed partial class SeccompProfile : pb::IMessage<SeccompProfile>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SeccompProfile> _parser = new pb::MessageParser<SeccompProfile>(() => new SeccompProfile());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SeccompProfile> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[168]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SeccompProfile() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SeccompProfile(SeccompProfile other) : this() {
      type_ = other.type_;
      localhostProfile_ = other.localhostProfile_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SeccompProfile Clone() {
      return new SeccompProfile(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// type indicates which kind of seccomp profile will be applied.
    /// Valid options are:
    ///
    /// Localhost - a profile defined in a file on the node should be used.
    /// RuntimeDefault - the container runtime default profile should be used.
    /// Unconfined - no profile should be applied.
    /// +unionDiscriminator
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "localhostProfile" field.</summary>
    public const int LocalhostProfileFieldNumber = 2;
    private readonly static string LocalhostProfileDefaultValue = "";

    private string localhostProfile_;
    /// <summary>
    /// localhostProfile indicates a profile defined in a file on the node should be used.
    /// The profile must be preconfigured on the node to work.
    /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
    /// Must only be set if type is "Localhost".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LocalhostProfile {
      get { return localhostProfile_ ?? LocalhostProfileDefaultValue; }
      set {
        localhostProfile_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "localhostProfile" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLocalhostProfile {
      get { return localhostProfile_ != null; }
    }
    /// <summary>Clears the value of the "localhostProfile" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLocalhostProfile() {
      localhostProfile_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SeccompProfile);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SeccompProfile other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (LocalhostProfile != other.LocalhostProfile) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasType) hash ^= Type.GetHashCode();
      if (HasLocalhostProfile) hash ^= LocalhostProfile.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasLocalhostProfile) {
        output.WriteRawTag(18);
        output.WriteString(LocalhostProfile);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasType) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (HasLocalhostProfile) {
        output.WriteRawTag(18);
        output.WriteString(LocalhostProfile);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (HasLocalhostProfile) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LocalhostProfile);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SeccompProfile other) {
      if (other == null) {
        return;
      }
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasLocalhostProfile) {
        LocalhostProfile = other.LocalhostProfile;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            LocalhostProfile = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 18: {
            LocalhostProfile = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Secret holds secret data of a certain type. The total bytes of the values in
  /// the Data field must be less than MaxSecretSize bytes.
  /// </summary>
  public sealed partial class Secret : pb::IMessage<Secret>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Secret> _parser = new pb::MessageParser<Secret>(() => new Secret());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Secret> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[169]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Secret() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Secret(Secret other) : this() {
      _hasBits0 = other._hasBits0;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      immutable_ = other.immutable_;
      data_ = other.data_.Clone();
      stringData_ = other.stringData_.Clone();
      type_ = other.type_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Secret Clone() {
      return new Secret(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "immutable" field.</summary>
    public const int ImmutableFieldNumber = 5;
    private readonly static bool ImmutableDefaultValue = false;

    private bool immutable_;
    /// <summary>
    /// Immutable, if set to true, ensures that data stored in the Secret cannot
    /// be updated (only object metadata can be modified).
    /// If not set to true, the field can be modified at any time.
    /// Defaulted to nil.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Immutable {
      get { if ((_hasBits0 & 1) != 0) { return immutable_; } else { return ImmutableDefaultValue; } }
      set {
        _hasBits0 |= 1;
        immutable_ = value;
      }
    }
    /// <summary>Gets whether the "immutable" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasImmutable {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "immutable" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearImmutable() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "data" field.</summary>
    public const int DataFieldNumber = 2;
    private static readonly pbc::MapField<string, pb::ByteString>.Codec _map_data_codec
        = new pbc::MapField<string, pb::ByteString>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForBytes(18, pb::ByteString.Empty), 18);
    private readonly pbc::MapField<string, pb::ByteString> data_ = new pbc::MapField<string, pb::ByteString>();
    /// <summary>
    /// Data contains the secret data. Each key must consist of alphanumeric
    /// characters, '-', '_' or '.'. The serialized form of the secret data is a
    /// base64 encoded string, representing the arbitrary (possibly non-string)
    /// data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, pb::ByteString> Data {
      get { return data_; }
    }

    /// <summary>Field number for the "stringData" field.</summary>
    public const int StringDataFieldNumber = 4;
    private static readonly pbc::MapField<string, string>.Codec _map_stringData_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 34);
    private readonly pbc::MapField<string, string> stringData_ = new pbc::MapField<string, string>();
    /// <summary>
    /// stringData allows specifying non-binary secret data in string form.
    /// It is provided as a write-only input field for convenience.
    /// All keys and values are merged into the data field on write, overwriting any existing values.
    /// The stringData field is never output when reading from the API.
    /// +k8s:conversion-gen=false
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> StringData {
      get { return stringData_; }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 3;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// Used to facilitate programmatic handling of secret data.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Secret);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Secret other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (Immutable != other.Immutable) return false;
      if (!Data.Equals(other.Data)) return false;
      if (!StringData.Equals(other.StringData)) return false;
      if (Type != other.Type) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (HasImmutable) hash ^= Immutable.GetHashCode();
      hash ^= Data.GetHashCode();
      hash ^= StringData.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      data_.WriteTo(output, _map_data_codec);
      if (HasType) {
        output.WriteRawTag(26);
        output.WriteString(Type);
      }
      stringData_.WriteTo(output, _map_stringData_codec);
      if (HasImmutable) {
        output.WriteRawTag(40);
        output.WriteBool(Immutable);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      data_.WriteTo(ref output, _map_data_codec);
      if (HasType) {
        output.WriteRawTag(26);
        output.WriteString(Type);
      }
      stringData_.WriteTo(ref output, _map_stringData_codec);
      if (HasImmutable) {
        output.WriteRawTag(40);
        output.WriteBool(Immutable);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (HasImmutable) {
        size += 1 + 1;
      }
      size += data_.CalculateSize(_map_data_codec);
      size += stringData_.CalculateSize(_map_stringData_codec);
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Secret other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.HasImmutable) {
        Immutable = other.Immutable;
      }
      data_.Add(other.data_);
      stringData_.Add(other.stringData_);
      if (other.HasType) {
        Type = other.Type;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            data_.AddEntriesFrom(input, _map_data_codec);
            break;
          }
          case 26: {
            Type = input.ReadString();
            break;
          }
          case 34: {
            stringData_.AddEntriesFrom(input, _map_stringData_codec);
            break;
          }
          case 40: {
            Immutable = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            data_.AddEntriesFrom(ref input, _map_data_codec);
            break;
          }
          case 26: {
            Type = input.ReadString();
            break;
          }
          case 34: {
            stringData_.AddEntriesFrom(ref input, _map_stringData_codec);
            break;
          }
          case 40: {
            Immutable = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SecretEnvSource selects a Secret to populate the environment
  /// variables with.
  ///
  /// The contents of the target Secret's Data field will represent the
  /// key-value pairs as environment variables.
  /// </summary>
  public sealed partial class SecretEnvSource : pb::IMessage<SecretEnvSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecretEnvSource> _parser = new pb::MessageParser<SecretEnvSource>(() => new SecretEnvSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecretEnvSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[170]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretEnvSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretEnvSource(SecretEnvSource other) : this() {
      _hasBits0 = other._hasBits0;
      localObjectReference_ = other.localObjectReference_ != null ? other.localObjectReference_.Clone() : null;
      optional_ = other.optional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretEnvSource Clone() {
      return new SecretEnvSource(this);
    }

    /// <summary>Field number for the "localObjectReference" field.</summary>
    public const int LocalObjectReferenceFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference localObjectReference_;
    /// <summary>
    /// The Secret to select from.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference LocalObjectReference {
      get { return localObjectReference_; }
      set {
        localObjectReference_ = value;
      }
    }

    /// <summary>Field number for the "optional" field.</summary>
    public const int OptionalFieldNumber = 2;
    private readonly static bool OptionalDefaultValue = false;

    private bool optional_;
    /// <summary>
    /// Specify whether the Secret must be defined
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Optional {
      get { if ((_hasBits0 & 1) != 0) { return optional_; } else { return OptionalDefaultValue; } }
      set {
        _hasBits0 |= 1;
        optional_ = value;
      }
    }
    /// <summary>Gets whether the "optional" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOptional {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "optional" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOptional() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecretEnvSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecretEnvSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LocalObjectReference, other.LocalObjectReference)) return false;
      if (Optional != other.Optional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (localObjectReference_ != null) hash ^= LocalObjectReference.GetHashCode();
      if (HasOptional) hash ^= Optional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      if (HasOptional) {
        output.WriteRawTag(16);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      if (HasOptional) {
        output.WriteRawTag(16);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (localObjectReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalObjectReference);
      }
      if (HasOptional) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecretEnvSource other) {
      if (other == null) {
        return;
      }
      if (other.localObjectReference_ != null) {
        if (localObjectReference_ == null) {
          LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        LocalObjectReference.MergeFrom(other.LocalObjectReference);
      }
      if (other.HasOptional) {
        Optional = other.Optional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 16: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 16: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SecretKeySelector selects a key of a Secret.
  /// +structType=atomic
  /// </summary>
  public sealed partial class SecretKeySelector : pb::IMessage<SecretKeySelector>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecretKeySelector> _parser = new pb::MessageParser<SecretKeySelector>(() => new SecretKeySelector());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecretKeySelector> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[171]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretKeySelector() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretKeySelector(SecretKeySelector other) : this() {
      _hasBits0 = other._hasBits0;
      localObjectReference_ = other.localObjectReference_ != null ? other.localObjectReference_.Clone() : null;
      key_ = other.key_;
      optional_ = other.optional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretKeySelector Clone() {
      return new SecretKeySelector(this);
    }

    /// <summary>Field number for the "localObjectReference" field.</summary>
    public const int LocalObjectReferenceFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference localObjectReference_;
    /// <summary>
    /// The name of the secret in the pod's namespace to select from.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference LocalObjectReference {
      get { return localObjectReference_; }
      set {
        localObjectReference_ = value;
      }
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 2;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    /// <summary>
    /// The key of the secret to select from.  Must be a valid secret key.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "optional" field.</summary>
    public const int OptionalFieldNumber = 3;
    private readonly static bool OptionalDefaultValue = false;

    private bool optional_;
    /// <summary>
    /// Specify whether the Secret or its key must be defined
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Optional {
      get { if ((_hasBits0 & 1) != 0) { return optional_; } else { return OptionalDefaultValue; } }
      set {
        _hasBits0 |= 1;
        optional_ = value;
      }
    }
    /// <summary>Gets whether the "optional" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOptional {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "optional" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOptional() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecretKeySelector);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecretKeySelector other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LocalObjectReference, other.LocalObjectReference)) return false;
      if (Key != other.Key) return false;
      if (Optional != other.Optional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (localObjectReference_ != null) hash ^= LocalObjectReference.GetHashCode();
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasOptional) hash ^= Optional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      if (HasKey) {
        output.WriteRawTag(18);
        output.WriteString(Key);
      }
      if (HasOptional) {
        output.WriteRawTag(24);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      if (HasKey) {
        output.WriteRawTag(18);
        output.WriteString(Key);
      }
      if (HasOptional) {
        output.WriteRawTag(24);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (localObjectReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalObjectReference);
      }
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (HasOptional) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecretKeySelector other) {
      if (other == null) {
        return;
      }
      if (other.localObjectReference_ != null) {
        if (localObjectReference_ == null) {
          LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        LocalObjectReference.MergeFrom(other.LocalObjectReference);
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasOptional) {
        Optional = other.Optional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 18: {
            Key = input.ReadString();
            break;
          }
          case 24: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 18: {
            Key = input.ReadString();
            break;
          }
          case 24: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SecretList is a list of Secret.
  /// </summary>
  public sealed partial class SecretList : pb::IMessage<SecretList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecretList> _parser = new pb::MessageParser<SecretList>(() => new SecretList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecretList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[172]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretList(SecretList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretList Clone() {
      return new SecretList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Secret> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.Secret.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Secret> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Secret>();
    /// <summary>
    /// Items is a list of secret objects.
    /// More info: https://kubernetes.io/docs/concepts/configuration/secret
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Secret> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecretList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecretList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecretList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Adapts a secret into a projected volume.
  ///
  /// The contents of the target Secret's Data field will be presented in a
  /// projected volume as files using the keys in the Data field as the file names.
  /// Note that this is identical to a secret volume source without the default
  /// mode.
  /// </summary>
  public sealed partial class SecretProjection : pb::IMessage<SecretProjection>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecretProjection> _parser = new pb::MessageParser<SecretProjection>(() => new SecretProjection());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecretProjection> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[173]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretProjection() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretProjection(SecretProjection other) : this() {
      _hasBits0 = other._hasBits0;
      localObjectReference_ = other.localObjectReference_ != null ? other.localObjectReference_.Clone() : null;
      items_ = other.items_.Clone();
      optional_ = other.optional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretProjection Clone() {
      return new SecretProjection(this);
    }

    /// <summary>Field number for the "localObjectReference" field.</summary>
    public const int LocalObjectReferenceFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference localObjectReference_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference LocalObjectReference {
      get { return localObjectReference_; }
      set {
        localObjectReference_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.KeyToPath> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.KeyToPath.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath>();
    /// <summary>
    /// If unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath> Items {
      get { return items_; }
    }

    /// <summary>Field number for the "optional" field.</summary>
    public const int OptionalFieldNumber = 4;
    private readonly static bool OptionalDefaultValue = false;

    private bool optional_;
    /// <summary>
    /// Specify whether the Secret or its key must be defined
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Optional {
      get { if ((_hasBits0 & 1) != 0) { return optional_; } else { return OptionalDefaultValue; } }
      set {
        _hasBits0 |= 1;
        optional_ = value;
      }
    }
    /// <summary>Gets whether the "optional" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOptional {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "optional" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOptional() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecretProjection);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecretProjection other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LocalObjectReference, other.LocalObjectReference)) return false;
      if(!items_.Equals(other.items_)) return false;
      if (Optional != other.Optional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (localObjectReference_ != null) hash ^= LocalObjectReference.GetHashCode();
      hash ^= items_.GetHashCode();
      if (HasOptional) hash ^= Optional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (HasOptional) {
        output.WriteRawTag(32);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (localObjectReference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalObjectReference);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (HasOptional) {
        output.WriteRawTag(32);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (localObjectReference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalObjectReference);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (HasOptional) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecretProjection other) {
      if (other == null) {
        return;
      }
      if (other.localObjectReference_ != null) {
        if (localObjectReference_ == null) {
          LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        LocalObjectReference.MergeFrom(other.LocalObjectReference);
      }
      items_.Add(other.items_);
      if (other.HasOptional) {
        Optional = other.Optional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
          case 32: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (localObjectReference_ == null) {
              LocalObjectReference = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(LocalObjectReference);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
          case 32: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SecretReference represents a Secret Reference. It has enough information to retrieve secret
  /// in any namespace
  /// +structType=atomic
  /// </summary>
  public sealed partial class SecretReference : pb::IMessage<SecretReference>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecretReference> _parser = new pb::MessageParser<SecretReference>(() => new SecretReference());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecretReference> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[174]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretReference() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretReference(SecretReference other) : this() {
      name_ = other.name_;
      namespace_ = other.namespace_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretReference Clone() {
      return new SecretReference(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name is unique within a namespace to reference a secret resource.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "namespace" field.</summary>
    public const int NamespaceFieldNumber = 2;
    private readonly static string NamespaceDefaultValue = "";

    private string namespace_;
    /// <summary>
    /// Namespace defines the space within which the secret name must be unique.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Namespace {
      get { return namespace_ ?? NamespaceDefaultValue; }
      set {
        namespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "namespace" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNamespace {
      get { return namespace_ != null; }
    }
    /// <summary>Clears the value of the "namespace" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNamespace() {
      namespace_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecretReference);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecretReference other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Namespace != other.Namespace) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasNamespace) hash ^= Namespace.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasNamespace) {
        output.WriteRawTag(18);
        output.WriteString(Namespace);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasNamespace) {
        output.WriteRawTag(18);
        output.WriteString(Namespace);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasNamespace) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Namespace);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecretReference other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasNamespace) {
        Namespace = other.Namespace;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Namespace = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Namespace = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Adapts a Secret into a volume.
  ///
  /// The contents of the target Secret's Data field will be presented in a volume
  /// as files using the keys in the Data field as the file names.
  /// Secret volumes support ownership management and SELinux relabeling.
  /// </summary>
  public sealed partial class SecretVolumeSource : pb::IMessage<SecretVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecretVolumeSource> _parser = new pb::MessageParser<SecretVolumeSource>(() => new SecretVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecretVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[175]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretVolumeSource(SecretVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      secretName_ = other.secretName_;
      items_ = other.items_.Clone();
      defaultMode_ = other.defaultMode_;
      optional_ = other.optional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecretVolumeSource Clone() {
      return new SecretVolumeSource(this);
    }

    /// <summary>Field number for the "secretName" field.</summary>
    public const int SecretNameFieldNumber = 1;
    private readonly static string SecretNameDefaultValue = "";

    private string secretName_;
    /// <summary>
    /// Name of the secret in the pod's namespace to use.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SecretName {
      get { return secretName_ ?? SecretNameDefaultValue; }
      set {
        secretName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "secretName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSecretName {
      get { return secretName_ != null; }
    }
    /// <summary>Clears the value of the "secretName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSecretName() {
      secretName_ = null;
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.KeyToPath> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.KeyToPath.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath>();
    /// <summary>
    /// If unspecified, each key-value pair in the Data field of the referenced
    /// Secret will be projected into the volume as a file whose name is the
    /// key and content is the value. If specified, the listed keys will be
    /// projected into the specified paths, and unlisted keys will not be
    /// present. If a key is specified which is not present in the Secret,
    /// the volume setup will error unless it is marked optional. Paths must be
    /// relative and may not contain the '..' path or start with '..'.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.KeyToPath> Items {
      get { return items_; }
    }

    /// <summary>Field number for the "defaultMode" field.</summary>
    public const int DefaultModeFieldNumber = 3;
    private readonly static int DefaultModeDefaultValue = 0;

    private int defaultMode_;
    /// <summary>
    /// Optional: mode bits used to set permissions on created files by default.
    /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    /// YAML accepts both octal and decimal values, JSON requires decimal values
    /// for mode bits. Defaults to 0644.
    /// Directories within the path are not affected by this setting.
    /// This might be in conflict with other options that affect the file
    /// mode, like fsGroup, and the result can be other mode bits set.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int DefaultMode {
      get { if ((_hasBits0 & 1) != 0) { return defaultMode_; } else { return DefaultModeDefaultValue; } }
      set {
        _hasBits0 |= 1;
        defaultMode_ = value;
      }
    }
    /// <summary>Gets whether the "defaultMode" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDefaultMode {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "defaultMode" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDefaultMode() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "optional" field.</summary>
    public const int OptionalFieldNumber = 4;
    private readonly static bool OptionalDefaultValue = false;

    private bool optional_;
    /// <summary>
    /// Specify whether the Secret or its keys must be defined
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Optional {
      get { if ((_hasBits0 & 2) != 0) { return optional_; } else { return OptionalDefaultValue; } }
      set {
        _hasBits0 |= 2;
        optional_ = value;
      }
    }
    /// <summary>Gets whether the "optional" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOptional {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "optional" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOptional() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecretVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecretVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SecretName != other.SecretName) return false;
      if(!items_.Equals(other.items_)) return false;
      if (DefaultMode != other.DefaultMode) return false;
      if (Optional != other.Optional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasSecretName) hash ^= SecretName.GetHashCode();
      hash ^= items_.GetHashCode();
      if (HasDefaultMode) hash ^= DefaultMode.GetHashCode();
      if (HasOptional) hash ^= Optional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasSecretName) {
        output.WriteRawTag(10);
        output.WriteString(SecretName);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (HasDefaultMode) {
        output.WriteRawTag(24);
        output.WriteInt32(DefaultMode);
      }
      if (HasOptional) {
        output.WriteRawTag(32);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasSecretName) {
        output.WriteRawTag(10);
        output.WriteString(SecretName);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (HasDefaultMode) {
        output.WriteRawTag(24);
        output.WriteInt32(DefaultMode);
      }
      if (HasOptional) {
        output.WriteRawTag(32);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasSecretName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SecretName);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (HasDefaultMode) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(DefaultMode);
      }
      if (HasOptional) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecretVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasSecretName) {
        SecretName = other.SecretName;
      }
      items_.Add(other.items_);
      if (other.HasDefaultMode) {
        DefaultMode = other.DefaultMode;
      }
      if (other.HasOptional) {
        Optional = other.Optional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            SecretName = input.ReadString();
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
          case 24: {
            DefaultMode = input.ReadInt32();
            break;
          }
          case 32: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            SecretName = input.ReadString();
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
          case 24: {
            DefaultMode = input.ReadInt32();
            break;
          }
          case 32: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SecurityContext holds security configuration that will be applied to a container.
  /// Some fields are present in both SecurityContext and PodSecurityContext.  When both
  /// are set, the values in SecurityContext take precedence.
  /// </summary>
  public sealed partial class SecurityContext : pb::IMessage<SecurityContext>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SecurityContext> _parser = new pb::MessageParser<SecurityContext>(() => new SecurityContext());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SecurityContext> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[176]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecurityContext() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecurityContext(SecurityContext other) : this() {
      _hasBits0 = other._hasBits0;
      capabilities_ = other.capabilities_ != null ? other.capabilities_.Clone() : null;
      privileged_ = other.privileged_;
      seLinuxOptions_ = other.seLinuxOptions_ != null ? other.seLinuxOptions_.Clone() : null;
      windowsOptions_ = other.windowsOptions_ != null ? other.windowsOptions_.Clone() : null;
      runAsUser_ = other.runAsUser_;
      runAsGroup_ = other.runAsGroup_;
      runAsNonRoot_ = other.runAsNonRoot_;
      readOnlyRootFilesystem_ = other.readOnlyRootFilesystem_;
      allowPrivilegeEscalation_ = other.allowPrivilegeEscalation_;
      procMount_ = other.procMount_;
      seccompProfile_ = other.seccompProfile_ != null ? other.seccompProfile_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SecurityContext Clone() {
      return new SecurityContext(this);
    }

    /// <summary>Field number for the "capabilities" field.</summary>
    public const int CapabilitiesFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.Capabilities capabilities_;
    /// <summary>
    /// The capabilities to add/drop when running containers.
    /// Defaults to the default set of capabilities granted by the container runtime.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.Capabilities Capabilities {
      get { return capabilities_; }
      set {
        capabilities_ = value;
      }
    }

    /// <summary>Field number for the "privileged" field.</summary>
    public const int PrivilegedFieldNumber = 2;
    private readonly static bool PrivilegedDefaultValue = false;

    private bool privileged_;
    /// <summary>
    /// Run container in privileged mode.
    /// Processes in privileged containers are essentially equivalent to root on the host.
    /// Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Privileged {
      get { if ((_hasBits0 & 1) != 0) { return privileged_; } else { return PrivilegedDefaultValue; } }
      set {
        _hasBits0 |= 1;
        privileged_ = value;
      }
    }
    /// <summary>Gets whether the "privileged" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPrivileged {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "privileged" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPrivileged() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "seLinuxOptions" field.</summary>
    public const int SeLinuxOptionsFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.SELinuxOptions seLinuxOptions_;
    /// <summary>
    /// The SELinux context to be applied to the container.
    /// If unspecified, the container runtime will allocate a random SELinux context for each
    /// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SELinuxOptions SeLinuxOptions {
      get { return seLinuxOptions_; }
      set {
        seLinuxOptions_ = value;
      }
    }

    /// <summary>Field number for the "windowsOptions" field.</summary>
    public const int WindowsOptionsFieldNumber = 10;
    private global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions windowsOptions_;
    /// <summary>
    /// The Windows specific settings applied to all containers.
    /// If unspecified, the options from the PodSecurityContext will be used.
    /// If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions WindowsOptions {
      get { return windowsOptions_; }
      set {
        windowsOptions_ = value;
      }
    }

    /// <summary>Field number for the "runAsUser" field.</summary>
    public const int RunAsUserFieldNumber = 4;
    private readonly static long RunAsUserDefaultValue = 0L;

    private long runAsUser_;
    /// <summary>
    /// The UID to run the entrypoint of the container process.
    /// Defaults to user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RunAsUser {
      get { if ((_hasBits0 & 2) != 0) { return runAsUser_; } else { return RunAsUserDefaultValue; } }
      set {
        _hasBits0 |= 2;
        runAsUser_ = value;
      }
    }
    /// <summary>Gets whether the "runAsUser" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRunAsUser {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "runAsUser" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRunAsUser() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "runAsGroup" field.</summary>
    public const int RunAsGroupFieldNumber = 8;
    private readonly static long RunAsGroupDefaultValue = 0L;

    private long runAsGroup_;
    /// <summary>
    /// The GID to run the entrypoint of the container process.
    /// Uses runtime default if unset.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long RunAsGroup {
      get { if ((_hasBits0 & 32) != 0) { return runAsGroup_; } else { return RunAsGroupDefaultValue; } }
      set {
        _hasBits0 |= 32;
        runAsGroup_ = value;
      }
    }
    /// <summary>Gets whether the "runAsGroup" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRunAsGroup {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "runAsGroup" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRunAsGroup() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "runAsNonRoot" field.</summary>
    public const int RunAsNonRootFieldNumber = 5;
    private readonly static bool RunAsNonRootDefaultValue = false;

    private bool runAsNonRoot_;
    /// <summary>
    /// Indicates that the container must run as a non-root user.
    /// If true, the Kubelet will validate the image at runtime to ensure that it
    /// does not run as UID 0 (root) and fail to start the container if it does.
    /// If unset or false, no such validation will be performed.
    /// May also be set in PodSecurityContext.  If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool RunAsNonRoot {
      get { if ((_hasBits0 & 4) != 0) { return runAsNonRoot_; } else { return RunAsNonRootDefaultValue; } }
      set {
        _hasBits0 |= 4;
        runAsNonRoot_ = value;
      }
    }
    /// <summary>Gets whether the "runAsNonRoot" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRunAsNonRoot {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "runAsNonRoot" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRunAsNonRoot() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "readOnlyRootFilesystem" field.</summary>
    public const int ReadOnlyRootFilesystemFieldNumber = 6;
    private readonly static bool ReadOnlyRootFilesystemDefaultValue = false;

    private bool readOnlyRootFilesystem_;
    /// <summary>
    /// Whether this container has a read-only root filesystem.
    /// Default is false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnlyRootFilesystem {
      get { if ((_hasBits0 & 8) != 0) { return readOnlyRootFilesystem_; } else { return ReadOnlyRootFilesystemDefaultValue; } }
      set {
        _hasBits0 |= 8;
        readOnlyRootFilesystem_ = value;
      }
    }
    /// <summary>Gets whether the "readOnlyRootFilesystem" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnlyRootFilesystem {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "readOnlyRootFilesystem" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnlyRootFilesystem() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "allowPrivilegeEscalation" field.</summary>
    public const int AllowPrivilegeEscalationFieldNumber = 7;
    private readonly static bool AllowPrivilegeEscalationDefaultValue = false;

    private bool allowPrivilegeEscalation_;
    /// <summary>
    /// AllowPrivilegeEscalation controls whether a process can gain more
    /// privileges than its parent process. This bool directly controls if
    /// the no_new_privs flag will be set on the container process.
    /// AllowPrivilegeEscalation is true always when the container is:
    /// 1) run as Privileged
    /// 2) has CAP_SYS_ADMIN
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowPrivilegeEscalation {
      get { if ((_hasBits0 & 16) != 0) { return allowPrivilegeEscalation_; } else { return AllowPrivilegeEscalationDefaultValue; } }
      set {
        _hasBits0 |= 16;
        allowPrivilegeEscalation_ = value;
      }
    }
    /// <summary>Gets whether the "allowPrivilegeEscalation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAllowPrivilegeEscalation {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "allowPrivilegeEscalation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAllowPrivilegeEscalation() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "procMount" field.</summary>
    public const int ProcMountFieldNumber = 9;
    private readonly static string ProcMountDefaultValue = "";

    private string procMount_;
    /// <summary>
    /// procMount denotes the type of proc mount to use for the containers.
    /// The default is DefaultProcMount which uses the container runtime defaults for
    /// readonly paths and masked paths.
    /// This requires the ProcMountType feature flag to be enabled.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ProcMount {
      get { return procMount_ ?? ProcMountDefaultValue; }
      set {
        procMount_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "procMount" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProcMount {
      get { return procMount_ != null; }
    }
    /// <summary>Clears the value of the "procMount" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProcMount() {
      procMount_ = null;
    }

    /// <summary>Field number for the "seccompProfile" field.</summary>
    public const int SeccompProfileFieldNumber = 11;
    private global::K8S.Io.Api.Core.V1.SeccompProfile seccompProfile_;
    /// <summary>
    /// The seccomp options to use by this container. If seccomp options are
    /// provided at both the pod &amp; container level, the container options
    /// override the pod options.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SeccompProfile SeccompProfile {
      get { return seccompProfile_; }
      set {
        seccompProfile_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SecurityContext);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SecurityContext other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Capabilities, other.Capabilities)) return false;
      if (Privileged != other.Privileged) return false;
      if (!object.Equals(SeLinuxOptions, other.SeLinuxOptions)) return false;
      if (!object.Equals(WindowsOptions, other.WindowsOptions)) return false;
      if (RunAsUser != other.RunAsUser) return false;
      if (RunAsGroup != other.RunAsGroup) return false;
      if (RunAsNonRoot != other.RunAsNonRoot) return false;
      if (ReadOnlyRootFilesystem != other.ReadOnlyRootFilesystem) return false;
      if (AllowPrivilegeEscalation != other.AllowPrivilegeEscalation) return false;
      if (ProcMount != other.ProcMount) return false;
      if (!object.Equals(SeccompProfile, other.SeccompProfile)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (capabilities_ != null) hash ^= Capabilities.GetHashCode();
      if (HasPrivileged) hash ^= Privileged.GetHashCode();
      if (seLinuxOptions_ != null) hash ^= SeLinuxOptions.GetHashCode();
      if (windowsOptions_ != null) hash ^= WindowsOptions.GetHashCode();
      if (HasRunAsUser) hash ^= RunAsUser.GetHashCode();
      if (HasRunAsGroup) hash ^= RunAsGroup.GetHashCode();
      if (HasRunAsNonRoot) hash ^= RunAsNonRoot.GetHashCode();
      if (HasReadOnlyRootFilesystem) hash ^= ReadOnlyRootFilesystem.GetHashCode();
      if (HasAllowPrivilegeEscalation) hash ^= AllowPrivilegeEscalation.GetHashCode();
      if (HasProcMount) hash ^= ProcMount.GetHashCode();
      if (seccompProfile_ != null) hash ^= SeccompProfile.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (capabilities_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Capabilities);
      }
      if (HasPrivileged) {
        output.WriteRawTag(16);
        output.WriteBool(Privileged);
      }
      if (seLinuxOptions_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SeLinuxOptions);
      }
      if (HasRunAsUser) {
        output.WriteRawTag(32);
        output.WriteInt64(RunAsUser);
      }
      if (HasRunAsNonRoot) {
        output.WriteRawTag(40);
        output.WriteBool(RunAsNonRoot);
      }
      if (HasReadOnlyRootFilesystem) {
        output.WriteRawTag(48);
        output.WriteBool(ReadOnlyRootFilesystem);
      }
      if (HasAllowPrivilegeEscalation) {
        output.WriteRawTag(56);
        output.WriteBool(AllowPrivilegeEscalation);
      }
      if (HasRunAsGroup) {
        output.WriteRawTag(64);
        output.WriteInt64(RunAsGroup);
      }
      if (HasProcMount) {
        output.WriteRawTag(74);
        output.WriteString(ProcMount);
      }
      if (windowsOptions_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(WindowsOptions);
      }
      if (seccompProfile_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(SeccompProfile);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (capabilities_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Capabilities);
      }
      if (HasPrivileged) {
        output.WriteRawTag(16);
        output.WriteBool(Privileged);
      }
      if (seLinuxOptions_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(SeLinuxOptions);
      }
      if (HasRunAsUser) {
        output.WriteRawTag(32);
        output.WriteInt64(RunAsUser);
      }
      if (HasRunAsNonRoot) {
        output.WriteRawTag(40);
        output.WriteBool(RunAsNonRoot);
      }
      if (HasReadOnlyRootFilesystem) {
        output.WriteRawTag(48);
        output.WriteBool(ReadOnlyRootFilesystem);
      }
      if (HasAllowPrivilegeEscalation) {
        output.WriteRawTag(56);
        output.WriteBool(AllowPrivilegeEscalation);
      }
      if (HasRunAsGroup) {
        output.WriteRawTag(64);
        output.WriteInt64(RunAsGroup);
      }
      if (HasProcMount) {
        output.WriteRawTag(74);
        output.WriteString(ProcMount);
      }
      if (windowsOptions_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(WindowsOptions);
      }
      if (seccompProfile_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(SeccompProfile);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (capabilities_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Capabilities);
      }
      if (HasPrivileged) {
        size += 1 + 1;
      }
      if (seLinuxOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SeLinuxOptions);
      }
      if (windowsOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WindowsOptions);
      }
      if (HasRunAsUser) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RunAsUser);
      }
      if (HasRunAsGroup) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RunAsGroup);
      }
      if (HasRunAsNonRoot) {
        size += 1 + 1;
      }
      if (HasReadOnlyRootFilesystem) {
        size += 1 + 1;
      }
      if (HasAllowPrivilegeEscalation) {
        size += 1 + 1;
      }
      if (HasProcMount) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProcMount);
      }
      if (seccompProfile_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SeccompProfile);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SecurityContext other) {
      if (other == null) {
        return;
      }
      if (other.capabilities_ != null) {
        if (capabilities_ == null) {
          Capabilities = new global::K8S.Io.Api.Core.V1.Capabilities();
        }
        Capabilities.MergeFrom(other.Capabilities);
      }
      if (other.HasPrivileged) {
        Privileged = other.Privileged;
      }
      if (other.seLinuxOptions_ != null) {
        if (seLinuxOptions_ == null) {
          SeLinuxOptions = new global::K8S.Io.Api.Core.V1.SELinuxOptions();
        }
        SeLinuxOptions.MergeFrom(other.SeLinuxOptions);
      }
      if (other.windowsOptions_ != null) {
        if (windowsOptions_ == null) {
          WindowsOptions = new global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions();
        }
        WindowsOptions.MergeFrom(other.WindowsOptions);
      }
      if (other.HasRunAsUser) {
        RunAsUser = other.RunAsUser;
      }
      if (other.HasRunAsGroup) {
        RunAsGroup = other.RunAsGroup;
      }
      if (other.HasRunAsNonRoot) {
        RunAsNonRoot = other.RunAsNonRoot;
      }
      if (other.HasReadOnlyRootFilesystem) {
        ReadOnlyRootFilesystem = other.ReadOnlyRootFilesystem;
      }
      if (other.HasAllowPrivilegeEscalation) {
        AllowPrivilegeEscalation = other.AllowPrivilegeEscalation;
      }
      if (other.HasProcMount) {
        ProcMount = other.ProcMount;
      }
      if (other.seccompProfile_ != null) {
        if (seccompProfile_ == null) {
          SeccompProfile = new global::K8S.Io.Api.Core.V1.SeccompProfile();
        }
        SeccompProfile.MergeFrom(other.SeccompProfile);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (capabilities_ == null) {
              Capabilities = new global::K8S.Io.Api.Core.V1.Capabilities();
            }
            input.ReadMessage(Capabilities);
            break;
          }
          case 16: {
            Privileged = input.ReadBool();
            break;
          }
          case 26: {
            if (seLinuxOptions_ == null) {
              SeLinuxOptions = new global::K8S.Io.Api.Core.V1.SELinuxOptions();
            }
            input.ReadMessage(SeLinuxOptions);
            break;
          }
          case 32: {
            RunAsUser = input.ReadInt64();
            break;
          }
          case 40: {
            RunAsNonRoot = input.ReadBool();
            break;
          }
          case 48: {
            ReadOnlyRootFilesystem = input.ReadBool();
            break;
          }
          case 56: {
            AllowPrivilegeEscalation = input.ReadBool();
            break;
          }
          case 64: {
            RunAsGroup = input.ReadInt64();
            break;
          }
          case 74: {
            ProcMount = input.ReadString();
            break;
          }
          case 82: {
            if (windowsOptions_ == null) {
              WindowsOptions = new global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions();
            }
            input.ReadMessage(WindowsOptions);
            break;
          }
          case 90: {
            if (seccompProfile_ == null) {
              SeccompProfile = new global::K8S.Io.Api.Core.V1.SeccompProfile();
            }
            input.ReadMessage(SeccompProfile);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (capabilities_ == null) {
              Capabilities = new global::K8S.Io.Api.Core.V1.Capabilities();
            }
            input.ReadMessage(Capabilities);
            break;
          }
          case 16: {
            Privileged = input.ReadBool();
            break;
          }
          case 26: {
            if (seLinuxOptions_ == null) {
              SeLinuxOptions = new global::K8S.Io.Api.Core.V1.SELinuxOptions();
            }
            input.ReadMessage(SeLinuxOptions);
            break;
          }
          case 32: {
            RunAsUser = input.ReadInt64();
            break;
          }
          case 40: {
            RunAsNonRoot = input.ReadBool();
            break;
          }
          case 48: {
            ReadOnlyRootFilesystem = input.ReadBool();
            break;
          }
          case 56: {
            AllowPrivilegeEscalation = input.ReadBool();
            break;
          }
          case 64: {
            RunAsGroup = input.ReadInt64();
            break;
          }
          case 74: {
            ProcMount = input.ReadString();
            break;
          }
          case 82: {
            if (windowsOptions_ == null) {
              WindowsOptions = new global::K8S.Io.Api.Core.V1.WindowsSecurityContextOptions();
            }
            input.ReadMessage(WindowsOptions);
            break;
          }
          case 90: {
            if (seccompProfile_ == null) {
              SeccompProfile = new global::K8S.Io.Api.Core.V1.SeccompProfile();
            }
            input.ReadMessage(SeccompProfile);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SerializedReference is a reference to serialized object.
  /// </summary>
  public sealed partial class SerializedReference : pb::IMessage<SerializedReference>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SerializedReference> _parser = new pb::MessageParser<SerializedReference>(() => new SerializedReference());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SerializedReference> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[177]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SerializedReference() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SerializedReference(SerializedReference other) : this() {
      reference_ = other.reference_ != null ? other.reference_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SerializedReference Clone() {
      return new SerializedReference(this);
    }

    /// <summary>Field number for the "reference" field.</summary>
    public const int ReferenceFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.ObjectReference reference_;
    /// <summary>
    /// The reference to an object in the system.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ObjectReference Reference {
      get { return reference_; }
      set {
        reference_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SerializedReference);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SerializedReference other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Reference, other.Reference)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (reference_ != null) hash ^= Reference.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (reference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Reference);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (reference_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Reference);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (reference_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Reference);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SerializedReference other) {
      if (other == null) {
        return;
      }
      if (other.reference_ != null) {
        if (reference_ == null) {
          Reference = new global::K8S.Io.Api.Core.V1.ObjectReference();
        }
        Reference.MergeFrom(other.Reference);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (reference_ == null) {
              Reference = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(Reference);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (reference_ == null) {
              Reference = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(Reference);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Service is a named abstraction of software service (for example, mysql) consisting of local port
  /// (for example 3306) that the proxy listens on, and the selector that determines which pods
  /// will answer requests sent through the proxy.
  /// </summary>
  public sealed partial class Service : pb::IMessage<Service>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Service> _parser = new pb::MessageParser<Service>(() => new Service());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Service> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[178]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Service() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Service(Service other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Service Clone() {
      return new Service(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.ServiceSpec spec_;
    /// <summary>
    /// Spec defines the behavior of a service.
    /// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ServiceSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.ServiceStatus status_;
    /// <summary>
    /// Most recently observed status of the service.
    /// Populated by the system.
    /// Read-only.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ServiceStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Service);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Service other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Service other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Core.V1.ServiceSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::K8S.Io.Api.Core.V1.ServiceStatus();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.ServiceSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.ServiceStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Core.V1.ServiceSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Core.V1.ServiceStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ServiceAccount binds together:
  /// * a name, understood by users, and perhaps by peripheral systems, for an identity
  /// * a principal that can be authenticated and authorized
  /// * a set of secrets
  /// </summary>
  public sealed partial class ServiceAccount : pb::IMessage<ServiceAccount>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServiceAccount> _parser = new pb::MessageParser<ServiceAccount>(() => new ServiceAccount());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServiceAccount> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[179]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccount() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccount(ServiceAccount other) : this() {
      _hasBits0 = other._hasBits0;
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      secrets_ = other.secrets_.Clone();
      imagePullSecrets_ = other.imagePullSecrets_.Clone();
      automountServiceAccountToken_ = other.automountServiceAccountToken_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccount Clone() {
      return new ServiceAccount(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "secrets" field.</summary>
    public const int SecretsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ObjectReference> _repeated_secrets_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.ObjectReference.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ObjectReference> secrets_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ObjectReference>();
    /// <summary>
    /// Secrets is the list of secrets allowed to be used by pods running using this ServiceAccount.
    /// More info: https://kubernetes.io/docs/concepts/configuration/secret
    /// +optional
    /// +patchMergeKey=name
    /// +patchStrategy=merge
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ObjectReference> Secrets {
      get { return secrets_; }
    }

    /// <summary>Field number for the "imagePullSecrets" field.</summary>
    public const int ImagePullSecretsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.LocalObjectReference> _repeated_imagePullSecrets_codec
        = pb::FieldCodec.ForMessage(26, global::K8S.Io.Api.Core.V1.LocalObjectReference.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LocalObjectReference> imagePullSecrets_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LocalObjectReference>();
    /// <summary>
    /// ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
    /// in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
    /// can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
    /// More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.LocalObjectReference> ImagePullSecrets {
      get { return imagePullSecrets_; }
    }

    /// <summary>Field number for the "automountServiceAccountToken" field.</summary>
    public const int AutomountServiceAccountTokenFieldNumber = 4;
    private readonly static bool AutomountServiceAccountTokenDefaultValue = false;

    private bool automountServiceAccountToken_;
    /// <summary>
    /// AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.
    /// Can be overridden at the pod level.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AutomountServiceAccountToken {
      get { if ((_hasBits0 & 1) != 0) { return automountServiceAccountToken_; } else { return AutomountServiceAccountTokenDefaultValue; } }
      set {
        _hasBits0 |= 1;
        automountServiceAccountToken_ = value;
      }
    }
    /// <summary>Gets whether the "automountServiceAccountToken" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAutomountServiceAccountToken {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "automountServiceAccountToken" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAutomountServiceAccountToken() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServiceAccount);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServiceAccount other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!secrets_.Equals(other.secrets_)) return false;
      if(!imagePullSecrets_.Equals(other.imagePullSecrets_)) return false;
      if (AutomountServiceAccountToken != other.AutomountServiceAccountToken) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= secrets_.GetHashCode();
      hash ^= imagePullSecrets_.GetHashCode();
      if (HasAutomountServiceAccountToken) hash ^= AutomountServiceAccountToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      secrets_.WriteTo(output, _repeated_secrets_codec);
      imagePullSecrets_.WriteTo(output, _repeated_imagePullSecrets_codec);
      if (HasAutomountServiceAccountToken) {
        output.WriteRawTag(32);
        output.WriteBool(AutomountServiceAccountToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      secrets_.WriteTo(ref output, _repeated_secrets_codec);
      imagePullSecrets_.WriteTo(ref output, _repeated_imagePullSecrets_codec);
      if (HasAutomountServiceAccountToken) {
        output.WriteRawTag(32);
        output.WriteBool(AutomountServiceAccountToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += secrets_.CalculateSize(_repeated_secrets_codec);
      size += imagePullSecrets_.CalculateSize(_repeated_imagePullSecrets_codec);
      if (HasAutomountServiceAccountToken) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServiceAccount other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      secrets_.Add(other.secrets_);
      imagePullSecrets_.Add(other.imagePullSecrets_);
      if (other.HasAutomountServiceAccountToken) {
        AutomountServiceAccountToken = other.AutomountServiceAccountToken;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            secrets_.AddEntriesFrom(input, _repeated_secrets_codec);
            break;
          }
          case 26: {
            imagePullSecrets_.AddEntriesFrom(input, _repeated_imagePullSecrets_codec);
            break;
          }
          case 32: {
            AutomountServiceAccountToken = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            secrets_.AddEntriesFrom(ref input, _repeated_secrets_codec);
            break;
          }
          case 26: {
            imagePullSecrets_.AddEntriesFrom(ref input, _repeated_imagePullSecrets_codec);
            break;
          }
          case 32: {
            AutomountServiceAccountToken = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ServiceAccountList is a list of ServiceAccount objects
  /// </summary>
  public sealed partial class ServiceAccountList : pb::IMessage<ServiceAccountList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServiceAccountList> _parser = new pb::MessageParser<ServiceAccountList>(() => new ServiceAccountList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServiceAccountList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[180]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccountList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccountList(ServiceAccountList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccountList Clone() {
      return new ServiceAccountList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ServiceAccount> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.ServiceAccount.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ServiceAccount> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ServiceAccount>();
    /// <summary>
    /// List of ServiceAccounts.
    /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ServiceAccount> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServiceAccountList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServiceAccountList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServiceAccountList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ServiceAccountTokenProjection represents a projected service account token
  /// volume. This projection can be used to insert a service account token into
  /// the pods runtime filesystem for use against APIs (Kubernetes API Server or
  /// otherwise).
  /// </summary>
  public sealed partial class ServiceAccountTokenProjection : pb::IMessage<ServiceAccountTokenProjection>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServiceAccountTokenProjection> _parser = new pb::MessageParser<ServiceAccountTokenProjection>(() => new ServiceAccountTokenProjection());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServiceAccountTokenProjection> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[181]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccountTokenProjection() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccountTokenProjection(ServiceAccountTokenProjection other) : this() {
      _hasBits0 = other._hasBits0;
      audience_ = other.audience_;
      expirationSeconds_ = other.expirationSeconds_;
      path_ = other.path_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceAccountTokenProjection Clone() {
      return new ServiceAccountTokenProjection(this);
    }

    /// <summary>Field number for the "audience" field.</summary>
    public const int AudienceFieldNumber = 1;
    private readonly static string AudienceDefaultValue = "";

    private string audience_;
    /// <summary>
    /// Audience is the intended audience of the token. A recipient of a token
    /// must identify itself with an identifier specified in the audience of the
    /// token, and otherwise should reject the token. The audience defaults to the
    /// identifier of the apiserver.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Audience {
      get { return audience_ ?? AudienceDefaultValue; }
      set {
        audience_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "audience" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAudience {
      get { return audience_ != null; }
    }
    /// <summary>Clears the value of the "audience" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAudience() {
      audience_ = null;
    }

    /// <summary>Field number for the "expirationSeconds" field.</summary>
    public const int ExpirationSecondsFieldNumber = 2;
    private readonly static long ExpirationSecondsDefaultValue = 0L;

    private long expirationSeconds_;
    /// <summary>
    /// ExpirationSeconds is the requested duration of validity of the service
    /// account token. As the token approaches expiration, the kubelet volume
    /// plugin will proactively rotate the service account token. The kubelet will
    /// start trying to rotate the token if the token is older than 80 percent of
    /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
    /// and must be at least 10 minutes.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long ExpirationSeconds {
      get { if ((_hasBits0 & 1) != 0) { return expirationSeconds_; } else { return ExpirationSecondsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        expirationSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "expirationSeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExpirationSeconds {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "expirationSeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExpirationSeconds() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 3;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Path is the path relative to the mount point of the file to project the
    /// token into.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServiceAccountTokenProjection);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServiceAccountTokenProjection other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Audience != other.Audience) return false;
      if (ExpirationSeconds != other.ExpirationSeconds) return false;
      if (Path != other.Path) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAudience) hash ^= Audience.GetHashCode();
      if (HasExpirationSeconds) hash ^= ExpirationSeconds.GetHashCode();
      if (HasPath) hash ^= Path.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAudience) {
        output.WriteRawTag(10);
        output.WriteString(Audience);
      }
      if (HasExpirationSeconds) {
        output.WriteRawTag(16);
        output.WriteInt64(ExpirationSeconds);
      }
      if (HasPath) {
        output.WriteRawTag(26);
        output.WriteString(Path);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAudience) {
        output.WriteRawTag(10);
        output.WriteString(Audience);
      }
      if (HasExpirationSeconds) {
        output.WriteRawTag(16);
        output.WriteInt64(ExpirationSeconds);
      }
      if (HasPath) {
        output.WriteRawTag(26);
        output.WriteString(Path);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAudience) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Audience);
      }
      if (HasExpirationSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ExpirationSeconds);
      }
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServiceAccountTokenProjection other) {
      if (other == null) {
        return;
      }
      if (other.HasAudience) {
        Audience = other.Audience;
      }
      if (other.HasExpirationSeconds) {
        ExpirationSeconds = other.ExpirationSeconds;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Audience = input.ReadString();
            break;
          }
          case 16: {
            ExpirationSeconds = input.ReadInt64();
            break;
          }
          case 26: {
            Path = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Audience = input.ReadString();
            break;
          }
          case 16: {
            ExpirationSeconds = input.ReadInt64();
            break;
          }
          case 26: {
            Path = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ServiceList holds a list of services.
  /// </summary>
  public sealed partial class ServiceList : pb::IMessage<ServiceList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServiceList> _parser = new pb::MessageParser<ServiceList>(() => new ServiceList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServiceList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[182]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceList(ServiceList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceList Clone() {
      return new ServiceList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.Service> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Core.V1.Service.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Service> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Service>();
    /// <summary>
    /// List of services
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.Service> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServiceList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServiceList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServiceList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ServicePort contains information on service's port.
  /// </summary>
  public sealed partial class ServicePort : pb::IMessage<ServicePort>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServicePort> _parser = new pb::MessageParser<ServicePort>(() => new ServicePort());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServicePort> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[183]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServicePort() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServicePort(ServicePort other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      protocol_ = other.protocol_;
      appProtocol_ = other.appProtocol_;
      port_ = other.port_;
      targetPort_ = other.targetPort_ != null ? other.targetPort_.Clone() : null;
      nodePort_ = other.nodePort_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServicePort Clone() {
      return new ServicePort(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// The name of this port within the service. This must be a DNS_LABEL.
    /// All ports within a ServiceSpec must have unique names. When considering
    /// the endpoints for a Service, this must match the 'name' field in the
    /// EndpointPort.
    /// Optional if only one ServicePort is defined on this service.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 2;
    private readonly static string ProtocolDefaultValue = "";

    private string protocol_;
    /// <summary>
    /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
    /// Default is TCP.
    /// +default="TCP"
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Protocol {
      get { return protocol_ ?? ProtocolDefaultValue; }
      set {
        protocol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "protocol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProtocol {
      get { return protocol_ != null; }
    }
    /// <summary>Clears the value of the "protocol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProtocol() {
      protocol_ = null;
    }

    /// <summary>Field number for the "appProtocol" field.</summary>
    public const int AppProtocolFieldNumber = 6;
    private readonly static string AppProtocolDefaultValue = "";

    private string appProtocol_;
    /// <summary>
    /// The application protocol for this port.
    /// This field follows standard Kubernetes label syntax.
    /// Un-prefixed names are reserved for IANA standard service names (as per
    /// RFC-6335 and http://www.iana.org/assignments/service-names).
    /// Non-standard protocols should use prefixed names such as
    /// mycompany.com/my-custom-protocol.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string AppProtocol {
      get { return appProtocol_ ?? AppProtocolDefaultValue; }
      set {
        appProtocol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "appProtocol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAppProtocol {
      get { return appProtocol_ != null; }
    }
    /// <summary>Clears the value of the "appProtocol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAppProtocol() {
      appProtocol_ = null;
    }

    /// <summary>Field number for the "port" field.</summary>
    public const int PortFieldNumber = 3;
    private readonly static int PortDefaultValue = 0;

    private int port_;
    /// <summary>
    /// The port that will be exposed by this service.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Port {
      get { if ((_hasBits0 & 1) != 0) { return port_; } else { return PortDefaultValue; } }
      set {
        _hasBits0 |= 1;
        port_ = value;
      }
    }
    /// <summary>Gets whether the "port" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPort {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "port" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPort() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "targetPort" field.</summary>
    public const int TargetPortFieldNumber = 4;
    private global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString targetPort_;
    /// <summary>
    /// Number or name of the port to access on the pods targeted by the service.
    /// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    /// If this is a string, it will be looked up as a named port in the
    /// target Pod's container ports. If this is not specified, the value
    /// of the 'port' field is used (an identity map).
    /// This field is ignored for services with clusterIP=None, and should be
    /// omitted or set equal to the 'port' field.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString TargetPort {
      get { return targetPort_; }
      set {
        targetPort_ = value;
      }
    }

    /// <summary>Field number for the "nodePort" field.</summary>
    public const int NodePortFieldNumber = 5;
    private readonly static int NodePortDefaultValue = 0;

    private int nodePort_;
    /// <summary>
    /// The port on each node on which this service is exposed when type is
    /// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
    /// specified, in-range, and not in use it will be used, otherwise the
    /// operation will fail.  If not specified, a port will be allocated if this
    /// Service requires one.  If this field is specified when creating a
    /// Service which does not need it, creation will fail. This field will be
    /// wiped when updating a Service to no longer need it (e.g. changing type
    /// from NodePort to ClusterIP).
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int NodePort {
      get { if ((_hasBits0 & 2) != 0) { return nodePort_; } else { return NodePortDefaultValue; } }
      set {
        _hasBits0 |= 2;
        nodePort_ = value;
      }
    }
    /// <summary>Gets whether the "nodePort" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNodePort {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "nodePort" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNodePort() {
      _hasBits0 &= ~2;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServicePort);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServicePort other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Protocol != other.Protocol) return false;
      if (AppProtocol != other.AppProtocol) return false;
      if (Port != other.Port) return false;
      if (!object.Equals(TargetPort, other.TargetPort)) return false;
      if (NodePort != other.NodePort) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasProtocol) hash ^= Protocol.GetHashCode();
      if (HasAppProtocol) hash ^= AppProtocol.GetHashCode();
      if (HasPort) hash ^= Port.GetHashCode();
      if (targetPort_ != null) hash ^= TargetPort.GetHashCode();
      if (HasNodePort) hash ^= NodePort.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasProtocol) {
        output.WriteRawTag(18);
        output.WriteString(Protocol);
      }
      if (HasPort) {
        output.WriteRawTag(24);
        output.WriteInt32(Port);
      }
      if (targetPort_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(TargetPort);
      }
      if (HasNodePort) {
        output.WriteRawTag(40);
        output.WriteInt32(NodePort);
      }
      if (HasAppProtocol) {
        output.WriteRawTag(50);
        output.WriteString(AppProtocol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasProtocol) {
        output.WriteRawTag(18);
        output.WriteString(Protocol);
      }
      if (HasPort) {
        output.WriteRawTag(24);
        output.WriteInt32(Port);
      }
      if (targetPort_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(TargetPort);
      }
      if (HasNodePort) {
        output.WriteRawTag(40);
        output.WriteInt32(NodePort);
      }
      if (HasAppProtocol) {
        output.WriteRawTag(50);
        output.WriteString(AppProtocol);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasProtocol) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Protocol);
      }
      if (HasAppProtocol) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AppProtocol);
      }
      if (HasPort) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Port);
      }
      if (targetPort_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TargetPort);
      }
      if (HasNodePort) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NodePort);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServicePort other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasProtocol) {
        Protocol = other.Protocol;
      }
      if (other.HasAppProtocol) {
        AppProtocol = other.AppProtocol;
      }
      if (other.HasPort) {
        Port = other.Port;
      }
      if (other.targetPort_ != null) {
        if (targetPort_ == null) {
          TargetPort = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
        }
        TargetPort.MergeFrom(other.TargetPort);
      }
      if (other.HasNodePort) {
        NodePort = other.NodePort;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Protocol = input.ReadString();
            break;
          }
          case 24: {
            Port = input.ReadInt32();
            break;
          }
          case 34: {
            if (targetPort_ == null) {
              TargetPort = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
            }
            input.ReadMessage(TargetPort);
            break;
          }
          case 40: {
            NodePort = input.ReadInt32();
            break;
          }
          case 50: {
            AppProtocol = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Protocol = input.ReadString();
            break;
          }
          case 24: {
            Port = input.ReadInt32();
            break;
          }
          case 34: {
            if (targetPort_ == null) {
              TargetPort = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
            }
            input.ReadMessage(TargetPort);
            break;
          }
          case 40: {
            NodePort = input.ReadInt32();
            break;
          }
          case 50: {
            AppProtocol = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ServiceProxyOptions is the query options to a Service's proxy call.
  /// </summary>
  public sealed partial class ServiceProxyOptions : pb::IMessage<ServiceProxyOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServiceProxyOptions> _parser = new pb::MessageParser<ServiceProxyOptions>(() => new ServiceProxyOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServiceProxyOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[184]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceProxyOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceProxyOptions(ServiceProxyOptions other) : this() {
      path_ = other.path_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceProxyOptions Clone() {
      return new ServiceProxyOptions(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Path is the part of URLs that include service endpoints, suffixes,
    /// and parameters to use for the current proxy request to service.
    /// For example, the whole request URL is
    /// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
    /// Path is _search?q=user:kimchy.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServiceProxyOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServiceProxyOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPath) hash ^= Path.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServiceProxyOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ServiceSpec describes the attributes that a user creates on a service.
  /// </summary>
  public sealed partial class ServiceSpec : pb::IMessage<ServiceSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServiceSpec> _parser = new pb::MessageParser<ServiceSpec>(() => new ServiceSpec());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServiceSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[185]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceSpec(ServiceSpec other) : this() {
      _hasBits0 = other._hasBits0;
      ports_ = other.ports_.Clone();
      selector_ = other.selector_.Clone();
      clusterIP_ = other.clusterIP_;
      clusterIPs_ = other.clusterIPs_.Clone();
      type_ = other.type_;
      externalIPs_ = other.externalIPs_.Clone();
      sessionAffinity_ = other.sessionAffinity_;
      loadBalancerIP_ = other.loadBalancerIP_;
      loadBalancerSourceRanges_ = other.loadBalancerSourceRanges_.Clone();
      externalName_ = other.externalName_;
      externalTrafficPolicy_ = other.externalTrafficPolicy_;
      healthCheckNodePort_ = other.healthCheckNodePort_;
      publishNotReadyAddresses_ = other.publishNotReadyAddresses_;
      sessionAffinityConfig_ = other.sessionAffinityConfig_ != null ? other.sessionAffinityConfig_.Clone() : null;
      ipFamilies_ = other.ipFamilies_.Clone();
      ipFamilyPolicy_ = other.ipFamilyPolicy_;
      allocateLoadBalancerNodePorts_ = other.allocateLoadBalancerNodePorts_;
      loadBalancerClass_ = other.loadBalancerClass_;
      internalTrafficPolicy_ = other.internalTrafficPolicy_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceSpec Clone() {
      return new ServiceSpec(this);
    }

    /// <summary>Field number for the "ports" field.</summary>
    public const int PortsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.ServicePort> _repeated_ports_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.ServicePort.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ServicePort> ports_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ServicePort>();
    /// <summary>
    /// The list of ports that are exposed by this service.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    /// +patchMergeKey=port
    /// +patchStrategy=merge
    /// +listType=map
    /// +listMapKey=port
    /// +listMapKey=protocol
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.ServicePort> Ports {
      get { return ports_; }
    }

    /// <summary>Field number for the "selector" field.</summary>
    public const int SelectorFieldNumber = 2;
    private static readonly pbc::MapField<string, string>.Codec _map_selector_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 18);
    private readonly pbc::MapField<string, string> selector_ = new pbc::MapField<string, string>();
    /// <summary>
    /// Route service traffic to pods with label keys and values matching this
    /// selector. If empty or not present, the service is assumed to have an
    /// external process managing its endpoints, which Kubernetes will not
    /// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
    /// Ignored if type is ExternalName.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/
    /// +optional
    /// +mapType=atomic
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> Selector {
      get { return selector_; }
    }

    /// <summary>Field number for the "clusterIP" field.</summary>
    public const int ClusterIPFieldNumber = 3;
    private readonly static string ClusterIPDefaultValue = "";

    private string clusterIP_;
    /// <summary>
    /// clusterIP is the IP address of the service and is usually assigned
    /// randomly. If an address is specified manually, is in-range (as per
    /// system configuration), and is not in use, it will be allocated to the
    /// service; otherwise creation of the service will fail. This field may not
    /// be changed through updates unless the type field is also being changed
    /// to ExternalName (which requires this field to be blank) or the type
    /// field is being changed from ExternalName (in which case this field may
    /// optionally be specified, as describe above).  Valid values are "None",
    /// empty string (""), or a valid IP address. Setting this to "None" makes a
    /// "headless service" (no virtual IP), which is useful when direct endpoint
    /// connections are preferred and proxying is not required.  Only applies to
    /// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
    /// when creating a Service of type ExternalName, creation will fail. This
    /// field will be wiped when updating a Service to type ExternalName.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ClusterIP {
      get { return clusterIP_ ?? ClusterIPDefaultValue; }
      set {
        clusterIP_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "clusterIP" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasClusterIP {
      get { return clusterIP_ != null; }
    }
    /// <summary>Clears the value of the "clusterIP" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearClusterIP() {
      clusterIP_ = null;
    }

    /// <summary>Field number for the "clusterIPs" field.</summary>
    public const int ClusterIPsFieldNumber = 18;
    private static readonly pb::FieldCodec<string> _repeated_clusterIPs_codec
        = pb::FieldCodec.ForString(146);
    private readonly pbc::RepeatedField<string> clusterIPs_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// ClusterIPs is a list of IP addresses assigned to this service, and are
    /// usually assigned randomly.  If an address is specified manually, is
    /// in-range (as per system configuration), and is not in use, it will be
    /// allocated to the service; otherwise creation of the service will fail.
    /// This field may not be changed through updates unless the type field is
    /// also being changed to ExternalName (which requires this field to be
    /// empty) or the type field is being changed from ExternalName (in which
    /// case this field may optionally be specified, as describe above).  Valid
    /// values are "None", empty string (""), or a valid IP address.  Setting
    /// this to "None" makes a "headless service" (no virtual IP), which is
    /// useful when direct endpoint connections are preferred and proxying is
    /// not required.  Only applies to types ClusterIP, NodePort, and
    /// LoadBalancer. If this field is specified when creating a Service of type
    /// ExternalName, creation will fail. This field will be wiped when updating
    /// a Service to type ExternalName.  If this field is not specified, it will
    /// be initialized from the clusterIP field.  If this field is specified,
    /// clients must ensure that clusterIPs[0] and clusterIP have the same
    /// value.
    ///
    /// Unless the "IPv6DualStack" feature gate is enabled, this field is
    /// limited to one value, which must be the same as the clusterIP field.  If
    /// the feature gate is enabled, this field may hold a maximum of two
    /// entries (dual-stack IPs, in either order).  These IPs must correspond to
    /// the values of the ipFamilies field. Both clusterIPs and ipFamilies are
    /// governed by the ipFamilyPolicy field.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    /// +listType=atomic
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> ClusterIPs {
      get { return clusterIPs_; }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 4;
    private readonly static string TypeDefaultValue = "";

    private string type_;
    /// <summary>
    /// type determines how the Service is exposed. Defaults to ClusterIP. Valid
    /// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
    /// "ClusterIP" allocates a cluster-internal IP address for load-balancing
    /// to endpoints. Endpoints are determined by the selector or if that is not
    /// specified, by manual construction of an Endpoints object or
    /// EndpointSlice objects. If clusterIP is "None", no virtual IP is
    /// allocated and the endpoints are published as a set of endpoints rather
    /// than a virtual IP.
    /// "NodePort" builds on ClusterIP and allocates a port on every node which
    /// routes to the same endpoints as the clusterIP.
    /// "LoadBalancer" builds on NodePort and creates an external load-balancer
    /// (if supported in the current cloud) which routes to the same endpoints
    /// as the clusterIP.
    /// "ExternalName" aliases this service to the specified externalName.
    /// Several other fields do not apply to ExternalName services.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Type {
      get { return type_ ?? TypeDefaultValue; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "type" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasType {
      get { return type_ != null; }
    }
    /// <summary>Clears the value of the "type" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearType() {
      type_ = null;
    }

    /// <summary>Field number for the "externalIPs" field.</summary>
    public const int ExternalIPsFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_externalIPs_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> externalIPs_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// externalIPs is a list of IP addresses for which nodes in the cluster
    /// will also accept traffic for this service.  These IPs are not managed by
    /// Kubernetes.  The user is responsible for ensuring that traffic arrives
    /// at a node with this IP.  A common example is external load-balancers
    /// that are not part of the Kubernetes system.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> ExternalIPs {
      get { return externalIPs_; }
    }

    /// <summary>Field number for the "sessionAffinity" field.</summary>
    public const int SessionAffinityFieldNumber = 7;
    private readonly static string SessionAffinityDefaultValue = "";

    private string sessionAffinity_;
    /// <summary>
    /// Supports "ClientIP" and "None". Used to maintain session affinity.
    /// Enable client IP based session affinity.
    /// Must be ClientIP or None.
    /// Defaults to None.
    /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SessionAffinity {
      get { return sessionAffinity_ ?? SessionAffinityDefaultValue; }
      set {
        sessionAffinity_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "sessionAffinity" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSessionAffinity {
      get { return sessionAffinity_ != null; }
    }
    /// <summary>Clears the value of the "sessionAffinity" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSessionAffinity() {
      sessionAffinity_ = null;
    }

    /// <summary>Field number for the "loadBalancerIP" field.</summary>
    public const int LoadBalancerIPFieldNumber = 8;
    private readonly static string LoadBalancerIPDefaultValue = "";

    private string loadBalancerIP_;
    /// <summary>
    /// Only applies to Service Type: LoadBalancer
    /// LoadBalancer will get created with the IP specified in this field.
    /// This feature depends on whether the underlying cloud-provider supports specifying
    /// the loadBalancerIP when a load balancer is created.
    /// This field will be ignored if the cloud-provider does not support the feature.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LoadBalancerIP {
      get { return loadBalancerIP_ ?? LoadBalancerIPDefaultValue; }
      set {
        loadBalancerIP_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "loadBalancerIP" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLoadBalancerIP {
      get { return loadBalancerIP_ != null; }
    }
    /// <summary>Clears the value of the "loadBalancerIP" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLoadBalancerIP() {
      loadBalancerIP_ = null;
    }

    /// <summary>Field number for the "loadBalancerSourceRanges" field.</summary>
    public const int LoadBalancerSourceRangesFieldNumber = 9;
    private static readonly pb::FieldCodec<string> _repeated_loadBalancerSourceRanges_codec
        = pb::FieldCodec.ForString(74);
    private readonly pbc::RepeatedField<string> loadBalancerSourceRanges_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If specified and supported by the platform, this will restrict traffic through the cloud-provider
    /// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
    /// cloud-provider does not support the feature."
    /// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> LoadBalancerSourceRanges {
      get { return loadBalancerSourceRanges_; }
    }

    /// <summary>Field number for the "externalName" field.</summary>
    public const int ExternalNameFieldNumber = 10;
    private readonly static string ExternalNameDefaultValue = "";

    private string externalName_;
    /// <summary>
    /// externalName is the external reference that discovery mechanisms will
    /// return as an alias for this service (e.g. a DNS CNAME record). No
    /// proxying will be involved.  Must be a lowercase RFC-1123 hostname
    /// (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ExternalName {
      get { return externalName_ ?? ExternalNameDefaultValue; }
      set {
        externalName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "externalName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExternalName {
      get { return externalName_ != null; }
    }
    /// <summary>Clears the value of the "externalName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExternalName() {
      externalName_ = null;
    }

    /// <summary>Field number for the "externalTrafficPolicy" field.</summary>
    public const int ExternalTrafficPolicyFieldNumber = 11;
    private readonly static string ExternalTrafficPolicyDefaultValue = "";

    private string externalTrafficPolicy_;
    /// <summary>
    /// externalTrafficPolicy denotes if this Service desires to route external
    /// traffic to node-local or cluster-wide endpoints. "Local" preserves the
    /// client source IP and avoids a second hop for LoadBalancer and Nodeport
    /// type services, but risks potentially imbalanced traffic spreading.
    /// "Cluster" obscures the client source IP and may cause a second hop to
    /// another node, but should have good overall load-spreading.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ExternalTrafficPolicy {
      get { return externalTrafficPolicy_ ?? ExternalTrafficPolicyDefaultValue; }
      set {
        externalTrafficPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "externalTrafficPolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasExternalTrafficPolicy {
      get { return externalTrafficPolicy_ != null; }
    }
    /// <summary>Clears the value of the "externalTrafficPolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearExternalTrafficPolicy() {
      externalTrafficPolicy_ = null;
    }

    /// <summary>Field number for the "healthCheckNodePort" field.</summary>
    public const int HealthCheckNodePortFieldNumber = 12;
    private readonly static int HealthCheckNodePortDefaultValue = 0;

    private int healthCheckNodePort_;
    /// <summary>
    /// healthCheckNodePort specifies the healthcheck nodePort for the service.
    /// This only applies when type is set to LoadBalancer and
    /// externalTrafficPolicy is set to Local. If a value is specified, is
    /// in-range, and is not in use, it will be used.  If not specified, a value
    /// will be automatically allocated.  External systems (e.g. load-balancers)
    /// can use this port to determine if a given node holds endpoints for this
    /// service or not.  If this field is specified when creating a Service
    /// which does not need it, creation will fail. This field will be wiped
    /// when updating a Service to no longer need it (e.g. changing type).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int HealthCheckNodePort {
      get { if ((_hasBits0 & 1) != 0) { return healthCheckNodePort_; } else { return HealthCheckNodePortDefaultValue; } }
      set {
        _hasBits0 |= 1;
        healthCheckNodePort_ = value;
      }
    }
    /// <summary>Gets whether the "healthCheckNodePort" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHealthCheckNodePort {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "healthCheckNodePort" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHealthCheckNodePort() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "publishNotReadyAddresses" field.</summary>
    public const int PublishNotReadyAddressesFieldNumber = 13;
    private readonly static bool PublishNotReadyAddressesDefaultValue = false;

    private bool publishNotReadyAddresses_;
    /// <summary>
    /// publishNotReadyAddresses indicates that any agent which deals with endpoints for this
    /// Service should disregard any indications of ready/not-ready.
    /// The primary use case for setting this field is for a StatefulSet's Headless Service to
    /// propagate SRV DNS records for its Pods for the purpose of peer discovery.
    /// The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
    /// Services interpret this to mean that all endpoints are considered "ready" even if the
    /// Pods themselves are not. Agents which consume only Kubernetes generated endpoints
    /// through the Endpoints or EndpointSlice resources can safely assume this behavior.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PublishNotReadyAddresses {
      get { if ((_hasBits0 & 2) != 0) { return publishNotReadyAddresses_; } else { return PublishNotReadyAddressesDefaultValue; } }
      set {
        _hasBits0 |= 2;
        publishNotReadyAddresses_ = value;
      }
    }
    /// <summary>Gets whether the "publishNotReadyAddresses" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPublishNotReadyAddresses {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "publishNotReadyAddresses" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPublishNotReadyAddresses() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "sessionAffinityConfig" field.</summary>
    public const int SessionAffinityConfigFieldNumber = 14;
    private global::K8S.Io.Api.Core.V1.SessionAffinityConfig sessionAffinityConfig_;
    /// <summary>
    /// sessionAffinityConfig contains the configurations of session affinity.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SessionAffinityConfig SessionAffinityConfig {
      get { return sessionAffinityConfig_; }
      set {
        sessionAffinityConfig_ = value;
      }
    }

    /// <summary>Field number for the "ipFamilies" field.</summary>
    public const int IpFamiliesFieldNumber = 19;
    private static readonly pb::FieldCodec<string> _repeated_ipFamilies_codec
        = pb::FieldCodec.ForString(154);
    private readonly pbc::RepeatedField<string> ipFamilies_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
    /// service, and is gated by the "IPv6DualStack" feature gate.  This field
    /// is usually assigned automatically based on cluster configuration and the
    /// ipFamilyPolicy field. If this field is specified manually, the requested
    /// family is available in the cluster, and ipFamilyPolicy allows it, it
    /// will be used; otherwise creation of the service will fail.  This field
    /// is conditionally mutable: it allows for adding or removing a secondary
    /// IP family, but it does not allow changing the primary IP family of the
    /// Service.  Valid values are "IPv4" and "IPv6".  This field only applies
    /// to Services of types ClusterIP, NodePort, and LoadBalancer, and does
    /// apply to "headless" services.  This field will be wiped when updating a
    /// Service to type ExternalName.
    ///
    /// This field may hold a maximum of two entries (dual-stack families, in
    /// either order).  These families must correspond to the values of the
    /// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
    /// governed by the ipFamilyPolicy field.
    /// +listType=atomic
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> IpFamilies {
      get { return ipFamilies_; }
    }

    /// <summary>Field number for the "ipFamilyPolicy" field.</summary>
    public const int IpFamilyPolicyFieldNumber = 17;
    private readonly static string IpFamilyPolicyDefaultValue = "";

    private string ipFamilyPolicy_;
    /// <summary>
    /// IPFamilyPolicy represents the dual-stack-ness requested or required by
    /// this Service, and is gated by the "IPv6DualStack" feature gate.  If
    /// there is no value provided, then this field will be set to SingleStack.
    /// Services can be "SingleStack" (a single IP family), "PreferDualStack"
    /// (two IP families on dual-stack configured clusters or a single IP family
    /// on single-stack clusters), or "RequireDualStack" (two IP families on
    /// dual-stack configured clusters, otherwise fail). The ipFamilies and
    /// clusterIPs fields depend on the value of this field.  This field will be
    /// wiped when updating a service to type ExternalName.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string IpFamilyPolicy {
      get { return ipFamilyPolicy_ ?? IpFamilyPolicyDefaultValue; }
      set {
        ipFamilyPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ipFamilyPolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIpFamilyPolicy {
      get { return ipFamilyPolicy_ != null; }
    }
    /// <summary>Clears the value of the "ipFamilyPolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIpFamilyPolicy() {
      ipFamilyPolicy_ = null;
    }

    /// <summary>Field number for the "allocateLoadBalancerNodePorts" field.</summary>
    public const int AllocateLoadBalancerNodePortsFieldNumber = 20;
    private readonly static bool AllocateLoadBalancerNodePortsDefaultValue = false;

    private bool allocateLoadBalancerNodePorts_;
    /// <summary>
    /// allocateLoadBalancerNodePorts defines if NodePorts will be automatically
    /// allocated for services with type LoadBalancer.  Default is "true". It
    /// may be set to "false" if the cluster load-balancer does not rely on
    /// NodePorts.  If the caller requests specific NodePorts (by specifying a
    /// value), those requests will be respected, regardless of this field.
    /// This field may only be set for services with type LoadBalancer and will
    /// be cleared if the type is changed to any other type.
    /// This field is beta-level and is only honored by servers that enable the ServiceLBNodePortControl feature.
    /// +featureGate=ServiceLBNodePortControl
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllocateLoadBalancerNodePorts {
      get { if ((_hasBits0 & 4) != 0) { return allocateLoadBalancerNodePorts_; } else { return AllocateLoadBalancerNodePortsDefaultValue; } }
      set {
        _hasBits0 |= 4;
        allocateLoadBalancerNodePorts_ = value;
      }
    }
    /// <summary>Gets whether the "allocateLoadBalancerNodePorts" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAllocateLoadBalancerNodePorts {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "allocateLoadBalancerNodePorts" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAllocateLoadBalancerNodePorts() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "loadBalancerClass" field.</summary>
    public const int LoadBalancerClassFieldNumber = 21;
    private readonly static string LoadBalancerClassDefaultValue = "";

    private string loadBalancerClass_;
    /// <summary>
    /// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
    /// If specified, the value of this field must be a label-style identifier, with an optional prefix,
    /// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
    /// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
    /// balancer implementation is used, today this is typically done through the cloud provider integration,
    /// but should apply for any default implementation. If set, it is assumed that a load balancer
    /// implementation is watching for Services with a matching class. Any default load balancer
    /// implementation (e.g. cloud providers) should ignore Services that set this field.
    /// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
    /// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
    /// +featureGate=LoadBalancerClass
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LoadBalancerClass {
      get { return loadBalancerClass_ ?? LoadBalancerClassDefaultValue; }
      set {
        loadBalancerClass_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "loadBalancerClass" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasLoadBalancerClass {
      get { return loadBalancerClass_ != null; }
    }
    /// <summary>Clears the value of the "loadBalancerClass" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearLoadBalancerClass() {
      loadBalancerClass_ = null;
    }

    /// <summary>Field number for the "internalTrafficPolicy" field.</summary>
    public const int InternalTrafficPolicyFieldNumber = 22;
    private readonly static string InternalTrafficPolicyDefaultValue = "";

    private string internalTrafficPolicy_;
    /// <summary>
    /// InternalTrafficPolicy specifies if the cluster internal traffic
    /// should be routed to all endpoints or node-local endpoints only.
    /// "Cluster" routes internal traffic to a Service to all endpoints.
    /// "Local" routes traffic to node-local endpoints only, traffic is
    /// dropped if no node-local endpoints are ready.
    /// The default value is "Cluster".
    /// +featureGate=ServiceInternalTrafficPolicy
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string InternalTrafficPolicy {
      get { return internalTrafficPolicy_ ?? InternalTrafficPolicyDefaultValue; }
      set {
        internalTrafficPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "internalTrafficPolicy" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasInternalTrafficPolicy {
      get { return internalTrafficPolicy_ != null; }
    }
    /// <summary>Clears the value of the "internalTrafficPolicy" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearInternalTrafficPolicy() {
      internalTrafficPolicy_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServiceSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServiceSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!ports_.Equals(other.ports_)) return false;
      if (!Selector.Equals(other.Selector)) return false;
      if (ClusterIP != other.ClusterIP) return false;
      if(!clusterIPs_.Equals(other.clusterIPs_)) return false;
      if (Type != other.Type) return false;
      if(!externalIPs_.Equals(other.externalIPs_)) return false;
      if (SessionAffinity != other.SessionAffinity) return false;
      if (LoadBalancerIP != other.LoadBalancerIP) return false;
      if(!loadBalancerSourceRanges_.Equals(other.loadBalancerSourceRanges_)) return false;
      if (ExternalName != other.ExternalName) return false;
      if (ExternalTrafficPolicy != other.ExternalTrafficPolicy) return false;
      if (HealthCheckNodePort != other.HealthCheckNodePort) return false;
      if (PublishNotReadyAddresses != other.PublishNotReadyAddresses) return false;
      if (!object.Equals(SessionAffinityConfig, other.SessionAffinityConfig)) return false;
      if(!ipFamilies_.Equals(other.ipFamilies_)) return false;
      if (IpFamilyPolicy != other.IpFamilyPolicy) return false;
      if (AllocateLoadBalancerNodePorts != other.AllocateLoadBalancerNodePorts) return false;
      if (LoadBalancerClass != other.LoadBalancerClass) return false;
      if (InternalTrafficPolicy != other.InternalTrafficPolicy) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= ports_.GetHashCode();
      hash ^= Selector.GetHashCode();
      if (HasClusterIP) hash ^= ClusterIP.GetHashCode();
      hash ^= clusterIPs_.GetHashCode();
      if (HasType) hash ^= Type.GetHashCode();
      hash ^= externalIPs_.GetHashCode();
      if (HasSessionAffinity) hash ^= SessionAffinity.GetHashCode();
      if (HasLoadBalancerIP) hash ^= LoadBalancerIP.GetHashCode();
      hash ^= loadBalancerSourceRanges_.GetHashCode();
      if (HasExternalName) hash ^= ExternalName.GetHashCode();
      if (HasExternalTrafficPolicy) hash ^= ExternalTrafficPolicy.GetHashCode();
      if (HasHealthCheckNodePort) hash ^= HealthCheckNodePort.GetHashCode();
      if (HasPublishNotReadyAddresses) hash ^= PublishNotReadyAddresses.GetHashCode();
      if (sessionAffinityConfig_ != null) hash ^= SessionAffinityConfig.GetHashCode();
      hash ^= ipFamilies_.GetHashCode();
      if (HasIpFamilyPolicy) hash ^= IpFamilyPolicy.GetHashCode();
      if (HasAllocateLoadBalancerNodePorts) hash ^= AllocateLoadBalancerNodePorts.GetHashCode();
      if (HasLoadBalancerClass) hash ^= LoadBalancerClass.GetHashCode();
      if (HasInternalTrafficPolicy) hash ^= InternalTrafficPolicy.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      ports_.WriteTo(output, _repeated_ports_codec);
      selector_.WriteTo(output, _map_selector_codec);
      if (HasClusterIP) {
        output.WriteRawTag(26);
        output.WriteString(ClusterIP);
      }
      if (HasType) {
        output.WriteRawTag(34);
        output.WriteString(Type);
      }
      externalIPs_.WriteTo(output, _repeated_externalIPs_codec);
      if (HasSessionAffinity) {
        output.WriteRawTag(58);
        output.WriteString(SessionAffinity);
      }
      if (HasLoadBalancerIP) {
        output.WriteRawTag(66);
        output.WriteString(LoadBalancerIP);
      }
      loadBalancerSourceRanges_.WriteTo(output, _repeated_loadBalancerSourceRanges_codec);
      if (HasExternalName) {
        output.WriteRawTag(82);
        output.WriteString(ExternalName);
      }
      if (HasExternalTrafficPolicy) {
        output.WriteRawTag(90);
        output.WriteString(ExternalTrafficPolicy);
      }
      if (HasHealthCheckNodePort) {
        output.WriteRawTag(96);
        output.WriteInt32(HealthCheckNodePort);
      }
      if (HasPublishNotReadyAddresses) {
        output.WriteRawTag(104);
        output.WriteBool(PublishNotReadyAddresses);
      }
      if (sessionAffinityConfig_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(SessionAffinityConfig);
      }
      if (HasIpFamilyPolicy) {
        output.WriteRawTag(138, 1);
        output.WriteString(IpFamilyPolicy);
      }
      clusterIPs_.WriteTo(output, _repeated_clusterIPs_codec);
      ipFamilies_.WriteTo(output, _repeated_ipFamilies_codec);
      if (HasAllocateLoadBalancerNodePorts) {
        output.WriteRawTag(160, 1);
        output.WriteBool(AllocateLoadBalancerNodePorts);
      }
      if (HasLoadBalancerClass) {
        output.WriteRawTag(170, 1);
        output.WriteString(LoadBalancerClass);
      }
      if (HasInternalTrafficPolicy) {
        output.WriteRawTag(178, 1);
        output.WriteString(InternalTrafficPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      ports_.WriteTo(ref output, _repeated_ports_codec);
      selector_.WriteTo(ref output, _map_selector_codec);
      if (HasClusterIP) {
        output.WriteRawTag(26);
        output.WriteString(ClusterIP);
      }
      if (HasType) {
        output.WriteRawTag(34);
        output.WriteString(Type);
      }
      externalIPs_.WriteTo(ref output, _repeated_externalIPs_codec);
      if (HasSessionAffinity) {
        output.WriteRawTag(58);
        output.WriteString(SessionAffinity);
      }
      if (HasLoadBalancerIP) {
        output.WriteRawTag(66);
        output.WriteString(LoadBalancerIP);
      }
      loadBalancerSourceRanges_.WriteTo(ref output, _repeated_loadBalancerSourceRanges_codec);
      if (HasExternalName) {
        output.WriteRawTag(82);
        output.WriteString(ExternalName);
      }
      if (HasExternalTrafficPolicy) {
        output.WriteRawTag(90);
        output.WriteString(ExternalTrafficPolicy);
      }
      if (HasHealthCheckNodePort) {
        output.WriteRawTag(96);
        output.WriteInt32(HealthCheckNodePort);
      }
      if (HasPublishNotReadyAddresses) {
        output.WriteRawTag(104);
        output.WriteBool(PublishNotReadyAddresses);
      }
      if (sessionAffinityConfig_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(SessionAffinityConfig);
      }
      if (HasIpFamilyPolicy) {
        output.WriteRawTag(138, 1);
        output.WriteString(IpFamilyPolicy);
      }
      clusterIPs_.WriteTo(ref output, _repeated_clusterIPs_codec);
      ipFamilies_.WriteTo(ref output, _repeated_ipFamilies_codec);
      if (HasAllocateLoadBalancerNodePorts) {
        output.WriteRawTag(160, 1);
        output.WriteBool(AllocateLoadBalancerNodePorts);
      }
      if (HasLoadBalancerClass) {
        output.WriteRawTag(170, 1);
        output.WriteString(LoadBalancerClass);
      }
      if (HasInternalTrafficPolicy) {
        output.WriteRawTag(178, 1);
        output.WriteString(InternalTrafficPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += ports_.CalculateSize(_repeated_ports_codec);
      size += selector_.CalculateSize(_map_selector_codec);
      if (HasClusterIP) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ClusterIP);
      }
      size += clusterIPs_.CalculateSize(_repeated_clusterIPs_codec);
      if (HasType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      size += externalIPs_.CalculateSize(_repeated_externalIPs_codec);
      if (HasSessionAffinity) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SessionAffinity);
      }
      if (HasLoadBalancerIP) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LoadBalancerIP);
      }
      size += loadBalancerSourceRanges_.CalculateSize(_repeated_loadBalancerSourceRanges_codec);
      if (HasExternalName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExternalName);
      }
      if (HasExternalTrafficPolicy) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExternalTrafficPolicy);
      }
      if (HasHealthCheckNodePort) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(HealthCheckNodePort);
      }
      if (HasPublishNotReadyAddresses) {
        size += 1 + 1;
      }
      if (sessionAffinityConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SessionAffinityConfig);
      }
      size += ipFamilies_.CalculateSize(_repeated_ipFamilies_codec);
      if (HasIpFamilyPolicy) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(IpFamilyPolicy);
      }
      if (HasAllocateLoadBalancerNodePorts) {
        size += 2 + 1;
      }
      if (HasLoadBalancerClass) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(LoadBalancerClass);
      }
      if (HasInternalTrafficPolicy) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(InternalTrafficPolicy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServiceSpec other) {
      if (other == null) {
        return;
      }
      ports_.Add(other.ports_);
      selector_.Add(other.selector_);
      if (other.HasClusterIP) {
        ClusterIP = other.ClusterIP;
      }
      clusterIPs_.Add(other.clusterIPs_);
      if (other.HasType) {
        Type = other.Type;
      }
      externalIPs_.Add(other.externalIPs_);
      if (other.HasSessionAffinity) {
        SessionAffinity = other.SessionAffinity;
      }
      if (other.HasLoadBalancerIP) {
        LoadBalancerIP = other.LoadBalancerIP;
      }
      loadBalancerSourceRanges_.Add(other.loadBalancerSourceRanges_);
      if (other.HasExternalName) {
        ExternalName = other.ExternalName;
      }
      if (other.HasExternalTrafficPolicy) {
        ExternalTrafficPolicy = other.ExternalTrafficPolicy;
      }
      if (other.HasHealthCheckNodePort) {
        HealthCheckNodePort = other.HealthCheckNodePort;
      }
      if (other.HasPublishNotReadyAddresses) {
        PublishNotReadyAddresses = other.PublishNotReadyAddresses;
      }
      if (other.sessionAffinityConfig_ != null) {
        if (sessionAffinityConfig_ == null) {
          SessionAffinityConfig = new global::K8S.Io.Api.Core.V1.SessionAffinityConfig();
        }
        SessionAffinityConfig.MergeFrom(other.SessionAffinityConfig);
      }
      ipFamilies_.Add(other.ipFamilies_);
      if (other.HasIpFamilyPolicy) {
        IpFamilyPolicy = other.IpFamilyPolicy;
      }
      if (other.HasAllocateLoadBalancerNodePorts) {
        AllocateLoadBalancerNodePorts = other.AllocateLoadBalancerNodePorts;
      }
      if (other.HasLoadBalancerClass) {
        LoadBalancerClass = other.LoadBalancerClass;
      }
      if (other.HasInternalTrafficPolicy) {
        InternalTrafficPolicy = other.InternalTrafficPolicy;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ports_.AddEntriesFrom(input, _repeated_ports_codec);
            break;
          }
          case 18: {
            selector_.AddEntriesFrom(input, _map_selector_codec);
            break;
          }
          case 26: {
            ClusterIP = input.ReadString();
            break;
          }
          case 34: {
            Type = input.ReadString();
            break;
          }
          case 42: {
            externalIPs_.AddEntriesFrom(input, _repeated_externalIPs_codec);
            break;
          }
          case 58: {
            SessionAffinity = input.ReadString();
            break;
          }
          case 66: {
            LoadBalancerIP = input.ReadString();
            break;
          }
          case 74: {
            loadBalancerSourceRanges_.AddEntriesFrom(input, _repeated_loadBalancerSourceRanges_codec);
            break;
          }
          case 82: {
            ExternalName = input.ReadString();
            break;
          }
          case 90: {
            ExternalTrafficPolicy = input.ReadString();
            break;
          }
          case 96: {
            HealthCheckNodePort = input.ReadInt32();
            break;
          }
          case 104: {
            PublishNotReadyAddresses = input.ReadBool();
            break;
          }
          case 114: {
            if (sessionAffinityConfig_ == null) {
              SessionAffinityConfig = new global::K8S.Io.Api.Core.V1.SessionAffinityConfig();
            }
            input.ReadMessage(SessionAffinityConfig);
            break;
          }
          case 138: {
            IpFamilyPolicy = input.ReadString();
            break;
          }
          case 146: {
            clusterIPs_.AddEntriesFrom(input, _repeated_clusterIPs_codec);
            break;
          }
          case 154: {
            ipFamilies_.AddEntriesFrom(input, _repeated_ipFamilies_codec);
            break;
          }
          case 160: {
            AllocateLoadBalancerNodePorts = input.ReadBool();
            break;
          }
          case 170: {
            LoadBalancerClass = input.ReadString();
            break;
          }
          case 178: {
            InternalTrafficPolicy = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ports_.AddEntriesFrom(ref input, _repeated_ports_codec);
            break;
          }
          case 18: {
            selector_.AddEntriesFrom(ref input, _map_selector_codec);
            break;
          }
          case 26: {
            ClusterIP = input.ReadString();
            break;
          }
          case 34: {
            Type = input.ReadString();
            break;
          }
          case 42: {
            externalIPs_.AddEntriesFrom(ref input, _repeated_externalIPs_codec);
            break;
          }
          case 58: {
            SessionAffinity = input.ReadString();
            break;
          }
          case 66: {
            LoadBalancerIP = input.ReadString();
            break;
          }
          case 74: {
            loadBalancerSourceRanges_.AddEntriesFrom(ref input, _repeated_loadBalancerSourceRanges_codec);
            break;
          }
          case 82: {
            ExternalName = input.ReadString();
            break;
          }
          case 90: {
            ExternalTrafficPolicy = input.ReadString();
            break;
          }
          case 96: {
            HealthCheckNodePort = input.ReadInt32();
            break;
          }
          case 104: {
            PublishNotReadyAddresses = input.ReadBool();
            break;
          }
          case 114: {
            if (sessionAffinityConfig_ == null) {
              SessionAffinityConfig = new global::K8S.Io.Api.Core.V1.SessionAffinityConfig();
            }
            input.ReadMessage(SessionAffinityConfig);
            break;
          }
          case 138: {
            IpFamilyPolicy = input.ReadString();
            break;
          }
          case 146: {
            clusterIPs_.AddEntriesFrom(ref input, _repeated_clusterIPs_codec);
            break;
          }
          case 154: {
            ipFamilies_.AddEntriesFrom(ref input, _repeated_ipFamilies_codec);
            break;
          }
          case 160: {
            AllocateLoadBalancerNodePorts = input.ReadBool();
            break;
          }
          case 170: {
            LoadBalancerClass = input.ReadString();
            break;
          }
          case 178: {
            InternalTrafficPolicy = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ServiceStatus represents the current status of a service.
  /// </summary>
  public sealed partial class ServiceStatus : pb::IMessage<ServiceStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServiceStatus> _parser = new pb::MessageParser<ServiceStatus>(() => new ServiceStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServiceStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[186]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceStatus(ServiceStatus other) : this() {
      loadBalancer_ = other.loadBalancer_ != null ? other.loadBalancer_.Clone() : null;
      conditions_ = other.conditions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceStatus Clone() {
      return new ServiceStatus(this);
    }

    /// <summary>Field number for the "loadBalancer" field.</summary>
    public const int LoadBalancerFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.LoadBalancerStatus loadBalancer_;
    /// <summary>
    /// LoadBalancer contains the current status of the load-balancer,
    /// if one is present.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LoadBalancerStatus LoadBalancer {
      get { return loadBalancer_; }
      set {
        loadBalancer_ = value;
      }
    }

    /// <summary>Field number for the "conditions" field.</summary>
    public const int ConditionsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Condition> _repeated_conditions_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Condition.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Condition> conditions_ = new pbc::RepeatedField<global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Condition>();
    /// <summary>
    /// Current service state
    /// +optional
    /// +patchMergeKey=type
    /// +patchStrategy=merge
    /// +listType=map
    /// +listMapKey=type
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Condition> Conditions {
      get { return conditions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServiceStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServiceStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LoadBalancer, other.LoadBalancer)) return false;
      if(!conditions_.Equals(other.conditions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (loadBalancer_ != null) hash ^= LoadBalancer.GetHashCode();
      hash ^= conditions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (loadBalancer_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LoadBalancer);
      }
      conditions_.WriteTo(output, _repeated_conditions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (loadBalancer_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LoadBalancer);
      }
      conditions_.WriteTo(ref output, _repeated_conditions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (loadBalancer_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LoadBalancer);
      }
      size += conditions_.CalculateSize(_repeated_conditions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServiceStatus other) {
      if (other == null) {
        return;
      }
      if (other.loadBalancer_ != null) {
        if (loadBalancer_ == null) {
          LoadBalancer = new global::K8S.Io.Api.Core.V1.LoadBalancerStatus();
        }
        LoadBalancer.MergeFrom(other.LoadBalancer);
      }
      conditions_.Add(other.conditions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (loadBalancer_ == null) {
              LoadBalancer = new global::K8S.Io.Api.Core.V1.LoadBalancerStatus();
            }
            input.ReadMessage(LoadBalancer);
            break;
          }
          case 18: {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (loadBalancer_ == null) {
              LoadBalancer = new global::K8S.Io.Api.Core.V1.LoadBalancerStatus();
            }
            input.ReadMessage(LoadBalancer);
            break;
          }
          case 18: {
            conditions_.AddEntriesFrom(ref input, _repeated_conditions_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// SessionAffinityConfig represents the configurations of session affinity.
  /// </summary>
  public sealed partial class SessionAffinityConfig : pb::IMessage<SessionAffinityConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SessionAffinityConfig> _parser = new pb::MessageParser<SessionAffinityConfig>(() => new SessionAffinityConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SessionAffinityConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[187]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SessionAffinityConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SessionAffinityConfig(SessionAffinityConfig other) : this() {
      clientIP_ = other.clientIP_ != null ? other.clientIP_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SessionAffinityConfig Clone() {
      return new SessionAffinityConfig(this);
    }

    /// <summary>Field number for the "clientIP" field.</summary>
    public const int ClientIPFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.ClientIPConfig clientIP_;
    /// <summary>
    /// clientIP contains the configurations of Client IP based session affinity.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ClientIPConfig ClientIP {
      get { return clientIP_; }
      set {
        clientIP_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SessionAffinityConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SessionAffinityConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ClientIP, other.ClientIP)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (clientIP_ != null) hash ^= ClientIP.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (clientIP_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ClientIP);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (clientIP_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ClientIP);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (clientIP_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClientIP);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SessionAffinityConfig other) {
      if (other == null) {
        return;
      }
      if (other.clientIP_ != null) {
        if (clientIP_ == null) {
          ClientIP = new global::K8S.Io.Api.Core.V1.ClientIPConfig();
        }
        ClientIP.MergeFrom(other.ClientIP);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (clientIP_ == null) {
              ClientIP = new global::K8S.Io.Api.Core.V1.ClientIPConfig();
            }
            input.ReadMessage(ClientIP);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (clientIP_ == null) {
              ClientIP = new global::K8S.Io.Api.Core.V1.ClientIPConfig();
            }
            input.ReadMessage(ClientIP);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a StorageOS persistent volume resource.
  /// </summary>
  public sealed partial class StorageOSPersistentVolumeSource : pb::IMessage<StorageOSPersistentVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StorageOSPersistentVolumeSource> _parser = new pb::MessageParser<StorageOSPersistentVolumeSource>(() => new StorageOSPersistentVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StorageOSPersistentVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[188]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StorageOSPersistentVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StorageOSPersistentVolumeSource(StorageOSPersistentVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      volumeName_ = other.volumeName_;
      volumeNamespace_ = other.volumeNamespace_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StorageOSPersistentVolumeSource Clone() {
      return new StorageOSPersistentVolumeSource(this);
    }

    /// <summary>Field number for the "volumeName" field.</summary>
    public const int VolumeNameFieldNumber = 1;
    private readonly static string VolumeNameDefaultValue = "";

    private string volumeName_;
    /// <summary>
    /// VolumeName is the human-readable name of the StorageOS volume.  Volume
    /// names are only unique within a namespace.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeName {
      get { return volumeName_ ?? VolumeNameDefaultValue; }
      set {
        volumeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeName {
      get { return volumeName_ != null; }
    }
    /// <summary>Clears the value of the "volumeName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeName() {
      volumeName_ = null;
    }

    /// <summary>Field number for the "volumeNamespace" field.</summary>
    public const int VolumeNamespaceFieldNumber = 2;
    private readonly static string VolumeNamespaceDefaultValue = "";

    private string volumeNamespace_;
    /// <summary>
    /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
    /// namespace is specified then the Pod's namespace will be used.  This allows the
    /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    /// Set VolumeName to any name to override the default behaviour.
    /// Set to "default" if you are not using namespaces within StorageOS.
    /// Namespaces that do not pre-exist within StorageOS will be created.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeNamespace {
      get { return volumeNamespace_ ?? VolumeNamespaceDefaultValue; }
      set {
        volumeNamespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeNamespace" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeNamespace {
      get { return volumeNamespace_ != null; }
    }
    /// <summary>Clears the value of the "volumeNamespace" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeNamespace() {
      volumeNamespace_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 3;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 4;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 5;
    private global::K8S.Io.Api.Core.V1.ObjectReference secretRef_;
    /// <summary>
    /// SecretRef specifies the secret to use for obtaining the StorageOS API
    /// credentials.  If not specified, default values will be attempted.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ObjectReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StorageOSPersistentVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StorageOSPersistentVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeName != other.VolumeName) return false;
      if (VolumeNamespace != other.VolumeNamespace) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasVolumeName) hash ^= VolumeName.GetHashCode();
      if (HasVolumeNamespace) hash ^= VolumeNamespace.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasVolumeName) {
        output.WriteRawTag(10);
        output.WriteString(VolumeName);
      }
      if (HasVolumeNamespace) {
        output.WriteRawTag(18);
        output.WriteString(VolumeNamespace);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasVolumeName) {
        output.WriteRawTag(10);
        output.WriteString(VolumeName);
      }
      if (HasVolumeNamespace) {
        output.WriteRawTag(18);
        output.WriteString(VolumeNamespace);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasVolumeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeName);
      }
      if (HasVolumeNamespace) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeNamespace);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StorageOSPersistentVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasVolumeName) {
        VolumeName = other.VolumeName;
      }
      if (other.HasVolumeNamespace) {
        VolumeNamespace = other.VolumeNamespace;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.ObjectReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeName = input.ReadString();
            break;
          }
          case 18: {
            VolumeNamespace = input.ReadString();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 42: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            VolumeName = input.ReadString();
            break;
          }
          case 18: {
            VolumeNamespace = input.ReadString();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 42: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.ObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a StorageOS persistent volume resource.
  /// </summary>
  public sealed partial class StorageOSVolumeSource : pb::IMessage<StorageOSVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<StorageOSVolumeSource> _parser = new pb::MessageParser<StorageOSVolumeSource>(() => new StorageOSVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<StorageOSVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[189]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StorageOSVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StorageOSVolumeSource(StorageOSVolumeSource other) : this() {
      _hasBits0 = other._hasBits0;
      volumeName_ = other.volumeName_;
      volumeNamespace_ = other.volumeNamespace_;
      fsType_ = other.fsType_;
      readOnly_ = other.readOnly_;
      secretRef_ = other.secretRef_ != null ? other.secretRef_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StorageOSVolumeSource Clone() {
      return new StorageOSVolumeSource(this);
    }

    /// <summary>Field number for the "volumeName" field.</summary>
    public const int VolumeNameFieldNumber = 1;
    private readonly static string VolumeNameDefaultValue = "";

    private string volumeName_;
    /// <summary>
    /// VolumeName is the human-readable name of the StorageOS volume.  Volume
    /// names are only unique within a namespace.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeName {
      get { return volumeName_ ?? VolumeNameDefaultValue; }
      set {
        volumeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeName {
      get { return volumeName_ != null; }
    }
    /// <summary>Clears the value of the "volumeName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeName() {
      volumeName_ = null;
    }

    /// <summary>Field number for the "volumeNamespace" field.</summary>
    public const int VolumeNamespaceFieldNumber = 2;
    private readonly static string VolumeNamespaceDefaultValue = "";

    private string volumeNamespace_;
    /// <summary>
    /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
    /// namespace is specified then the Pod's namespace will be used.  This allows the
    /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
    /// Set VolumeName to any name to override the default behaviour.
    /// Set to "default" if you are not using namespaces within StorageOS.
    /// Namespaces that do not pre-exist within StorageOS will be created.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumeNamespace {
      get { return volumeNamespace_ ?? VolumeNamespaceDefaultValue; }
      set {
        volumeNamespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumeNamespace" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumeNamespace {
      get { return volumeNamespace_ != null; }
    }
    /// <summary>Clears the value of the "volumeNamespace" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumeNamespace() {
      volumeNamespace_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 3;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 4;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Defaults to false (read/write). ReadOnly here will force
    /// the ReadOnly setting in VolumeMounts.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "secretRef" field.</summary>
    public const int SecretRefFieldNumber = 5;
    private global::K8S.Io.Api.Core.V1.LocalObjectReference secretRef_;
    /// <summary>
    /// SecretRef specifies the secret to use for obtaining the StorageOS API
    /// credentials.  If not specified, default values will be attempted.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LocalObjectReference SecretRef {
      get { return secretRef_; }
      set {
        secretRef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as StorageOSVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(StorageOSVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumeName != other.VolumeName) return false;
      if (VolumeNamespace != other.VolumeNamespace) return false;
      if (FsType != other.FsType) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (!object.Equals(SecretRef, other.SecretRef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasVolumeName) hash ^= VolumeName.GetHashCode();
      if (HasVolumeNamespace) hash ^= VolumeNamespace.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (secretRef_ != null) hash ^= SecretRef.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasVolumeName) {
        output.WriteRawTag(10);
        output.WriteString(VolumeName);
      }
      if (HasVolumeNamespace) {
        output.WriteRawTag(18);
        output.WriteString(VolumeNamespace);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasVolumeName) {
        output.WriteRawTag(10);
        output.WriteString(VolumeName);
      }
      if (HasVolumeNamespace) {
        output.WriteRawTag(18);
        output.WriteString(VolumeNamespace);
      }
      if (HasFsType) {
        output.WriteRawTag(26);
        output.WriteString(FsType);
      }
      if (HasReadOnly) {
        output.WriteRawTag(32);
        output.WriteBool(ReadOnly);
      }
      if (secretRef_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(SecretRef);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasVolumeName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeName);
      }
      if (HasVolumeNamespace) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumeNamespace);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (secretRef_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SecretRef);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(StorageOSVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasVolumeName) {
        VolumeName = other.VolumeName;
      }
      if (other.HasVolumeNamespace) {
        VolumeNamespace = other.VolumeNamespace;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.secretRef_ != null) {
        if (secretRef_ == null) {
          SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
        }
        SecretRef.MergeFrom(other.SecretRef);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumeName = input.ReadString();
            break;
          }
          case 18: {
            VolumeNamespace = input.ReadString();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 42: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            VolumeName = input.ReadString();
            break;
          }
          case 18: {
            VolumeNamespace = input.ReadString();
            break;
          }
          case 26: {
            FsType = input.ReadString();
            break;
          }
          case 32: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 42: {
            if (secretRef_ == null) {
              SecretRef = new global::K8S.Io.Api.Core.V1.LocalObjectReference();
            }
            input.ReadMessage(SecretRef);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Sysctl defines a kernel parameter to be set
  /// </summary>
  public sealed partial class Sysctl : pb::IMessage<Sysctl>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Sysctl> _parser = new pb::MessageParser<Sysctl>(() => new Sysctl());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Sysctl> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[190]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Sysctl() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Sysctl(Sysctl other) : this() {
      name_ = other.name_;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Sysctl Clone() {
      return new Sysctl(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name of a property to set
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    /// <summary>
    /// Value of a property to set
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Sysctl);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Sysctl other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Sysctl other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// TCPSocketAction describes an action based on opening a socket
  /// </summary>
  public sealed partial class TCPSocketAction : pb::IMessage<TCPSocketAction>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TCPSocketAction> _parser = new pb::MessageParser<TCPSocketAction>(() => new TCPSocketAction());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TCPSocketAction> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[191]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TCPSocketAction() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TCPSocketAction(TCPSocketAction other) : this() {
      port_ = other.port_ != null ? other.port_.Clone() : null;
      host_ = other.host_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TCPSocketAction Clone() {
      return new TCPSocketAction(this);
    }

    /// <summary>Field number for the "port" field.</summary>
    public const int PortFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString port_;
    /// <summary>
    /// Number or name of the port to access on the container.
    /// Number must be in the range 1 to 65535.
    /// Name must be an IANA_SVC_NAME.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString Port {
      get { return port_; }
      set {
        port_ = value;
      }
    }

    /// <summary>Field number for the "host" field.</summary>
    public const int HostFieldNumber = 2;
    private readonly static string HostDefaultValue = "";

    private string host_;
    /// <summary>
    /// Optional: Host name to connect to, defaults to the pod IP.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Host {
      get { return host_ ?? HostDefaultValue; }
      set {
        host_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "host" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHost {
      get { return host_ != null; }
    }
    /// <summary>Clears the value of the "host" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHost() {
      host_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TCPSocketAction);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TCPSocketAction other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Port, other.Port)) return false;
      if (Host != other.Host) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (port_ != null) hash ^= Port.GetHashCode();
      if (HasHost) hash ^= Host.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (port_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Port);
      }
      if (HasHost) {
        output.WriteRawTag(18);
        output.WriteString(Host);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (port_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Port);
      }
      if (HasHost) {
        output.WriteRawTag(18);
        output.WriteString(Host);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (port_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Port);
      }
      if (HasHost) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Host);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TCPSocketAction other) {
      if (other == null) {
        return;
      }
      if (other.port_ != null) {
        if (port_ == null) {
          Port = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
        }
        Port.MergeFrom(other.Port);
      }
      if (other.HasHost) {
        Host = other.Host;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (port_ == null) {
              Port = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
            }
            input.ReadMessage(Port);
            break;
          }
          case 18: {
            Host = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (port_ == null) {
              Port = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
            }
            input.ReadMessage(Port);
            break;
          }
          case 18: {
            Host = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The node this Taint is attached to has the "effect" on
  /// any pod that does not tolerate the Taint.
  /// </summary>
  public sealed partial class Taint : pb::IMessage<Taint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Taint> _parser = new pb::MessageParser<Taint>(() => new Taint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Taint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[192]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Taint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Taint(Taint other) : this() {
      key_ = other.key_;
      value_ = other.value_;
      effect_ = other.effect_;
      timeAdded_ = other.timeAdded_ != null ? other.timeAdded_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Taint Clone() {
      return new Taint(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    /// <summary>
    /// Required. The taint key to be applied to a node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    /// <summary>
    /// The taint value corresponding to the taint key.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      value_ = null;
    }

    /// <summary>Field number for the "effect" field.</summary>
    public const int EffectFieldNumber = 3;
    private readonly static string EffectDefaultValue = "";

    private string effect_;
    /// <summary>
    /// Required. The effect of the taint on pods
    /// that do not tolerate the taint.
    /// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Effect {
      get { return effect_ ?? EffectDefaultValue; }
      set {
        effect_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "effect" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEffect {
      get { return effect_ != null; }
    }
    /// <summary>Clears the value of the "effect" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEffect() {
      effect_ = null;
    }

    /// <summary>Field number for the "timeAdded" field.</summary>
    public const int TimeAddedFieldNumber = 4;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time timeAdded_;
    /// <summary>
    /// TimeAdded represents the time at which the taint was added.
    /// It is only written for NoExecute taints.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time TimeAdded {
      get { return timeAdded_; }
      set {
        timeAdded_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Taint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Taint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Value != other.Value) return false;
      if (Effect != other.Effect) return false;
      if (!object.Equals(TimeAdded, other.TimeAdded)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (HasEffect) hash ^= Effect.GetHashCode();
      if (timeAdded_ != null) hash ^= TimeAdded.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (HasEffect) {
        output.WriteRawTag(26);
        output.WriteString(Effect);
      }
      if (timeAdded_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(TimeAdded);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasValue) {
        output.WriteRawTag(18);
        output.WriteString(Value);
      }
      if (HasEffect) {
        output.WriteRawTag(26);
        output.WriteString(Effect);
      }
      if (timeAdded_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(TimeAdded);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (HasEffect) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Effect);
      }
      if (timeAdded_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TimeAdded);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Taint other) {
      if (other == null) {
        return;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      if (other.HasEffect) {
        Effect = other.Effect;
      }
      if (other.timeAdded_ != null) {
        if (timeAdded_ == null) {
          TimeAdded = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
        }
        TimeAdded.MergeFrom(other.TimeAdded);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
          case 26: {
            Effect = input.ReadString();
            break;
          }
          case 34: {
            if (timeAdded_ == null) {
              TimeAdded = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(TimeAdded);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Value = input.ReadString();
            break;
          }
          case 26: {
            Effect = input.ReadString();
            break;
          }
          case 34: {
            if (timeAdded_ == null) {
              TimeAdded = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.Time();
            }
            input.ReadMessage(TimeAdded);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The pod this Toleration is attached to tolerates any taint that matches
  /// the triple &lt;key,value,effect> using the matching operator &lt;operator>.
  /// </summary>
  public sealed partial class Toleration : pb::IMessage<Toleration>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Toleration> _parser = new pb::MessageParser<Toleration>(() => new Toleration());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Toleration> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[193]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Toleration() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Toleration(Toleration other) : this() {
      _hasBits0 = other._hasBits0;
      key_ = other.key_;
      operator_ = other.operator_;
      value_ = other.value_;
      effect_ = other.effect_;
      tolerationSeconds_ = other.tolerationSeconds_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Toleration Clone() {
      return new Toleration(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    /// <summary>
    /// Key is the taint key that the toleration applies to. Empty means match all taint keys.
    /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "operator" field.</summary>
    public const int OperatorFieldNumber = 2;
    private readonly static string OperatorDefaultValue = "";

    private string operator_;
    /// <summary>
    /// Operator represents a key's relationship to the value.
    /// Valid operators are Exists and Equal. Defaults to Equal.
    /// Exists is equivalent to wildcard for value, so that a pod can
    /// tolerate all taints of a particular category.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Operator {
      get { return operator_ ?? OperatorDefaultValue; }
      set {
        operator_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "operator" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasOperator {
      get { return operator_ != null; }
    }
    /// <summary>Clears the value of the "operator" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearOperator() {
      operator_ = null;
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 3;
    private readonly static string ValueDefaultValue = "";

    private string value_;
    /// <summary>
    /// Value is the taint value the toleration matches to.
    /// If the operator is Exists, the value should be empty, otherwise just a regular string.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_ ?? ValueDefaultValue; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "value" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasValue {
      get { return value_ != null; }
    }
    /// <summary>Clears the value of the "value" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      value_ = null;
    }

    /// <summary>Field number for the "effect" field.</summary>
    public const int EffectFieldNumber = 4;
    private readonly static string EffectDefaultValue = "";

    private string effect_;
    /// <summary>
    /// Effect indicates the taint effect to match. Empty means match all taint effects.
    /// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Effect {
      get { return effect_ ?? EffectDefaultValue; }
      set {
        effect_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "effect" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEffect {
      get { return effect_ != null; }
    }
    /// <summary>Clears the value of the "effect" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEffect() {
      effect_ = null;
    }

    /// <summary>Field number for the "tolerationSeconds" field.</summary>
    public const int TolerationSecondsFieldNumber = 5;
    private readonly static long TolerationSecondsDefaultValue = 0L;

    private long tolerationSeconds_;
    /// <summary>
    /// TolerationSeconds represents the period of time the toleration (which must be
    /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    /// it is not set, which means tolerate the taint forever (do not evict). Zero and
    /// negative values will be treated as 0 (evict immediately) by the system.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long TolerationSeconds {
      get { if ((_hasBits0 & 1) != 0) { return tolerationSeconds_; } else { return TolerationSecondsDefaultValue; } }
      set {
        _hasBits0 |= 1;
        tolerationSeconds_ = value;
      }
    }
    /// <summary>Gets whether the "tolerationSeconds" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTolerationSeconds {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "tolerationSeconds" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTolerationSeconds() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Toleration);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Toleration other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Operator != other.Operator) return false;
      if (Value != other.Value) return false;
      if (Effect != other.Effect) return false;
      if (TolerationSeconds != other.TolerationSeconds) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasKey) hash ^= Key.GetHashCode();
      if (HasOperator) hash ^= Operator.GetHashCode();
      if (HasValue) hash ^= Value.GetHashCode();
      if (HasEffect) hash ^= Effect.GetHashCode();
      if (HasTolerationSeconds) hash ^= TolerationSeconds.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasOperator) {
        output.WriteRawTag(18);
        output.WriteString(Operator);
      }
      if (HasValue) {
        output.WriteRawTag(26);
        output.WriteString(Value);
      }
      if (HasEffect) {
        output.WriteRawTag(34);
        output.WriteString(Effect);
      }
      if (HasTolerationSeconds) {
        output.WriteRawTag(40);
        output.WriteInt64(TolerationSeconds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      if (HasOperator) {
        output.WriteRawTag(18);
        output.WriteString(Operator);
      }
      if (HasValue) {
        output.WriteRawTag(26);
        output.WriteString(Value);
      }
      if (HasEffect) {
        output.WriteRawTag(34);
        output.WriteString(Effect);
      }
      if (HasTolerationSeconds) {
        output.WriteRawTag(40);
        output.WriteInt64(TolerationSeconds);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      if (HasOperator) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Operator);
      }
      if (HasValue) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (HasEffect) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Effect);
      }
      if (HasTolerationSeconds) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TolerationSeconds);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Toleration other) {
      if (other == null) {
        return;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      if (other.HasOperator) {
        Operator = other.Operator;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      if (other.HasEffect) {
        Effect = other.Effect;
      }
      if (other.HasTolerationSeconds) {
        TolerationSeconds = other.TolerationSeconds;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Operator = input.ReadString();
            break;
          }
          case 26: {
            Value = input.ReadString();
            break;
          }
          case 34: {
            Effect = input.ReadString();
            break;
          }
          case 40: {
            TolerationSeconds = input.ReadInt64();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            Operator = input.ReadString();
            break;
          }
          case 26: {
            Value = input.ReadString();
            break;
          }
          case 34: {
            Effect = input.ReadString();
            break;
          }
          case 40: {
            TolerationSeconds = input.ReadInt64();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A topology selector requirement is a selector that matches given label.
  /// This is an alpha feature and may change in the future.
  /// </summary>
  public sealed partial class TopologySelectorLabelRequirement : pb::IMessage<TopologySelectorLabelRequirement>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TopologySelectorLabelRequirement> _parser = new pb::MessageParser<TopologySelectorLabelRequirement>(() => new TopologySelectorLabelRequirement());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TopologySelectorLabelRequirement> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[194]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopologySelectorLabelRequirement() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopologySelectorLabelRequirement(TopologySelectorLabelRequirement other) : this() {
      key_ = other.key_;
      values_ = other.values_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopologySelectorLabelRequirement Clone() {
      return new TopologySelectorLabelRequirement(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private readonly static string KeyDefaultValue = "";

    private string key_;
    /// <summary>
    /// The label key that the selector applies to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Key {
      get { return key_ ?? KeyDefaultValue; }
      set {
        key_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "key" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKey {
      get { return key_ != null; }
    }
    /// <summary>Clears the value of the "key" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKey() {
      key_ = null;
    }

    /// <summary>Field number for the "values" field.</summary>
    public const int ValuesFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_values_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> values_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// An array of string values. One value must match the label to be selected.
    /// Each entry in Values is ORed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Values {
      get { return values_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TopologySelectorLabelRequirement);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TopologySelectorLabelRequirement other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if(!values_.Equals(other.values_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasKey) hash ^= Key.GetHashCode();
      hash ^= values_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      values_.WriteTo(output, _repeated_values_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasKey) {
        output.WriteRawTag(10);
        output.WriteString(Key);
      }
      values_.WriteTo(ref output, _repeated_values_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Key);
      }
      size += values_.CalculateSize(_repeated_values_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TopologySelectorLabelRequirement other) {
      if (other == null) {
        return;
      }
      if (other.HasKey) {
        Key = other.Key;
      }
      values_.Add(other.values_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            values_.AddEntriesFrom(input, _repeated_values_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Key = input.ReadString();
            break;
          }
          case 18: {
            values_.AddEntriesFrom(ref input, _repeated_values_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A topology selector term represents the result of label queries.
  /// A null or empty topology selector term matches no objects.
  /// The requirements of them are ANDed.
  /// It provides a subset of functionality as NodeSelectorTerm.
  /// This is an alpha feature and may change in the future.
  /// +structType=atomic
  /// </summary>
  public sealed partial class TopologySelectorTerm : pb::IMessage<TopologySelectorTerm>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TopologySelectorTerm> _parser = new pb::MessageParser<TopologySelectorTerm>(() => new TopologySelectorTerm());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TopologySelectorTerm> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[195]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopologySelectorTerm() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopologySelectorTerm(TopologySelectorTerm other) : this() {
      matchLabelExpressions_ = other.matchLabelExpressions_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopologySelectorTerm Clone() {
      return new TopologySelectorTerm(this);
    }

    /// <summary>Field number for the "matchLabelExpressions" field.</summary>
    public const int MatchLabelExpressionsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Core.V1.TopologySelectorLabelRequirement> _repeated_matchLabelExpressions_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Core.V1.TopologySelectorLabelRequirement.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Core.V1.TopologySelectorLabelRequirement> matchLabelExpressions_ = new pbc::RepeatedField<global::K8S.Io.Api.Core.V1.TopologySelectorLabelRequirement>();
    /// <summary>
    /// A list of topology selector requirements by labels.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Core.V1.TopologySelectorLabelRequirement> MatchLabelExpressions {
      get { return matchLabelExpressions_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TopologySelectorTerm);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TopologySelectorTerm other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!matchLabelExpressions_.Equals(other.matchLabelExpressions_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= matchLabelExpressions_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      matchLabelExpressions_.WriteTo(output, _repeated_matchLabelExpressions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      matchLabelExpressions_.WriteTo(ref output, _repeated_matchLabelExpressions_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += matchLabelExpressions_.CalculateSize(_repeated_matchLabelExpressions_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TopologySelectorTerm other) {
      if (other == null) {
        return;
      }
      matchLabelExpressions_.Add(other.matchLabelExpressions_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            matchLabelExpressions_.AddEntriesFrom(input, _repeated_matchLabelExpressions_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            matchLabelExpressions_.AddEntriesFrom(ref input, _repeated_matchLabelExpressions_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
  /// </summary>
  public sealed partial class TopologySpreadConstraint : pb::IMessage<TopologySpreadConstraint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TopologySpreadConstraint> _parser = new pb::MessageParser<TopologySpreadConstraint>(() => new TopologySpreadConstraint());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TopologySpreadConstraint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[196]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopologySpreadConstraint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopologySpreadConstraint(TopologySpreadConstraint other) : this() {
      _hasBits0 = other._hasBits0;
      maxSkew_ = other.maxSkew_;
      topologyKey_ = other.topologyKey_;
      whenUnsatisfiable_ = other.whenUnsatisfiable_;
      labelSelector_ = other.labelSelector_ != null ? other.labelSelector_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TopologySpreadConstraint Clone() {
      return new TopologySpreadConstraint(this);
    }

    /// <summary>Field number for the "maxSkew" field.</summary>
    public const int MaxSkewFieldNumber = 1;
    private readonly static int MaxSkewDefaultValue = 0;

    private int maxSkew_;
    /// <summary>
    /// MaxSkew describes the degree to which pods may be unevenly distributed.
    /// When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
    /// between the number of matching pods in the target topology and the global minimum.
    /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    /// labelSelector spread as 1/1/0:
    /// +-------+-------+-------+
    /// | zone1 | zone2 | zone3 |
    /// +-------+-------+-------+
    /// |   P   |   P   |       |
    /// +-------+-------+-------+
    /// - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
    /// scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
    /// violate MaxSkew(1).
    /// - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
    /// When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
    /// to topologies that satisfy it.
    /// It's a required field. Default value is 1 and 0 is not allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxSkew {
      get { if ((_hasBits0 & 1) != 0) { return maxSkew_; } else { return MaxSkewDefaultValue; } }
      set {
        _hasBits0 |= 1;
        maxSkew_ = value;
      }
    }
    /// <summary>Gets whether the "maxSkew" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMaxSkew {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "maxSkew" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMaxSkew() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "topologyKey" field.</summary>
    public const int TopologyKeyFieldNumber = 2;
    private readonly static string TopologyKeyDefaultValue = "";

    private string topologyKey_;
    /// <summary>
    /// TopologyKey is the key of node labels. Nodes that have a label with this key
    /// and identical values are considered to be in the same topology.
    /// We consider each &lt;key, value> as a "bucket", and try to put balanced number
    /// of pods into each bucket.
    /// It's a required field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string TopologyKey {
      get { return topologyKey_ ?? TopologyKeyDefaultValue; }
      set {
        topologyKey_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "topologyKey" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasTopologyKey {
      get { return topologyKey_ != null; }
    }
    /// <summary>Clears the value of the "topologyKey" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearTopologyKey() {
      topologyKey_ = null;
    }

    /// <summary>Field number for the "whenUnsatisfiable" field.</summary>
    public const int WhenUnsatisfiableFieldNumber = 3;
    private readonly static string WhenUnsatisfiableDefaultValue = "";

    private string whenUnsatisfiable_;
    /// <summary>
    /// WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
    /// the spread constraint.
    /// - DoNotSchedule (default) tells the scheduler not to schedule it.
    /// - ScheduleAnyway tells the scheduler to schedule the pod in any location,
    ///   but giving higher precedence to topologies that would help reduce the
    ///   skew.
    /// A constraint is considered "Unsatisfiable" for an incoming pod
    /// if and only if every possible node assigment for that pod would violate
    /// "MaxSkew" on some topology.
    /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
    /// labelSelector spread as 3/1/1:
    /// +-------+-------+-------+
    /// | zone1 | zone2 | zone3 |
    /// +-------+-------+-------+
    /// | P P P |   P   |   P   |
    /// +-------+-------+-------+
    /// If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
    /// to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
    /// MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
    /// won't make it *more* imbalanced.
    /// It's a required field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string WhenUnsatisfiable {
      get { return whenUnsatisfiable_ ?? WhenUnsatisfiableDefaultValue; }
      set {
        whenUnsatisfiable_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "whenUnsatisfiable" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWhenUnsatisfiable {
      get { return whenUnsatisfiable_ != null; }
    }
    /// <summary>Clears the value of the "whenUnsatisfiable" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWhenUnsatisfiable() {
      whenUnsatisfiable_ = null;
    }

    /// <summary>Field number for the "labelSelector" field.</summary>
    public const int LabelSelectorFieldNumber = 4;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector labelSelector_;
    /// <summary>
    /// LabelSelector is used to find matching pods.
    /// Pods that match this label selector are counted to determine the number of pods
    /// in their corresponding topology domain.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector LabelSelector {
      get { return labelSelector_; }
      set {
        labelSelector_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TopologySpreadConstraint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TopologySpreadConstraint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxSkew != other.MaxSkew) return false;
      if (TopologyKey != other.TopologyKey) return false;
      if (WhenUnsatisfiable != other.WhenUnsatisfiable) return false;
      if (!object.Equals(LabelSelector, other.LabelSelector)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasMaxSkew) hash ^= MaxSkew.GetHashCode();
      if (HasTopologyKey) hash ^= TopologyKey.GetHashCode();
      if (HasWhenUnsatisfiable) hash ^= WhenUnsatisfiable.GetHashCode();
      if (labelSelector_ != null) hash ^= LabelSelector.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasMaxSkew) {
        output.WriteRawTag(8);
        output.WriteInt32(MaxSkew);
      }
      if (HasTopologyKey) {
        output.WriteRawTag(18);
        output.WriteString(TopologyKey);
      }
      if (HasWhenUnsatisfiable) {
        output.WriteRawTag(26);
        output.WriteString(WhenUnsatisfiable);
      }
      if (labelSelector_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LabelSelector);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasMaxSkew) {
        output.WriteRawTag(8);
        output.WriteInt32(MaxSkew);
      }
      if (HasTopologyKey) {
        output.WriteRawTag(18);
        output.WriteString(TopologyKey);
      }
      if (HasWhenUnsatisfiable) {
        output.WriteRawTag(26);
        output.WriteString(WhenUnsatisfiable);
      }
      if (labelSelector_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(LabelSelector);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasMaxSkew) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxSkew);
      }
      if (HasTopologyKey) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TopologyKey);
      }
      if (HasWhenUnsatisfiable) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WhenUnsatisfiable);
      }
      if (labelSelector_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LabelSelector);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TopologySpreadConstraint other) {
      if (other == null) {
        return;
      }
      if (other.HasMaxSkew) {
        MaxSkew = other.MaxSkew;
      }
      if (other.HasTopologyKey) {
        TopologyKey = other.TopologyKey;
      }
      if (other.HasWhenUnsatisfiable) {
        WhenUnsatisfiable = other.WhenUnsatisfiable;
      }
      if (other.labelSelector_ != null) {
        if (labelSelector_ == null) {
          LabelSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
        }
        LabelSelector.MergeFrom(other.LabelSelector);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MaxSkew = input.ReadInt32();
            break;
          }
          case 18: {
            TopologyKey = input.ReadString();
            break;
          }
          case 26: {
            WhenUnsatisfiable = input.ReadString();
            break;
          }
          case 34: {
            if (labelSelector_ == null) {
              LabelSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(LabelSelector);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            MaxSkew = input.ReadInt32();
            break;
          }
          case 18: {
            TopologyKey = input.ReadString();
            break;
          }
          case 26: {
            WhenUnsatisfiable = input.ReadString();
            break;
          }
          case 34: {
            if (labelSelector_ == null) {
              LabelSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(LabelSelector);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// TypedLocalObjectReference contains enough information to let you locate the
  /// typed referenced object inside the same namespace.
  /// +structType=atomic
  /// </summary>
  public sealed partial class TypedLocalObjectReference : pb::IMessage<TypedLocalObjectReference>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<TypedLocalObjectReference> _parser = new pb::MessageParser<TypedLocalObjectReference>(() => new TypedLocalObjectReference());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<TypedLocalObjectReference> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[197]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TypedLocalObjectReference() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TypedLocalObjectReference(TypedLocalObjectReference other) : this() {
      apiGroup_ = other.apiGroup_;
      kind_ = other.kind_;
      name_ = other.name_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public TypedLocalObjectReference Clone() {
      return new TypedLocalObjectReference(this);
    }

    /// <summary>Field number for the "apiGroup" field.</summary>
    public const int ApiGroupFieldNumber = 1;
    private readonly static string ApiGroupDefaultValue = "";

    private string apiGroup_;
    /// <summary>
    /// APIGroup is the group for the resource being referenced.
    /// If APIGroup is not specified, the specified Kind must be in the core API group.
    /// For any other third-party types, APIGroup is required.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string ApiGroup {
      get { return apiGroup_ ?? ApiGroupDefaultValue; }
      set {
        apiGroup_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "apiGroup" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasApiGroup {
      get { return apiGroup_ != null; }
    }
    /// <summary>Clears the value of the "apiGroup" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearApiGroup() {
      apiGroup_ = null;
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 2;
    private readonly static string KindDefaultValue = "";

    private string kind_;
    /// <summary>
    /// Kind is the type of resource being referenced
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Kind {
      get { return kind_ ?? KindDefaultValue; }
      set {
        kind_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "kind" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKind {
      get { return kind_ != null; }
    }
    /// <summary>Clears the value of the "kind" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKind() {
      kind_ = null;
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name is the name of resource being referenced
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as TypedLocalObjectReference);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(TypedLocalObjectReference other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ApiGroup != other.ApiGroup) return false;
      if (Kind != other.Kind) return false;
      if (Name != other.Name) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasApiGroup) hash ^= ApiGroup.GetHashCode();
      if (HasKind) hash ^= Kind.GetHashCode();
      if (HasName) hash ^= Name.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasApiGroup) {
        output.WriteRawTag(10);
        output.WriteString(ApiGroup);
      }
      if (HasKind) {
        output.WriteRawTag(18);
        output.WriteString(Kind);
      }
      if (HasName) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasApiGroup) {
        output.WriteRawTag(10);
        output.WriteString(ApiGroup);
      }
      if (HasKind) {
        output.WriteRawTag(18);
        output.WriteString(Kind);
      }
      if (HasName) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasApiGroup) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ApiGroup);
      }
      if (HasKind) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Kind);
      }
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(TypedLocalObjectReference other) {
      if (other == null) {
        return;
      }
      if (other.HasApiGroup) {
        ApiGroup = other.ApiGroup;
      }
      if (other.HasKind) {
        Kind = other.Kind;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ApiGroup = input.ReadString();
            break;
          }
          case 18: {
            Kind = input.ReadString();
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ApiGroup = input.ReadString();
            break;
          }
          case 18: {
            Kind = input.ReadString();
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Volume represents a named volume in a pod that may be accessed by any container in the pod.
  /// </summary>
  public sealed partial class Volume : pb::IMessage<Volume>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Volume> _parser = new pb::MessageParser<Volume>(() => new Volume());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Volume> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[198]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Volume() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Volume(Volume other) : this() {
      name_ = other.name_;
      volumeSource_ = other.volumeSource_ != null ? other.volumeSource_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Volume Clone() {
      return new Volume(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Volume's name.
    /// Must be a DNS_LABEL and unique within the pod.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "volumeSource" field.</summary>
    public const int VolumeSourceFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.VolumeSource volumeSource_;
    /// <summary>
    /// VolumeSource represents the location and type of the mounted volume.
    /// If not specified, the Volume is implied to be an EmptyDir.
    /// This implied behavior is deprecated and will be removed in a future version.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.VolumeSource VolumeSource {
      get { return volumeSource_; }
      set {
        volumeSource_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Volume);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Volume other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(VolumeSource, other.VolumeSource)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (volumeSource_ != null) hash ^= VolumeSource.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (volumeSource_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(VolumeSource);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (volumeSource_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(VolumeSource);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (volumeSource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VolumeSource);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Volume other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.volumeSource_ != null) {
        if (volumeSource_ == null) {
          VolumeSource = new global::K8S.Io.Api.Core.V1.VolumeSource();
        }
        VolumeSource.MergeFrom(other.VolumeSource);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (volumeSource_ == null) {
              VolumeSource = new global::K8S.Io.Api.Core.V1.VolumeSource();
            }
            input.ReadMessage(VolumeSource);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (volumeSource_ == null) {
              VolumeSource = new global::K8S.Io.Api.Core.V1.VolumeSource();
            }
            input.ReadMessage(VolumeSource);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// volumeDevice describes a mapping of a raw block device within a container.
  /// </summary>
  public sealed partial class VolumeDevice : pb::IMessage<VolumeDevice>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VolumeDevice> _parser = new pb::MessageParser<VolumeDevice>(() => new VolumeDevice());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VolumeDevice> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[199]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeDevice() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeDevice(VolumeDevice other) : this() {
      name_ = other.name_;
      devicePath_ = other.devicePath_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeDevice Clone() {
      return new VolumeDevice(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// name must match the name of a persistentVolumeClaim in the pod
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "devicePath" field.</summary>
    public const int DevicePathFieldNumber = 2;
    private readonly static string DevicePathDefaultValue = "";

    private string devicePath_;
    /// <summary>
    /// devicePath is the path inside of the container that the device will be mapped to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DevicePath {
      get { return devicePath_ ?? DevicePathDefaultValue; }
      set {
        devicePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "devicePath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasDevicePath {
      get { return devicePath_ != null; }
    }
    /// <summary>Clears the value of the "devicePath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearDevicePath() {
      devicePath_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VolumeDevice);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VolumeDevice other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DevicePath != other.DevicePath) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasDevicePath) hash ^= DevicePath.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasDevicePath) {
        output.WriteRawTag(18);
        output.WriteString(DevicePath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasDevicePath) {
        output.WriteRawTag(18);
        output.WriteString(DevicePath);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasDevicePath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DevicePath);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VolumeDevice other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasDevicePath) {
        DevicePath = other.DevicePath;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            DevicePath = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            DevicePath = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// VolumeMount describes a mounting of a Volume within a container.
  /// </summary>
  public sealed partial class VolumeMount : pb::IMessage<VolumeMount>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VolumeMount> _parser = new pb::MessageParser<VolumeMount>(() => new VolumeMount());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VolumeMount> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[200]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeMount() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeMount(VolumeMount other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      readOnly_ = other.readOnly_;
      mountPath_ = other.mountPath_;
      subPath_ = other.subPath_;
      mountPropagation_ = other.mountPropagation_;
      subPathExpr_ = other.subPathExpr_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeMount Clone() {
      return new VolumeMount(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// This must match the Name of a Volume.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "readOnly" field.</summary>
    public const int ReadOnlyFieldNumber = 2;
    private readonly static bool ReadOnlyDefaultValue = false;

    private bool readOnly_;
    /// <summary>
    /// Mounted read-only if true, read-write otherwise (false or unspecified).
    /// Defaults to false.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool ReadOnly {
      get { if ((_hasBits0 & 1) != 0) { return readOnly_; } else { return ReadOnlyDefaultValue; } }
      set {
        _hasBits0 |= 1;
        readOnly_ = value;
      }
    }
    /// <summary>Gets whether the "readOnly" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasReadOnly {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "readOnly" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearReadOnly() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "mountPath" field.</summary>
    public const int MountPathFieldNumber = 3;
    private readonly static string MountPathDefaultValue = "";

    private string mountPath_;
    /// <summary>
    /// Path within the container at which the volume should be mounted.  Must
    /// not contain ':'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MountPath {
      get { return mountPath_ ?? MountPathDefaultValue; }
      set {
        mountPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "mountPath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMountPath {
      get { return mountPath_ != null; }
    }
    /// <summary>Clears the value of the "mountPath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMountPath() {
      mountPath_ = null;
    }

    /// <summary>Field number for the "subPath" field.</summary>
    public const int SubPathFieldNumber = 4;
    private readonly static string SubPathDefaultValue = "";

    private string subPath_;
    /// <summary>
    /// Path within the volume from which the container's volume should be mounted.
    /// Defaults to "" (volume's root).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SubPath {
      get { return subPath_ ?? SubPathDefaultValue; }
      set {
        subPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "subPath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSubPath {
      get { return subPath_ != null; }
    }
    /// <summary>Clears the value of the "subPath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSubPath() {
      subPath_ = null;
    }

    /// <summary>Field number for the "mountPropagation" field.</summary>
    public const int MountPropagationFieldNumber = 5;
    private readonly static string MountPropagationDefaultValue = "";

    private string mountPropagation_;
    /// <summary>
    /// mountPropagation determines how mounts are propagated from the host
    /// to container and the other way around.
    /// When not set, MountPropagationNone is used.
    /// This field is beta in 1.10.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string MountPropagation {
      get { return mountPropagation_ ?? MountPropagationDefaultValue; }
      set {
        mountPropagation_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "mountPropagation" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMountPropagation {
      get { return mountPropagation_ != null; }
    }
    /// <summary>Clears the value of the "mountPropagation" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMountPropagation() {
      mountPropagation_ = null;
    }

    /// <summary>Field number for the "subPathExpr" field.</summary>
    public const int SubPathExprFieldNumber = 6;
    private readonly static string SubPathExprDefaultValue = "";

    private string subPathExpr_;
    /// <summary>
    /// Expanded path within the volume from which the container's volume should be mounted.
    /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
    /// Defaults to "" (volume's root).
    /// SubPathExpr and SubPath are mutually exclusive.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SubPathExpr {
      get { return subPathExpr_ ?? SubPathExprDefaultValue; }
      set {
        subPathExpr_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "subPathExpr" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSubPathExpr {
      get { return subPathExpr_ != null; }
    }
    /// <summary>Clears the value of the "subPathExpr" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSubPathExpr() {
      subPathExpr_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VolumeMount);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VolumeMount other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (ReadOnly != other.ReadOnly) return false;
      if (MountPath != other.MountPath) return false;
      if (SubPath != other.SubPath) return false;
      if (MountPropagation != other.MountPropagation) return false;
      if (SubPathExpr != other.SubPathExpr) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasReadOnly) hash ^= ReadOnly.GetHashCode();
      if (HasMountPath) hash ^= MountPath.GetHashCode();
      if (HasSubPath) hash ^= SubPath.GetHashCode();
      if (HasMountPropagation) hash ^= MountPropagation.GetHashCode();
      if (HasSubPathExpr) hash ^= SubPathExpr.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasReadOnly) {
        output.WriteRawTag(16);
        output.WriteBool(ReadOnly);
      }
      if (HasMountPath) {
        output.WriteRawTag(26);
        output.WriteString(MountPath);
      }
      if (HasSubPath) {
        output.WriteRawTag(34);
        output.WriteString(SubPath);
      }
      if (HasMountPropagation) {
        output.WriteRawTag(42);
        output.WriteString(MountPropagation);
      }
      if (HasSubPathExpr) {
        output.WriteRawTag(50);
        output.WriteString(SubPathExpr);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasReadOnly) {
        output.WriteRawTag(16);
        output.WriteBool(ReadOnly);
      }
      if (HasMountPath) {
        output.WriteRawTag(26);
        output.WriteString(MountPath);
      }
      if (HasSubPath) {
        output.WriteRawTag(34);
        output.WriteString(SubPath);
      }
      if (HasMountPropagation) {
        output.WriteRawTag(42);
        output.WriteString(MountPropagation);
      }
      if (HasSubPathExpr) {
        output.WriteRawTag(50);
        output.WriteString(SubPathExpr);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasReadOnly) {
        size += 1 + 1;
      }
      if (HasMountPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MountPath);
      }
      if (HasSubPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SubPath);
      }
      if (HasMountPropagation) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MountPropagation);
      }
      if (HasSubPathExpr) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SubPathExpr);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VolumeMount other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasReadOnly) {
        ReadOnly = other.ReadOnly;
      }
      if (other.HasMountPath) {
        MountPath = other.MountPath;
      }
      if (other.HasSubPath) {
        SubPath = other.SubPath;
      }
      if (other.HasMountPropagation) {
        MountPropagation = other.MountPropagation;
      }
      if (other.HasSubPathExpr) {
        SubPathExpr = other.SubPathExpr;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 26: {
            MountPath = input.ReadString();
            break;
          }
          case 34: {
            SubPath = input.ReadString();
            break;
          }
          case 42: {
            MountPropagation = input.ReadString();
            break;
          }
          case 50: {
            SubPathExpr = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            ReadOnly = input.ReadBool();
            break;
          }
          case 26: {
            MountPath = input.ReadString();
            break;
          }
          case 34: {
            SubPath = input.ReadString();
            break;
          }
          case 42: {
            MountPropagation = input.ReadString();
            break;
          }
          case 50: {
            SubPathExpr = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed from.
  /// </summary>
  public sealed partial class VolumeNodeAffinity : pb::IMessage<VolumeNodeAffinity>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VolumeNodeAffinity> _parser = new pb::MessageParser<VolumeNodeAffinity>(() => new VolumeNodeAffinity());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VolumeNodeAffinity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[201]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeNodeAffinity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeNodeAffinity(VolumeNodeAffinity other) : this() {
      required_ = other.required_ != null ? other.required_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeNodeAffinity Clone() {
      return new VolumeNodeAffinity(this);
    }

    /// <summary>Field number for the "required" field.</summary>
    public const int RequiredFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.NodeSelector required_;
    /// <summary>
    /// Required specifies hard node constraints that must be met.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NodeSelector Required {
      get { return required_; }
      set {
        required_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VolumeNodeAffinity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VolumeNodeAffinity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Required, other.Required)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (required_ != null) hash ^= Required.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (required_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Required);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (required_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Required);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (required_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Required);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VolumeNodeAffinity other) {
      if (other == null) {
        return;
      }
      if (other.required_ != null) {
        if (required_ == null) {
          Required = new global::K8S.Io.Api.Core.V1.NodeSelector();
        }
        Required.MergeFrom(other.Required);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (required_ == null) {
              Required = new global::K8S.Io.Api.Core.V1.NodeSelector();
            }
            input.ReadMessage(Required);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (required_ == null) {
              Required = new global::K8S.Io.Api.Core.V1.NodeSelector();
            }
            input.ReadMessage(Required);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Projection that may be projected along with other supported volume types
  /// </summary>
  public sealed partial class VolumeProjection : pb::IMessage<VolumeProjection>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VolumeProjection> _parser = new pb::MessageParser<VolumeProjection>(() => new VolumeProjection());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VolumeProjection> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[202]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeProjection() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeProjection(VolumeProjection other) : this() {
      secret_ = other.secret_ != null ? other.secret_.Clone() : null;
      downwardAPI_ = other.downwardAPI_ != null ? other.downwardAPI_.Clone() : null;
      configMap_ = other.configMap_ != null ? other.configMap_.Clone() : null;
      serviceAccountToken_ = other.serviceAccountToken_ != null ? other.serviceAccountToken_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeProjection Clone() {
      return new VolumeProjection(this);
    }

    /// <summary>Field number for the "secret" field.</summary>
    public const int SecretFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.SecretProjection secret_;
    /// <summary>
    /// information about the secret data to project
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretProjection Secret {
      get { return secret_; }
      set {
        secret_ = value;
      }
    }

    /// <summary>Field number for the "downwardAPI" field.</summary>
    public const int DownwardAPIFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.DownwardAPIProjection downwardAPI_;
    /// <summary>
    /// information about the downwardAPI data to project
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.DownwardAPIProjection DownwardAPI {
      get { return downwardAPI_; }
      set {
        downwardAPI_ = value;
      }
    }

    /// <summary>Field number for the "configMap" field.</summary>
    public const int ConfigMapFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.ConfigMapProjection configMap_;
    /// <summary>
    /// information about the configMap data to project
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ConfigMapProjection ConfigMap {
      get { return configMap_; }
      set {
        configMap_ = value;
      }
    }

    /// <summary>Field number for the "serviceAccountToken" field.</summary>
    public const int ServiceAccountTokenFieldNumber = 4;
    private global::K8S.Io.Api.Core.V1.ServiceAccountTokenProjection serviceAccountToken_;
    /// <summary>
    /// information about the serviceAccountToken data to project
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ServiceAccountTokenProjection ServiceAccountToken {
      get { return serviceAccountToken_; }
      set {
        serviceAccountToken_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VolumeProjection);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VolumeProjection other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Secret, other.Secret)) return false;
      if (!object.Equals(DownwardAPI, other.DownwardAPI)) return false;
      if (!object.Equals(ConfigMap, other.ConfigMap)) return false;
      if (!object.Equals(ServiceAccountToken, other.ServiceAccountToken)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (secret_ != null) hash ^= Secret.GetHashCode();
      if (downwardAPI_ != null) hash ^= DownwardAPI.GetHashCode();
      if (configMap_ != null) hash ^= ConfigMap.GetHashCode();
      if (serviceAccountToken_ != null) hash ^= ServiceAccountToken.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (secret_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Secret);
      }
      if (downwardAPI_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(DownwardAPI);
      }
      if (configMap_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ConfigMap);
      }
      if (serviceAccountToken_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ServiceAccountToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (secret_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Secret);
      }
      if (downwardAPI_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(DownwardAPI);
      }
      if (configMap_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ConfigMap);
      }
      if (serviceAccountToken_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ServiceAccountToken);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (secret_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Secret);
      }
      if (downwardAPI_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DownwardAPI);
      }
      if (configMap_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConfigMap);
      }
      if (serviceAccountToken_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ServiceAccountToken);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VolumeProjection other) {
      if (other == null) {
        return;
      }
      if (other.secret_ != null) {
        if (secret_ == null) {
          Secret = new global::K8S.Io.Api.Core.V1.SecretProjection();
        }
        Secret.MergeFrom(other.Secret);
      }
      if (other.downwardAPI_ != null) {
        if (downwardAPI_ == null) {
          DownwardAPI = new global::K8S.Io.Api.Core.V1.DownwardAPIProjection();
        }
        DownwardAPI.MergeFrom(other.DownwardAPI);
      }
      if (other.configMap_ != null) {
        if (configMap_ == null) {
          ConfigMap = new global::K8S.Io.Api.Core.V1.ConfigMapProjection();
        }
        ConfigMap.MergeFrom(other.ConfigMap);
      }
      if (other.serviceAccountToken_ != null) {
        if (serviceAccountToken_ == null) {
          ServiceAccountToken = new global::K8S.Io.Api.Core.V1.ServiceAccountTokenProjection();
        }
        ServiceAccountToken.MergeFrom(other.ServiceAccountToken);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (secret_ == null) {
              Secret = new global::K8S.Io.Api.Core.V1.SecretProjection();
            }
            input.ReadMessage(Secret);
            break;
          }
          case 18: {
            if (downwardAPI_ == null) {
              DownwardAPI = new global::K8S.Io.Api.Core.V1.DownwardAPIProjection();
            }
            input.ReadMessage(DownwardAPI);
            break;
          }
          case 26: {
            if (configMap_ == null) {
              ConfigMap = new global::K8S.Io.Api.Core.V1.ConfigMapProjection();
            }
            input.ReadMessage(ConfigMap);
            break;
          }
          case 34: {
            if (serviceAccountToken_ == null) {
              ServiceAccountToken = new global::K8S.Io.Api.Core.V1.ServiceAccountTokenProjection();
            }
            input.ReadMessage(ServiceAccountToken);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (secret_ == null) {
              Secret = new global::K8S.Io.Api.Core.V1.SecretProjection();
            }
            input.ReadMessage(Secret);
            break;
          }
          case 18: {
            if (downwardAPI_ == null) {
              DownwardAPI = new global::K8S.Io.Api.Core.V1.DownwardAPIProjection();
            }
            input.ReadMessage(DownwardAPI);
            break;
          }
          case 26: {
            if (configMap_ == null) {
              ConfigMap = new global::K8S.Io.Api.Core.V1.ConfigMapProjection();
            }
            input.ReadMessage(ConfigMap);
            break;
          }
          case 34: {
            if (serviceAccountToken_ == null) {
              ServiceAccountToken = new global::K8S.Io.Api.Core.V1.ServiceAccountTokenProjection();
            }
            input.ReadMessage(ServiceAccountToken);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents the source of a volume to mount.
  /// Only one of its members may be specified.
  /// </summary>
  public sealed partial class VolumeSource : pb::IMessage<VolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VolumeSource> _parser = new pb::MessageParser<VolumeSource>(() => new VolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[203]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeSource(VolumeSource other) : this() {
      hostPath_ = other.hostPath_ != null ? other.hostPath_.Clone() : null;
      emptyDir_ = other.emptyDir_ != null ? other.emptyDir_.Clone() : null;
      gcePersistentDisk_ = other.gcePersistentDisk_ != null ? other.gcePersistentDisk_.Clone() : null;
      awsElasticBlockStore_ = other.awsElasticBlockStore_ != null ? other.awsElasticBlockStore_.Clone() : null;
      gitRepo_ = other.gitRepo_ != null ? other.gitRepo_.Clone() : null;
      secret_ = other.secret_ != null ? other.secret_.Clone() : null;
      nfs_ = other.nfs_ != null ? other.nfs_.Clone() : null;
      iscsi_ = other.iscsi_ != null ? other.iscsi_.Clone() : null;
      glusterfs_ = other.glusterfs_ != null ? other.glusterfs_.Clone() : null;
      persistentVolumeClaim_ = other.persistentVolumeClaim_ != null ? other.persistentVolumeClaim_.Clone() : null;
      rbd_ = other.rbd_ != null ? other.rbd_.Clone() : null;
      flexVolume_ = other.flexVolume_ != null ? other.flexVolume_.Clone() : null;
      cinder_ = other.cinder_ != null ? other.cinder_.Clone() : null;
      cephfs_ = other.cephfs_ != null ? other.cephfs_.Clone() : null;
      flocker_ = other.flocker_ != null ? other.flocker_.Clone() : null;
      downwardAPI_ = other.downwardAPI_ != null ? other.downwardAPI_.Clone() : null;
      fc_ = other.fc_ != null ? other.fc_.Clone() : null;
      azureFile_ = other.azureFile_ != null ? other.azureFile_.Clone() : null;
      configMap_ = other.configMap_ != null ? other.configMap_.Clone() : null;
      vsphereVolume_ = other.vsphereVolume_ != null ? other.vsphereVolume_.Clone() : null;
      quobyte_ = other.quobyte_ != null ? other.quobyte_.Clone() : null;
      azureDisk_ = other.azureDisk_ != null ? other.azureDisk_.Clone() : null;
      photonPersistentDisk_ = other.photonPersistentDisk_ != null ? other.photonPersistentDisk_.Clone() : null;
      projected_ = other.projected_ != null ? other.projected_.Clone() : null;
      portworxVolume_ = other.portworxVolume_ != null ? other.portworxVolume_.Clone() : null;
      scaleIO_ = other.scaleIO_ != null ? other.scaleIO_.Clone() : null;
      storageos_ = other.storageos_ != null ? other.storageos_.Clone() : null;
      csi_ = other.csi_ != null ? other.csi_.Clone() : null;
      ephemeral_ = other.ephemeral_ != null ? other.ephemeral_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VolumeSource Clone() {
      return new VolumeSource(this);
    }

    /// <summary>Field number for the "hostPath" field.</summary>
    public const int HostPathFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.HostPathVolumeSource hostPath_;
    /// <summary>
    /// HostPath represents a pre-existing file or directory on the host
    /// machine that is directly exposed to the container. This is generally
    /// used for system agents or other privileged things that are allowed
    /// to see the host machine. Most containers will NOT need this.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
    /// ---
    /// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
    /// mount host directories as read/write.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.HostPathVolumeSource HostPath {
      get { return hostPath_; }
      set {
        hostPath_ = value;
      }
    }

    /// <summary>Field number for the "emptyDir" field.</summary>
    public const int EmptyDirFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.EmptyDirVolumeSource emptyDir_;
    /// <summary>
    /// EmptyDir represents a temporary directory that shares a pod's lifetime.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.EmptyDirVolumeSource EmptyDir {
      get { return emptyDir_; }
      set {
        emptyDir_ = value;
      }
    }

    /// <summary>Field number for the "gcePersistentDisk" field.</summary>
    public const int GcePersistentDiskFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource gcePersistentDisk_;
    /// <summary>
    /// GCEPersistentDisk represents a GCE Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource GcePersistentDisk {
      get { return gcePersistentDisk_; }
      set {
        gcePersistentDisk_ = value;
      }
    }

    /// <summary>Field number for the "awsElasticBlockStore" field.</summary>
    public const int AwsElasticBlockStoreFieldNumber = 4;
    private global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore_;
    /// <summary>
    /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource AwsElasticBlockStore {
      get { return awsElasticBlockStore_; }
      set {
        awsElasticBlockStore_ = value;
      }
    }

    /// <summary>Field number for the "gitRepo" field.</summary>
    public const int GitRepoFieldNumber = 5;
    private global::K8S.Io.Api.Core.V1.GitRepoVolumeSource gitRepo_;
    /// <summary>
    /// GitRepo represents a git repository at a particular revision.
    /// DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    /// into the Pod's container.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.GitRepoVolumeSource GitRepo {
      get { return gitRepo_; }
      set {
        gitRepo_ = value;
      }
    }

    /// <summary>Field number for the "secret" field.</summary>
    public const int SecretFieldNumber = 6;
    private global::K8S.Io.Api.Core.V1.SecretVolumeSource secret_;
    /// <summary>
    /// Secret represents a secret that should populate this volume.
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.SecretVolumeSource Secret {
      get { return secret_; }
      set {
        secret_ = value;
      }
    }

    /// <summary>Field number for the "nfs" field.</summary>
    public const int NfsFieldNumber = 7;
    private global::K8S.Io.Api.Core.V1.NFSVolumeSource nfs_;
    /// <summary>
    /// NFS represents an NFS mount on the host that shares a pod's lifetime
    /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.NFSVolumeSource Nfs {
      get { return nfs_; }
      set {
        nfs_ = value;
      }
    }

    /// <summary>Field number for the "iscsi" field.</summary>
    public const int IscsiFieldNumber = 8;
    private global::K8S.Io.Api.Core.V1.ISCSIVolumeSource iscsi_;
    /// <summary>
    /// ISCSI represents an ISCSI Disk resource that is attached to a
    /// kubelet's host machine and then exposed to the pod.
    /// More info: https://examples.k8s.io/volumes/iscsi/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ISCSIVolumeSource Iscsi {
      get { return iscsi_; }
      set {
        iscsi_ = value;
      }
    }

    /// <summary>Field number for the "glusterfs" field.</summary>
    public const int GlusterfsFieldNumber = 9;
    private global::K8S.Io.Api.Core.V1.GlusterfsVolumeSource glusterfs_;
    /// <summary>
    /// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
    /// More info: https://examples.k8s.io/volumes/glusterfs/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.GlusterfsVolumeSource Glusterfs {
      get { return glusterfs_; }
      set {
        glusterfs_ = value;
      }
    }

    /// <summary>Field number for the "persistentVolumeClaim" field.</summary>
    public const int PersistentVolumeClaimFieldNumber = 10;
    private global::K8S.Io.Api.Core.V1.PersistentVolumeClaimVolumeSource persistentVolumeClaim_;
    /// <summary>
    /// PersistentVolumeClaimVolumeSource represents a reference to a
    /// PersistentVolumeClaim in the same namespace.
    /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PersistentVolumeClaimVolumeSource PersistentVolumeClaim {
      get { return persistentVolumeClaim_; }
      set {
        persistentVolumeClaim_ = value;
      }
    }

    /// <summary>Field number for the "rbd" field.</summary>
    public const int RbdFieldNumber = 11;
    private global::K8S.Io.Api.Core.V1.RBDVolumeSource rbd_;
    /// <summary>
    /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
    /// More info: https://examples.k8s.io/volumes/rbd/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.RBDVolumeSource Rbd {
      get { return rbd_; }
      set {
        rbd_ = value;
      }
    }

    /// <summary>Field number for the "flexVolume" field.</summary>
    public const int FlexVolumeFieldNumber = 12;
    private global::K8S.Io.Api.Core.V1.FlexVolumeSource flexVolume_;
    /// <summary>
    /// FlexVolume represents a generic volume resource that is
    /// provisioned/attached using an exec based plugin.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.FlexVolumeSource FlexVolume {
      get { return flexVolume_; }
      set {
        flexVolume_ = value;
      }
    }

    /// <summary>Field number for the "cinder" field.</summary>
    public const int CinderFieldNumber = 13;
    private global::K8S.Io.Api.Core.V1.CinderVolumeSource cinder_;
    /// <summary>
    /// Cinder represents a cinder volume attached and mounted on kubelets host machine.
    /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.CinderVolumeSource Cinder {
      get { return cinder_; }
      set {
        cinder_ = value;
      }
    }

    /// <summary>Field number for the "cephfs" field.</summary>
    public const int CephfsFieldNumber = 14;
    private global::K8S.Io.Api.Core.V1.CephFSVolumeSource cephfs_;
    /// <summary>
    /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.CephFSVolumeSource Cephfs {
      get { return cephfs_; }
      set {
        cephfs_ = value;
      }
    }

    /// <summary>Field number for the "flocker" field.</summary>
    public const int FlockerFieldNumber = 15;
    private global::K8S.Io.Api.Core.V1.FlockerVolumeSource flocker_;
    /// <summary>
    /// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.FlockerVolumeSource Flocker {
      get { return flocker_; }
      set {
        flocker_ = value;
      }
    }

    /// <summary>Field number for the "downwardAPI" field.</summary>
    public const int DownwardAPIFieldNumber = 16;
    private global::K8S.Io.Api.Core.V1.DownwardAPIVolumeSource downwardAPI_;
    /// <summary>
    /// DownwardAPI represents downward API about the pod that should populate this volume
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.DownwardAPIVolumeSource DownwardAPI {
      get { return downwardAPI_; }
      set {
        downwardAPI_ = value;
      }
    }

    /// <summary>Field number for the "fc" field.</summary>
    public const int FcFieldNumber = 17;
    private global::K8S.Io.Api.Core.V1.FCVolumeSource fc_;
    /// <summary>
    /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.FCVolumeSource Fc {
      get { return fc_; }
      set {
        fc_ = value;
      }
    }

    /// <summary>Field number for the "azureFile" field.</summary>
    public const int AzureFileFieldNumber = 18;
    private global::K8S.Io.Api.Core.V1.AzureFileVolumeSource azureFile_;
    /// <summary>
    /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.AzureFileVolumeSource AzureFile {
      get { return azureFile_; }
      set {
        azureFile_ = value;
      }
    }

    /// <summary>Field number for the "configMap" field.</summary>
    public const int ConfigMapFieldNumber = 19;
    private global::K8S.Io.Api.Core.V1.ConfigMapVolumeSource configMap_;
    /// <summary>
    /// ConfigMap represents a configMap that should populate this volume
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ConfigMapVolumeSource ConfigMap {
      get { return configMap_; }
      set {
        configMap_ = value;
      }
    }

    /// <summary>Field number for the "vsphereVolume" field.</summary>
    public const int VsphereVolumeFieldNumber = 20;
    private global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource vsphereVolume_;
    /// <summary>
    /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource VsphereVolume {
      get { return vsphereVolume_; }
      set {
        vsphereVolume_ = value;
      }
    }

    /// <summary>Field number for the "quobyte" field.</summary>
    public const int QuobyteFieldNumber = 21;
    private global::K8S.Io.Api.Core.V1.QuobyteVolumeSource quobyte_;
    /// <summary>
    /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.QuobyteVolumeSource Quobyte {
      get { return quobyte_; }
      set {
        quobyte_ = value;
      }
    }

    /// <summary>Field number for the "azureDisk" field.</summary>
    public const int AzureDiskFieldNumber = 22;
    private global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource azureDisk_;
    /// <summary>
    /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource AzureDisk {
      get { return azureDisk_; }
      set {
        azureDisk_ = value;
      }
    }

    /// <summary>Field number for the "photonPersistentDisk" field.</summary>
    public const int PhotonPersistentDiskFieldNumber = 23;
    private global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource photonPersistentDisk_;
    /// <summary>
    /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource PhotonPersistentDisk {
      get { return photonPersistentDisk_; }
      set {
        photonPersistentDisk_ = value;
      }
    }

    /// <summary>Field number for the "projected" field.</summary>
    public const int ProjectedFieldNumber = 26;
    private global::K8S.Io.Api.Core.V1.ProjectedVolumeSource projected_;
    /// <summary>
    /// Items for all in one resources secrets, configmaps, and downward API
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ProjectedVolumeSource Projected {
      get { return projected_; }
      set {
        projected_ = value;
      }
    }

    /// <summary>Field number for the "portworxVolume" field.</summary>
    public const int PortworxVolumeFieldNumber = 24;
    private global::K8S.Io.Api.Core.V1.PortworxVolumeSource portworxVolume_;
    /// <summary>
    /// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PortworxVolumeSource PortworxVolume {
      get { return portworxVolume_; }
      set {
        portworxVolume_ = value;
      }
    }

    /// <summary>Field number for the "scaleIO" field.</summary>
    public const int ScaleIOFieldNumber = 25;
    private global::K8S.Io.Api.Core.V1.ScaleIOVolumeSource scaleIO_;
    /// <summary>
    /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.ScaleIOVolumeSource ScaleIO {
      get { return scaleIO_; }
      set {
        scaleIO_ = value;
      }
    }

    /// <summary>Field number for the "storageos" field.</summary>
    public const int StorageosFieldNumber = 27;
    private global::K8S.Io.Api.Core.V1.StorageOSVolumeSource storageos_;
    /// <summary>
    /// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.StorageOSVolumeSource Storageos {
      get { return storageos_; }
      set {
        storageos_ = value;
      }
    }

    /// <summary>Field number for the "csi" field.</summary>
    public const int CsiFieldNumber = 28;
    private global::K8S.Io.Api.Core.V1.CSIVolumeSource csi_;
    /// <summary>
    /// CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.CSIVolumeSource Csi {
      get { return csi_; }
      set {
        csi_ = value;
      }
    }

    /// <summary>Field number for the "ephemeral" field.</summary>
    public const int EphemeralFieldNumber = 29;
    private global::K8S.Io.Api.Core.V1.EphemeralVolumeSource ephemeral_;
    /// <summary>
    /// Ephemeral represents a volume that is handled by a cluster storage driver.
    /// The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
    /// and deleted when the pod is removed.
    ///
    /// Use this if:
    /// a) the volume is only needed while the pod runs,
    /// b) features of normal volumes like restoring from snapshot or capacity
    ///    tracking are needed,
    /// c) the storage driver is specified through a storage class, and
    /// d) the storage driver supports dynamic volume provisioning through
    ///    a PersistentVolumeClaim (see EphemeralVolumeSource for more
    ///    information on the connection between this volume type
    ///    and PersistentVolumeClaim).
    ///
    /// Use PersistentVolumeClaim or one of the vendor-specific
    /// APIs for volumes that persist for longer than the lifecycle
    /// of an individual pod.
    ///
    /// Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
    /// be used that way - see the documentation of the driver for
    /// more information.
    ///
    /// A pod can use both types of ephemeral volumes and
    /// persistent volumes at the same time.
    ///
    /// This is a beta feature and only available when the GenericEphemeralVolume
    /// feature gate is enabled.
    ///
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.EphemeralVolumeSource Ephemeral {
      get { return ephemeral_; }
      set {
        ephemeral_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(HostPath, other.HostPath)) return false;
      if (!object.Equals(EmptyDir, other.EmptyDir)) return false;
      if (!object.Equals(GcePersistentDisk, other.GcePersistentDisk)) return false;
      if (!object.Equals(AwsElasticBlockStore, other.AwsElasticBlockStore)) return false;
      if (!object.Equals(GitRepo, other.GitRepo)) return false;
      if (!object.Equals(Secret, other.Secret)) return false;
      if (!object.Equals(Nfs, other.Nfs)) return false;
      if (!object.Equals(Iscsi, other.Iscsi)) return false;
      if (!object.Equals(Glusterfs, other.Glusterfs)) return false;
      if (!object.Equals(PersistentVolumeClaim, other.PersistentVolumeClaim)) return false;
      if (!object.Equals(Rbd, other.Rbd)) return false;
      if (!object.Equals(FlexVolume, other.FlexVolume)) return false;
      if (!object.Equals(Cinder, other.Cinder)) return false;
      if (!object.Equals(Cephfs, other.Cephfs)) return false;
      if (!object.Equals(Flocker, other.Flocker)) return false;
      if (!object.Equals(DownwardAPI, other.DownwardAPI)) return false;
      if (!object.Equals(Fc, other.Fc)) return false;
      if (!object.Equals(AzureFile, other.AzureFile)) return false;
      if (!object.Equals(ConfigMap, other.ConfigMap)) return false;
      if (!object.Equals(VsphereVolume, other.VsphereVolume)) return false;
      if (!object.Equals(Quobyte, other.Quobyte)) return false;
      if (!object.Equals(AzureDisk, other.AzureDisk)) return false;
      if (!object.Equals(PhotonPersistentDisk, other.PhotonPersistentDisk)) return false;
      if (!object.Equals(Projected, other.Projected)) return false;
      if (!object.Equals(PortworxVolume, other.PortworxVolume)) return false;
      if (!object.Equals(ScaleIO, other.ScaleIO)) return false;
      if (!object.Equals(Storageos, other.Storageos)) return false;
      if (!object.Equals(Csi, other.Csi)) return false;
      if (!object.Equals(Ephemeral, other.Ephemeral)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (hostPath_ != null) hash ^= HostPath.GetHashCode();
      if (emptyDir_ != null) hash ^= EmptyDir.GetHashCode();
      if (gcePersistentDisk_ != null) hash ^= GcePersistentDisk.GetHashCode();
      if (awsElasticBlockStore_ != null) hash ^= AwsElasticBlockStore.GetHashCode();
      if (gitRepo_ != null) hash ^= GitRepo.GetHashCode();
      if (secret_ != null) hash ^= Secret.GetHashCode();
      if (nfs_ != null) hash ^= Nfs.GetHashCode();
      if (iscsi_ != null) hash ^= Iscsi.GetHashCode();
      if (glusterfs_ != null) hash ^= Glusterfs.GetHashCode();
      if (persistentVolumeClaim_ != null) hash ^= PersistentVolumeClaim.GetHashCode();
      if (rbd_ != null) hash ^= Rbd.GetHashCode();
      if (flexVolume_ != null) hash ^= FlexVolume.GetHashCode();
      if (cinder_ != null) hash ^= Cinder.GetHashCode();
      if (cephfs_ != null) hash ^= Cephfs.GetHashCode();
      if (flocker_ != null) hash ^= Flocker.GetHashCode();
      if (downwardAPI_ != null) hash ^= DownwardAPI.GetHashCode();
      if (fc_ != null) hash ^= Fc.GetHashCode();
      if (azureFile_ != null) hash ^= AzureFile.GetHashCode();
      if (configMap_ != null) hash ^= ConfigMap.GetHashCode();
      if (vsphereVolume_ != null) hash ^= VsphereVolume.GetHashCode();
      if (quobyte_ != null) hash ^= Quobyte.GetHashCode();
      if (azureDisk_ != null) hash ^= AzureDisk.GetHashCode();
      if (photonPersistentDisk_ != null) hash ^= PhotonPersistentDisk.GetHashCode();
      if (projected_ != null) hash ^= Projected.GetHashCode();
      if (portworxVolume_ != null) hash ^= PortworxVolume.GetHashCode();
      if (scaleIO_ != null) hash ^= ScaleIO.GetHashCode();
      if (storageos_ != null) hash ^= Storageos.GetHashCode();
      if (csi_ != null) hash ^= Csi.GetHashCode();
      if (ephemeral_ != null) hash ^= Ephemeral.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (hostPath_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(HostPath);
      }
      if (emptyDir_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(EmptyDir);
      }
      if (gcePersistentDisk_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(GcePersistentDisk);
      }
      if (awsElasticBlockStore_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(AwsElasticBlockStore);
      }
      if (gitRepo_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(GitRepo);
      }
      if (secret_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Secret);
      }
      if (nfs_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Nfs);
      }
      if (iscsi_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Iscsi);
      }
      if (glusterfs_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Glusterfs);
      }
      if (persistentVolumeClaim_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(PersistentVolumeClaim);
      }
      if (rbd_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Rbd);
      }
      if (flexVolume_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(FlexVolume);
      }
      if (cinder_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Cinder);
      }
      if (cephfs_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(Cephfs);
      }
      if (flocker_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Flocker);
      }
      if (downwardAPI_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DownwardAPI);
      }
      if (fc_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Fc);
      }
      if (azureFile_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(AzureFile);
      }
      if (configMap_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ConfigMap);
      }
      if (vsphereVolume_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(VsphereVolume);
      }
      if (quobyte_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(Quobyte);
      }
      if (azureDisk_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(AzureDisk);
      }
      if (photonPersistentDisk_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(PhotonPersistentDisk);
      }
      if (portworxVolume_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(PortworxVolume);
      }
      if (scaleIO_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(ScaleIO);
      }
      if (projected_ != null) {
        output.WriteRawTag(210, 1);
        output.WriteMessage(Projected);
      }
      if (storageos_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(Storageos);
      }
      if (csi_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(Csi);
      }
      if (ephemeral_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(Ephemeral);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (hostPath_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(HostPath);
      }
      if (emptyDir_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(EmptyDir);
      }
      if (gcePersistentDisk_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(GcePersistentDisk);
      }
      if (awsElasticBlockStore_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(AwsElasticBlockStore);
      }
      if (gitRepo_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(GitRepo);
      }
      if (secret_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Secret);
      }
      if (nfs_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Nfs);
      }
      if (iscsi_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Iscsi);
      }
      if (glusterfs_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Glusterfs);
      }
      if (persistentVolumeClaim_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(PersistentVolumeClaim);
      }
      if (rbd_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Rbd);
      }
      if (flexVolume_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(FlexVolume);
      }
      if (cinder_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(Cinder);
      }
      if (cephfs_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(Cephfs);
      }
      if (flocker_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Flocker);
      }
      if (downwardAPI_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DownwardAPI);
      }
      if (fc_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(Fc);
      }
      if (azureFile_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(AzureFile);
      }
      if (configMap_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ConfigMap);
      }
      if (vsphereVolume_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(VsphereVolume);
      }
      if (quobyte_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(Quobyte);
      }
      if (azureDisk_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(AzureDisk);
      }
      if (photonPersistentDisk_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(PhotonPersistentDisk);
      }
      if (portworxVolume_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(PortworxVolume);
      }
      if (scaleIO_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(ScaleIO);
      }
      if (projected_ != null) {
        output.WriteRawTag(210, 1);
        output.WriteMessage(Projected);
      }
      if (storageos_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(Storageos);
      }
      if (csi_ != null) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(Csi);
      }
      if (ephemeral_ != null) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(Ephemeral);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (hostPath_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HostPath);
      }
      if (emptyDir_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EmptyDir);
      }
      if (gcePersistentDisk_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GcePersistentDisk);
      }
      if (awsElasticBlockStore_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AwsElasticBlockStore);
      }
      if (gitRepo_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GitRepo);
      }
      if (secret_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Secret);
      }
      if (nfs_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Nfs);
      }
      if (iscsi_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Iscsi);
      }
      if (glusterfs_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Glusterfs);
      }
      if (persistentVolumeClaim_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PersistentVolumeClaim);
      }
      if (rbd_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Rbd);
      }
      if (flexVolume_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FlexVolume);
      }
      if (cinder_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cinder);
      }
      if (cephfs_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cephfs);
      }
      if (flocker_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Flocker);
      }
      if (downwardAPI_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DownwardAPI);
      }
      if (fc_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Fc);
      }
      if (azureFile_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(AzureFile);
      }
      if (configMap_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ConfigMap);
      }
      if (vsphereVolume_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(VsphereVolume);
      }
      if (quobyte_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Quobyte);
      }
      if (azureDisk_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(AzureDisk);
      }
      if (photonPersistentDisk_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(PhotonPersistentDisk);
      }
      if (projected_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Projected);
      }
      if (portworxVolume_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(PortworxVolume);
      }
      if (scaleIO_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ScaleIO);
      }
      if (storageos_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Storageos);
      }
      if (csi_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Csi);
      }
      if (ephemeral_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Ephemeral);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.hostPath_ != null) {
        if (hostPath_ == null) {
          HostPath = new global::K8S.Io.Api.Core.V1.HostPathVolumeSource();
        }
        HostPath.MergeFrom(other.HostPath);
      }
      if (other.emptyDir_ != null) {
        if (emptyDir_ == null) {
          EmptyDir = new global::K8S.Io.Api.Core.V1.EmptyDirVolumeSource();
        }
        EmptyDir.MergeFrom(other.EmptyDir);
      }
      if (other.gcePersistentDisk_ != null) {
        if (gcePersistentDisk_ == null) {
          GcePersistentDisk = new global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource();
        }
        GcePersistentDisk.MergeFrom(other.GcePersistentDisk);
      }
      if (other.awsElasticBlockStore_ != null) {
        if (awsElasticBlockStore_ == null) {
          AwsElasticBlockStore = new global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource();
        }
        AwsElasticBlockStore.MergeFrom(other.AwsElasticBlockStore);
      }
      if (other.gitRepo_ != null) {
        if (gitRepo_ == null) {
          GitRepo = new global::K8S.Io.Api.Core.V1.GitRepoVolumeSource();
        }
        GitRepo.MergeFrom(other.GitRepo);
      }
      if (other.secret_ != null) {
        if (secret_ == null) {
          Secret = new global::K8S.Io.Api.Core.V1.SecretVolumeSource();
        }
        Secret.MergeFrom(other.Secret);
      }
      if (other.nfs_ != null) {
        if (nfs_ == null) {
          Nfs = new global::K8S.Io.Api.Core.V1.NFSVolumeSource();
        }
        Nfs.MergeFrom(other.Nfs);
      }
      if (other.iscsi_ != null) {
        if (iscsi_ == null) {
          Iscsi = new global::K8S.Io.Api.Core.V1.ISCSIVolumeSource();
        }
        Iscsi.MergeFrom(other.Iscsi);
      }
      if (other.glusterfs_ != null) {
        if (glusterfs_ == null) {
          Glusterfs = new global::K8S.Io.Api.Core.V1.GlusterfsVolumeSource();
        }
        Glusterfs.MergeFrom(other.Glusterfs);
      }
      if (other.persistentVolumeClaim_ != null) {
        if (persistentVolumeClaim_ == null) {
          PersistentVolumeClaim = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimVolumeSource();
        }
        PersistentVolumeClaim.MergeFrom(other.PersistentVolumeClaim);
      }
      if (other.rbd_ != null) {
        if (rbd_ == null) {
          Rbd = new global::K8S.Io.Api.Core.V1.RBDVolumeSource();
        }
        Rbd.MergeFrom(other.Rbd);
      }
      if (other.flexVolume_ != null) {
        if (flexVolume_ == null) {
          FlexVolume = new global::K8S.Io.Api.Core.V1.FlexVolumeSource();
        }
        FlexVolume.MergeFrom(other.FlexVolume);
      }
      if (other.cinder_ != null) {
        if (cinder_ == null) {
          Cinder = new global::K8S.Io.Api.Core.V1.CinderVolumeSource();
        }
        Cinder.MergeFrom(other.Cinder);
      }
      if (other.cephfs_ != null) {
        if (cephfs_ == null) {
          Cephfs = new global::K8S.Io.Api.Core.V1.CephFSVolumeSource();
        }
        Cephfs.MergeFrom(other.Cephfs);
      }
      if (other.flocker_ != null) {
        if (flocker_ == null) {
          Flocker = new global::K8S.Io.Api.Core.V1.FlockerVolumeSource();
        }
        Flocker.MergeFrom(other.Flocker);
      }
      if (other.downwardAPI_ != null) {
        if (downwardAPI_ == null) {
          DownwardAPI = new global::K8S.Io.Api.Core.V1.DownwardAPIVolumeSource();
        }
        DownwardAPI.MergeFrom(other.DownwardAPI);
      }
      if (other.fc_ != null) {
        if (fc_ == null) {
          Fc = new global::K8S.Io.Api.Core.V1.FCVolumeSource();
        }
        Fc.MergeFrom(other.Fc);
      }
      if (other.azureFile_ != null) {
        if (azureFile_ == null) {
          AzureFile = new global::K8S.Io.Api.Core.V1.AzureFileVolumeSource();
        }
        AzureFile.MergeFrom(other.AzureFile);
      }
      if (other.configMap_ != null) {
        if (configMap_ == null) {
          ConfigMap = new global::K8S.Io.Api.Core.V1.ConfigMapVolumeSource();
        }
        ConfigMap.MergeFrom(other.ConfigMap);
      }
      if (other.vsphereVolume_ != null) {
        if (vsphereVolume_ == null) {
          VsphereVolume = new global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource();
        }
        VsphereVolume.MergeFrom(other.VsphereVolume);
      }
      if (other.quobyte_ != null) {
        if (quobyte_ == null) {
          Quobyte = new global::K8S.Io.Api.Core.V1.QuobyteVolumeSource();
        }
        Quobyte.MergeFrom(other.Quobyte);
      }
      if (other.azureDisk_ != null) {
        if (azureDisk_ == null) {
          AzureDisk = new global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource();
        }
        AzureDisk.MergeFrom(other.AzureDisk);
      }
      if (other.photonPersistentDisk_ != null) {
        if (photonPersistentDisk_ == null) {
          PhotonPersistentDisk = new global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource();
        }
        PhotonPersistentDisk.MergeFrom(other.PhotonPersistentDisk);
      }
      if (other.projected_ != null) {
        if (projected_ == null) {
          Projected = new global::K8S.Io.Api.Core.V1.ProjectedVolumeSource();
        }
        Projected.MergeFrom(other.Projected);
      }
      if (other.portworxVolume_ != null) {
        if (portworxVolume_ == null) {
          PortworxVolume = new global::K8S.Io.Api.Core.V1.PortworxVolumeSource();
        }
        PortworxVolume.MergeFrom(other.PortworxVolume);
      }
      if (other.scaleIO_ != null) {
        if (scaleIO_ == null) {
          ScaleIO = new global::K8S.Io.Api.Core.V1.ScaleIOVolumeSource();
        }
        ScaleIO.MergeFrom(other.ScaleIO);
      }
      if (other.storageos_ != null) {
        if (storageos_ == null) {
          Storageos = new global::K8S.Io.Api.Core.V1.StorageOSVolumeSource();
        }
        Storageos.MergeFrom(other.Storageos);
      }
      if (other.csi_ != null) {
        if (csi_ == null) {
          Csi = new global::K8S.Io.Api.Core.V1.CSIVolumeSource();
        }
        Csi.MergeFrom(other.Csi);
      }
      if (other.ephemeral_ != null) {
        if (ephemeral_ == null) {
          Ephemeral = new global::K8S.Io.Api.Core.V1.EphemeralVolumeSource();
        }
        Ephemeral.MergeFrom(other.Ephemeral);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (hostPath_ == null) {
              HostPath = new global::K8S.Io.Api.Core.V1.HostPathVolumeSource();
            }
            input.ReadMessage(HostPath);
            break;
          }
          case 18: {
            if (emptyDir_ == null) {
              EmptyDir = new global::K8S.Io.Api.Core.V1.EmptyDirVolumeSource();
            }
            input.ReadMessage(EmptyDir);
            break;
          }
          case 26: {
            if (gcePersistentDisk_ == null) {
              GcePersistentDisk = new global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource();
            }
            input.ReadMessage(GcePersistentDisk);
            break;
          }
          case 34: {
            if (awsElasticBlockStore_ == null) {
              AwsElasticBlockStore = new global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource();
            }
            input.ReadMessage(AwsElasticBlockStore);
            break;
          }
          case 42: {
            if (gitRepo_ == null) {
              GitRepo = new global::K8S.Io.Api.Core.V1.GitRepoVolumeSource();
            }
            input.ReadMessage(GitRepo);
            break;
          }
          case 50: {
            if (secret_ == null) {
              Secret = new global::K8S.Io.Api.Core.V1.SecretVolumeSource();
            }
            input.ReadMessage(Secret);
            break;
          }
          case 58: {
            if (nfs_ == null) {
              Nfs = new global::K8S.Io.Api.Core.V1.NFSVolumeSource();
            }
            input.ReadMessage(Nfs);
            break;
          }
          case 66: {
            if (iscsi_ == null) {
              Iscsi = new global::K8S.Io.Api.Core.V1.ISCSIVolumeSource();
            }
            input.ReadMessage(Iscsi);
            break;
          }
          case 74: {
            if (glusterfs_ == null) {
              Glusterfs = new global::K8S.Io.Api.Core.V1.GlusterfsVolumeSource();
            }
            input.ReadMessage(Glusterfs);
            break;
          }
          case 82: {
            if (persistentVolumeClaim_ == null) {
              PersistentVolumeClaim = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimVolumeSource();
            }
            input.ReadMessage(PersistentVolumeClaim);
            break;
          }
          case 90: {
            if (rbd_ == null) {
              Rbd = new global::K8S.Io.Api.Core.V1.RBDVolumeSource();
            }
            input.ReadMessage(Rbd);
            break;
          }
          case 98: {
            if (flexVolume_ == null) {
              FlexVolume = new global::K8S.Io.Api.Core.V1.FlexVolumeSource();
            }
            input.ReadMessage(FlexVolume);
            break;
          }
          case 106: {
            if (cinder_ == null) {
              Cinder = new global::K8S.Io.Api.Core.V1.CinderVolumeSource();
            }
            input.ReadMessage(Cinder);
            break;
          }
          case 114: {
            if (cephfs_ == null) {
              Cephfs = new global::K8S.Io.Api.Core.V1.CephFSVolumeSource();
            }
            input.ReadMessage(Cephfs);
            break;
          }
          case 122: {
            if (flocker_ == null) {
              Flocker = new global::K8S.Io.Api.Core.V1.FlockerVolumeSource();
            }
            input.ReadMessage(Flocker);
            break;
          }
          case 130: {
            if (downwardAPI_ == null) {
              DownwardAPI = new global::K8S.Io.Api.Core.V1.DownwardAPIVolumeSource();
            }
            input.ReadMessage(DownwardAPI);
            break;
          }
          case 138: {
            if (fc_ == null) {
              Fc = new global::K8S.Io.Api.Core.V1.FCVolumeSource();
            }
            input.ReadMessage(Fc);
            break;
          }
          case 146: {
            if (azureFile_ == null) {
              AzureFile = new global::K8S.Io.Api.Core.V1.AzureFileVolumeSource();
            }
            input.ReadMessage(AzureFile);
            break;
          }
          case 154: {
            if (configMap_ == null) {
              ConfigMap = new global::K8S.Io.Api.Core.V1.ConfigMapVolumeSource();
            }
            input.ReadMessage(ConfigMap);
            break;
          }
          case 162: {
            if (vsphereVolume_ == null) {
              VsphereVolume = new global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource();
            }
            input.ReadMessage(VsphereVolume);
            break;
          }
          case 170: {
            if (quobyte_ == null) {
              Quobyte = new global::K8S.Io.Api.Core.V1.QuobyteVolumeSource();
            }
            input.ReadMessage(Quobyte);
            break;
          }
          case 178: {
            if (azureDisk_ == null) {
              AzureDisk = new global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource();
            }
            input.ReadMessage(AzureDisk);
            break;
          }
          case 186: {
            if (photonPersistentDisk_ == null) {
              PhotonPersistentDisk = new global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource();
            }
            input.ReadMessage(PhotonPersistentDisk);
            break;
          }
          case 194: {
            if (portworxVolume_ == null) {
              PortworxVolume = new global::K8S.Io.Api.Core.V1.PortworxVolumeSource();
            }
            input.ReadMessage(PortworxVolume);
            break;
          }
          case 202: {
            if (scaleIO_ == null) {
              ScaleIO = new global::K8S.Io.Api.Core.V1.ScaleIOVolumeSource();
            }
            input.ReadMessage(ScaleIO);
            break;
          }
          case 210: {
            if (projected_ == null) {
              Projected = new global::K8S.Io.Api.Core.V1.ProjectedVolumeSource();
            }
            input.ReadMessage(Projected);
            break;
          }
          case 218: {
            if (storageos_ == null) {
              Storageos = new global::K8S.Io.Api.Core.V1.StorageOSVolumeSource();
            }
            input.ReadMessage(Storageos);
            break;
          }
          case 226: {
            if (csi_ == null) {
              Csi = new global::K8S.Io.Api.Core.V1.CSIVolumeSource();
            }
            input.ReadMessage(Csi);
            break;
          }
          case 234: {
            if (ephemeral_ == null) {
              Ephemeral = new global::K8S.Io.Api.Core.V1.EphemeralVolumeSource();
            }
            input.ReadMessage(Ephemeral);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (hostPath_ == null) {
              HostPath = new global::K8S.Io.Api.Core.V1.HostPathVolumeSource();
            }
            input.ReadMessage(HostPath);
            break;
          }
          case 18: {
            if (emptyDir_ == null) {
              EmptyDir = new global::K8S.Io.Api.Core.V1.EmptyDirVolumeSource();
            }
            input.ReadMessage(EmptyDir);
            break;
          }
          case 26: {
            if (gcePersistentDisk_ == null) {
              GcePersistentDisk = new global::K8S.Io.Api.Core.V1.GCEPersistentDiskVolumeSource();
            }
            input.ReadMessage(GcePersistentDisk);
            break;
          }
          case 34: {
            if (awsElasticBlockStore_ == null) {
              AwsElasticBlockStore = new global::K8S.Io.Api.Core.V1.AWSElasticBlockStoreVolumeSource();
            }
            input.ReadMessage(AwsElasticBlockStore);
            break;
          }
          case 42: {
            if (gitRepo_ == null) {
              GitRepo = new global::K8S.Io.Api.Core.V1.GitRepoVolumeSource();
            }
            input.ReadMessage(GitRepo);
            break;
          }
          case 50: {
            if (secret_ == null) {
              Secret = new global::K8S.Io.Api.Core.V1.SecretVolumeSource();
            }
            input.ReadMessage(Secret);
            break;
          }
          case 58: {
            if (nfs_ == null) {
              Nfs = new global::K8S.Io.Api.Core.V1.NFSVolumeSource();
            }
            input.ReadMessage(Nfs);
            break;
          }
          case 66: {
            if (iscsi_ == null) {
              Iscsi = new global::K8S.Io.Api.Core.V1.ISCSIVolumeSource();
            }
            input.ReadMessage(Iscsi);
            break;
          }
          case 74: {
            if (glusterfs_ == null) {
              Glusterfs = new global::K8S.Io.Api.Core.V1.GlusterfsVolumeSource();
            }
            input.ReadMessage(Glusterfs);
            break;
          }
          case 82: {
            if (persistentVolumeClaim_ == null) {
              PersistentVolumeClaim = new global::K8S.Io.Api.Core.V1.PersistentVolumeClaimVolumeSource();
            }
            input.ReadMessage(PersistentVolumeClaim);
            break;
          }
          case 90: {
            if (rbd_ == null) {
              Rbd = new global::K8S.Io.Api.Core.V1.RBDVolumeSource();
            }
            input.ReadMessage(Rbd);
            break;
          }
          case 98: {
            if (flexVolume_ == null) {
              FlexVolume = new global::K8S.Io.Api.Core.V1.FlexVolumeSource();
            }
            input.ReadMessage(FlexVolume);
            break;
          }
          case 106: {
            if (cinder_ == null) {
              Cinder = new global::K8S.Io.Api.Core.V1.CinderVolumeSource();
            }
            input.ReadMessage(Cinder);
            break;
          }
          case 114: {
            if (cephfs_ == null) {
              Cephfs = new global::K8S.Io.Api.Core.V1.CephFSVolumeSource();
            }
            input.ReadMessage(Cephfs);
            break;
          }
          case 122: {
            if (flocker_ == null) {
              Flocker = new global::K8S.Io.Api.Core.V1.FlockerVolumeSource();
            }
            input.ReadMessage(Flocker);
            break;
          }
          case 130: {
            if (downwardAPI_ == null) {
              DownwardAPI = new global::K8S.Io.Api.Core.V1.DownwardAPIVolumeSource();
            }
            input.ReadMessage(DownwardAPI);
            break;
          }
          case 138: {
            if (fc_ == null) {
              Fc = new global::K8S.Io.Api.Core.V1.FCVolumeSource();
            }
            input.ReadMessage(Fc);
            break;
          }
          case 146: {
            if (azureFile_ == null) {
              AzureFile = new global::K8S.Io.Api.Core.V1.AzureFileVolumeSource();
            }
            input.ReadMessage(AzureFile);
            break;
          }
          case 154: {
            if (configMap_ == null) {
              ConfigMap = new global::K8S.Io.Api.Core.V1.ConfigMapVolumeSource();
            }
            input.ReadMessage(ConfigMap);
            break;
          }
          case 162: {
            if (vsphereVolume_ == null) {
              VsphereVolume = new global::K8S.Io.Api.Core.V1.VsphereVirtualDiskVolumeSource();
            }
            input.ReadMessage(VsphereVolume);
            break;
          }
          case 170: {
            if (quobyte_ == null) {
              Quobyte = new global::K8S.Io.Api.Core.V1.QuobyteVolumeSource();
            }
            input.ReadMessage(Quobyte);
            break;
          }
          case 178: {
            if (azureDisk_ == null) {
              AzureDisk = new global::K8S.Io.Api.Core.V1.AzureDiskVolumeSource();
            }
            input.ReadMessage(AzureDisk);
            break;
          }
          case 186: {
            if (photonPersistentDisk_ == null) {
              PhotonPersistentDisk = new global::K8S.Io.Api.Core.V1.PhotonPersistentDiskVolumeSource();
            }
            input.ReadMessage(PhotonPersistentDisk);
            break;
          }
          case 194: {
            if (portworxVolume_ == null) {
              PortworxVolume = new global::K8S.Io.Api.Core.V1.PortworxVolumeSource();
            }
            input.ReadMessage(PortworxVolume);
            break;
          }
          case 202: {
            if (scaleIO_ == null) {
              ScaleIO = new global::K8S.Io.Api.Core.V1.ScaleIOVolumeSource();
            }
            input.ReadMessage(ScaleIO);
            break;
          }
          case 210: {
            if (projected_ == null) {
              Projected = new global::K8S.Io.Api.Core.V1.ProjectedVolumeSource();
            }
            input.ReadMessage(Projected);
            break;
          }
          case 218: {
            if (storageos_ == null) {
              Storageos = new global::K8S.Io.Api.Core.V1.StorageOSVolumeSource();
            }
            input.ReadMessage(Storageos);
            break;
          }
          case 226: {
            if (csi_ == null) {
              Csi = new global::K8S.Io.Api.Core.V1.CSIVolumeSource();
            }
            input.ReadMessage(Csi);
            break;
          }
          case 234: {
            if (ephemeral_ == null) {
              Ephemeral = new global::K8S.Io.Api.Core.V1.EphemeralVolumeSource();
            }
            input.ReadMessage(Ephemeral);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Represents a vSphere volume resource.
  /// </summary>
  public sealed partial class VsphereVirtualDiskVolumeSource : pb::IMessage<VsphereVirtualDiskVolumeSource>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<VsphereVirtualDiskVolumeSource> _parser = new pb::MessageParser<VsphereVirtualDiskVolumeSource>(() => new VsphereVirtualDiskVolumeSource());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<VsphereVirtualDiskVolumeSource> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[204]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VsphereVirtualDiskVolumeSource() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VsphereVirtualDiskVolumeSource(VsphereVirtualDiskVolumeSource other) : this() {
      volumePath_ = other.volumePath_;
      fsType_ = other.fsType_;
      storagePolicyName_ = other.storagePolicyName_;
      storagePolicyID_ = other.storagePolicyID_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public VsphereVirtualDiskVolumeSource Clone() {
      return new VsphereVirtualDiskVolumeSource(this);
    }

    /// <summary>Field number for the "volumePath" field.</summary>
    public const int VolumePathFieldNumber = 1;
    private readonly static string VolumePathDefaultValue = "";

    private string volumePath_;
    /// <summary>
    /// Path that identifies vSphere volume vmdk
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string VolumePath {
      get { return volumePath_ ?? VolumePathDefaultValue; }
      set {
        volumePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "volumePath" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasVolumePath {
      get { return volumePath_ != null; }
    }
    /// <summary>Clears the value of the "volumePath" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearVolumePath() {
      volumePath_ = null;
    }

    /// <summary>Field number for the "fsType" field.</summary>
    public const int FsTypeFieldNumber = 2;
    private readonly static string FsTypeDefaultValue = "";

    private string fsType_;
    /// <summary>
    /// Filesystem type to mount.
    /// Must be a filesystem type supported by the host operating system.
    /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string FsType {
      get { return fsType_ ?? FsTypeDefaultValue; }
      set {
        fsType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "fsType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasFsType {
      get { return fsType_ != null; }
    }
    /// <summary>Clears the value of the "fsType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearFsType() {
      fsType_ = null;
    }

    /// <summary>Field number for the "storagePolicyName" field.</summary>
    public const int StoragePolicyNameFieldNumber = 3;
    private readonly static string StoragePolicyNameDefaultValue = "";

    private string storagePolicyName_;
    /// <summary>
    /// Storage Policy Based Management (SPBM) profile name.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StoragePolicyName {
      get { return storagePolicyName_ ?? StoragePolicyNameDefaultValue; }
      set {
        storagePolicyName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "storagePolicyName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStoragePolicyName {
      get { return storagePolicyName_ != null; }
    }
    /// <summary>Clears the value of the "storagePolicyName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStoragePolicyName() {
      storagePolicyName_ = null;
    }

    /// <summary>Field number for the "storagePolicyID" field.</summary>
    public const int StoragePolicyIDFieldNumber = 4;
    private readonly static string StoragePolicyIDDefaultValue = "";

    private string storagePolicyID_;
    /// <summary>
    /// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StoragePolicyID {
      get { return storagePolicyID_ ?? StoragePolicyIDDefaultValue; }
      set {
        storagePolicyID_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "storagePolicyID" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasStoragePolicyID {
      get { return storagePolicyID_ != null; }
    }
    /// <summary>Clears the value of the "storagePolicyID" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStoragePolicyID() {
      storagePolicyID_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as VsphereVirtualDiskVolumeSource);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(VsphereVirtualDiskVolumeSource other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (VolumePath != other.VolumePath) return false;
      if (FsType != other.FsType) return false;
      if (StoragePolicyName != other.StoragePolicyName) return false;
      if (StoragePolicyID != other.StoragePolicyID) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasVolumePath) hash ^= VolumePath.GetHashCode();
      if (HasFsType) hash ^= FsType.GetHashCode();
      if (HasStoragePolicyName) hash ^= StoragePolicyName.GetHashCode();
      if (HasStoragePolicyID) hash ^= StoragePolicyID.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasVolumePath) {
        output.WriteRawTag(10);
        output.WriteString(VolumePath);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasStoragePolicyName) {
        output.WriteRawTag(26);
        output.WriteString(StoragePolicyName);
      }
      if (HasStoragePolicyID) {
        output.WriteRawTag(34);
        output.WriteString(StoragePolicyID);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasVolumePath) {
        output.WriteRawTag(10);
        output.WriteString(VolumePath);
      }
      if (HasFsType) {
        output.WriteRawTag(18);
        output.WriteString(FsType);
      }
      if (HasStoragePolicyName) {
        output.WriteRawTag(26);
        output.WriteString(StoragePolicyName);
      }
      if (HasStoragePolicyID) {
        output.WriteRawTag(34);
        output.WriteString(StoragePolicyID);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasVolumePath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VolumePath);
      }
      if (HasFsType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FsType);
      }
      if (HasStoragePolicyName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StoragePolicyName);
      }
      if (HasStoragePolicyID) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StoragePolicyID);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(VsphereVirtualDiskVolumeSource other) {
      if (other == null) {
        return;
      }
      if (other.HasVolumePath) {
        VolumePath = other.VolumePath;
      }
      if (other.HasFsType) {
        FsType = other.FsType;
      }
      if (other.HasStoragePolicyName) {
        StoragePolicyName = other.StoragePolicyName;
      }
      if (other.HasStoragePolicyID) {
        StoragePolicyID = other.StoragePolicyID;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            VolumePath = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 26: {
            StoragePolicyName = input.ReadString();
            break;
          }
          case 34: {
            StoragePolicyID = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            VolumePath = input.ReadString();
            break;
          }
          case 18: {
            FsType = input.ReadString();
            break;
          }
          case 26: {
            StoragePolicyName = input.ReadString();
            break;
          }
          case 34: {
            StoragePolicyID = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
  /// </summary>
  public sealed partial class WeightedPodAffinityTerm : pb::IMessage<WeightedPodAffinityTerm>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WeightedPodAffinityTerm> _parser = new pb::MessageParser<WeightedPodAffinityTerm>(() => new WeightedPodAffinityTerm());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<WeightedPodAffinityTerm> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[205]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WeightedPodAffinityTerm() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WeightedPodAffinityTerm(WeightedPodAffinityTerm other) : this() {
      _hasBits0 = other._hasBits0;
      weight_ = other.weight_;
      podAffinityTerm_ = other.podAffinityTerm_ != null ? other.podAffinityTerm_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WeightedPodAffinityTerm Clone() {
      return new WeightedPodAffinityTerm(this);
    }

    /// <summary>Field number for the "weight" field.</summary>
    public const int WeightFieldNumber = 1;
    private readonly static int WeightDefaultValue = 0;

    private int weight_;
    /// <summary>
    /// weight associated with matching the corresponding podAffinityTerm,
    /// in the range 1-100.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Weight {
      get { if ((_hasBits0 & 1) != 0) { return weight_; } else { return WeightDefaultValue; } }
      set {
        _hasBits0 |= 1;
        weight_ = value;
      }
    }
    /// <summary>Gets whether the "weight" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasWeight {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "weight" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearWeight() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "podAffinityTerm" field.</summary>
    public const int PodAffinityTermFieldNumber = 2;
    private global::K8S.Io.Api.Core.V1.PodAffinityTerm podAffinityTerm_;
    /// <summary>
    /// Required. A pod affinity term, associated with the corresponding weight.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.PodAffinityTerm PodAffinityTerm {
      get { return podAffinityTerm_; }
      set {
        podAffinityTerm_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as WeightedPodAffinityTerm);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(WeightedPodAffinityTerm other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Weight != other.Weight) return false;
      if (!object.Equals(PodAffinityTerm, other.PodAffinityTerm)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasWeight) hash ^= Weight.GetHashCode();
      if (podAffinityTerm_ != null) hash ^= PodAffinityTerm.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasWeight) {
        output.WriteRawTag(8);
        output.WriteInt32(Weight);
      }
      if (podAffinityTerm_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PodAffinityTerm);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasWeight) {
        output.WriteRawTag(8);
        output.WriteInt32(Weight);
      }
      if (podAffinityTerm_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(PodAffinityTerm);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasWeight) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Weight);
      }
      if (podAffinityTerm_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PodAffinityTerm);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(WeightedPodAffinityTerm other) {
      if (other == null) {
        return;
      }
      if (other.HasWeight) {
        Weight = other.Weight;
      }
      if (other.podAffinityTerm_ != null) {
        if (podAffinityTerm_ == null) {
          PodAffinityTerm = new global::K8S.Io.Api.Core.V1.PodAffinityTerm();
        }
        PodAffinityTerm.MergeFrom(other.PodAffinityTerm);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Weight = input.ReadInt32();
            break;
          }
          case 18: {
            if (podAffinityTerm_ == null) {
              PodAffinityTerm = new global::K8S.Io.Api.Core.V1.PodAffinityTerm();
            }
            input.ReadMessage(PodAffinityTerm);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Weight = input.ReadInt32();
            break;
          }
          case 18: {
            if (podAffinityTerm_ == null) {
              PodAffinityTerm = new global::K8S.Io.Api.Core.V1.PodAffinityTerm();
            }
            input.ReadMessage(PodAffinityTerm);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// WindowsSecurityContextOptions contain Windows-specific options and credentials.
  /// </summary>
  public sealed partial class WindowsSecurityContextOptions : pb::IMessage<WindowsSecurityContextOptions>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<WindowsSecurityContextOptions> _parser = new pb::MessageParser<WindowsSecurityContextOptions>(() => new WindowsSecurityContextOptions());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<WindowsSecurityContextOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor.MessageTypes[206]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WindowsSecurityContextOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WindowsSecurityContextOptions(WindowsSecurityContextOptions other) : this() {
      _hasBits0 = other._hasBits0;
      gmsaCredentialSpecName_ = other.gmsaCredentialSpecName_;
      gmsaCredentialSpec_ = other.gmsaCredentialSpec_;
      runAsUserName_ = other.runAsUserName_;
      hostProcess_ = other.hostProcess_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public WindowsSecurityContextOptions Clone() {
      return new WindowsSecurityContextOptions(this);
    }

    /// <summary>Field number for the "gmsaCredentialSpecName" field.</summary>
    public const int GmsaCredentialSpecNameFieldNumber = 1;
    private readonly static string GmsaCredentialSpecNameDefaultValue = "";

    private string gmsaCredentialSpecName_;
    /// <summary>
    /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string GmsaCredentialSpecName {
      get { return gmsaCredentialSpecName_ ?? GmsaCredentialSpecNameDefaultValue; }
      set {
        gmsaCredentialSpecName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gmsaCredentialSpecName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGmsaCredentialSpecName {
      get { return gmsaCredentialSpecName_ != null; }
    }
    /// <summary>Clears the value of the "gmsaCredentialSpecName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGmsaCredentialSpecName() {
      gmsaCredentialSpecName_ = null;
    }

    /// <summary>Field number for the "gmsaCredentialSpec" field.</summary>
    public const int GmsaCredentialSpecFieldNumber = 2;
    private readonly static string GmsaCredentialSpecDefaultValue = "";

    private string gmsaCredentialSpec_;
    /// <summary>
    /// GMSACredentialSpec is where the GMSA admission webhook
    /// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
    /// GMSA credential spec named by the GMSACredentialSpecName field.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string GmsaCredentialSpec {
      get { return gmsaCredentialSpec_ ?? GmsaCredentialSpecDefaultValue; }
      set {
        gmsaCredentialSpec_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "gmsaCredentialSpec" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasGmsaCredentialSpec {
      get { return gmsaCredentialSpec_ != null; }
    }
    /// <summary>Clears the value of the "gmsaCredentialSpec" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearGmsaCredentialSpec() {
      gmsaCredentialSpec_ = null;
    }

    /// <summary>Field number for the "runAsUserName" field.</summary>
    public const int RunAsUserNameFieldNumber = 3;
    private readonly static string RunAsUserNameDefaultValue = "";

    private string runAsUserName_;
    /// <summary>
    /// The UserName in Windows to run the entrypoint of the container process.
    /// Defaults to the user specified in image metadata if unspecified.
    /// May also be set in PodSecurityContext. If set in both SecurityContext and
    /// PodSecurityContext, the value specified in SecurityContext takes precedence.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string RunAsUserName {
      get { return runAsUserName_ ?? RunAsUserNameDefaultValue; }
      set {
        runAsUserName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "runAsUserName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasRunAsUserName {
      get { return runAsUserName_ != null; }
    }
    /// <summary>Clears the value of the "runAsUserName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearRunAsUserName() {
      runAsUserName_ = null;
    }

    /// <summary>Field number for the "hostProcess" field.</summary>
    public const int HostProcessFieldNumber = 4;
    private readonly static bool HostProcessDefaultValue = false;

    private bool hostProcess_;
    /// <summary>
    /// HostProcess determines if a container should be run as a 'Host Process' container.
    /// This field is alpha-level and will only be honored by components that enable the
    /// WindowsHostProcessContainers feature flag. Setting this field without the feature
    /// flag will result in errors when validating the Pod. All of a Pod's containers must
    /// have the same effective HostProcess value (it is not allowed to have a mix of HostProcess
    /// containers and non-HostProcess containers).  In addition, if HostProcess is true
    /// then HostNetwork must also be set to true.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HostProcess {
      get { if ((_hasBits0 & 1) != 0) { return hostProcess_; } else { return HostProcessDefaultValue; } }
      set {
        _hasBits0 |= 1;
        hostProcess_ = value;
      }
    }
    /// <summary>Gets whether the "hostProcess" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHostProcess {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "hostProcess" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHostProcess() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as WindowsSecurityContextOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(WindowsSecurityContextOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (GmsaCredentialSpecName != other.GmsaCredentialSpecName) return false;
      if (GmsaCredentialSpec != other.GmsaCredentialSpec) return false;
      if (RunAsUserName != other.RunAsUserName) return false;
      if (HostProcess != other.HostProcess) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasGmsaCredentialSpecName) hash ^= GmsaCredentialSpecName.GetHashCode();
      if (HasGmsaCredentialSpec) hash ^= GmsaCredentialSpec.GetHashCode();
      if (HasRunAsUserName) hash ^= RunAsUserName.GetHashCode();
      if (HasHostProcess) hash ^= HostProcess.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasGmsaCredentialSpecName) {
        output.WriteRawTag(10);
        output.WriteString(GmsaCredentialSpecName);
      }
      if (HasGmsaCredentialSpec) {
        output.WriteRawTag(18);
        output.WriteString(GmsaCredentialSpec);
      }
      if (HasRunAsUserName) {
        output.WriteRawTag(26);
        output.WriteString(RunAsUserName);
      }
      if (HasHostProcess) {
        output.WriteRawTag(32);
        output.WriteBool(HostProcess);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasGmsaCredentialSpecName) {
        output.WriteRawTag(10);
        output.WriteString(GmsaCredentialSpecName);
      }
      if (HasGmsaCredentialSpec) {
        output.WriteRawTag(18);
        output.WriteString(GmsaCredentialSpec);
      }
      if (HasRunAsUserName) {
        output.WriteRawTag(26);
        output.WriteString(RunAsUserName);
      }
      if (HasHostProcess) {
        output.WriteRawTag(32);
        output.WriteBool(HostProcess);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasGmsaCredentialSpecName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GmsaCredentialSpecName);
      }
      if (HasGmsaCredentialSpec) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(GmsaCredentialSpec);
      }
      if (HasRunAsUserName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(RunAsUserName);
      }
      if (HasHostProcess) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(WindowsSecurityContextOptions other) {
      if (other == null) {
        return;
      }
      if (other.HasGmsaCredentialSpecName) {
        GmsaCredentialSpecName = other.GmsaCredentialSpecName;
      }
      if (other.HasGmsaCredentialSpec) {
        GmsaCredentialSpec = other.GmsaCredentialSpec;
      }
      if (other.HasRunAsUserName) {
        RunAsUserName = other.RunAsUserName;
      }
      if (other.HasHostProcess) {
        HostProcess = other.HostProcess;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            GmsaCredentialSpecName = input.ReadString();
            break;
          }
          case 18: {
            GmsaCredentialSpec = input.ReadString();
            break;
          }
          case 26: {
            RunAsUserName = input.ReadString();
            break;
          }
          case 32: {
            HostProcess = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            GmsaCredentialSpecName = input.ReadString();
            break;
          }
          case 18: {
            GmsaCredentialSpec = input.ReadString();
            break;
          }
          case 26: {
            RunAsUserName = input.ReadString();
            break;
          }
          case 32: {
            HostProcess = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
