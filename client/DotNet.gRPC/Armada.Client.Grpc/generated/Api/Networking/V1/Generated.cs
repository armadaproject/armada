// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: k8s.io/api/networking/v1/generated.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace K8S.Io.Api.Networking.V1 {

  /// <summary>Holder for reflection information generated from k8s.io/api/networking/v1/generated.proto</summary>
  public static partial class GeneratedReflection {

    #region Descriptor
    /// <summary>File descriptor for k8s.io/api/networking/v1/generated.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static GeneratedReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CihrOHMuaW8vYXBpL25ldHdvcmtpbmcvdjEvZ2VuZXJhdGVkLnByb3RvEhhr",
            "OHMuaW8uYXBpLm5ldHdvcmtpbmcudjEaIms4cy5pby9hcGkvY29yZS92MS9n",
            "ZW5lcmF0ZWQucHJvdG8aNGs4cy5pby9hcGltYWNoaW5lcnkvcGtnL2FwaXMv",
            "bWV0YS92MS9nZW5lcmF0ZWQucHJvdG8aL2s4cy5pby9hcGltYWNoaW5lcnkv",
            "cGtnL3J1bnRpbWUvZ2VuZXJhdGVkLnByb3RvGjZrOHMuaW8vYXBpbWFjaGlu",
            "ZXJ5L3BrZy9ydW50aW1lL3NjaGVtYS9nZW5lcmF0ZWQucHJvdG8aM2s4cy5p",
            "by9hcGltYWNoaW5lcnkvcGtnL3V0aWwvaW50c3RyL2dlbmVyYXRlZC5wcm90",
            "byJsCg9IVFRQSW5ncmVzc1BhdGgSDAoEcGF0aBgBIAEoCRIQCghwYXRoVHlw",
            "ZRgDIAEoCRI5CgdiYWNrZW5kGAIgASgLMiguazhzLmlvLmFwaS5uZXR3b3Jr",
            "aW5nLnYxLkluZ3Jlc3NCYWNrZW5kIlAKFEhUVFBJbmdyZXNzUnVsZVZhbHVl",
            "EjgKBXBhdGhzGAEgAygLMikuazhzLmlvLmFwaS5uZXR3b3JraW5nLnYxLkhU",
            "VFBJbmdyZXNzUGF0aCInCgdJUEJsb2NrEgwKBGNpZHIYASABKAkSDgoGZXhj",
            "ZXB0GAIgAygJIrsBCgdJbmdyZXNzEkIKCG1ldGFkYXRhGAEgASgLMjAuazhz",
            "LmlvLmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGES",
            "MwoEc3BlYxgCIAEoCzIlLms4cy5pby5hcGkubmV0d29ya2luZy52MS5Jbmdy",
            "ZXNzU3BlYxI3CgZzdGF0dXMYAyABKAsyJy5rOHMuaW8uYXBpLm5ldHdvcmtp",
            "bmcudjEuSW5ncmVzc1N0YXR1cyKTAQoOSW5ncmVzc0JhY2tlbmQSQAoHc2Vy",
            "dmljZRgEIAEoCzIvLms4cy5pby5hcGkubmV0d29ya2luZy52MS5JbmdyZXNz",
            "U2VydmljZUJhY2tlbmQSPwoIcmVzb3VyY2UYAyABKAsyLS5rOHMuaW8uYXBp",
            "LmNvcmUudjEuVHlwZWRMb2NhbE9iamVjdFJlZmVyZW5jZSKMAQoMSW5ncmVz",
            "c0NsYXNzEkIKCG1ldGFkYXRhGAEgASgLMjAuazhzLmlvLmFwaW1hY2hpbmVy",
            "eS5wa2cuYXBpcy5tZXRhLnYxLk9iamVjdE1ldGESOAoEc3BlYxgCIAEoCzIq",
            "Lms4cy5pby5hcGkubmV0d29ya2luZy52MS5JbmdyZXNzQ2xhc3NTcGVjIosB",
            "ChBJbmdyZXNzQ2xhc3NMaXN0EkAKCG1ldGFkYXRhGAEgASgLMi4uazhzLmlv",
            "LmFwaW1hY2hpbmVyeS5wa2cuYXBpcy5tZXRhLnYxLkxpc3RNZXRhEjUKBWl0",
            "ZW1zGAIgAygLMiYuazhzLmlvLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3ND",
            "bGFzcyJxCh9JbmdyZXNzQ2xhc3NQYXJhbWV0ZXJzUmVmZXJlbmNlEhAKCGFQ",
            "SUdyb3VwGAEgASgJEgwKBGtpbmQYAiABKAkSDAoEbmFtZRgDIAEoCRINCgVz",
            "Y29wZRgEIAEoCRIRCgluYW1lc3BhY2UYBSABKAkidQoQSW5ncmVzc0NsYXNz",
            "U3BlYxISCgpjb250cm9sbGVyGAEgASgJEk0KCnBhcmFtZXRlcnMYAiABKAsy",
            "OS5rOHMuaW8uYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0NsYXNzUGFyYW1l",
            "dGVyc1JlZmVyZW5jZSKBAQoLSW5ncmVzc0xpc3QSQAoIbWV0YWRhdGEYASAB",
            "KAsyLi5rOHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGlz",
            "dE1ldGESMAoFaXRlbXMYAiADKAsyIS5rOHMuaW8uYXBpLm5ldHdvcmtpbmcu",
            "djEuSW5ncmVzcyJhCgtJbmdyZXNzUnVsZRIMCgRob3N0GAEgASgJEkQKEGlu",
            "Z3Jlc3NSdWxlVmFsdWUYAiABKAsyKi5rOHMuaW8uYXBpLm5ldHdvcmtpbmcu",
            "djEuSW5ncmVzc1J1bGVWYWx1ZSJQChBJbmdyZXNzUnVsZVZhbHVlEjwKBGh0",
            "dHAYASABKAsyLi5rOHMuaW8uYXBpLm5ldHdvcmtpbmcudjEuSFRUUEluZ3Jl",
            "c3NSdWxlVmFsdWUiYQoVSW5ncmVzc1NlcnZpY2VCYWNrZW5kEgwKBG5hbWUY",
            "ASABKAkSOgoEcG9ydBgCIAEoCzIsLms4cy5pby5hcGkubmV0d29ya2luZy52",
            "MS5TZXJ2aWNlQmFja2VuZFBvcnQi0gEKC0luZ3Jlc3NTcGVjEhgKEGluZ3Jl",
            "c3NDbGFzc05hbWUYBCABKAkSQAoOZGVmYXVsdEJhY2tlbmQYASABKAsyKC5r",
            "OHMuaW8uYXBpLm5ldHdvcmtpbmcudjEuSW5ncmVzc0JhY2tlbmQSMQoDdGxz",
            "GAIgAygLMiQuazhzLmlvLmFwaS5uZXR3b3JraW5nLnYxLkluZ3Jlc3NUTFMS",
            "NAoFcnVsZXMYAyADKAsyJS5rOHMuaW8uYXBpLm5ldHdvcmtpbmcudjEuSW5n",
            "cmVzc1J1bGUiTQoNSW5ncmVzc1N0YXR1cxI8Cgxsb2FkQmFsYW5jZXIYASAB",
            "KAsyJi5rOHMuaW8uYXBpLmNvcmUudjEuTG9hZEJhbGFuY2VyU3RhdHVzIi8K",
            "CkluZ3Jlc3NUTFMSDQoFaG9zdHMYASADKAkSEgoKc2VjcmV0TmFtZRgCIAEo",
            "CSKOAQoNTmV0d29ya1BvbGljeRJCCghtZXRhZGF0YRgBIAEoCzIwLms4cy5p",
            "by5hcGltYWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5PYmplY3RNZXRhEjkK",
            "BHNwZWMYAiABKAsyKy5rOHMuaW8uYXBpLm5ldHdvcmtpbmcudjEuTmV0d29y",
            "a1BvbGljeVNwZWMijgEKF05ldHdvcmtQb2xpY3lFZ3Jlc3NSdWxlEjoKBXBv",
            "cnRzGAEgAygLMisuazhzLmlvLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQ",
            "b2xpY3lQb3J0EjcKAnRvGAIgAygLMisuazhzLmlvLmFwaS5uZXR3b3JraW5n",
            "LnYxLk5ldHdvcmtQb2xpY3lQZWVyIpEBChhOZXR3b3JrUG9saWN5SW5ncmVz",
            "c1J1bGUSOgoFcG9ydHMYASADKAsyKy5rOHMuaW8uYXBpLm5ldHdvcmtpbmcu",
            "djEuTmV0d29ya1BvbGljeVBvcnQSOQoEZnJvbRgCIAMoCzIrLms4cy5pby5h",
            "cGkubmV0d29ya2luZy52MS5OZXR3b3JrUG9saWN5UGVlciKNAQoRTmV0d29y",
            "a1BvbGljeUxpc3QSQAoIbWV0YWRhdGEYASABKAsyLi5rOHMuaW8uYXBpbWFj",
            "aGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGlzdE1ldGESNgoFaXRlbXMYAiAD",
            "KAsyJy5rOHMuaW8uYXBpLm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeSLh",
            "AQoRTmV0d29ya1BvbGljeVBlZXISSAoLcG9kU2VsZWN0b3IYASABKAsyMy5r",
            "OHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGFiZWxTZWxl",
            "Y3RvchJOChFuYW1lc3BhY2VTZWxlY3RvchgCIAEoCzIzLms4cy5pby5hcGlt",
            "YWNoaW5lcnkucGtnLmFwaXMubWV0YS52MS5MYWJlbFNlbGVjdG9yEjIKB2lw",
            "QmxvY2sYAyABKAsyIS5rOHMuaW8uYXBpLm5ldHdvcmtpbmcudjEuSVBCbG9j",
            "ayJ2ChFOZXR3b3JrUG9saWN5UG9ydBIQCghwcm90b2NvbBgBIAEoCRI+CgRw",
            "b3J0GAIgASgLMjAuazhzLmlvLmFwaW1hY2hpbmVyeS5wa2cudXRpbC5pbnRz",
            "dHIuSW50T3JTdHJpbmcSDwoHZW5kUG9ydBgDIAEoBSL6AQoRTmV0d29ya1Bv",
            "bGljeVNwZWMSSAoLcG9kU2VsZWN0b3IYASABKAsyMy5rOHMuaW8uYXBpbWFj",
            "aGluZXJ5LnBrZy5hcGlzLm1ldGEudjEuTGFiZWxTZWxlY3RvchJDCgdpbmdy",
            "ZXNzGAIgAygLMjIuazhzLmlvLmFwaS5uZXR3b3JraW5nLnYxLk5ldHdvcmtQ",
            "b2xpY3lJbmdyZXNzUnVsZRJBCgZlZ3Jlc3MYAyADKAsyMS5rOHMuaW8uYXBp",
            "Lm5ldHdvcmtpbmcudjEuTmV0d29ya1BvbGljeUVncmVzc1J1bGUSEwoLcG9s",
            "aWN5VHlwZXMYBCADKAkiMgoSU2VydmljZUJhY2tlbmRQb3J0EgwKBG5hbWUY",
            "ASABKAkSDgoGbnVtYmVyGAIgASgFQgRaAnYx"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::K8S.Io.Api.Core.V1.GeneratedReflection.Descriptor, global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.GeneratedReflection.Descriptor, global::K8S.Io.Apimachinery.Pkg.Runtime.GeneratedReflection.Descriptor, global::K8S.Io.Apimachinery.Pkg.Runtime.Schema.GeneratedReflection.Descriptor, global::K8S.Io.Apimachinery.Pkg.Util.Intstr.GeneratedReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.HTTPIngressPath), global::K8S.Io.Api.Networking.V1.HTTPIngressPath.Parser, new[]{ "Path", "PathType", "Backend" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.HTTPIngressRuleValue), global::K8S.Io.Api.Networking.V1.HTTPIngressRuleValue.Parser, new[]{ "Paths" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IPBlock), global::K8S.Io.Api.Networking.V1.IPBlock.Parser, new[]{ "Cidr", "Except" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.Ingress), global::K8S.Io.Api.Networking.V1.Ingress.Parser, new[]{ "Metadata", "Spec", "Status" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressBackend), global::K8S.Io.Api.Networking.V1.IngressBackend.Parser, new[]{ "Service", "Resource" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressClass), global::K8S.Io.Api.Networking.V1.IngressClass.Parser, new[]{ "Metadata", "Spec" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressClassList), global::K8S.Io.Api.Networking.V1.IngressClassList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressClassParametersReference), global::K8S.Io.Api.Networking.V1.IngressClassParametersReference.Parser, new[]{ "APIGroup", "Kind", "Name", "Scope", "Namespace" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressClassSpec), global::K8S.Io.Api.Networking.V1.IngressClassSpec.Parser, new[]{ "Controller", "Parameters" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressList), global::K8S.Io.Api.Networking.V1.IngressList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressRule), global::K8S.Io.Api.Networking.V1.IngressRule.Parser, new[]{ "Host", "IngressRuleValue" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressRuleValue), global::K8S.Io.Api.Networking.V1.IngressRuleValue.Parser, new[]{ "Http" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressServiceBackend), global::K8S.Io.Api.Networking.V1.IngressServiceBackend.Parser, new[]{ "Name", "Port" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressSpec), global::K8S.Io.Api.Networking.V1.IngressSpec.Parser, new[]{ "IngressClassName", "DefaultBackend", "Tls", "Rules" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressStatus), global::K8S.Io.Api.Networking.V1.IngressStatus.Parser, new[]{ "LoadBalancer" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.IngressTLS), global::K8S.Io.Api.Networking.V1.IngressTLS.Parser, new[]{ "Hosts", "SecretName" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.NetworkPolicy), global::K8S.Io.Api.Networking.V1.NetworkPolicy.Parser, new[]{ "Metadata", "Spec" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.NetworkPolicyEgressRule), global::K8S.Io.Api.Networking.V1.NetworkPolicyEgressRule.Parser, new[]{ "Ports", "To" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.NetworkPolicyIngressRule), global::K8S.Io.Api.Networking.V1.NetworkPolicyIngressRule.Parser, new[]{ "Ports", "From" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.NetworkPolicyList), global::K8S.Io.Api.Networking.V1.NetworkPolicyList.Parser, new[]{ "Metadata", "Items" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer), global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer.Parser, new[]{ "PodSelector", "NamespaceSelector", "IpBlock" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.NetworkPolicyPort), global::K8S.Io.Api.Networking.V1.NetworkPolicyPort.Parser, new[]{ "Protocol", "Port", "EndPort" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.NetworkPolicySpec), global::K8S.Io.Api.Networking.V1.NetworkPolicySpec.Parser, new[]{ "PodSelector", "Ingress", "Egress", "PolicyTypes" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Api.Networking.V1.ServiceBackendPort), global::K8S.Io.Api.Networking.V1.ServiceBackendPort.Parser, new[]{ "Name", "Number" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// HTTPIngressPath associates a path with a backend. Incoming urls matching the
  /// path are forwarded to the backend.
  /// </summary>
  public sealed partial class HTTPIngressPath : pb::IMessage<HTTPIngressPath>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HTTPIngressPath> _parser = new pb::MessageParser<HTTPIngressPath>(() => new HTTPIngressPath());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HTTPIngressPath> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPIngressPath() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPIngressPath(HTTPIngressPath other) : this() {
      path_ = other.path_;
      pathType_ = other.pathType_;
      backend_ = other.backend_ != null ? other.backend_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPIngressPath Clone() {
      return new HTTPIngressPath(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private readonly static string PathDefaultValue = "";

    private string path_;
    /// <summary>
    /// Path is matched against the path of an incoming request. Currently it can
    /// contain characters disallowed from the conventional "path" part of a URL
    /// as defined by RFC 3986. Paths must begin with a '/' and must be present
    /// when using PathType with value "Exact" or "Prefix".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Path {
      get { return path_ ?? PathDefaultValue; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "path" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPath {
      get { return path_ != null; }
    }
    /// <summary>Clears the value of the "path" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPath() {
      path_ = null;
    }

    /// <summary>Field number for the "pathType" field.</summary>
    public const int PathTypeFieldNumber = 3;
    private readonly static string PathTypeDefaultValue = "";

    private string pathType_;
    /// <summary>
    /// PathType determines the interpretation of the Path matching. PathType can
    /// be one of the following values:
    /// * Exact: Matches the URL path exactly.
    /// * Prefix: Matches based on a URL path prefix split by '/'. Matching is
    ///   done on a path element by element basis. A path element refers is the
    ///   list of labels in the path split by the '/' separator. A request is a
    ///   match for path p if every p is an element-wise prefix of p of the
    ///   request path. Note that if the last element of the path is a substring
    ///   of the last element in request path, it is not a match (e.g. /foo/bar
    ///   matches /foo/bar/baz, but does not match /foo/barbaz).
    /// * ImplementationSpecific: Interpretation of the Path matching is up to
    ///   the IngressClass. Implementations can treat this as a separate PathType
    ///   or treat it identically to Prefix or Exact path types.
    /// Implementations are required to support all path types.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string PathType {
      get { return pathType_ ?? PathTypeDefaultValue; }
      set {
        pathType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "pathType" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasPathType {
      get { return pathType_ != null; }
    }
    /// <summary>Clears the value of the "pathType" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPathType() {
      pathType_ = null;
    }

    /// <summary>Field number for the "backend" field.</summary>
    public const int BackendFieldNumber = 2;
    private global::K8S.Io.Api.Networking.V1.IngressBackend backend_;
    /// <summary>
    /// Backend defines the referenced service endpoint to which the traffic
    /// will be forwarded to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.IngressBackend Backend {
      get { return backend_; }
      set {
        backend_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HTTPIngressPath);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HTTPIngressPath other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      if (PathType != other.PathType) return false;
      if (!object.Equals(Backend, other.Backend)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasPath) hash ^= Path.GetHashCode();
      if (HasPathType) hash ^= PathType.GetHashCode();
      if (backend_ != null) hash ^= Backend.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (backend_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Backend);
      }
      if (HasPathType) {
        output.WriteRawTag(26);
        output.WriteString(PathType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasPath) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
      if (backend_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Backend);
      }
      if (HasPathType) {
        output.WriteRawTag(26);
        output.WriteString(PathType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasPath) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      if (HasPathType) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PathType);
      }
      if (backend_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Backend);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HTTPIngressPath other) {
      if (other == null) {
        return;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.HasPathType) {
        PathType = other.PathType;
      }
      if (other.backend_ != null) {
        if (backend_ == null) {
          Backend = new global::K8S.Io.Api.Networking.V1.IngressBackend();
        }
        Backend.MergeFrom(other.Backend);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            if (backend_ == null) {
              Backend = new global::K8S.Io.Api.Networking.V1.IngressBackend();
            }
            input.ReadMessage(Backend);
            break;
          }
          case 26: {
            PathType = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
          case 18: {
            if (backend_ == null) {
              Backend = new global::K8S.Io.Api.Networking.V1.IngressBackend();
            }
            input.ReadMessage(Backend);
            break;
          }
          case 26: {
            PathType = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// HTTPIngressRuleValue is a list of http selectors pointing to backends.
  /// In the example: http://&lt;host>/&lt;path>?&lt;searchpart> -> backend where
  /// where parts of the url correspond to RFC 3986, this resource will be used
  /// to match against everything after the last '/' and before the first '?'
  /// or '#'.
  /// </summary>
  public sealed partial class HTTPIngressRuleValue : pb::IMessage<HTTPIngressRuleValue>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HTTPIngressRuleValue> _parser = new pb::MessageParser<HTTPIngressRuleValue>(() => new HTTPIngressRuleValue());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HTTPIngressRuleValue> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPIngressRuleValue() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPIngressRuleValue(HTTPIngressRuleValue other) : this() {
      paths_ = other.paths_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HTTPIngressRuleValue Clone() {
      return new HTTPIngressRuleValue(this);
    }

    /// <summary>Field number for the "paths" field.</summary>
    public const int PathsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.HTTPIngressPath> _repeated_paths_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Networking.V1.HTTPIngressPath.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.HTTPIngressPath> paths_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.HTTPIngressPath>();
    /// <summary>
    /// A collection of paths that map requests to backends.
    /// +listType=atomic
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.HTTPIngressPath> Paths {
      get { return paths_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HTTPIngressRuleValue);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HTTPIngressRuleValue other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!paths_.Equals(other.paths_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= paths_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      paths_.WriteTo(output, _repeated_paths_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      paths_.WriteTo(ref output, _repeated_paths_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += paths_.CalculateSize(_repeated_paths_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HTTPIngressRuleValue other) {
      if (other == null) {
        return;
      }
      paths_.Add(other.paths_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            paths_.AddEntriesFrom(input, _repeated_paths_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            paths_.AddEntriesFrom(ref input, _repeated_paths_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IPBlock describes a particular CIDR (Ex. "192.168.1.1/24","2001:db9::/64") that is allowed
  /// to the pods matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs
  /// that should not be included within this rule.
  /// </summary>
  public sealed partial class IPBlock : pb::IMessage<IPBlock>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IPBlock> _parser = new pb::MessageParser<IPBlock>(() => new IPBlock());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IPBlock> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IPBlock() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IPBlock(IPBlock other) : this() {
      cidr_ = other.cidr_;
      except_ = other.except_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IPBlock Clone() {
      return new IPBlock(this);
    }

    /// <summary>Field number for the "cidr" field.</summary>
    public const int CidrFieldNumber = 1;
    private readonly static string CidrDefaultValue = "";

    private string cidr_;
    /// <summary>
    /// CIDR is a string representing the IP Block
    /// Valid examples are "192.168.1.1/24" or "2001:db9::/64"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Cidr {
      get { return cidr_ ?? CidrDefaultValue; }
      set {
        cidr_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "cidr" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasCidr {
      get { return cidr_ != null; }
    }
    /// <summary>Clears the value of the "cidr" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearCidr() {
      cidr_ = null;
    }

    /// <summary>Field number for the "except" field.</summary>
    public const int ExceptFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_except_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> except_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Except is a slice of CIDRs that should not be included within an IP Block
    /// Valid examples are "192.168.1.1/24" or "2001:db9::/64"
    /// Except values will be rejected if they are outside the CIDR range
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Except {
      get { return except_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IPBlock);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IPBlock other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Cidr != other.Cidr) return false;
      if(!except_.Equals(other.except_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasCidr) hash ^= Cidr.GetHashCode();
      hash ^= except_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasCidr) {
        output.WriteRawTag(10);
        output.WriteString(Cidr);
      }
      except_.WriteTo(output, _repeated_except_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasCidr) {
        output.WriteRawTag(10);
        output.WriteString(Cidr);
      }
      except_.WriteTo(ref output, _repeated_except_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasCidr) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Cidr);
      }
      size += except_.CalculateSize(_repeated_except_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IPBlock other) {
      if (other == null) {
        return;
      }
      if (other.HasCidr) {
        Cidr = other.Cidr;
      }
      except_.Add(other.except_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Cidr = input.ReadString();
            break;
          }
          case 18: {
            except_.AddEntriesFrom(input, _repeated_except_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Cidr = input.ReadString();
            break;
          }
          case 18: {
            except_.AddEntriesFrom(ref input, _repeated_except_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Ingress is a collection of rules that allow inbound connections to reach the
  /// endpoints defined by a backend. An Ingress can be configured to give services
  /// externally-reachable urls, load balance traffic, terminate SSL, offer name
  /// based virtual hosting etc.
  /// </summary>
  public sealed partial class Ingress : pb::IMessage<Ingress>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Ingress> _parser = new pb::MessageParser<Ingress>(() => new Ingress());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Ingress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Ingress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Ingress(Ingress other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Ingress Clone() {
      return new Ingress(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Networking.V1.IngressSpec spec_;
    /// <summary>
    /// Spec is the desired state of the Ingress.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.IngressSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 3;
    private global::K8S.Io.Api.Networking.V1.IngressStatus status_;
    /// <summary>
    /// Status is the current state of the Ingress.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.IngressStatus Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Ingress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Ingress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (status_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Ingress other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Networking.V1.IngressSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::K8S.Io.Api.Networking.V1.IngressStatus();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Networking.V1.IngressSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Networking.V1.IngressStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Networking.V1.IngressSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
          case 26: {
            if (status_ == null) {
              Status = new global::K8S.Io.Api.Networking.V1.IngressStatus();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressBackend describes all endpoints for a given service and port.
  /// </summary>
  public sealed partial class IngressBackend : pb::IMessage<IngressBackend>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressBackend> _parser = new pb::MessageParser<IngressBackend>(() => new IngressBackend());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressBackend> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressBackend() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressBackend(IngressBackend other) : this() {
      service_ = other.service_ != null ? other.service_.Clone() : null;
      resource_ = other.resource_ != null ? other.resource_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressBackend Clone() {
      return new IngressBackend(this);
    }

    /// <summary>Field number for the "service" field.</summary>
    public const int ServiceFieldNumber = 4;
    private global::K8S.Io.Api.Networking.V1.IngressServiceBackend service_;
    /// <summary>
    /// Service references a Service as a Backend.
    /// This is a mutually exclusive setting with "Resource".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.IngressServiceBackend Service {
      get { return service_; }
      set {
        service_ = value;
      }
    }

    /// <summary>Field number for the "resource" field.</summary>
    public const int ResourceFieldNumber = 3;
    private global::K8S.Io.Api.Core.V1.TypedLocalObjectReference resource_;
    /// <summary>
    /// Resource is an ObjectRef to another Kubernetes resource in the namespace
    /// of the Ingress object. If resource is specified, a service.Name and
    /// service.Port must not be specified.
    /// This is a mutually exclusive setting with "Service".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.TypedLocalObjectReference Resource {
      get { return resource_; }
      set {
        resource_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressBackend);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressBackend other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Service, other.Service)) return false;
      if (!object.Equals(Resource, other.Resource)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (service_ != null) hash ^= Service.GetHashCode();
      if (resource_ != null) hash ^= Resource.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (resource_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Resource);
      }
      if (service_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Service);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (resource_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Resource);
      }
      if (service_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Service);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (service_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Service);
      }
      if (resource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Resource);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressBackend other) {
      if (other == null) {
        return;
      }
      if (other.service_ != null) {
        if (service_ == null) {
          Service = new global::K8S.Io.Api.Networking.V1.IngressServiceBackend();
        }
        Service.MergeFrom(other.Service);
      }
      if (other.resource_ != null) {
        if (resource_ == null) {
          Resource = new global::K8S.Io.Api.Core.V1.TypedLocalObjectReference();
        }
        Resource.MergeFrom(other.Resource);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 26: {
            if (resource_ == null) {
              Resource = new global::K8S.Io.Api.Core.V1.TypedLocalObjectReference();
            }
            input.ReadMessage(Resource);
            break;
          }
          case 34: {
            if (service_ == null) {
              Service = new global::K8S.Io.Api.Networking.V1.IngressServiceBackend();
            }
            input.ReadMessage(Service);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 26: {
            if (resource_ == null) {
              Resource = new global::K8S.Io.Api.Core.V1.TypedLocalObjectReference();
            }
            input.ReadMessage(Resource);
            break;
          }
          case 34: {
            if (service_ == null) {
              Service = new global::K8S.Io.Api.Networking.V1.IngressServiceBackend();
            }
            input.ReadMessage(Service);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressClass represents the class of the Ingress, referenced by the Ingress
  /// Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be
  /// used to indicate that an IngressClass should be considered default. When a
  /// single IngressClass resource has this annotation set to true, new Ingress
  /// resources without a class specified will be assigned this default class.
  /// </summary>
  public sealed partial class IngressClass : pb::IMessage<IngressClass>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressClass> _parser = new pb::MessageParser<IngressClass>(() => new IngressClass());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressClass> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClass() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClass(IngressClass other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClass Clone() {
      return new IngressClass(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Networking.V1.IngressClassSpec spec_;
    /// <summary>
    /// Spec is the desired state of the IngressClass.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.IngressClassSpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressClass);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressClass other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressClass other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Networking.V1.IngressClassSpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Networking.V1.IngressClassSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Networking.V1.IngressClassSpec();
            }
            input.ReadMessage(Spec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressClassList is a collection of IngressClasses.
  /// </summary>
  public sealed partial class IngressClassList : pb::IMessage<IngressClassList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressClassList> _parser = new pb::MessageParser<IngressClassList>(() => new IngressClassList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressClassList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClassList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClassList(IngressClassList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClassList Clone() {
      return new IngressClassList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.IngressClass> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Networking.V1.IngressClass.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.IngressClass> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.IngressClass>();
    /// <summary>
    /// Items is the list of IngressClasses.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.IngressClass> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressClassList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressClassList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressClassList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressClassParametersReference identifies an API object. This can be used
  /// to specify a cluster or namespace-scoped resource.
  /// </summary>
  public sealed partial class IngressClassParametersReference : pb::IMessage<IngressClassParametersReference>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressClassParametersReference> _parser = new pb::MessageParser<IngressClassParametersReference>(() => new IngressClassParametersReference());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressClassParametersReference> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClassParametersReference() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClassParametersReference(IngressClassParametersReference other) : this() {
      aPIGroup_ = other.aPIGroup_;
      kind_ = other.kind_;
      name_ = other.name_;
      scope_ = other.scope_;
      namespace_ = other.namespace_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClassParametersReference Clone() {
      return new IngressClassParametersReference(this);
    }

    /// <summary>Field number for the "aPIGroup" field.</summary>
    public const int APIGroupFieldNumber = 1;
    private readonly static string APIGroupDefaultValue = "";

    private string aPIGroup_;
    /// <summary>
    /// APIGroup is the group for the resource being referenced. If APIGroup is
    /// not specified, the specified Kind must be in the core API group. For any
    /// other third-party types, APIGroup is required.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string APIGroup {
      get { return aPIGroup_ ?? APIGroupDefaultValue; }
      set {
        aPIGroup_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "aPIGroup" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAPIGroup {
      get { return aPIGroup_ != null; }
    }
    /// <summary>Clears the value of the "aPIGroup" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAPIGroup() {
      aPIGroup_ = null;
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 2;
    private readonly static string KindDefaultValue = "";

    private string kind_;
    /// <summary>
    /// Kind is the type of resource being referenced.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Kind {
      get { return kind_ ?? KindDefaultValue; }
      set {
        kind_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "kind" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasKind {
      get { return kind_ != null; }
    }
    /// <summary>Clears the value of the "kind" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearKind() {
      kind_ = null;
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name is the name of resource being referenced.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "scope" field.</summary>
    public const int ScopeFieldNumber = 4;
    private readonly static string ScopeDefaultValue = "";

    private string scope_;
    /// <summary>
    /// Scope represents if this refers to a cluster or namespace scoped resource.
    /// This may be set to "Cluster" (default) or "Namespace".
    /// Field can be enabled with IngressClassNamespacedParams feature gate.
    /// +optional
    /// +featureGate=IngressClassNamespacedParams
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Scope {
      get { return scope_ ?? ScopeDefaultValue; }
      set {
        scope_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "scope" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasScope {
      get { return scope_ != null; }
    }
    /// <summary>Clears the value of the "scope" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearScope() {
      scope_ = null;
    }

    /// <summary>Field number for the "namespace" field.</summary>
    public const int NamespaceFieldNumber = 5;
    private readonly static string NamespaceDefaultValue = "";

    private string namespace_;
    /// <summary>
    /// Namespace is the namespace of the resource being referenced. This field is
    /// required when scope is set to "Namespace" and must be unset when scope is set to
    /// "Cluster".
    /// +optional
    /// +featureGate=IngressClassNamespacedParams
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Namespace {
      get { return namespace_ ?? NamespaceDefaultValue; }
      set {
        namespace_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "namespace" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNamespace {
      get { return namespace_ != null; }
    }
    /// <summary>Clears the value of the "namespace" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNamespace() {
      namespace_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressClassParametersReference);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressClassParametersReference other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (APIGroup != other.APIGroup) return false;
      if (Kind != other.Kind) return false;
      if (Name != other.Name) return false;
      if (Scope != other.Scope) return false;
      if (Namespace != other.Namespace) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasAPIGroup) hash ^= APIGroup.GetHashCode();
      if (HasKind) hash ^= Kind.GetHashCode();
      if (HasName) hash ^= Name.GetHashCode();
      if (HasScope) hash ^= Scope.GetHashCode();
      if (HasNamespace) hash ^= Namespace.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasAPIGroup) {
        output.WriteRawTag(10);
        output.WriteString(APIGroup);
      }
      if (HasKind) {
        output.WriteRawTag(18);
        output.WriteString(Kind);
      }
      if (HasName) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (HasScope) {
        output.WriteRawTag(34);
        output.WriteString(Scope);
      }
      if (HasNamespace) {
        output.WriteRawTag(42);
        output.WriteString(Namespace);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasAPIGroup) {
        output.WriteRawTag(10);
        output.WriteString(APIGroup);
      }
      if (HasKind) {
        output.WriteRawTag(18);
        output.WriteString(Kind);
      }
      if (HasName) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (HasScope) {
        output.WriteRawTag(34);
        output.WriteString(Scope);
      }
      if (HasNamespace) {
        output.WriteRawTag(42);
        output.WriteString(Namespace);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasAPIGroup) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(APIGroup);
      }
      if (HasKind) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Kind);
      }
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasScope) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Scope);
      }
      if (HasNamespace) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Namespace);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressClassParametersReference other) {
      if (other == null) {
        return;
      }
      if (other.HasAPIGroup) {
        APIGroup = other.APIGroup;
      }
      if (other.HasKind) {
        Kind = other.Kind;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasScope) {
        Scope = other.Scope;
      }
      if (other.HasNamespace) {
        Namespace = other.Namespace;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            APIGroup = input.ReadString();
            break;
          }
          case 18: {
            Kind = input.ReadString();
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            Scope = input.ReadString();
            break;
          }
          case 42: {
            Namespace = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            APIGroup = input.ReadString();
            break;
          }
          case 18: {
            Kind = input.ReadString();
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            Scope = input.ReadString();
            break;
          }
          case 42: {
            Namespace = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressClassSpec provides information about the class of an Ingress.
  /// </summary>
  public sealed partial class IngressClassSpec : pb::IMessage<IngressClassSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressClassSpec> _parser = new pb::MessageParser<IngressClassSpec>(() => new IngressClassSpec());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressClassSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClassSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClassSpec(IngressClassSpec other) : this() {
      controller_ = other.controller_;
      parameters_ = other.parameters_ != null ? other.parameters_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressClassSpec Clone() {
      return new IngressClassSpec(this);
    }

    /// <summary>Field number for the "controller" field.</summary>
    public const int ControllerFieldNumber = 1;
    private readonly static string ControllerDefaultValue = "";

    private string controller_;
    /// <summary>
    /// Controller refers to the name of the controller that should handle this
    /// class. This allows for different "flavors" that are controlled by the
    /// same controller. For example, you may have different Parameters for the
    /// same implementing controller. This should be specified as a
    /// domain-prefixed path no more than 250 characters in length, e.g.
    /// "acme.io/ingress-controller". This field is immutable.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Controller {
      get { return controller_ ?? ControllerDefaultValue; }
      set {
        controller_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "controller" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasController {
      get { return controller_ != null; }
    }
    /// <summary>Clears the value of the "controller" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearController() {
      controller_ = null;
    }

    /// <summary>Field number for the "parameters" field.</summary>
    public const int ParametersFieldNumber = 2;
    private global::K8S.Io.Api.Networking.V1.IngressClassParametersReference parameters_;
    /// <summary>
    /// Parameters is a link to a custom resource containing additional
    /// configuration for the controller. This is optional if the controller does
    /// not require extra parameters.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.IngressClassParametersReference Parameters {
      get { return parameters_; }
      set {
        parameters_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressClassSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressClassSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Controller != other.Controller) return false;
      if (!object.Equals(Parameters, other.Parameters)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasController) hash ^= Controller.GetHashCode();
      if (parameters_ != null) hash ^= Parameters.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasController) {
        output.WriteRawTag(10);
        output.WriteString(Controller);
      }
      if (parameters_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Parameters);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasController) {
        output.WriteRawTag(10);
        output.WriteString(Controller);
      }
      if (parameters_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Parameters);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasController) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Controller);
      }
      if (parameters_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Parameters);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressClassSpec other) {
      if (other == null) {
        return;
      }
      if (other.HasController) {
        Controller = other.Controller;
      }
      if (other.parameters_ != null) {
        if (parameters_ == null) {
          Parameters = new global::K8S.Io.Api.Networking.V1.IngressClassParametersReference();
        }
        Parameters.MergeFrom(other.Parameters);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Controller = input.ReadString();
            break;
          }
          case 18: {
            if (parameters_ == null) {
              Parameters = new global::K8S.Io.Api.Networking.V1.IngressClassParametersReference();
            }
            input.ReadMessage(Parameters);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Controller = input.ReadString();
            break;
          }
          case 18: {
            if (parameters_ == null) {
              Parameters = new global::K8S.Io.Api.Networking.V1.IngressClassParametersReference();
            }
            input.ReadMessage(Parameters);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressList is a collection of Ingress.
  /// </summary>
  public sealed partial class IngressList : pb::IMessage<IngressList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressList> _parser = new pb::MessageParser<IngressList>(() => new IngressList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressList(IngressList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressList Clone() {
      return new IngressList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.Ingress> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Networking.V1.Ingress.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.Ingress> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.Ingress>();
    /// <summary>
    /// Items is the list of Ingress.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.Ingress> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressRule represents the rules mapping the paths under a specified host to
  /// the related backend services. Incoming requests are first evaluated for a host
  /// match, then routed to the backend associated with the matching IngressRuleValue.
  /// </summary>
  public sealed partial class IngressRule : pb::IMessage<IngressRule>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressRule> _parser = new pb::MessageParser<IngressRule>(() => new IngressRule());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressRule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressRule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressRule(IngressRule other) : this() {
      host_ = other.host_;
      ingressRuleValue_ = other.ingressRuleValue_ != null ? other.ingressRuleValue_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressRule Clone() {
      return new IngressRule(this);
    }

    /// <summary>Field number for the "host" field.</summary>
    public const int HostFieldNumber = 1;
    private readonly static string HostDefaultValue = "";

    private string host_;
    /// <summary>
    /// Host is the fully qualified domain name of a network host, as defined by RFC 3986.
    /// Note the following deviations from the "host" part of the
    /// URI as defined in RFC 3986:
    /// 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
    ///    the IP in the Spec of the parent Ingress.
    /// 2. The `:` delimiter is not respected because ports are not allowed.
    /// 	  Currently the port of an Ingress is implicitly :80 for http and
    /// 	  :443 for https.
    /// Both these may change in the future.
    /// Incoming requests are matched against the host before the
    /// IngressRuleValue. If the host is unspecified, the Ingress routes all
    /// traffic based on the specified IngressRuleValue.
    ///
    /// Host can be "precise" which is a domain name without the terminating dot of
    /// a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
    /// prefixed with a single wildcard label (e.g. "*.foo.com").
    /// The wildcard character '*' must appear by itself as the first DNS label and
    /// matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
    /// Requests will be matched against the Host field in the following way:
    /// 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
    /// 2. If Host is a wildcard, then the request matches this rule if the http host header
    /// is to equal to the suffix (removing the first label) of the wildcard rule.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Host {
      get { return host_ ?? HostDefaultValue; }
      set {
        host_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "host" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasHost {
      get { return host_ != null; }
    }
    /// <summary>Clears the value of the "host" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearHost() {
      host_ = null;
    }

    /// <summary>Field number for the "ingressRuleValue" field.</summary>
    public const int IngressRuleValueFieldNumber = 2;
    private global::K8S.Io.Api.Networking.V1.IngressRuleValue ingressRuleValue_;
    /// <summary>
    /// IngressRuleValue represents a rule to route requests for this IngressRule.
    /// If unspecified, the rule defaults to a http catch-all. Whether that sends
    /// just traffic matching the host to the default backend or all traffic to the
    /// default backend, is left to the controller fulfilling the Ingress. Http is
    /// currently the only supported IngressRuleValue.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.IngressRuleValue IngressRuleValue {
      get { return ingressRuleValue_; }
      set {
        ingressRuleValue_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressRule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressRule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Host != other.Host) return false;
      if (!object.Equals(IngressRuleValue, other.IngressRuleValue)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasHost) hash ^= Host.GetHashCode();
      if (ingressRuleValue_ != null) hash ^= IngressRuleValue.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasHost) {
        output.WriteRawTag(10);
        output.WriteString(Host);
      }
      if (ingressRuleValue_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(IngressRuleValue);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasHost) {
        output.WriteRawTag(10);
        output.WriteString(Host);
      }
      if (ingressRuleValue_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(IngressRuleValue);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasHost) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Host);
      }
      if (ingressRuleValue_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IngressRuleValue);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressRule other) {
      if (other == null) {
        return;
      }
      if (other.HasHost) {
        Host = other.Host;
      }
      if (other.ingressRuleValue_ != null) {
        if (ingressRuleValue_ == null) {
          IngressRuleValue = new global::K8S.Io.Api.Networking.V1.IngressRuleValue();
        }
        IngressRuleValue.MergeFrom(other.IngressRuleValue);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Host = input.ReadString();
            break;
          }
          case 18: {
            if (ingressRuleValue_ == null) {
              IngressRuleValue = new global::K8S.Io.Api.Networking.V1.IngressRuleValue();
            }
            input.ReadMessage(IngressRuleValue);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Host = input.ReadString();
            break;
          }
          case 18: {
            if (ingressRuleValue_ == null) {
              IngressRuleValue = new global::K8S.Io.Api.Networking.V1.IngressRuleValue();
            }
            input.ReadMessage(IngressRuleValue);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressRuleValue represents a rule to apply against incoming requests. If the
  /// rule is satisfied, the request is routed to the specified backend. Currently
  /// mixing different types of rules in a single Ingress is disallowed, so exactly
  /// one of the following must be set.
  /// </summary>
  public sealed partial class IngressRuleValue : pb::IMessage<IngressRuleValue>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressRuleValue> _parser = new pb::MessageParser<IngressRuleValue>(() => new IngressRuleValue());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressRuleValue> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressRuleValue() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressRuleValue(IngressRuleValue other) : this() {
      http_ = other.http_ != null ? other.http_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressRuleValue Clone() {
      return new IngressRuleValue(this);
    }

    /// <summary>Field number for the "http" field.</summary>
    public const int HttpFieldNumber = 1;
    private global::K8S.Io.Api.Networking.V1.HTTPIngressRuleValue http_;
    /// <summary>
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.HTTPIngressRuleValue Http {
      get { return http_; }
      set {
        http_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressRuleValue);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressRuleValue other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Http, other.Http)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (http_ != null) hash ^= Http.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (http_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Http);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (http_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Http);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (http_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressRuleValue other) {
      if (other == null) {
        return;
      }
      if (other.http_ != null) {
        if (http_ == null) {
          Http = new global::K8S.Io.Api.Networking.V1.HTTPIngressRuleValue();
        }
        Http.MergeFrom(other.Http);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (http_ == null) {
              Http = new global::K8S.Io.Api.Networking.V1.HTTPIngressRuleValue();
            }
            input.ReadMessage(Http);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (http_ == null) {
              Http = new global::K8S.Io.Api.Networking.V1.HTTPIngressRuleValue();
            }
            input.ReadMessage(Http);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressServiceBackend references a Kubernetes Service as a Backend.
  /// </summary>
  public sealed partial class IngressServiceBackend : pb::IMessage<IngressServiceBackend>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressServiceBackend> _parser = new pb::MessageParser<IngressServiceBackend>(() => new IngressServiceBackend());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressServiceBackend> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressServiceBackend() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressServiceBackend(IngressServiceBackend other) : this() {
      name_ = other.name_;
      port_ = other.port_ != null ? other.port_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressServiceBackend Clone() {
      return new IngressServiceBackend(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name is the referenced service. The service must exist in
    /// the same namespace as the Ingress object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "port" field.</summary>
    public const int PortFieldNumber = 2;
    private global::K8S.Io.Api.Networking.V1.ServiceBackendPort port_;
    /// <summary>
    /// Port of the referenced service. A port name or port number
    /// is required for a IngressServiceBackend.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.ServiceBackendPort Port {
      get { return port_; }
      set {
        port_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressServiceBackend);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressServiceBackend other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Port, other.Port)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (port_ != null) hash ^= Port.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (port_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Port);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (port_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Port);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (port_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Port);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressServiceBackend other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.port_ != null) {
        if (port_ == null) {
          Port = new global::K8S.Io.Api.Networking.V1.ServiceBackendPort();
        }
        Port.MergeFrom(other.Port);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (port_ == null) {
              Port = new global::K8S.Io.Api.Networking.V1.ServiceBackendPort();
            }
            input.ReadMessage(Port);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (port_ == null) {
              Port = new global::K8S.Io.Api.Networking.V1.ServiceBackendPort();
            }
            input.ReadMessage(Port);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressSpec describes the Ingress the user wishes to exist.
  /// </summary>
  public sealed partial class IngressSpec : pb::IMessage<IngressSpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressSpec> _parser = new pb::MessageParser<IngressSpec>(() => new IngressSpec());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressSpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressSpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressSpec(IngressSpec other) : this() {
      ingressClassName_ = other.ingressClassName_;
      defaultBackend_ = other.defaultBackend_ != null ? other.defaultBackend_.Clone() : null;
      tls_ = other.tls_.Clone();
      rules_ = other.rules_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressSpec Clone() {
      return new IngressSpec(this);
    }

    /// <summary>Field number for the "ingressClassName" field.</summary>
    public const int IngressClassNameFieldNumber = 4;
    private readonly static string IngressClassNameDefaultValue = "";

    private string ingressClassName_;
    /// <summary>
    /// IngressClassName is the name of the IngressClass cluster resource. The
    /// associated IngressClass defines which controller will implement the
    /// resource. This replaces the deprecated `kubernetes.io/ingress.class`
    /// annotation. For backwards compatibility, when that annotation is set, it
    /// must be given precedence over this field. The controller may emit a
    /// warning if the field and annotation have different values.
    /// Implementations of this API should ignore Ingresses without a class
    /// specified. An IngressClass resource may be marked as default, which can
    /// be used to set a default value for this field. For more information,
    /// refer to the IngressClass documentation.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string IngressClassName {
      get { return ingressClassName_ ?? IngressClassNameDefaultValue; }
      set {
        ingressClassName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "ingressClassName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasIngressClassName {
      get { return ingressClassName_ != null; }
    }
    /// <summary>Clears the value of the "ingressClassName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearIngressClassName() {
      ingressClassName_ = null;
    }

    /// <summary>Field number for the "defaultBackend" field.</summary>
    public const int DefaultBackendFieldNumber = 1;
    private global::K8S.Io.Api.Networking.V1.IngressBackend defaultBackend_;
    /// <summary>
    /// DefaultBackend is the backend that should handle requests that don't
    /// match any rule. If Rules are not specified, DefaultBackend must be specified.
    /// If DefaultBackend is not set, the handling of requests that do not match any
    /// of the rules will be up to the Ingress controller.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.IngressBackend DefaultBackend {
      get { return defaultBackend_; }
      set {
        defaultBackend_ = value;
      }
    }

    /// <summary>Field number for the "tls" field.</summary>
    public const int TlsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.IngressTLS> _repeated_tls_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Networking.V1.IngressTLS.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.IngressTLS> tls_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.IngressTLS>();
    /// <summary>
    /// TLS configuration. Currently the Ingress only supports a single TLS
    /// port, 443. If multiple members of this list specify different hosts, they
    /// will be multiplexed on the same port according to the hostname specified
    /// through the SNI TLS extension, if the ingress controller fulfilling the
    /// ingress supports SNI.
    /// +listType=atomic
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.IngressTLS> Tls {
      get { return tls_; }
    }

    /// <summary>Field number for the "rules" field.</summary>
    public const int RulesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.IngressRule> _repeated_rules_codec
        = pb::FieldCodec.ForMessage(26, global::K8S.Io.Api.Networking.V1.IngressRule.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.IngressRule> rules_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.IngressRule>();
    /// <summary>
    /// A list of host rules used to configure the Ingress. If unspecified, or
    /// no rule matches, all traffic is sent to the default backend.
    /// +listType=atomic
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.IngressRule> Rules {
      get { return rules_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressSpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressSpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IngressClassName != other.IngressClassName) return false;
      if (!object.Equals(DefaultBackend, other.DefaultBackend)) return false;
      if(!tls_.Equals(other.tls_)) return false;
      if(!rules_.Equals(other.rules_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasIngressClassName) hash ^= IngressClassName.GetHashCode();
      if (defaultBackend_ != null) hash ^= DefaultBackend.GetHashCode();
      hash ^= tls_.GetHashCode();
      hash ^= rules_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (defaultBackend_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(DefaultBackend);
      }
      tls_.WriteTo(output, _repeated_tls_codec);
      rules_.WriteTo(output, _repeated_rules_codec);
      if (HasIngressClassName) {
        output.WriteRawTag(34);
        output.WriteString(IngressClassName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (defaultBackend_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(DefaultBackend);
      }
      tls_.WriteTo(ref output, _repeated_tls_codec);
      rules_.WriteTo(ref output, _repeated_rules_codec);
      if (HasIngressClassName) {
        output.WriteRawTag(34);
        output.WriteString(IngressClassName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasIngressClassName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(IngressClassName);
      }
      if (defaultBackend_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultBackend);
      }
      size += tls_.CalculateSize(_repeated_tls_codec);
      size += rules_.CalculateSize(_repeated_rules_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressSpec other) {
      if (other == null) {
        return;
      }
      if (other.HasIngressClassName) {
        IngressClassName = other.IngressClassName;
      }
      if (other.defaultBackend_ != null) {
        if (defaultBackend_ == null) {
          DefaultBackend = new global::K8S.Io.Api.Networking.V1.IngressBackend();
        }
        DefaultBackend.MergeFrom(other.DefaultBackend);
      }
      tls_.Add(other.tls_);
      rules_.Add(other.rules_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (defaultBackend_ == null) {
              DefaultBackend = new global::K8S.Io.Api.Networking.V1.IngressBackend();
            }
            input.ReadMessage(DefaultBackend);
            break;
          }
          case 18: {
            tls_.AddEntriesFrom(input, _repeated_tls_codec);
            break;
          }
          case 26: {
            rules_.AddEntriesFrom(input, _repeated_rules_codec);
            break;
          }
          case 34: {
            IngressClassName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (defaultBackend_ == null) {
              DefaultBackend = new global::K8S.Io.Api.Networking.V1.IngressBackend();
            }
            input.ReadMessage(DefaultBackend);
            break;
          }
          case 18: {
            tls_.AddEntriesFrom(ref input, _repeated_tls_codec);
            break;
          }
          case 26: {
            rules_.AddEntriesFrom(ref input, _repeated_rules_codec);
            break;
          }
          case 34: {
            IngressClassName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressStatus describe the current state of the Ingress.
  /// </summary>
  public sealed partial class IngressStatus : pb::IMessage<IngressStatus>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressStatus> _parser = new pb::MessageParser<IngressStatus>(() => new IngressStatus());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressStatus> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressStatus() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressStatus(IngressStatus other) : this() {
      loadBalancer_ = other.loadBalancer_ != null ? other.loadBalancer_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressStatus Clone() {
      return new IngressStatus(this);
    }

    /// <summary>Field number for the "loadBalancer" field.</summary>
    public const int LoadBalancerFieldNumber = 1;
    private global::K8S.Io.Api.Core.V1.LoadBalancerStatus loadBalancer_;
    /// <summary>
    /// LoadBalancer contains the current status of the load-balancer.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Core.V1.LoadBalancerStatus LoadBalancer {
      get { return loadBalancer_; }
      set {
        loadBalancer_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressStatus);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressStatus other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LoadBalancer, other.LoadBalancer)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (loadBalancer_ != null) hash ^= LoadBalancer.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (loadBalancer_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LoadBalancer);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (loadBalancer_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LoadBalancer);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (loadBalancer_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LoadBalancer);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressStatus other) {
      if (other == null) {
        return;
      }
      if (other.loadBalancer_ != null) {
        if (loadBalancer_ == null) {
          LoadBalancer = new global::K8S.Io.Api.Core.V1.LoadBalancerStatus();
        }
        LoadBalancer.MergeFrom(other.LoadBalancer);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (loadBalancer_ == null) {
              LoadBalancer = new global::K8S.Io.Api.Core.V1.LoadBalancerStatus();
            }
            input.ReadMessage(LoadBalancer);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (loadBalancer_ == null) {
              LoadBalancer = new global::K8S.Io.Api.Core.V1.LoadBalancerStatus();
            }
            input.ReadMessage(LoadBalancer);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// IngressTLS describes the transport layer security associated with an Ingress.
  /// </summary>
  public sealed partial class IngressTLS : pb::IMessage<IngressTLS>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<IngressTLS> _parser = new pb::MessageParser<IngressTLS>(() => new IngressTLS());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<IngressTLS> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressTLS() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressTLS(IngressTLS other) : this() {
      hosts_ = other.hosts_.Clone();
      secretName_ = other.secretName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public IngressTLS Clone() {
      return new IngressTLS(this);
    }

    /// <summary>Field number for the "hosts" field.</summary>
    public const int HostsFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_hosts_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> hosts_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Hosts are a list of hosts included in the TLS certificate. The values in
    /// this list must match the name/s used in the tlsSecret. Defaults to the
    /// wildcard host setting for the loadbalancer controller fulfilling this
    /// Ingress, if left unspecified.
    /// +listType=atomic
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Hosts {
      get { return hosts_; }
    }

    /// <summary>Field number for the "secretName" field.</summary>
    public const int SecretNameFieldNumber = 2;
    private readonly static string SecretNameDefaultValue = "";

    private string secretName_;
    /// <summary>
    /// SecretName is the name of the secret used to terminate TLS traffic on
    /// port 443. Field is left optional to allow TLS routing based on SNI
    /// hostname alone. If the SNI host in a listener conflicts with the "Host"
    /// header field used by an IngressRule, the SNI host is used for termination
    /// and value of the Host header is used for routing.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SecretName {
      get { return secretName_ ?? SecretNameDefaultValue; }
      set {
        secretName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "secretName" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSecretName {
      get { return secretName_ != null; }
    }
    /// <summary>Clears the value of the "secretName" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSecretName() {
      secretName_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as IngressTLS);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(IngressTLS other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!hosts_.Equals(other.hosts_)) return false;
      if (SecretName != other.SecretName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= hosts_.GetHashCode();
      if (HasSecretName) hash ^= SecretName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      hosts_.WriteTo(output, _repeated_hosts_codec);
      if (HasSecretName) {
        output.WriteRawTag(18);
        output.WriteString(SecretName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      hosts_.WriteTo(ref output, _repeated_hosts_codec);
      if (HasSecretName) {
        output.WriteRawTag(18);
        output.WriteString(SecretName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += hosts_.CalculateSize(_repeated_hosts_codec);
      if (HasSecretName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SecretName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(IngressTLS other) {
      if (other == null) {
        return;
      }
      hosts_.Add(other.hosts_);
      if (other.HasSecretName) {
        SecretName = other.SecretName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            hosts_.AddEntriesFrom(input, _repeated_hosts_codec);
            break;
          }
          case 18: {
            SecretName = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            hosts_.AddEntriesFrom(ref input, _repeated_hosts_codec);
            break;
          }
          case 18: {
            SecretName = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NetworkPolicy describes what network traffic is allowed for a set of Pods
  /// </summary>
  public sealed partial class NetworkPolicy : pb::IMessage<NetworkPolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NetworkPolicy> _parser = new pb::MessageParser<NetworkPolicy>(() => new NetworkPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NetworkPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicy(NetworkPolicy other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      spec_ = other.spec_ != null ? other.spec_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicy Clone() {
      return new NetworkPolicy(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta metadata_;
    /// <summary>
    /// Standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "spec" field.</summary>
    public const int SpecFieldNumber = 2;
    private global::K8S.Io.Api.Networking.V1.NetworkPolicySpec spec_;
    /// <summary>
    /// Specification of the desired behavior for this NetworkPolicy.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.NetworkPolicySpec Spec {
      get { return spec_; }
      set {
        spec_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NetworkPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NetworkPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(Spec, other.Spec)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (spec_ != null) hash ^= Spec.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      if (spec_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Spec);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (spec_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Spec);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NetworkPolicy other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.spec_ != null) {
        if (spec_ == null) {
          Spec = new global::K8S.Io.Api.Networking.V1.NetworkPolicySpec();
        }
        Spec.MergeFrom(other.Spec);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Networking.V1.NetworkPolicySpec();
            }
            input.ReadMessage(Spec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ObjectMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            if (spec_ == null) {
              Spec = new global::K8S.Io.Api.Networking.V1.NetworkPolicySpec();
            }
            input.ReadMessage(Spec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
  /// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.
  /// This type is beta-level in 1.8
  /// </summary>
  public sealed partial class NetworkPolicyEgressRule : pb::IMessage<NetworkPolicyEgressRule>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NetworkPolicyEgressRule> _parser = new pb::MessageParser<NetworkPolicyEgressRule>(() => new NetworkPolicyEgressRule());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NetworkPolicyEgressRule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyEgressRule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyEgressRule(NetworkPolicyEgressRule other) : this() {
      ports_ = other.ports_.Clone();
      to_ = other.to_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyEgressRule Clone() {
      return new NetworkPolicyEgressRule(this);
    }

    /// <summary>Field number for the "ports" field.</summary>
    public const int PortsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.NetworkPolicyPort> _repeated_ports_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Networking.V1.NetworkPolicyPort.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPort> ports_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPort>();
    /// <summary>
    /// List of destination ports for outgoing traffic.
    /// Each item in this list is combined using a logical OR. If this field is
    /// empty or missing, this rule matches all ports (traffic not restricted by port).
    /// If this field is present and contains at least one item, then this rule allows
    /// traffic only if the traffic matches at least one port in the list.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPort> Ports {
      get { return ports_; }
    }

    /// <summary>Field number for the "to" field.</summary>
    public const int ToFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer> _repeated_to_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer> to_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer>();
    /// <summary>
    /// List of destinations for outgoing traffic of pods selected for this rule.
    /// Items in this list are combined using a logical OR operation. If this field is
    /// empty or missing, this rule matches all destinations (traffic not restricted by
    /// destination). If this field is present and contains at least one item, this rule
    /// allows traffic only if the traffic matches at least one item in the to list.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer> To {
      get { return to_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NetworkPolicyEgressRule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NetworkPolicyEgressRule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!ports_.Equals(other.ports_)) return false;
      if(!to_.Equals(other.to_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= ports_.GetHashCode();
      hash ^= to_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      ports_.WriteTo(output, _repeated_ports_codec);
      to_.WriteTo(output, _repeated_to_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      ports_.WriteTo(ref output, _repeated_ports_codec);
      to_.WriteTo(ref output, _repeated_to_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += ports_.CalculateSize(_repeated_ports_codec);
      size += to_.CalculateSize(_repeated_to_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NetworkPolicyEgressRule other) {
      if (other == null) {
        return;
      }
      ports_.Add(other.ports_);
      to_.Add(other.to_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ports_.AddEntriesFrom(input, _repeated_ports_codec);
            break;
          }
          case 18: {
            to_.AddEntriesFrom(input, _repeated_to_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ports_.AddEntriesFrom(ref input, _repeated_ports_codec);
            break;
          }
          case 18: {
            to_.AddEntriesFrom(ref input, _repeated_to_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
  /// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
  /// </summary>
  public sealed partial class NetworkPolicyIngressRule : pb::IMessage<NetworkPolicyIngressRule>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NetworkPolicyIngressRule> _parser = new pb::MessageParser<NetworkPolicyIngressRule>(() => new NetworkPolicyIngressRule());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NetworkPolicyIngressRule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyIngressRule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyIngressRule(NetworkPolicyIngressRule other) : this() {
      ports_ = other.ports_.Clone();
      from_ = other.from_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyIngressRule Clone() {
      return new NetworkPolicyIngressRule(this);
    }

    /// <summary>Field number for the "ports" field.</summary>
    public const int PortsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.NetworkPolicyPort> _repeated_ports_codec
        = pb::FieldCodec.ForMessage(10, global::K8S.Io.Api.Networking.V1.NetworkPolicyPort.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPort> ports_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPort>();
    /// <summary>
    /// List of ports which should be made accessible on the pods selected for this
    /// rule. Each item in this list is combined using a logical OR. If this field is
    /// empty or missing, this rule matches all ports (traffic not restricted by port).
    /// If this field is present and contains at least one item, then this rule allows
    /// traffic only if the traffic matches at least one port in the list.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPort> Ports {
      get { return ports_; }
    }

    /// <summary>Field number for the "from" field.</summary>
    public const int FromFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer> _repeated_from_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer> from_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer>();
    /// <summary>
    /// List of sources which should be able to access the pods selected for this rule.
    /// Items in this list are combined using a logical OR operation. If this field is
    /// empty or missing, this rule matches all sources (traffic not restricted by
    /// source). If this field is present and contains at least one item, this rule
    /// allows traffic only if the traffic matches at least one item in the from list.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyPeer> From {
      get { return from_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NetworkPolicyIngressRule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NetworkPolicyIngressRule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!ports_.Equals(other.ports_)) return false;
      if(!from_.Equals(other.from_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= ports_.GetHashCode();
      hash ^= from_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      ports_.WriteTo(output, _repeated_ports_codec);
      from_.WriteTo(output, _repeated_from_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      ports_.WriteTo(ref output, _repeated_ports_codec);
      from_.WriteTo(ref output, _repeated_from_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += ports_.CalculateSize(_repeated_ports_codec);
      size += from_.CalculateSize(_repeated_from_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NetworkPolicyIngressRule other) {
      if (other == null) {
        return;
      }
      ports_.Add(other.ports_);
      from_.Add(other.from_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            ports_.AddEntriesFrom(input, _repeated_ports_codec);
            break;
          }
          case 18: {
            from_.AddEntriesFrom(input, _repeated_from_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            ports_.AddEntriesFrom(ref input, _repeated_ports_codec);
            break;
          }
          case 18: {
            from_.AddEntriesFrom(ref input, _repeated_from_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NetworkPolicyList is a list of NetworkPolicy objects.
  /// </summary>
  public sealed partial class NetworkPolicyList : pb::IMessage<NetworkPolicyList>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NetworkPolicyList> _parser = new pb::MessageParser<NetworkPolicyList>(() => new NetworkPolicyList());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NetworkPolicyList> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyList() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyList(NetworkPolicyList other) : this() {
      metadata_ = other.metadata_ != null ? other.metadata_.Clone() : null;
      items_ = other.items_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyList Clone() {
      return new NetworkPolicyList(this);
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta metadata_;
    /// <summary>
    /// Standard list metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "items" field.</summary>
    public const int ItemsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.NetworkPolicy> _repeated_items_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Networking.V1.NetworkPolicy.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicy> items_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicy>();
    /// <summary>
    /// Items is a list of schema objects.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicy> Items {
      get { return items_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NetworkPolicyList);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NetworkPolicyList other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if(!items_.Equals(other.items_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      hash ^= items_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (metadata_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Metadata);
      }
      items_.WriteTo(ref output, _repeated_items_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      size += items_.CalculateSize(_repeated_items_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NetworkPolicyList other) {
      if (other == null) {
        return;
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      items_.Add(other.items_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(input, _repeated_items_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (metadata_ == null) {
              Metadata = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.ListMeta();
            }
            input.ReadMessage(Metadata);
            break;
          }
          case 18: {
            items_.AddEntriesFrom(ref input, _repeated_items_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of
  /// fields are allowed
  /// </summary>
  public sealed partial class NetworkPolicyPeer : pb::IMessage<NetworkPolicyPeer>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NetworkPolicyPeer> _parser = new pb::MessageParser<NetworkPolicyPeer>(() => new NetworkPolicyPeer());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NetworkPolicyPeer> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyPeer() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyPeer(NetworkPolicyPeer other) : this() {
      podSelector_ = other.podSelector_ != null ? other.podSelector_.Clone() : null;
      namespaceSelector_ = other.namespaceSelector_ != null ? other.namespaceSelector_.Clone() : null;
      ipBlock_ = other.ipBlock_ != null ? other.ipBlock_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyPeer Clone() {
      return new NetworkPolicyPeer(this);
    }

    /// <summary>Field number for the "podSelector" field.</summary>
    public const int PodSelectorFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector podSelector_;
    /// <summary>
    /// This is a label selector which selects Pods. This field follows standard label
    /// selector semantics; if present but empty, it selects all pods.
    ///
    /// If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
    /// the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
    /// Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector PodSelector {
      get { return podSelector_; }
      set {
        podSelector_ = value;
      }
    }

    /// <summary>Field number for the "namespaceSelector" field.</summary>
    public const int NamespaceSelectorFieldNumber = 2;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector namespaceSelector_;
    /// <summary>
    /// Selects Namespaces using cluster-scoped labels. This field follows standard label
    /// selector semantics; if present but empty, it selects all namespaces.
    ///
    /// If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
    /// the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
    /// Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector NamespaceSelector {
      get { return namespaceSelector_; }
      set {
        namespaceSelector_ = value;
      }
    }

    /// <summary>Field number for the "ipBlock" field.</summary>
    public const int IpBlockFieldNumber = 3;
    private global::K8S.Io.Api.Networking.V1.IPBlock ipBlock_;
    /// <summary>
    /// IPBlock defines policy on a particular IPBlock. If this field is set then
    /// neither of the other fields can be.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Api.Networking.V1.IPBlock IpBlock {
      get { return ipBlock_; }
      set {
        ipBlock_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NetworkPolicyPeer);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NetworkPolicyPeer other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(PodSelector, other.PodSelector)) return false;
      if (!object.Equals(NamespaceSelector, other.NamespaceSelector)) return false;
      if (!object.Equals(IpBlock, other.IpBlock)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (podSelector_ != null) hash ^= PodSelector.GetHashCode();
      if (namespaceSelector_ != null) hash ^= NamespaceSelector.GetHashCode();
      if (ipBlock_ != null) hash ^= IpBlock.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (podSelector_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PodSelector);
      }
      if (namespaceSelector_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(NamespaceSelector);
      }
      if (ipBlock_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(IpBlock);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (podSelector_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PodSelector);
      }
      if (namespaceSelector_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(NamespaceSelector);
      }
      if (ipBlock_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(IpBlock);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (podSelector_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PodSelector);
      }
      if (namespaceSelector_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NamespaceSelector);
      }
      if (ipBlock_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(IpBlock);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NetworkPolicyPeer other) {
      if (other == null) {
        return;
      }
      if (other.podSelector_ != null) {
        if (podSelector_ == null) {
          PodSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
        }
        PodSelector.MergeFrom(other.PodSelector);
      }
      if (other.namespaceSelector_ != null) {
        if (namespaceSelector_ == null) {
          NamespaceSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
        }
        NamespaceSelector.MergeFrom(other.NamespaceSelector);
      }
      if (other.ipBlock_ != null) {
        if (ipBlock_ == null) {
          IpBlock = new global::K8S.Io.Api.Networking.V1.IPBlock();
        }
        IpBlock.MergeFrom(other.IpBlock);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (podSelector_ == null) {
              PodSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(PodSelector);
            break;
          }
          case 18: {
            if (namespaceSelector_ == null) {
              NamespaceSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(NamespaceSelector);
            break;
          }
          case 26: {
            if (ipBlock_ == null) {
              IpBlock = new global::K8S.Io.Api.Networking.V1.IPBlock();
            }
            input.ReadMessage(IpBlock);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (podSelector_ == null) {
              PodSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(PodSelector);
            break;
          }
          case 18: {
            if (namespaceSelector_ == null) {
              NamespaceSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(NamespaceSelector);
            break;
          }
          case 26: {
            if (ipBlock_ == null) {
              IpBlock = new global::K8S.Io.Api.Networking.V1.IPBlock();
            }
            input.ReadMessage(IpBlock);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NetworkPolicyPort describes a port to allow traffic on
  /// </summary>
  public sealed partial class NetworkPolicyPort : pb::IMessage<NetworkPolicyPort>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NetworkPolicyPort> _parser = new pb::MessageParser<NetworkPolicyPort>(() => new NetworkPolicyPort());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NetworkPolicyPort> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyPort() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyPort(NetworkPolicyPort other) : this() {
      _hasBits0 = other._hasBits0;
      protocol_ = other.protocol_;
      port_ = other.port_ != null ? other.port_.Clone() : null;
      endPort_ = other.endPort_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicyPort Clone() {
      return new NetworkPolicyPort(this);
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 1;
    private readonly static string ProtocolDefaultValue = "";

    private string protocol_;
    /// <summary>
    /// The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this
    /// field defaults to TCP.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Protocol {
      get { return protocol_ ?? ProtocolDefaultValue; }
      set {
        protocol_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "protocol" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasProtocol {
      get { return protocol_ != null; }
    }
    /// <summary>Clears the value of the "protocol" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearProtocol() {
      protocol_ = null;
    }

    /// <summary>Field number for the "port" field.</summary>
    public const int PortFieldNumber = 2;
    private global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString port_;
    /// <summary>
    /// The port on the given protocol. This can either be a numerical or named
    /// port on a pod. If this field is not provided, this matches all port names and
    /// numbers.
    /// If present, only traffic on the specified protocol AND port will be matched.
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString Port {
      get { return port_; }
      set {
        port_ = value;
      }
    }

    /// <summary>Field number for the "endPort" field.</summary>
    public const int EndPortFieldNumber = 3;
    private readonly static int EndPortDefaultValue = 0;

    private int endPort_;
    /// <summary>
    /// If set, indicates that the range of ports from port to endPort, inclusive,
    /// should be allowed by the policy. This field cannot be defined if the port field
    /// is not defined or if the port field is defined as a named (string) port.
    /// The endPort must be equal or greater than port.
    /// This feature is in Beta state and is enabled by default.
    /// It can be disabled using the Feature Gate "NetworkPolicyEndPort".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int EndPort {
      get { if ((_hasBits0 & 1) != 0) { return endPort_; } else { return EndPortDefaultValue; } }
      set {
        _hasBits0 |= 1;
        endPort_ = value;
      }
    }
    /// <summary>Gets whether the "endPort" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasEndPort {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "endPort" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearEndPort() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NetworkPolicyPort);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NetworkPolicyPort other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Protocol != other.Protocol) return false;
      if (!object.Equals(Port, other.Port)) return false;
      if (EndPort != other.EndPort) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasProtocol) hash ^= Protocol.GetHashCode();
      if (port_ != null) hash ^= Port.GetHashCode();
      if (HasEndPort) hash ^= EndPort.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasProtocol) {
        output.WriteRawTag(10);
        output.WriteString(Protocol);
      }
      if (port_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Port);
      }
      if (HasEndPort) {
        output.WriteRawTag(24);
        output.WriteInt32(EndPort);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasProtocol) {
        output.WriteRawTag(10);
        output.WriteString(Protocol);
      }
      if (port_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Port);
      }
      if (HasEndPort) {
        output.WriteRawTag(24);
        output.WriteInt32(EndPort);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasProtocol) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Protocol);
      }
      if (port_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Port);
      }
      if (HasEndPort) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(EndPort);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NetworkPolicyPort other) {
      if (other == null) {
        return;
      }
      if (other.HasProtocol) {
        Protocol = other.Protocol;
      }
      if (other.port_ != null) {
        if (port_ == null) {
          Port = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
        }
        Port.MergeFrom(other.Port);
      }
      if (other.HasEndPort) {
        EndPort = other.EndPort;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Protocol = input.ReadString();
            break;
          }
          case 18: {
            if (port_ == null) {
              Port = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
            }
            input.ReadMessage(Port);
            break;
          }
          case 24: {
            EndPort = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Protocol = input.ReadString();
            break;
          }
          case 18: {
            if (port_ == null) {
              Port = new global::K8S.Io.Apimachinery.Pkg.Util.Intstr.IntOrString();
            }
            input.ReadMessage(Port);
            break;
          }
          case 24: {
            EndPort = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NetworkPolicySpec provides the specification of a NetworkPolicy
  /// </summary>
  public sealed partial class NetworkPolicySpec : pb::IMessage<NetworkPolicySpec>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NetworkPolicySpec> _parser = new pb::MessageParser<NetworkPolicySpec>(() => new NetworkPolicySpec());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NetworkPolicySpec> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicySpec() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicySpec(NetworkPolicySpec other) : this() {
      podSelector_ = other.podSelector_ != null ? other.podSelector_.Clone() : null;
      ingress_ = other.ingress_.Clone();
      egress_ = other.egress_.Clone();
      policyTypes_ = other.policyTypes_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NetworkPolicySpec Clone() {
      return new NetworkPolicySpec(this);
    }

    /// <summary>Field number for the "podSelector" field.</summary>
    public const int PodSelectorFieldNumber = 1;
    private global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector podSelector_;
    /// <summary>
    /// Selects the pods to which this NetworkPolicy object applies. The array of
    /// ingress rules is applied to any pods selected by this field. Multiple network
    /// policies can select the same set of pods. In this case, the ingress rules for
    /// each are combined additively. This field is NOT optional and follows standard
    /// label selector semantics. An empty podSelector matches all pods in this
    /// namespace.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector PodSelector {
      get { return podSelector_; }
      set {
        podSelector_ = value;
      }
    }

    /// <summary>Field number for the "ingress" field.</summary>
    public const int IngressFieldNumber = 2;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.NetworkPolicyIngressRule> _repeated_ingress_codec
        = pb::FieldCodec.ForMessage(18, global::K8S.Io.Api.Networking.V1.NetworkPolicyIngressRule.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyIngressRule> ingress_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyIngressRule>();
    /// <summary>
    /// List of ingress rules to be applied to the selected pods. Traffic is allowed to
    /// a pod if there are no NetworkPolicies selecting the pod
    /// (and cluster policy otherwise allows the traffic), OR if the traffic source is
    /// the pod's local node, OR if the traffic matches at least one ingress rule
    /// across all of the NetworkPolicy objects whose podSelector matches the pod. If
    /// this field is empty then this NetworkPolicy does not allow any traffic (and serves
    /// solely to ensure that the pods it selects are isolated by default)
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyIngressRule> Ingress {
      get { return ingress_; }
    }

    /// <summary>Field number for the "egress" field.</summary>
    public const int EgressFieldNumber = 3;
    private static readonly pb::FieldCodec<global::K8S.Io.Api.Networking.V1.NetworkPolicyEgressRule> _repeated_egress_codec
        = pb::FieldCodec.ForMessage(26, global::K8S.Io.Api.Networking.V1.NetworkPolicyEgressRule.Parser);
    private readonly pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyEgressRule> egress_ = new pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyEgressRule>();
    /// <summary>
    /// List of egress rules to be applied to the selected pods. Outgoing traffic is
    /// allowed if there are no NetworkPolicies selecting the pod (and cluster policy
    /// otherwise allows the traffic), OR if the traffic matches at least one egress rule
    /// across all of the NetworkPolicy objects whose podSelector matches the pod. If
    /// this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
    /// solely to ensure that the pods it selects are isolated by default).
    /// This field is beta-level in 1.8
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::K8S.Io.Api.Networking.V1.NetworkPolicyEgressRule> Egress {
      get { return egress_; }
    }

    /// <summary>Field number for the "policyTypes" field.</summary>
    public const int PolicyTypesFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_policyTypes_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> policyTypes_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// List of rule types that the NetworkPolicy relates to.
    /// Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
    /// If this field is not specified, it will default based on the existence of Ingress or Egress rules;
    /// policies that contain an Egress section are assumed to affect Egress, and all policies
    /// (whether or not they contain an Ingress section) are assumed to affect Ingress.
    /// If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
    /// Likewise, if you want to write a policy that specifies that no egress is allowed,
    /// you must specify a policyTypes value that include "Egress" (since such a policy would not include
    /// an Egress section and would otherwise default to just [ "Ingress" ]).
    /// This field is beta-level in 1.8
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> PolicyTypes {
      get { return policyTypes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NetworkPolicySpec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NetworkPolicySpec other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(PodSelector, other.PodSelector)) return false;
      if(!ingress_.Equals(other.ingress_)) return false;
      if(!egress_.Equals(other.egress_)) return false;
      if(!policyTypes_.Equals(other.policyTypes_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (podSelector_ != null) hash ^= PodSelector.GetHashCode();
      hash ^= ingress_.GetHashCode();
      hash ^= egress_.GetHashCode();
      hash ^= policyTypes_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (podSelector_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PodSelector);
      }
      ingress_.WriteTo(output, _repeated_ingress_codec);
      egress_.WriteTo(output, _repeated_egress_codec);
      policyTypes_.WriteTo(output, _repeated_policyTypes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (podSelector_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(PodSelector);
      }
      ingress_.WriteTo(ref output, _repeated_ingress_codec);
      egress_.WriteTo(ref output, _repeated_egress_codec);
      policyTypes_.WriteTo(ref output, _repeated_policyTypes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (podSelector_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PodSelector);
      }
      size += ingress_.CalculateSize(_repeated_ingress_codec);
      size += egress_.CalculateSize(_repeated_egress_codec);
      size += policyTypes_.CalculateSize(_repeated_policyTypes_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NetworkPolicySpec other) {
      if (other == null) {
        return;
      }
      if (other.podSelector_ != null) {
        if (podSelector_ == null) {
          PodSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
        }
        PodSelector.MergeFrom(other.PodSelector);
      }
      ingress_.Add(other.ingress_);
      egress_.Add(other.egress_);
      policyTypes_.Add(other.policyTypes_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (podSelector_ == null) {
              PodSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(PodSelector);
            break;
          }
          case 18: {
            ingress_.AddEntriesFrom(input, _repeated_ingress_codec);
            break;
          }
          case 26: {
            egress_.AddEntriesFrom(input, _repeated_egress_codec);
            break;
          }
          case 34: {
            policyTypes_.AddEntriesFrom(input, _repeated_policyTypes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (podSelector_ == null) {
              PodSelector = new global::K8S.Io.Apimachinery.Pkg.Apis.Meta.V1.LabelSelector();
            }
            input.ReadMessage(PodSelector);
            break;
          }
          case 18: {
            ingress_.AddEntriesFrom(ref input, _repeated_ingress_codec);
            break;
          }
          case 26: {
            egress_.AddEntriesFrom(ref input, _repeated_egress_codec);
            break;
          }
          case 34: {
            policyTypes_.AddEntriesFrom(ref input, _repeated_policyTypes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ServiceBackendPort is the service port being referenced.
  /// </summary>
  public sealed partial class ServiceBackendPort : pb::IMessage<ServiceBackendPort>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ServiceBackendPort> _parser = new pb::MessageParser<ServiceBackendPort>(() => new ServiceBackendPort());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ServiceBackendPort> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Api.Networking.V1.GeneratedReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceBackendPort() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceBackendPort(ServiceBackendPort other) : this() {
      _hasBits0 = other._hasBits0;
      name_ = other.name_;
      number_ = other.number_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ServiceBackendPort Clone() {
      return new ServiceBackendPort(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private readonly static string NameDefaultValue = "";

    private string name_;
    /// <summary>
    /// Name is the name of the port on the Service.
    /// This is a mutually exclusive setting with "Number".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_ ?? NameDefaultValue; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "name" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasName {
      get { return name_ != null; }
    }
    /// <summary>Clears the value of the "name" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearName() {
      name_ = null;
    }

    /// <summary>Field number for the "number" field.</summary>
    public const int NumberFieldNumber = 2;
    private readonly static int NumberDefaultValue = 0;

    private int number_;
    /// <summary>
    /// Number is the numerical port number (e.g. 80) on the Service.
    /// This is a mutually exclusive setting with "Name".
    /// +optional
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Number {
      get { if ((_hasBits0 & 1) != 0) { return number_; } else { return NumberDefaultValue; } }
      set {
        _hasBits0 |= 1;
        number_ = value;
      }
    }
    /// <summary>Gets whether the "number" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasNumber {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "number" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearNumber() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ServiceBackendPort);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ServiceBackendPort other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Number != other.Number) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasName) hash ^= Name.GetHashCode();
      if (HasNumber) hash ^= Number.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasNumber) {
        output.WriteRawTag(16);
        output.WriteInt32(Number);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasName) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (HasNumber) {
        output.WriteRawTag(16);
        output.WriteInt32(Number);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasName) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (HasNumber) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Number);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ServiceBackendPort other) {
      if (other == null) {
        return;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasNumber) {
        Number = other.Number;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Number = input.ReadInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Number = input.ReadInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
