// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: k8s.io/apimachinery/pkg/api/resource/generated.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace K8S.Io.Apimachinery.Pkg.Api.Resource {

  /// <summary>Holder for reflection information generated from k8s.io/apimachinery/pkg/api/resource/generated.proto</summary>
  public static partial class GeneratedReflection {

    #region Descriptor
    /// <summary>File descriptor for k8s.io/apimachinery/pkg/api/resource/generated.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static GeneratedReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjRrOHMuaW8vYXBpbWFjaGluZXJ5L3BrZy9hcGkvcmVzb3VyY2UvZ2VuZXJh",
            "dGVkLnByb3RvEiRrOHMuaW8uYXBpbWFjaGluZXJ5LnBrZy5hcGkucmVzb3Vy",
            "Y2UiGgoIUXVhbnRpdHkSDgoGc3RyaW5nGAEgASgJQgpaCHJlc291cmNl"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity), global::K8S.Io.Apimachinery.Pkg.Api.Resource.Quantity.Parser, new[]{ "String" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Quantity is a fixed-point representation of a number.
  /// It provides convenient marshaling/unmarshaling in JSON and YAML,
  /// in addition to String() and AsInt64() accessors.
  ///
  /// The serialization format is:
  ///
  /// &lt;quantity>        ::= &lt;signedNumber>&lt;suffix>
  ///   (Note that &lt;suffix> may be empty, from the "" case in &lt;decimalSI>.)
  /// &lt;digit>           ::= 0 | 1 | ... | 9
  /// &lt;digits>          ::= &lt;digit> | &lt;digit>&lt;digits>
  /// &lt;number>          ::= &lt;digits> | &lt;digits>.&lt;digits> | &lt;digits>. | .&lt;digits>
  /// &lt;sign>            ::= "+" | "-"
  /// &lt;signedNumber>    ::= &lt;number> | &lt;sign>&lt;number>
  /// &lt;suffix>          ::= &lt;binarySI> | &lt;decimalExponent> | &lt;decimalSI>
  /// &lt;binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  ///   (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
  /// &lt;decimalSI>       ::= m | "" | k | M | G | T | P | E
  ///   (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
  /// &lt;decimalExponent> ::= "e" &lt;signedNumber> | "E" &lt;signedNumber>
  ///
  /// No matter which of the three exponent forms is used, no quantity may represent
  /// a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal
  /// places. Numbers larger or more precise will be capped or rounded up.
  /// (E.g.: 0.1m will rounded up to 1m.)
  /// This may be extended in the future if we require larger or smaller quantities.
  ///
  /// When a Quantity is parsed from a string, it will remember the type of suffix
  /// it had, and will use the same type again when it is serialized.
  ///
  /// Before serializing, Quantity will be put in "canonical form".
  /// This means that Exponent/suffix will be adjusted up or down (with a
  /// corresponding increase or decrease in Mantissa) such that:
  ///   a. No precision is lost
  ///   b. No fractional digits will be emitted
  ///   c. The exponent (or suffix) is as large as possible.
  /// The sign will be omitted unless the number is negative.
  ///
  /// Examples:
  ///   1.5 will be serialized as "1500m"
  ///   1.5Gi will be serialized as "1536Mi"
  ///
  /// Note that the quantity will NEVER be internally represented by a
  /// floating point number. That is the whole point of this exercise.
  ///
  /// Non-canonical values will still parse as long as they are well formed,
  /// but will be re-emitted in their canonical form. (So always use canonical
  /// form, or don't diff.)
  ///
  /// This format is intended to make it difficult to use these numbers without
  /// writing some sort of special handling code in the hopes that that will
  /// cause implementors to also use a fixed point implementation.
  ///
  /// +protobuf=true
  /// +protobuf.embed=string
  /// +protobuf.options.marshal=false
  /// +protobuf.options.(gogoproto.goproto_stringer)=false
  /// +k8s:deepcopy-gen=true
  /// +k8s:openapi-gen=true
  /// </summary>
  public sealed partial class Quantity : pb::IMessage<Quantity>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Quantity> _parser = new pb::MessageParser<Quantity>(() => new Quantity());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Quantity> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::K8S.Io.Apimachinery.Pkg.Api.Resource.GeneratedReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Quantity() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Quantity(Quantity other) : this() {
      string_ = other.string_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Quantity Clone() {
      return new Quantity(this);
    }

    /// <summary>Field number for the "string" field.</summary>
    public const int StringFieldNumber = 1;
    private readonly static string StringDefaultValue = "";

    private string string_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string String {
      get { return string_ ?? StringDefaultValue; }
      set {
        string_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "string" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasString {
      get { return string_ != null; }
    }
    /// <summary>Clears the value of the "string" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearString() {
      string_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Quantity);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Quantity other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (String != other.String) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (HasString) hash ^= String.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (HasString) {
        output.WriteRawTag(10);
        output.WriteString(String);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (HasString) {
        output.WriteRawTag(10);
        output.WriteString(String);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (HasString) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(String);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Quantity other) {
      if (other == null) {
        return;
      }
      if (other.HasString) {
        String = other.String;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            String = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            String = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
