//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.3.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace GResearch.Armada.Client
{
    using System = global::System;
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.1.3.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ArmadaClient 
    {
        private string _baseUrl = "";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public ArmadaClient(string baseUrl, System.Net.Http.HttpClient httpClient)
        {
            BaseUrl = baseUrl; 
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() => 
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApiBatchQueueCreateResponse> CreateQueuesAsync(ApiQueueList body)
        {
            return CreateQueuesAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ApiBatchQueueCreateResponse> CreateQueuesAsync(ApiQueueList body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/batched/create_queues");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiBatchQueueCreateResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApiBatchQueueUpdateResponse> UpdateQueuesAsync(ApiQueueList body)
        {
            return UpdateQueuesAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ApiBatchQueueUpdateResponse> UpdateQueuesAsync(ApiQueueList body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/batched/update_queues");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiBatchQueueUpdateResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        protected System.Threading.Tasks.Task<FileResponse> GetJobSetEventsCoreAsync(string queue, string id, ApiJobSetRequest body)
        {
            return GetJobSetEventsCoreAsync(queue, id, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        protected async System.Threading.Tasks.Task<FileResponse> GetJobSetEventsCoreAsync(string queue, string id, ApiJobSetRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (queue == null)
                throw new System.ArgumentNullException("queue");
    
            if (id == null)
                throw new System.ArgumentNullException("id");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/job-set/{queue}/{id}");
            urlBuilder_.Replace("{queue}", System.Uri.EscapeDataString(ConvertToString(queue, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{id}", System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/ndjson-stream"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200" || status_ == "206") 
                        {
                            var responseStream_ = response_.Content == null ? System.IO.Stream.Null : await response_.Content.ReadAsStreamAsync().ConfigureAwait(false);
                            var fileResponse_ = new FileResponse((int)response_.StatusCode, headers_, responseStream_, null, response_); 
                            client_ = null; response_ = null; // response and client are disposed by FileResponse
                            return fileResponse_;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApiCancellationResult> CancelJobsAsync(ApiJobCancelRequest body)
        {
            return CancelJobsAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ApiCancellationResult> CancelJobsAsync(ApiJobCancelRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/job/cancel");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiCancellationResult>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApiJobReprioritizeResponse> ReprioritizeJobsAsync(ApiJobReprioritizeRequest body)
        {
            return ReprioritizeJobsAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ApiJobReprioritizeResponse> ReprioritizeJobsAsync(ApiJobReprioritizeRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/job/reprioritize");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiJobReprioritizeResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApiJobSubmitResponse> SubmitJobsAsync(ApiJobSubmitRequest body)
        {
            return SubmitJobsAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ApiJobSubmitResponse> SubmitJobsAsync(ApiJobSubmitRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/job/submit");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiJobSubmitResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> CancelJobSetAsync(ApiJobSetCancelRequest body)
        {
            return CancelJobSetAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> CancelJobSetAsync(ApiJobSetCancelRequest body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/jobset/cancel");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> CreateQueueAsync(ApiQueue body)
        {
            return CreateQueueAsync(body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> CreateQueueAsync(ApiQueue body, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/queue");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApiQueue> GetQueueAsync(string name)
        {
            return GetQueueAsync(name, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ApiQueue> GetQueueAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/queue/{name}");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiQueue>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> UpdateQueueAsync(string name, ApiQueue body)
        {
            return UpdateQueueAsync(name, body, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> UpdateQueueAsync(string name, ApiQueue body, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/queue/{name}");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<object> DeleteQueueAsync(string name)
        {
            return DeleteQueueAsync(name, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<object> DeleteQueueAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/queue/{name}");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<object>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ApiQueueInfo> GetQueueInfoAsync(string name)
        {
            return GetQueueInfoAsync(name, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ApiQueueInfo> GetQueueInfoAsync(string name, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/queue/{name}/info");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ApiQueueInfo>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RuntimeError>(response_, headers_).ConfigureAwait(false);
                            throw new ApiException<RuntimeError>("An unexpected error response.", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class PermissionsSubject 
    {
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class QueuePermissions 
    {
        [Newtonsoft.Json.JsonProperty("subjects", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PermissionsSubject> Subjects { get; set; }
    
        [Newtonsoft.Json.JsonProperty("verbs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Verbs { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiBatchQueueCreateResponse 
    {
        [Newtonsoft.Json.JsonProperty("failedQueues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiQueueCreateResponse> FailedQueues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiBatchQueueUpdateResponse 
    {
        [Newtonsoft.Json.JsonProperty("failedQueues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiQueueUpdateResponse> FailedQueues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiCancellationResult 
    {
        [Newtonsoft.Json.JsonProperty("cancelledIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> CancelledIds { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ApiCause
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Error")]
        Error = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Evicted")]
        Evicted = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OOM")]
        OOM = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DeadlineExceeded")]
        DeadlineExceeded = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiContainerStatus 
    {
        [Newtonsoft.Json.JsonProperty("cause", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApiCause? Cause { get; set; }
    
        [Newtonsoft.Json.JsonProperty("exitCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ExitCode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiEventMessage 
    {
        [Newtonsoft.Json.JsonProperty("cancelled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobCancelledEvent Cancelled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("cancelling", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobCancellingEvent Cancelling { get; set; }
    
        [Newtonsoft.Json.JsonProperty("duplicateFound", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobDuplicateFoundEvent DuplicateFound { get; set; }
    
        [Newtonsoft.Json.JsonProperty("failed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobFailedEvent Failed { get; set; }
    
        [Newtonsoft.Json.JsonProperty("failedCompressed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobFailedEventCompressed FailedCompressed { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ingressInfo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobIngressInfoEvent IngressInfo { get; set; }
    
        [Newtonsoft.Json.JsonProperty("leaseExpired", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobLeaseExpiredEvent LeaseExpired { get; set; }
    
        [Newtonsoft.Json.JsonProperty("leaseReturned", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobLeaseReturnedEvent LeaseReturned { get; set; }
    
        [Newtonsoft.Json.JsonProperty("leased", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobLeasedEvent Leased { get; set; }
    
        [Newtonsoft.Json.JsonProperty("pending", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobPendingEvent Pending { get; set; }
    
        [Newtonsoft.Json.JsonProperty("preempted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobPreemptedEvent Preempted { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queued", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobQueuedEvent Queued { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reprioritized", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobReprioritizedEvent Reprioritized { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reprioritizing", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobReprioritizingEvent Reprioritizing { get; set; }
    
        [Newtonsoft.Json.JsonProperty("running", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobRunningEvent Running { get; set; }
    
        [Newtonsoft.Json.JsonProperty("submitted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobSubmittedEvent Submitted { get; set; }
    
        [Newtonsoft.Json.JsonProperty("succeeded", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobSucceededEvent Succeeded { get; set; }
    
        [Newtonsoft.Json.JsonProperty("terminated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobTerminatedEvent Terminated { get; set; }
    
        [Newtonsoft.Json.JsonProperty("unableToSchedule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobUnableToScheduleEvent UnableToSchedule { get; set; }
    
        [Newtonsoft.Json.JsonProperty("updated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobUpdatedEvent Updated { get; set; }
    
        [Newtonsoft.Json.JsonProperty("utilisation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobUtilisationEvent Utilisation { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiEventStreamMessage 
    {
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiEventMessage Message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiIngressConfig 
    {
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }
    
        [Newtonsoft.Json.JsonProperty("certName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CertName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> Ports { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tlsEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsEnabled { get; set; }
    
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApiIngressType? Type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("useClusterIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseClusterIP { get; set; }
    
    
    }
    
    /// <summary>Ingress type is being kept here to maintain backwards compatibility for a while.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ApiIngressType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Ingress")]
        Ingress = 0,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJob 
    {
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }
    
        [Newtonsoft.Json.JsonProperty("clientId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("compressedQueueOwnershipUserGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] CompressedQueueOwnershipUserGroups { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        /// <summary>Services can be provided either as Armada-specific config objects or as proper k8s objects.
        /// These options are exclusive, i.e., if either ingress or services is provided,
        /// then neither of k8s_ingress or k8s_service can be provided, and vice versa.</summary>
        [Newtonsoft.Json.JsonProperty("ingress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiIngressConfig> Ingress { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("k8sIngress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1Ingress> K8sIngress { get; set; }
    
        [Newtonsoft.Json.JsonProperty("k8sService", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1Service> K8sService { get; set; }
    
        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }
    
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Owner { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podSpec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PodSpec PodSpec { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podSpecs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1PodSpec> PodSpecs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Priority { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queueOwnershipUserGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> QueueOwnershipUserGroups { get; set; }
    
        /// <summary>Queuing TTL for this job in seconds. If this job queues for more than this duration it will be cancelled. Zero indicates an infinite lifetime.</summary>
        [Newtonsoft.Json.JsonProperty("queueTtlSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string QueueTtlSeconds { get; set; }
    
        [Newtonsoft.Json.JsonProperty("requiredNodeLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> RequiredNodeLabels { get; set; }
    
        /// <summary>Indicates which scheduler should manage this job.
        /// If empty, the default scheduler is used.</summary>
        [Newtonsoft.Json.JsonProperty("scheduler", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scheduler { get; set; }
    
        /// <summary>max(
        /// 
        /// 	sum across all containers,
        /// 	max over all init containers,
        /// 
        /// )
        /// 
        /// This is because containers run in parallel, whereas initContainers run serially.
        /// This field is populated automatically at submission.
        /// Submitting a job with this field already populated results in an error.</summary>
        [Newtonsoft.Json.JsonProperty("schedulingResourceRequirements", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ResourceRequirements SchedulingResourceRequirements { get; set; }
    
        [Newtonsoft.Json.JsonProperty("services", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiServiceConfig> Services { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobCancelRequest 
    {
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> JobIds { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobCancelledEvent 
    {
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }
    
        [Newtonsoft.Json.JsonProperty("requestor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Requestor { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobCancellingEvent 
    {
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }
    
        [Newtonsoft.Json.JsonProperty("requestor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Requestor { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobDuplicateFoundEvent 
    {
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("originalJobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OriginalJobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobFailedEvent 
    {
        [Newtonsoft.Json.JsonProperty("cause", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApiCause? Cause { get; set; }
    
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("containerStatuses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiContainerStatus> ContainerStatuses { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("exitCodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, int> ExitCodes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kubernetesId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KubernetesId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodNamespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PodNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobFailedEventCompressed 
    {
        [Newtonsoft.Json.JsonProperty("event", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Event { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobIngressInfoEvent 
    {
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ingressAddresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> IngressAddresses { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kubernetesId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KubernetesId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodNamespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PodNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobLeaseExpiredEvent 
    {
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobLeaseReturnedEvent 
    {
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kubernetesId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KubernetesId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PodNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }
    
        [Newtonsoft.Json.JsonProperty("runAttempted", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RunAttempted { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobLeasedEvent 
    {
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobPendingEvent 
    {
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kubernetesId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KubernetesId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodNamespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PodNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobPreemptedEvent 
    {
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("preemptiveJobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PreemptiveJobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("preemptiveRunId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PreemptiveRunId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("runId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RunId { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobQueuedEvent 
    {
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobReprioritizeRequest 
    {
        [Newtonsoft.Json.JsonProperty("jobIds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> JobIds { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("newPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? NewPriority { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobReprioritizeResponse 
    {
        [Newtonsoft.Json.JsonProperty("reprioritizationResults", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> ReprioritizationResults { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobReprioritizedEvent 
    {
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("newPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? NewPriority { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("requestor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Requestor { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobReprioritizingEvent 
    {
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("newPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? NewPriority { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("requestor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Requestor { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobRunningEvent 
    {
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kubernetesId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KubernetesId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodNamespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PodNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobSetCancelRequest 
    {
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJobSetFilter Filter { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobSetFilter 
    {
        [Newtonsoft.Json.JsonProperty("states", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<ApiJobState> States { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobSetInfo 
    {
        [Newtonsoft.Json.JsonProperty("leasedJobs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? LeasedJobs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queuedJobs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? QueuedJobs { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobSetRequest 
    {
        [Newtonsoft.Json.JsonProperty("errorIfMissing", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ErrorIfMissing { get; set; }
    
        [Newtonsoft.Json.JsonProperty("forceLegacy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ForceLegacy { get; set; }
    
        [Newtonsoft.Json.JsonProperty("forceNew", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ForceNew { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fromMessageId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FromMessageId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("watch", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Watch { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ApiJobState
    {
        [System.Runtime.Serialization.EnumMember(Value = @"QUEUED")]
        QUEUED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PENDING")]
        PENDING = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RUNNING")]
        RUNNING = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCEEDED")]
        SUCCEEDED = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FAILED")]
        FAILED = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobSubmitRequest 
    {
        [Newtonsoft.Json.JsonProperty("jobRequestItems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiJobSubmitRequestItem> JobRequestItems { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobSubmitRequestItem 
    {
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }
    
        [Newtonsoft.Json.JsonProperty("clientId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ingress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiIngressConfig> Ingress { get; set; }
    
        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }
    
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podSpec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PodSpec PodSpec { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podSpecs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1PodSpec> PodSpecs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Priority { get; set; }
    
        /// <summary>Queuing TTL for this job in seconds. If this job queues for more than this duration it will be cancelled. Zero indicates an infinite lifetime.</summary>
        [Newtonsoft.Json.JsonProperty("queueTtlSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string QueueTtlSeconds { get; set; }
    
        [Newtonsoft.Json.JsonProperty("requiredNodeLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> RequiredNodeLabels { get; set; }
    
        /// <summary>Indicates which scheduler should manage this job.
        /// If empty, the default scheduler is used.</summary>
        [Newtonsoft.Json.JsonProperty("scheduler", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scheduler { get; set; }
    
        [Newtonsoft.Json.JsonProperty("services", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiServiceConfig> Services { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobSubmitResponse 
    {
        [Newtonsoft.Json.JsonProperty("jobResponseItems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiJobSubmitResponseItem> JobResponseItems { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobSubmitResponseItem 
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobSubmittedEvent 
    {
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("job", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJob Job { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobSucceededEvent 
    {
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kubernetesId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KubernetesId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodNamespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PodNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobTerminatedEvent 
    {
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kubernetesId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KubernetesId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodNamespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PodNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobUnableToScheduleEvent 
    {
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kubernetesId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KubernetesId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodNamespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PodNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobUpdatedEvent 
    {
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("job", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiJob Job { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("requestor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Requestor { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiJobUtilisationEvent 
    {
        [Newtonsoft.Json.JsonProperty("MaxResourcesForPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> MaxResourcesForPeriod { get; set; }
    
        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("created", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Created { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("jobSetId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JobSetId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kubernetesId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KubernetesId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodNamespace { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PodNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }
    
        [Newtonsoft.Json.JsonProperty("totalCumulativeUsage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> TotalCumulativeUsage { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiQueue 
    {
        [Newtonsoft.Json.JsonProperty("groupOwners", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> GroupOwners { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("permissions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<QueuePermissions> Permissions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("priorityFactor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? PriorityFactor { get; set; }
    
        [Newtonsoft.Json.JsonProperty("resourceLimits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, double> ResourceLimits { get; set; }
    
        [Newtonsoft.Json.JsonProperty("userOwners", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> UserOwners { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiQueueCreateResponse 
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiQueue Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiQueueInfo 
    {
        [Newtonsoft.Json.JsonProperty("activeJobSets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiJobSetInfo> ActiveJobSets { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiQueueList 
    {
        [Newtonsoft.Json.JsonProperty("queues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ApiQueue> Queues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiQueueUpdateResponse 
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ApiQueue Queue { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ApiServiceConfig 
    {
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> Ports { get; set; }
    
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApiServiceType? Type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public enum ApiServiceType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"NodePort")]
        NodePort = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Headless")]
        Headless = 1,
    
    }
    
    /// <summary>+protobuf=true
    /// +protobuf.options.(gogoproto.goproto_stringer)=false
    /// +k8s:openapi-gen=true</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class IntstrIntOrString 
    {
        [Newtonsoft.Json.JsonProperty("IntVal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? IntVal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("StrVal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StrVal { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Type { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class ProtobufAny 
    {
        [Newtonsoft.Json.JsonProperty("typeUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TypeUrl { get; set; }
    
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Value { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RuntimeError 
    {
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Code { get; set; }
    
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ProtobufAny> Details { get; set; }
    
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class RuntimeStreamError 
    {
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ProtobufAny> Details { get; set; }
    
        [Newtonsoft.Json.JsonProperty("grpcCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? GrpcCode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("httpCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HttpCode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("httpStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HttpStatus { get; set; }
    
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
    
    }
    
    /// <summary>An AWS EBS disk must exist before mounting to a container. The disk
    /// must also be in the same AWS zone as the kubelet. An AWS EBS disk
    /// can only be mounted as read/write once. AWS EBS volumes support
    /// ownership management and SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1AWSElasticBlockStoreVolumeSource 
    {
        /// <summary>Filesystem type of the volume that you want to mount.
        /// Tip: Ensure that the filesystem type is supported by the host operating system.
        /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// TODO: how do we prevent errors in the filesystem from compromising the machine
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>The partition in the volume that you want to mount.
        /// If omitted, the default is to mount by volume name.
        /// Examples: For volume /dev/sda1, you specify the partition as "1".
        /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("partition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Partition { get; set; }
    
        /// <summary>Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
        /// If omitted, the default is "false".
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        /// <summary>Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore</summary>
        [Newtonsoft.Json.JsonProperty("volumeID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeID { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Affinity 
    {
        [Newtonsoft.Json.JsonProperty("nodeAffinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1NodeAffinity NodeAffinity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podAffinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PodAffinity PodAffinity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("podAntiAffinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PodAntiAffinity PodAntiAffinity { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1AzureDiskVolumeSource 
    {
        [Newtonsoft.Json.JsonProperty("cachingMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CachingMode { get; set; }
    
        /// <summary>The Name of the data disk in the blob storage</summary>
        [Newtonsoft.Json.JsonProperty("diskName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DiskName { get; set; }
    
        /// <summary>The URI the data disk in the blob storage</summary>
        [Newtonsoft.Json.JsonProperty("diskURI", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DiskURI { get; set; }
    
        /// <summary>Filesystem type to mount.
        /// Must be a filesystem type supported by the host operating system.
        /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }
    
        /// <summary>Defaults to false (read/write). ReadOnly here will force
        /// the ReadOnly setting in VolumeMounts.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1AzureFileVolumeSource 
    {
        /// <summary>Defaults to false (read/write). ReadOnly here will force
        /// the ReadOnly setting in VolumeMounts.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        /// <summary>the name of secret that contains Azure Storage Account Name and Key</summary>
        [Newtonsoft.Json.JsonProperty("secretName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SecretName { get; set; }
    
        /// <summary>Share Name</summary>
        [Newtonsoft.Json.JsonProperty("shareName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ShareName { get; set; }
    
    
    }
    
    /// <summary>Represents a source location of a volume to mount, managed by an external CSI driver</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1CSIVolumeSource 
    {
        /// <summary>Driver is the name of the CSI driver that handles this volume.
        /// Consult with your admin for the correct name as registered in the cluster.</summary>
        [Newtonsoft.Json.JsonProperty("driver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Driver { get; set; }
    
        /// <summary>Filesystem type to mount. Ex. "ext4", "xfs", "ntfs".
        /// If not provided, the empty value is passed to the associated CSI driver
        /// which will determine the default filesystem to apply.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodePublishSecretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LocalObjectReference NodePublishSecretRef { get; set; }
    
        /// <summary>Specifies a read-only configuration for the volume.
        /// Defaults to false (read/write).
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        /// <summary>VolumeAttributes stores driver-specific properties that are passed to the CSI
        /// driver. Consult your driver's documentation for supported values.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("volumeAttributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> VolumeAttributes { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Capabilities 
    {
        /// <summary>Added capabilities
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("add", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Add { get; set; }
    
        /// <summary>Removed capabilities
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("drop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Drop { get; set; }
    
    
    }
    
    /// <summary>Represents a Ceph Filesystem mount that lasts the lifetime of a pod
    /// Cephfs volumes do not support ownership management or SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1CephFSVolumeSource 
    {
        /// <summary>Required: Monitors is a collection of Ceph monitors
        /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it</summary>
        [Newtonsoft.Json.JsonProperty("monitors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Monitors { get; set; }
    
        /// <summary>Optional: Used as the mounted root, rather than the full Ceph tree, default is /
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>Optional: Defaults to false (read/write). ReadOnly here will force
        /// the ReadOnly setting in VolumeMounts.
        /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        /// <summary>Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
        /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("secretFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SecretFile { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LocalObjectReference SecretRef { get; set; }
    
        /// <summary>Optional: User is the rados user name, default is admin
        /// More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }
    
    
    }
    
    /// <summary>A Cinder volume must exist before mounting to a container.
    /// The volume must also be in the same region as the kubelet.
    /// Cinder volumes support ownership management and SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1CinderVolumeSource 
    {
        /// <summary>Filesystem type to mount.
        /// Must be a filesystem type supported by the host operating system.
        /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>Optional: Defaults to false (read/write). ReadOnly here will force
        /// the ReadOnly setting in VolumeMounts.
        /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LocalObjectReference SecretRef { get; set; }
    
        /// <summary>volume id used to identify the volume in cinder.
        /// More info: https://examples.k8s.io/mysql-cinder-pd/README.md</summary>
        [Newtonsoft.Json.JsonProperty("volumeID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeID { get; set; }
    
    
    }
    
    /// <summary>ClientIPConfig represents the configurations of Client IP based session affinity.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ClientIPConfig 
    {
        [Newtonsoft.Json.JsonProperty("timeoutSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TimeoutSeconds { get; set; }
    
    
    }
    
    /// <summary>// other fields
    /// }</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Condition 
    {
        [Newtonsoft.Json.JsonProperty("lastTransitionTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastTransitionTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
        [Newtonsoft.Json.JsonProperty("observedGeneration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ObservedGeneration { get; set; }
    
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }
    
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }
    
    
    }
    
    /// <summary>The contents of the target ConfigMap's Data field will represent the
    /// key-value pairs as environment variables.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ConfigMapEnvSource 
    {
        /// <summary>Name of the referent.
        /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// TODO: Add other useful fields. apiVersion, kind, uid?
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Specify whether the ConfigMap must be defined
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    
    
    }
    
    /// <summary>+structType=atomic</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ConfigMapKeySelector 
    {
        /// <summary>The key to select.</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        /// <summary>Name of the referent.
        /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// TODO: Add other useful fields. apiVersion, kind, uid?
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Specify whether the ConfigMap or its key must be defined
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    
    
    }
    
    /// <summary>The contents of the target ConfigMap's Data field will be presented in a
    /// projected volume as files using the keys in the Data field as the file names,
    /// unless the items element is populated with specific mappings of keys to paths.
    /// Note that this is identical to a configmap volume source without the default
    /// mode.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ConfigMapProjection 
    {
        /// <summary>If unspecified, each key-value pair in the Data field of the referenced
        /// ConfigMap will be projected into the volume as a file whose name is the
        /// key and content is the value. If specified, the listed keys will be
        /// projected into the specified paths, and unlisted keys will not be
        /// present. If a key is specified which is not present in the ConfigMap,
        /// the volume setup will error unless it is marked optional. Paths must be
        /// relative and may not contain the '..' path or start with '..'.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1KeyToPath> Items { get; set; }
    
        /// <summary>Name of the referent.
        /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// TODO: Add other useful fields. apiVersion, kind, uid?
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Specify whether the ConfigMap or its keys must be defined
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    
    
    }
    
    /// <summary>The contents of the target ConfigMap's Data field will be presented in a
    /// volume as files using the keys in the Data field as the file names, unless
    /// the items element is populated with specific mappings of keys to paths.
    /// ConfigMap volumes support ownership management and SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ConfigMapVolumeSource 
    {
        /// <summary>Optional: mode bits used to set permissions on created files by default.
        /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
        /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
        /// Defaults to 0644.
        /// Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file
        /// mode, like fsGroup, and the result can be other mode bits set.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("defaultMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DefaultMode { get; set; }
    
        /// <summary>If unspecified, each key-value pair in the Data field of the referenced
        /// ConfigMap will be projected into the volume as a file whose name is the
        /// key and content is the value. If specified, the listed keys will be
        /// projected into the specified paths, and unlisted keys will not be
        /// present. If a key is specified which is not present in the ConfigMap,
        /// the volume setup will error unless it is marked optional. Paths must be
        /// relative and may not contain the '..' path or start with '..'.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1KeyToPath> Items { get; set; }
    
        /// <summary>Name of the referent.
        /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// TODO: Add other useful fields. apiVersion, kind, uid?
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Specify whether the ConfigMap or its keys must be defined
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Container 
    {
        /// <summary>Arguments to the entrypoint.
        /// The docker image's CMD is used if this is not provided.
        /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        /// of whether the variable exists or not. Cannot be updated.
        /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Args { get; set; }
    
        /// <summary>Entrypoint array. Not executed within a shell.
        /// The docker image's ENTRYPOINT is used if this is not provided.
        /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        /// of whether the variable exists or not. Cannot be updated.
        /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("command", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Command { get; set; }
    
        /// <summary>List of environment variables to set in the container.
        /// Cannot be updated.
        /// +optional
        /// +patchMergeKey=name
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("env", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1EnvVar> Env { get; set; }
    
        /// <summary>List of sources to populate environment variables in the container.
        /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
        /// will be reported as an event when the container is starting. When a key exists in multiple
        /// sources, the value associated with the last source will take precedence.
        /// Values defined by an Env with a duplicate key will take precedence.
        /// Cannot be updated.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("envFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1EnvFromSource> EnvFrom { get; set; }
    
        /// <summary>Docker image name.
        /// More info: https://kubernetes.io/docs/concepts/containers/images
        /// This field is optional to allow higher level config management to default or override
        /// container images in workload controllers like Deployments and StatefulSets.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Image { get; set; }
    
        [Newtonsoft.Json.JsonProperty("imagePullPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImagePullPolicy { get; set; }
    
        [Newtonsoft.Json.JsonProperty("lifecycle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Lifecycle Lifecycle { get; set; }
    
        [Newtonsoft.Json.JsonProperty("livenessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Probe LivenessProbe { get; set; }
    
        /// <summary>Name of the container specified as a DNS_LABEL.
        /// Each container in a pod must have a unique name (DNS_LABEL).
        /// Cannot be updated.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>List of ports to expose from the container. Exposing a port here gives
        /// the system additional information about the network connections a
        /// container uses, but is primarily informational. Not specifying a port here
        /// DOES NOT prevent that port from being exposed. Any port which is
        /// listening on the default "0.0.0.0" address inside a container will be
        /// accessible from the network.
        /// Cannot be updated.
        /// +optional
        /// +patchMergeKey=containerPort
        /// +patchStrategy=merge
        /// +listType=map
        /// +listMapKey=containerPort
        /// +listMapKey=protocol</summary>
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1ContainerPort> Ports { get; set; }
    
        [Newtonsoft.Json.JsonProperty("readinessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Probe ReadinessProbe { get; set; }
    
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ResourceRequirements Resources { get; set; }
    
        [Newtonsoft.Json.JsonProperty("securityContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SecurityContext SecurityContext { get; set; }
    
        [Newtonsoft.Json.JsonProperty("startupProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Probe StartupProbe { get; set; }
    
        /// <summary>Whether this container should allocate a buffer for stdin in the container runtime. If this
        /// is not set, reads from stdin in the container will always result in EOF.
        /// Default is false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("stdin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Stdin { get; set; }
    
        /// <summary>Whether the container runtime should close the stdin channel after it has been opened by
        /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
        /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
        /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
        /// at which time stdin is closed and remains closed until the container is restarted. If this
        /// flag is false, a container processes that reads from stdin will never receive an EOF.
        /// Default is false
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("stdinOnce", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StdinOnce { get; set; }
    
        /// <summary>Optional: Path at which the file to which the container's termination message
        /// will be written is mounted into the container's filesystem.
        /// Message written is intended to be brief final status, such as an assertion failure message.
        /// Will be truncated by the node if greater than 4096 bytes. The total message length across
        /// all containers will be limited to 12kb.
        /// Defaults to /dev/termination-log.
        /// Cannot be updated.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("terminationMessagePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePath { get; set; }
    
        [Newtonsoft.Json.JsonProperty("terminationMessagePolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePolicy { get; set; }
    
        /// <summary>Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
        /// Default is false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("tty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tty { get; set; }
    
        /// <summary>volumeDevices is the list of block devices to be used by the container.
        /// +patchMergeKey=devicePath
        /// +patchStrategy=merge
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("volumeDevices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1VolumeDevice> VolumeDevices { get; set; }
    
        /// <summary>Pod volumes to mount into the container's filesystem.
        /// Cannot be updated.
        /// +optional
        /// +patchMergeKey=mountPath
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("volumeMounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1VolumeMount> VolumeMounts { get; set; }
    
        /// <summary>Container's working directory.
        /// If not specified, the container runtime's default will be used, which
        /// might be configured in the container image.
        /// Cannot be updated.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("workingDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkingDir { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ContainerPort 
    {
        /// <summary>Number of port to expose on the pod's IP address.
        /// This must be a valid port number, 0 &lt; x &lt; 65536.</summary>
        [Newtonsoft.Json.JsonProperty("containerPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ContainerPort { get; set; }
    
        /// <summary>What host IP to bind the external port to.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("hostIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HostIP { get; set; }
    
        /// <summary>Number of port to expose on the host.
        /// If specified, this must be a valid port number, 0 &lt; x &lt; 65536.
        /// If HostNetwork is specified, this must match ContainerPort.
        /// Most containers do not need this.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("hostPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HostPort { get; set; }
    
        /// <summary>If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
        /// named port in a pod must have a unique name. Name for the port that can be
        /// referred to by services.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Protocol { get; set; }
    
    
    }
    
    /// <summary>Note that this is identical to a downwardAPI volume source without the default
    /// mode.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1DownwardAPIProjection 
    {
        /// <summary>Items is a list of DownwardAPIVolume file
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1DownwardAPIVolumeFile> Items { get; set; }
    
    
    }
    
    /// <summary>DownwardAPIVolumeFile represents information to create the file containing the pod field</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1DownwardAPIVolumeFile 
    {
        [Newtonsoft.Json.JsonProperty("fieldRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ObjectFieldSelector FieldRef { get; set; }
    
        /// <summary>Optional: mode bits used to set permissions on this file, must be an octal value
        /// between 0000 and 0777 or a decimal value between 0 and 511.
        /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
        /// If not specified, the volume defaultMode will be used.
        /// This might be in conflict with other options that affect the file
        /// mode, like fsGroup, and the result can be other mode bits set.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Mode { get; set; }
    
        /// <summary>Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        [Newtonsoft.Json.JsonProperty("resourceFieldRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ResourceFieldSelector ResourceFieldRef { get; set; }
    
    
    }
    
    /// <summary>Downward API volumes support ownership management and SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1DownwardAPIVolumeSource 
    {
        /// <summary>Optional: mode bits to use on created files by default. Must be a
        /// Optional: mode bits used to set permissions on created files by default.
        /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
        /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
        /// Defaults to 0644.
        /// Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file
        /// mode, like fsGroup, and the result can be other mode bits set.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("defaultMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DefaultMode { get; set; }
    
        /// <summary>Items is a list of downward API volume file
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1DownwardAPIVolumeFile> Items { get; set; }
    
    
    }
    
    /// <summary>Empty directory volumes support ownership management and SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1EmptyDirVolumeSource 
    {
        [Newtonsoft.Json.JsonProperty("medium", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Medium { get; set; }
    
        [Newtonsoft.Json.JsonProperty("sizeLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SizeLimit { get; set; }
    
    
    }
    
    /// <summary>EnvFromSource represents the source of a set of ConfigMaps</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1EnvFromSource 
    {
        [Newtonsoft.Json.JsonProperty("configMapRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ConfigMapEnvSource ConfigMapRef { get; set; }
    
        /// <summary>An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prefix { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SecretEnvSource SecretRef { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1EnvVar 
    {
        /// <summary>Name of the environment variable. Must be a C_IDENTIFIER.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Variable references $(VAR_NAME) are expanded
        /// using the previously defined environment variables in the container and
        /// any service environment variables. If a variable cannot be resolved,
        /// the reference in the input string will be unchanged. Double $$ are reduced
        /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
        /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
        /// Escaped references will never be expanded, regardless of whether the variable
        /// exists or not.
        /// Defaults to "".
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
        [Newtonsoft.Json.JsonProperty("valueFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1EnvVarSource ValueFrom { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1EnvVarSource 
    {
        [Newtonsoft.Json.JsonProperty("configMapKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ConfigMapKeySelector ConfigMapKeyRef { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fieldRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ObjectFieldSelector FieldRef { get; set; }
    
        [Newtonsoft.Json.JsonProperty("resourceFieldRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ResourceFieldSelector ResourceFieldRef { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secretKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SecretKeySelector SecretKeyRef { get; set; }
    
    
    }
    
    /// <summary>An EphemeralContainer is a container that may be added temporarily to an existing pod for
    /// user-initiated activities such as debugging. Ephemeral containers have no resource or
    /// scheduling guarantees, and they will not be restarted when they exit or when a pod is
    /// removed or restarted. If an ephemeral container causes a pod to exceed its resource
    /// allocation, the pod may be evicted.
    /// Ephemeral containers may not be added by directly updating the pod spec. They must be added
    /// via the pod's ephemeralcontainers subresource, and they will appear in the pod spec
    /// once added.
    /// This is an alpha feature enabled by the EphemeralContainers feature flag.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1EphemeralContainer 
    {
        /// <summary>Arguments to the entrypoint.
        /// The docker image's CMD is used if this is not provided.
        /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        /// of whether the variable exists or not. Cannot be updated.
        /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Args { get; set; }
    
        /// <summary>Entrypoint array. Not executed within a shell.
        /// The docker image's ENTRYPOINT is used if this is not provided.
        /// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
        /// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
        /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
        /// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
        /// of whether the variable exists or not. Cannot be updated.
        /// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("command", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Command { get; set; }
    
        /// <summary>List of environment variables to set in the container.
        /// Cannot be updated.
        /// +optional
        /// +patchMergeKey=name
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("env", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1EnvVar> Env { get; set; }
    
        /// <summary>List of sources to populate environment variables in the container.
        /// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
        /// will be reported as an event when the container is starting. When a key exists in multiple
        /// sources, the value associated with the last source will take precedence.
        /// Values defined by an Env with a duplicate key will take precedence.
        /// Cannot be updated.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("envFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1EnvFromSource> EnvFrom { get; set; }
    
        /// <summary>Docker image name.
        /// More info: https://kubernetes.io/docs/concepts/containers/images</summary>
        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Image { get; set; }
    
        [Newtonsoft.Json.JsonProperty("imagePullPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImagePullPolicy { get; set; }
    
        [Newtonsoft.Json.JsonProperty("lifecycle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Lifecycle Lifecycle { get; set; }
    
        [Newtonsoft.Json.JsonProperty("livenessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Probe LivenessProbe { get; set; }
    
        /// <summary>Name of the ephemeral container specified as a DNS_LABEL.
        /// This name must be unique among all containers, init containers and ephemeral containers.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Ports are not allowed for ephemeral containers.</summary>
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1ContainerPort> Ports { get; set; }
    
        [Newtonsoft.Json.JsonProperty("readinessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Probe ReadinessProbe { get; set; }
    
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ResourceRequirements Resources { get; set; }
    
        [Newtonsoft.Json.JsonProperty("securityContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SecurityContext SecurityContext { get; set; }
    
        [Newtonsoft.Json.JsonProperty("startupProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Probe StartupProbe { get; set; }
    
        /// <summary>Whether this container should allocate a buffer for stdin in the container runtime. If this
        /// is not set, reads from stdin in the container will always result in EOF.
        /// Default is false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("stdin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Stdin { get; set; }
    
        /// <summary>Whether the container runtime should close the stdin channel after it has been opened by
        /// a single attach. When stdin is true the stdin stream will remain open across multiple attach
        /// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
        /// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
        /// at which time stdin is closed and remains closed until the container is restarted. If this
        /// flag is false, a container processes that reads from stdin will never receive an EOF.
        /// Default is false
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("stdinOnce", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StdinOnce { get; set; }
    
        /// <summary>If set, the name of the container from PodSpec that this ephemeral container targets.
        /// The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
        /// If not set then the ephemeral container is run in whatever namespaces are shared
        /// for the pod. Note that the container runtime must support this feature.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("targetContainerName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetContainerName { get; set; }
    
        /// <summary>Optional: Path at which the file to which the container's termination message
        /// will be written is mounted into the container's filesystem.
        /// Message written is intended to be brief final status, such as an assertion failure message.
        /// Will be truncated by the node if greater than 4096 bytes. The total message length across
        /// all containers will be limited to 12kb.
        /// Defaults to /dev/termination-log.
        /// Cannot be updated.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("terminationMessagePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePath { get; set; }
    
        [Newtonsoft.Json.JsonProperty("terminationMessagePolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePolicy { get; set; }
    
        /// <summary>Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
        /// Default is false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("tty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tty { get; set; }
    
        /// <summary>volumeDevices is the list of block devices to be used by the container.
        /// +patchMergeKey=devicePath
        /// +patchStrategy=merge
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("volumeDevices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1VolumeDevice> VolumeDevices { get; set; }
    
        /// <summary>Pod volumes to mount into the container's filesystem.
        /// Cannot be updated.
        /// +optional
        /// +patchMergeKey=mountPath
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("volumeMounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1VolumeMount> VolumeMounts { get; set; }
    
        /// <summary>Container's working directory.
        /// If not specified, the container runtime's default will be used, which
        /// might be configured in the container image.
        /// Cannot be updated.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("workingDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkingDir { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1EphemeralVolumeSource 
    {
        [Newtonsoft.Json.JsonProperty("volumeClaimTemplate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PersistentVolumeClaimTemplate VolumeClaimTemplate { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ExecAction 
    {
        /// <summary>Command is the command line to execute inside the container, the working directory for the
        /// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
        /// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
        /// a shell, you need to explicitly call out to that shell.
        /// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("command", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Command { get; set; }
    
    
    }
    
    /// <summary>Fibre Channel volumes can only be mounted as read/write once.
    /// Fibre Channel volumes support ownership management and SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1FCVolumeSource 
    {
        /// <summary>Filesystem type to mount.
        /// Must be a filesystem type supported by the host operating system.
        /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// TODO: how do we prevent errors in the filesystem from compromising the machine
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>Optional: FC target lun number
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("lun", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Lun { get; set; }
    
        /// <summary>Optional: Defaults to false (read/write). ReadOnly here will force
        /// the ReadOnly setting in VolumeMounts.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        /// <summary>Optional: FC target worldwide names (WWNs)
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("targetWWNs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TargetWWNs { get; set; }
    
        /// <summary>Optional: FC volume world wide identifiers (wwids)
        /// Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("wwids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Wwids { get; set; }
    
    
    }
    
    /// <summary>Each key is either a '.' representing the field itself, and will always map to an empty set,
    /// or a string representing a sub-field or item. The string will follow one of these four formats:
    /// 'f:&lt;name&gt;', where &lt;name&gt; is the name of a field in a struct, or key in a map
    /// 'v:&lt;value&gt;', where &lt;value&gt; is the exact json formatted value of a list item
    /// 'i:&lt;index&gt;', where &lt;index&gt; is position of a item in a list
    /// 'k:&lt;keys&gt;', where &lt;keys&gt; is a map of  a list item's key fields to their unique values
    /// If a key maps to an empty Fields value, the field that key represents is part of the set.
    /// 
    /// The exact format is defined in sigs.k8s.io/structured-merge-diff
    /// +protobuf.options.(gogoproto.goproto_stringer)=false</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1FieldsV1 
    {
    
    }
    
    /// <summary>FlexVolume represents a generic volume resource that is
    /// provisioned/attached using an exec based plugin.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1FlexVolumeSource 
    {
        /// <summary>Driver is the name of the driver to use for this volume.</summary>
        [Newtonsoft.Json.JsonProperty("driver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Driver { get; set; }
    
        /// <summary>Filesystem type to mount.
        /// Must be a filesystem type supported by the host operating system.
        /// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>Optional: Extra command options if any.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }
    
        /// <summary>Optional: Defaults to false (read/write). ReadOnly here will force
        /// the ReadOnly setting in VolumeMounts.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LocalObjectReference SecretRef { get; set; }
    
    
    }
    
    /// <summary>One and only one of datasetName and datasetUUID should be set.
    /// Flocker volumes do not support ownership management or SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1FlockerVolumeSource 
    {
        /// <summary>Name of the dataset stored as metadata -&gt; name on the dataset for Flocker
        /// should be considered as deprecated
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("datasetName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DatasetName { get; set; }
    
        /// <summary>UUID of the dataset. This is unique identifier of a Flocker dataset
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("datasetUUID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DatasetUUID { get; set; }
    
    
    }
    
    /// <summary>A GCE PD must exist before mounting to a container. The disk must
    /// also be in the same GCE project and zone as the kubelet. A GCE PD
    /// can only be mounted as read/write once or read-only many times. GCE
    /// PDs support ownership management and SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1GCEPersistentDiskVolumeSource 
    {
        /// <summary>Filesystem type of the volume that you want to mount.
        /// Tip: Ensure that the filesystem type is supported by the host operating system.
        /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// TODO: how do we prevent errors in the filesystem from compromising the machine
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>The partition in the volume that you want to mount.
        /// If omitted, the default is to mount by volume name.
        /// Examples: For volume /dev/sda1, you specify the partition as "1".
        /// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("partition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Partition { get; set; }
    
        /// <summary>Unique name of the PD resource in GCE. Used to identify the disk in GCE.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk</summary>
        [Newtonsoft.Json.JsonProperty("pdName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PdName { get; set; }
    
        /// <summary>ReadOnly here will force the ReadOnly setting in VolumeMounts.
        /// Defaults to false.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
    
    }
    
    /// <summary>DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
    /// EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
    /// into the Pod's container.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1GitRepoVolumeSource 
    {
        /// <summary>Target directory name.
        /// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
        /// git repository.  Otherwise, if specified, the volume will contain the git repository in
        /// the subdirectory with the given name.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("directory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Directory { get; set; }
    
        /// <summary>Repository URL</summary>
        [Newtonsoft.Json.JsonProperty("repository", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Repository { get; set; }
    
        /// <summary>Commit hash for the specified revision.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("revision", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Revision { get; set; }
    
    
    }
    
    /// <summary>Glusterfs volumes do not support ownership management or SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1GlusterfsVolumeSource 
    {
        /// <summary>EndpointsName is the endpoint name that details Glusterfs topology.
        /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod</summary>
        [Newtonsoft.Json.JsonProperty("endpoints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Endpoints { get; set; }
    
        /// <summary>Path is the Glusterfs volume path.
        /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
        /// Defaults to false.
        /// More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1HTTPGetAction 
    {
        /// <summary>Host name to connect to, defaults to the pod IP. You probably want to set
        /// "Host" in httpHeaders instead.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host { get; set; }
    
        /// <summary>Custom headers to set in the request. HTTP allows repeated headers.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("httpHeaders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1HTTPHeader> HttpHeaders { get; set; }
    
        /// <summary>Path to access on the HTTP server.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IntstrIntOrString Port { get; set; }
    
        [Newtonsoft.Json.JsonProperty("scheme", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Scheme { get; set; }
    
    
    }
    
    /// <summary>HTTPHeader describes a custom header to be used in HTTP probes</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1HTTPHeader 
    {
        /// <summary>The header field name</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>The header field value</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>HTTPIngressPath associates a path with a backend. Incoming urls matching the
    /// path are forwarded to the backend.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1HTTPIngressPath 
    {
        /// <summary>Backend defines the referenced service endpoint to which the traffic
        /// will be forwarded to.</summary>
        [Newtonsoft.Json.JsonProperty("backend", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1IngressBackend Backend { get; set; }
    
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>PathType determines the interpretation of the Path matching. PathType can
        /// be one of the following values:
        /// * Exact: Matches the URL path exactly.
        /// * Prefix: Matches based on a URL path prefix split by '/'. Matching is
        ///   done on a path element by element basis. A path element refers is the
        ///   list of labels in the path split by the '/' separator. A request is a
        ///   match for path p if every p is an element-wise prefix of p of the
        ///   request path. Note that if the last element of the path is a substring
        ///   of the last element in request path, it is not a match (e.g. /foo/bar
        ///   matches /foo/bar/baz, but does not match /foo/barbaz).
        /// * ImplementationSpecific: Interpretation of the Path matching is up to
        ///   the IngressClass. Implementations can treat this as a separate PathType
        ///   or treat it identically to Prefix or Exact path types.
        /// Implementations are required to support all path types.</summary>
        [Newtonsoft.Json.JsonProperty("pathType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PathType { get; set; }
    
    
    }
    
    /// <summary>HTTPIngressRuleValue is a list of http selectors pointing to backends.
    /// In the example: http://&lt;host&gt;/&lt;path&gt;?&lt;searchpart&gt; -&gt; backend where
    /// where parts of the url correspond to RFC 3986, this resource will be used
    /// to match against everything after the last '/' and before the first '?'
    /// or '#'.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1HTTPIngressRuleValue 
    {
        [Newtonsoft.Json.JsonProperty("paths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1HTTPIngressPath> Paths { get; set; }
    
    
    }
    
    /// <summary>Handler defines a specific action that should be taken
    /// TODO: pass structured data to these actions, and document that data here.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Handler 
    {
        [Newtonsoft.Json.JsonProperty("exec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ExecAction Exec { get; set; }
    
        [Newtonsoft.Json.JsonProperty("httpGet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1HTTPGetAction HttpGet { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tcpSocket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1TCPSocketAction TcpSocket { get; set; }
    
    
    }
    
    /// <summary>HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
    /// pod's hosts file.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1HostAlias 
    {
        /// <summary>Hostnames for the above IP address.</summary>
        [Newtonsoft.Json.JsonProperty("hostnames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Hostnames { get; set; }
    
        /// <summary>IP address of the host file entry.</summary>
        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip { get; set; }
    
    
    }
    
    /// <summary>Host path volumes do not support ownership management or SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1HostPathVolumeSource 
    {
        /// <summary>Path of the directory on the host.
        /// If the path is a symlink, it will follow the link to the real path.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }
    
    
    }
    
    /// <summary>ISCSI volumes can only be mounted as read/write once.
    /// ISCSI volumes support ownership management and SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ISCSIVolumeSource 
    {
        /// <summary>whether support iSCSI Discovery CHAP authentication
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("chapAuthDiscovery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ChapAuthDiscovery { get; set; }
    
        /// <summary>whether support iSCSI Session CHAP authentication
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("chapAuthSession", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ChapAuthSession { get; set; }
    
        /// <summary>Filesystem type of the volume that you want to mount.
        /// Tip: Ensure that the filesystem type is supported by the host operating system.
        /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        /// TODO: how do we prevent errors in the filesystem from compromising the machine
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>Custom iSCSI Initiator Name.
        /// If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
        /// &lt;target portal&gt;:&lt;volume name&gt; will be created for the connection.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("initiatorName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InitiatorName { get; set; }
    
        /// <summary>Target iSCSI Qualified Name.</summary>
        [Newtonsoft.Json.JsonProperty("iqn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Iqn { get; set; }
    
        /// <summary>iSCSI Interface Name that uses an iSCSI transport.
        /// Defaults to 'default' (tcp).
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("iscsiInterface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IscsiInterface { get; set; }
    
        /// <summary>iSCSI Target Lun number.</summary>
        [Newtonsoft.Json.JsonProperty("lun", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Lun { get; set; }
    
        /// <summary>iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
        /// is other than default (typically TCP ports 860 and 3260).
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("portals", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Portals { get; set; }
    
        /// <summary>ReadOnly here will force the ReadOnly setting in VolumeMounts.
        /// Defaults to false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LocalObjectReference SecretRef { get; set; }
    
        /// <summary>iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
        /// is other than default (typically TCP ports 860 and 3260).</summary>
        [Newtonsoft.Json.JsonProperty("targetPortal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetPortal { get; set; }
    
    
    }
    
    /// <summary>Ingress is a collection of rules that allow inbound connections to reach the
    /// endpoints defined by a backend. An Ingress can be configured to give services
    /// externally-reachable urls, load balance traffic, terminate SSL, offer name
    /// based virtual hosting etc.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Ingress 
    {
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ObjectMeta Metadata { get; set; }
    
        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1IngressSpec Spec { get; set; }
    
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1IngressStatus Status { get; set; }
    
    
    }
    
    /// <summary>IngressBackend describes all endpoints for a given service and port.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1IngressBackend 
    {
        [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1TypedLocalObjectReference Resource { get; set; }
    
        [Newtonsoft.Json.JsonProperty("service", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1IngressServiceBackend Service { get; set; }
    
    
    }
    
    /// <summary>IngressRule represents the rules mapping the paths under a specified host to
    /// the related backend services. Incoming requests are first evaluated for a host
    /// match, then routed to the backend associated with the matching IngressRuleValue.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1IngressRule 
    {
        /// <summary>Host is the fully qualified domain name of a network host, as defined by RFC 3986.
        /// Note the following deviations from the "host" part of the
        /// URI as defined in RFC 3986:
        /// 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
        ///    the IP in the Spec of the parent Ingress.
        /// 2. The `:` delimiter is not respected because ports are not allowed.
        /// 	  Currently the port of an Ingress is implicitly :80 for http and
        /// 	  :443 for https.
        /// Both these may change in the future.
        /// Incoming requests are matched against the host before the
        /// IngressRuleValue. If the host is unspecified, the Ingress routes all
        /// traffic based on the specified IngressRuleValue.
        /// 
        /// Host can be "precise" which is a domain name without the terminating dot of
        /// a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
        /// prefixed with a single wildcard label (e.g. "*.foo.com").
        /// The wildcard character '*' must appear by itself as the first DNS label and
        /// matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
        /// Requests will be matched against the Host field in the following way:
        /// 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
        /// 2. If Host is a wildcard, then the request matches this rule if the http host header
        /// is to equal to the suffix (removing the first label) of the wildcard rule.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ingressRuleValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1IngressRuleValue IngressRuleValue { get; set; }
    
    
    }
    
    /// <summary>IngressRuleValue represents a rule to apply against incoming requests. If the
    /// rule is satisfied, the request is routed to the specified backend. Currently
    /// mixing different types of rules in a single Ingress is disallowed, so exactly
    /// one of the following must be set.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1IngressRuleValue 
    {
        [Newtonsoft.Json.JsonProperty("http", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1HTTPIngressRuleValue Http { get; set; }
    
    
    }
    
    /// <summary>IngressServiceBackend references a Kubernetes Service as a Backend.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1IngressServiceBackend 
    {
        /// <summary>Name is the referenced service. The service must exist in
        /// the same namespace as the Ingress object.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Port of the referenced service. A port name or port number
        /// is required for a IngressServiceBackend.</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ServiceBackendPort Port { get; set; }
    
    
    }
    
    /// <summary>IngressSpec describes the Ingress the user wishes to exist.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1IngressSpec 
    {
        [Newtonsoft.Json.JsonProperty("defaultBackend", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1IngressBackend DefaultBackend { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ingressClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IngressClassName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1IngressRule> Rules { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1IngressTLS> Tls { get; set; }
    
    
    }
    
    /// <summary>IngressStatus describe the current state of the Ingress.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1IngressStatus 
    {
        [Newtonsoft.Json.JsonProperty("loadBalancer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LoadBalancerStatus LoadBalancer { get; set; }
    
    
    }
    
    /// <summary>IngressTLS describes the transport layer security associated with an Ingress.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1IngressTLS 
    {
        [Newtonsoft.Json.JsonProperty("hosts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Hosts { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secretName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SecretName { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1KeyToPath 
    {
        /// <summary>The key to project.</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        /// <summary>Optional: mode bits used to set permissions on this file.
        /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
        /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
        /// If not specified, the volume defaultMode will be used.
        /// This might be in conflict with other options that affect the file
        /// mode, like fsGroup, and the result can be other mode bits set.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Mode { get; set; }
    
        /// <summary>The relative path of the file to map the key to.
        /// May not be an absolute path.
        /// May not contain the path element '..'.
        /// May not start with the string '..'.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
    
    }
    
    /// <summary>A label selector is a label query over a set of resources. The result of matchLabels and
    /// matchExpressions are ANDed. An empty label selector matches all objects. A null
    /// label selector matches no objects.
    /// +structType=atomic</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1LabelSelector 
    {
        /// <summary>matchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("matchExpressions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1LabelSelectorRequirement> MatchExpressions { get; set; }
    
        /// <summary>matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
        /// map is equivalent to an element of matchExpressions, whose key field is "key", the
        /// operator is "In", and the values array contains only "value". The requirements are ANDed.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("matchLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> MatchLabels { get; set; }
    
    
    }
    
    /// <summary>A label selector requirement is a selector that contains values, a key, and an operator that
    /// relates the key and values.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1LabelSelectorRequirement 
    {
        /// <summary>key is the label key that the selector applies to.
        /// +patchMergeKey=key
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Operator { get; set; }
    
        /// <summary>values is an array of string values. If the operator is In or NotIn,
        /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
        /// the values array must be empty. This array is replaced during a strategic
        /// merge patch.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Values { get; set; }
    
    
    }
    
    /// <summary>Lifecycle describes actions that the management system should take in response to container lifecycle
    /// events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
    /// until the action is complete, unless the container process fails, in which case the handler is aborted.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Lifecycle 
    {
        [Newtonsoft.Json.JsonProperty("postStart", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Handler PostStart { get; set; }
    
        [Newtonsoft.Json.JsonProperty("preStop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Handler PreStop { get; set; }
    
    
    }
    
    /// <summary>LoadBalancerIngress represents the status of a load-balancer ingress point:
    /// traffic intended for the service should be sent to an ingress point.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1LoadBalancerIngress 
    {
        [Newtonsoft.Json.JsonProperty("hostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Hostname { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1PortStatus> Ports { get; set; }
    
    
    }
    
    /// <summary>LoadBalancerStatus represents the status of a load-balancer.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1LoadBalancerStatus 
    {
        [Newtonsoft.Json.JsonProperty("ingress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1LoadBalancerIngress> Ingress { get; set; }
    
    
    }
    
    /// <summary>LocalObjectReference contains enough information to let you locate the
    /// referenced object inside the same namespace.
    /// +structType=atomic</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1LocalObjectReference 
    {
        /// <summary>Name of the referent.
        /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// TODO: Add other useful fields. apiVersion, kind, uid?
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    /// <summary>ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
    /// that the fieldset applies to.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ManagedFieldsEntry 
    {
        /// <summary>APIVersion defines the version of this resource that this field set
        /// applies to. The format is "group/version" just like the top-level
        /// APIVersion field. It is necessary to track the version of a field
        /// set because it cannot be automatically converted.</summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }
    
        /// <summary>FieldsType is the discriminator for the different fields format and version.
        /// There is currently only one possible value: "FieldsV1"</summary>
        [Newtonsoft.Json.JsonProperty("fieldsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldsType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fieldsV1", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1FieldsV1 FieldsV1 { get; set; }
    
        /// <summary>Manager is an identifier of the workflow managing these fields.</summary>
        [Newtonsoft.Json.JsonProperty("manager", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Manager { get; set; }
    
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Operation { get; set; }
    
        /// <summary>Subresource is the name of the subresource used to update that object, or
        /// empty string if the object was updated through the main resource. The
        /// value of this field is used to distinguish between managers, even if they
        /// share the same name. For example, a status update will be distinct from a
        /// regular update using the same manager name.
        /// Note that the APIVersion field is not related to the Subresource field and
        /// it always corresponds to the version of the main resource.</summary>
        [Newtonsoft.Json.JsonProperty("subresource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subresource { get; set; }
    
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Time { get; set; }
    
    
    }
    
    /// <summary>NFS volumes do not support ownership management or SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1NFSVolumeSource 
    {
        /// <summary>Path that is exported by the NFS server.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
        /// <summary>ReadOnly here will force
        /// the NFS export to be mounted with read-only permissions.
        /// Defaults to false.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        /// <summary>Server is the hostname or IP address of the NFS server.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs</summary>
        [Newtonsoft.Json.JsonProperty("server", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Server { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1NodeAffinity 
    {
        /// <summary>The scheduler will prefer to schedule pods to nodes that satisfy
        /// the affinity expressions specified by this field, but it may choose
        /// a node that violates one or more of the expressions. The node that is
        /// most preferred is the one with the greatest sum of weights, i.e.
        /// for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling affinity expressions, etc.),
        /// compute a sum by iterating through the elements of this field and adding
        /// "weight" to the sum if the node matches the corresponding matchExpressions; the
        /// node(s) with the highest sum are the most preferred.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("preferredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1PreferredSchedulingTerm> PreferredDuringSchedulingIgnoredDuringExecution { get; set; }
    
        [Newtonsoft.Json.JsonProperty("requiredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1NodeSelector RequiredDuringSchedulingIgnoredDuringExecution { get; set; }
    
    
    }
    
    /// <summary>A node selector represents the union of the results of one or more label queries
    /// over a set of nodes; that is, it represents the OR of the selectors represented
    /// by the node selector terms.
    /// +structType=atomic</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1NodeSelector 
    {
        /// <summary>Required. A list of node selector terms. The terms are ORed.</summary>
        [Newtonsoft.Json.JsonProperty("nodeSelectorTerms", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1NodeSelectorTerm> NodeSelectorTerms { get; set; }
    
    
    }
    
    /// <summary>A node selector requirement is a selector that contains values, a key, and an operator
    /// that relates the key and values.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1NodeSelectorRequirement 
    {
        /// <summary>The label key that the selector applies to.</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Operator { get; set; }
    
        /// <summary>An array of string values. If the operator is In or NotIn,
        /// the values array must be non-empty. If the operator is Exists or DoesNotExist,
        /// the values array must be empty. If the operator is Gt or Lt, the values
        /// array must have a single element, which will be interpreted as an integer.
        /// This array is replaced during a strategic merge patch.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Values { get; set; }
    
    
    }
    
    /// <summary>A null or empty node selector term matches no objects. The requirements of
    /// them are ANDed.
    /// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
    /// +structType=atomic</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1NodeSelectorTerm 
    {
        /// <summary>A list of node selector requirements by node's labels.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("matchExpressions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1NodeSelectorRequirement> MatchExpressions { get; set; }
    
        /// <summary>A list of node selector requirements by node's fields.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("matchFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1NodeSelectorRequirement> MatchFields { get; set; }
    
    
    }
    
    /// <summary>+structType=atomic</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ObjectFieldSelector 
    {
        /// <summary>Version of the schema the FieldPath is written in terms of, defaults to "v1".
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }
    
        /// <summary>Path of the field to select in the specified API version.</summary>
        [Newtonsoft.Json.JsonProperty("fieldPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldPath { get; set; }
    
    
    }
    
    /// <summary>ObjectMeta is metadata that all persisted resources must have, which includes all objects
    /// users must create.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ObjectMeta 
    {
        /// <summary>Annotations is an unstructured key value map stored with a resource that may be
        /// set by external tools to store and retrieve arbitrary metadata. They are not
        /// queryable and should be preserved when modifying objects.
        /// More info: http://kubernetes.io/docs/user-guide/annotations
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }
    
        /// <summary>The name of the cluster which the object belongs to.
        /// This is used to distinguish resources with same name and namespace in different clusters.
        /// This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("clusterName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("creationTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreationTimestamp { get; set; }
    
        /// <summary>Number of seconds allowed for this object to gracefully terminate before
        /// it will be removed from the system. Only set when deletionTimestamp is also set.
        /// May only be shortened.
        /// Read-only.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("deletionGracePeriodSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DeletionGracePeriodSeconds { get; set; }
    
        [Newtonsoft.Json.JsonProperty("deletionTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DeletionTimestamp { get; set; }
    
        /// <summary>Must be empty before the object is deleted from the registry. Each entry
        /// is an identifier for the responsible component that will remove the entry
        /// from the list. If the deletionTimestamp of the object is non-nil, entries
        /// in this list can only be removed.
        /// Finalizers may be processed and removed in any order.  Order is NOT enforced
        /// because it introduces significant risk of stuck finalizers.
        /// finalizers is a shared field, any actor with permission can reorder it.
        /// If the finalizer list is processed in order, then this can lead to a situation
        /// in which the component responsible for the first finalizer in the list is
        /// waiting for a signal (field value, external system, or other) produced by a
        /// component responsible for a finalizer later in the list, resulting in a deadlock.
        /// Without enforced ordering finalizers are free to order amongst themselves and
        /// are not vulnerable to ordering changes in the list.
        /// +optional
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("finalizers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Finalizers { get; set; }
    
        /// <summary>GenerateName is an optional prefix, used by the server, to generate a unique
        /// name ONLY IF the Name field has not been provided.
        /// If this field is used, the name returned to the client will be different
        /// than the name passed. This value will also be combined with a unique suffix.
        /// The provided value has the same validation rules as the Name field,
        /// and may be truncated by the length of the suffix required to make the value
        /// unique on the server.
        /// 
        /// If this field is specified and the generated name exists, the server will
        /// NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
        /// ServerTimeout indicating a unique name could not be found in the time allotted, and the client
        /// should retry (optionally after the time indicated in the Retry-After header).
        /// 
        /// Applied only if Name is not specified.
        /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("generateName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GenerateName { get; set; }
    
        /// <summary>A sequence number representing a specific generation of the desired state.
        /// Populated by the system. Read-only.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("generation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Generation { get; set; }
    
        /// <summary>Map of string keys and values that can be used to organize and categorize
        /// (scope and select) objects. May match selectors of replication controllers
        /// and services.
        /// More info: http://kubernetes.io/docs/user-guide/labels
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }
    
        /// <summary>ManagedFields maps workflow-id and version to the set of fields
        /// that are managed by that workflow. This is mostly for internal
        /// housekeeping, and users typically shouldn't need to set or
        /// understand this field. A workflow can be the user's name, a
        /// controller's name, or the name of a specific apply path like
        /// "ci-cd". The set of fields is always in the version that the
        /// workflow used when modifying the object.
        /// 
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("managedFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1ManagedFieldsEntry> ManagedFields { get; set; }
    
        /// <summary>Name must be unique within a namespace. Is required when creating resources, although
        /// some resources may allow a client to request the generation of an appropriate name
        /// automatically. Name is primarily intended for creation idempotence and configuration
        /// definition.
        /// Cannot be updated.
        /// More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Namespace defines the space within which each name must be unique. An empty namespace is
        /// equivalent to the "default" namespace, but "default" is the canonical representation.
        /// Not all objects are required to be scoped to a namespace - the value of this field for
        /// those objects will be empty.
        /// 
        /// Must be a DNS_LABEL.
        /// Cannot be updated.
        /// More info: http://kubernetes.io/docs/user-guide/namespaces
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }
    
        /// <summary>List of objects depended by this object. If ALL objects in the list have
        /// been deleted, this object will be garbage collected. If this object is managed by a controller,
        /// then an entry in this list will point to this controller, with the controller field set to true.
        /// There cannot be more than one managing controller.
        /// +optional
        /// +patchMergeKey=uid
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("ownerReferences", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1OwnerReference> OwnerReferences { get; set; }
    
        /// <summary>An opaque value that represents the internal version of this object that can
        /// be used by clients to determine when objects have changed. May be used for optimistic
        /// concurrency, change detection, and the watch operation on a resource or set of resources.
        /// Clients must treat these values as opaque and passed unmodified back to the server.
        /// They may only be valid for a particular resource or set of resources.
        /// 
        /// Populated by the system.
        /// Read-only.
        /// Value must be treated as opaque by clients and .
        /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("resourceVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceVersion { get; set; }
    
        /// <summary>SelfLink is a URL representing this object.
        /// Populated by the system.
        /// Read-only.
        /// 
        /// DEPRECATED
        /// Kubernetes will stop propagating this field in 1.20 release and the field is planned
        /// to be removed in 1.21 release.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("selfLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SelfLink { get; set; }
    
        [Newtonsoft.Json.JsonProperty("uid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uid { get; set; }
    
    
    }
    
    /// <summary>OwnerReference contains enough information to let you identify an owning
    /// object. An owning object must be in the same namespace as the dependent, or
    /// be cluster-scoped, so there is no namespace field.
    /// +structType=atomic</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1OwnerReference 
    {
        /// <summary>API version of the referent.</summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }
    
        /// <summary>If true, AND if the owner has the "foregroundDeletion" finalizer, then
        /// the owner cannot be deleted from the key-value store until this
        /// reference is removed.
        /// Defaults to false.
        /// To set this field, a user needs "delete" permission of the owner,
        /// otherwise 422 (Unprocessable Entity) will be returned.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("blockOwnerDeletion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? BlockOwnerDeletion { get; set; }
    
        /// <summary>If true, this reference points to the managing controller.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("controller", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Controller { get; set; }
    
        /// <summary>Kind of the referent.
        /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }
    
        /// <summary>Name of the referent.
        /// More info: http://kubernetes.io/docs/user-guide/identifiers#names</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("uid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uid { get; set; }
    
    
    }
    
    /// <summary>PersistentVolumeClaimSpec describes the common attributes of storage devices
    /// and allows a Source for provider-specific attributes</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PersistentVolumeClaimSpec 
    {
        /// <summary>AccessModes contains the desired access modes the volume should have.
        /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("accessModes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AccessModes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("dataSource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1TypedLocalObjectReference DataSource { get; set; }
    
        [Newtonsoft.Json.JsonProperty("dataSourceRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1TypedLocalObjectReference DataSourceRef { get; set; }
    
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ResourceRequirements Resources { get; set; }
    
        [Newtonsoft.Json.JsonProperty("selector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LabelSelector Selector { get; set; }
    
        /// <summary>Name of the StorageClass required by the claim.
        /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("storageClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StorageClassName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("volumeMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeMode { get; set; }
    
        /// <summary>VolumeName is the binding reference to the PersistentVolume backing this claim.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }
    
    
    }
    
    /// <summary>PersistentVolumeClaimTemplate is used to produce
    /// PersistentVolumeClaim objects as part of an EphemeralVolumeSource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PersistentVolumeClaimTemplate 
    {
        /// <summary>Annotations is an unstructured key value map stored with a resource that may be
        /// set by external tools to store and retrieve arbitrary metadata. They are not
        /// queryable and should be preserved when modifying objects.
        /// More info: http://kubernetes.io/docs/user-guide/annotations
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }
    
        /// <summary>The name of the cluster which the object belongs to.
        /// This is used to distinguish resources with same name and namespace in different clusters.
        /// This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("clusterName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("creationTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreationTimestamp { get; set; }
    
        /// <summary>Number of seconds allowed for this object to gracefully terminate before
        /// it will be removed from the system. Only set when deletionTimestamp is also set.
        /// May only be shortened.
        /// Read-only.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("deletionGracePeriodSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? DeletionGracePeriodSeconds { get; set; }
    
        [Newtonsoft.Json.JsonProperty("deletionTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DeletionTimestamp { get; set; }
    
        /// <summary>Must be empty before the object is deleted from the registry. Each entry
        /// is an identifier for the responsible component that will remove the entry
        /// from the list. If the deletionTimestamp of the object is non-nil, entries
        /// in this list can only be removed.
        /// Finalizers may be processed and removed in any order.  Order is NOT enforced
        /// because it introduces significant risk of stuck finalizers.
        /// finalizers is a shared field, any actor with permission can reorder it.
        /// If the finalizer list is processed in order, then this can lead to a situation
        /// in which the component responsible for the first finalizer in the list is
        /// waiting for a signal (field value, external system, or other) produced by a
        /// component responsible for a finalizer later in the list, resulting in a deadlock.
        /// Without enforced ordering finalizers are free to order amongst themselves and
        /// are not vulnerable to ordering changes in the list.
        /// +optional
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("finalizers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Finalizers { get; set; }
    
        /// <summary>GenerateName is an optional prefix, used by the server, to generate a unique
        /// name ONLY IF the Name field has not been provided.
        /// If this field is used, the name returned to the client will be different
        /// than the name passed. This value will also be combined with a unique suffix.
        /// The provided value has the same validation rules as the Name field,
        /// and may be truncated by the length of the suffix required to make the value
        /// unique on the server.
        /// 
        /// If this field is specified and the generated name exists, the server will
        /// NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
        /// ServerTimeout indicating a unique name could not be found in the time allotted, and the client
        /// should retry (optionally after the time indicated in the Retry-After header).
        /// 
        /// Applied only if Name is not specified.
        /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("generateName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GenerateName { get; set; }
    
        /// <summary>A sequence number representing a specific generation of the desired state.
        /// Populated by the system. Read-only.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("generation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Generation { get; set; }
    
        /// <summary>Map of string keys and values that can be used to organize and categorize
        /// (scope and select) objects. May match selectors of replication controllers
        /// and services.
        /// More info: http://kubernetes.io/docs/user-guide/labels
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }
    
        /// <summary>ManagedFields maps workflow-id and version to the set of fields
        /// that are managed by that workflow. This is mostly for internal
        /// housekeeping, and users typically shouldn't need to set or
        /// understand this field. A workflow can be the user's name, a
        /// controller's name, or the name of a specific apply path like
        /// "ci-cd". The set of fields is always in the version that the
        /// workflow used when modifying the object.
        /// 
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("managedFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1ManagedFieldsEntry> ManagedFields { get; set; }
    
        /// <summary>Name must be unique within a namespace. Is required when creating resources, although
        /// some resources may allow a client to request the generation of an appropriate name
        /// automatically. Name is primarily intended for creation idempotence and configuration
        /// definition.
        /// Cannot be updated.
        /// More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Namespace defines the space within which each name must be unique. An empty namespace is
        /// equivalent to the "default" namespace, but "default" is the canonical representation.
        /// Not all objects are required to be scoped to a namespace - the value of this field for
        /// those objects will be empty.
        /// 
        /// Must be a DNS_LABEL.
        /// Cannot be updated.
        /// More info: http://kubernetes.io/docs/user-guide/namespaces
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }
    
        /// <summary>List of objects depended by this object. If ALL objects in the list have
        /// been deleted, this object will be garbage collected. If this object is managed by a controller,
        /// then an entry in this list will point to this controller, with the controller field set to true.
        /// There cannot be more than one managing controller.
        /// +optional
        /// +patchMergeKey=uid
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("ownerReferences", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1OwnerReference> OwnerReferences { get; set; }
    
        /// <summary>An opaque value that represents the internal version of this object that can
        /// be used by clients to determine when objects have changed. May be used for optimistic
        /// concurrency, change detection, and the watch operation on a resource or set of resources.
        /// Clients must treat these values as opaque and passed unmodified back to the server.
        /// They may only be valid for a particular resource or set of resources.
        /// 
        /// Populated by the system.
        /// Read-only.
        /// Value must be treated as opaque by clients and .
        /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("resourceVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceVersion { get; set; }
    
        /// <summary>SelfLink is a URL representing this object.
        /// Populated by the system.
        /// Read-only.
        /// 
        /// DEPRECATED
        /// Kubernetes will stop propagating this field in 1.20 release and the field is planned
        /// to be removed in 1.21 release.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("selfLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SelfLink { get; set; }
    
        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PersistentVolumeClaimSpec Spec { get; set; }
    
        [Newtonsoft.Json.JsonProperty("uid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uid { get; set; }
    
    
    }
    
    /// <summary>This volume finds the bound PV and mounts that volume for the pod. A
    /// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
    /// type of volume that is owned by someone else (the system).</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PersistentVolumeClaimVolumeSource 
    {
        /// <summary>ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
        /// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims</summary>
        [Newtonsoft.Json.JsonProperty("claimName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClaimName { get; set; }
    
        /// <summary>Will force the ReadOnly setting in VolumeMounts.
        /// Default false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PhotonPersistentDiskVolumeSource 
    {
        /// <summary>Filesystem type to mount.
        /// Must be a filesystem type supported by the host operating system.
        /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>ID that identifies Photon Controller persistent disk</summary>
        [Newtonsoft.Json.JsonProperty("pdID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PdID { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PodAffinity 
    {
        /// <summary>The scheduler will prefer to schedule pods to nodes that satisfy
        /// the affinity expressions specified by this field, but it may choose
        /// a node that violates one or more of the expressions. The node that is
        /// most preferred is the one with the greatest sum of weights, i.e.
        /// for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling affinity expressions, etc.),
        /// compute a sum by iterating through the elements of this field and adding
        /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
        /// node(s) with the highest sum are the most preferred.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("preferredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1WeightedPodAffinityTerm> PreferredDuringSchedulingIgnoredDuringExecution { get; set; }
    
        /// <summary>If the affinity requirements specified by this field are not met at
        /// scheduling time, the pod will not be scheduled onto the node.
        /// If the affinity requirements specified by this field cease to be met
        /// at some point during pod execution (e.g. due to a pod label update), the
        /// system may or may not try to eventually evict the pod from its node.
        /// When there are multiple elements, the lists of nodes corresponding to each
        /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("requiredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1PodAffinityTerm> RequiredDuringSchedulingIgnoredDuringExecution { get; set; }
    
    
    }
    
    /// <summary>Defines a set of pods (namely those matching the labelSelector
    /// relative to the given namespace(s)) that this pod should be
    /// co-located (affinity) or not co-located (anti-affinity) with,
    /// where co-located is defined as running on a node whose value of
    /// the label with key &lt;topologyKey&gt; matches that of any node on which
    /// a pod of the set of pods is running</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PodAffinityTerm 
    {
        [Newtonsoft.Json.JsonProperty("labelSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LabelSelector LabelSelector { get; set; }
    
        [Newtonsoft.Json.JsonProperty("namespaceSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LabelSelector NamespaceSelector { get; set; }
    
        /// <summary>namespaces specifies a static list of namespace names that the term applies to.
        /// The term is applied to the union of the namespaces listed in this field
        /// and the ones selected by namespaceSelector.
        /// null or empty namespaces list and null namespaceSelector means "this pod's namespace"
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("namespaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Namespaces { get; set; }
    
        /// <summary>This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
        /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
        /// whose value of the label with key topologyKey matches that of any node on which any of the
        /// selected pods is running.
        /// Empty topologyKey is not allowed.</summary>
        [Newtonsoft.Json.JsonProperty("topologyKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TopologyKey { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PodAntiAffinity 
    {
        /// <summary>The scheduler will prefer to schedule pods to nodes that satisfy
        /// the anti-affinity expressions specified by this field, but it may choose
        /// a node that violates one or more of the expressions. The node that is
        /// most preferred is the one with the greatest sum of weights, i.e.
        /// for each node that meets all of the scheduling requirements (resource
        /// request, requiredDuringScheduling anti-affinity expressions, etc.),
        /// compute a sum by iterating through the elements of this field and adding
        /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
        /// node(s) with the highest sum are the most preferred.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("preferredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1WeightedPodAffinityTerm> PreferredDuringSchedulingIgnoredDuringExecution { get; set; }
    
        /// <summary>If the anti-affinity requirements specified by this field are not met at
        /// scheduling time, the pod will not be scheduled onto the node.
        /// If the anti-affinity requirements specified by this field cease to be met
        /// at some point during pod execution (e.g. due to a pod label update), the
        /// system may or may not try to eventually evict the pod from its node.
        /// When there are multiple elements, the lists of nodes corresponding to each
        /// podAffinityTerm are intersected, i.e. all terms must be satisfied.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("requiredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1PodAffinityTerm> RequiredDuringSchedulingIgnoredDuringExecution { get; set; }
    
    
    }
    
    /// <summary>PodDNSConfig defines the DNS parameters of a pod in addition to
    /// those generated from DNSPolicy.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PodDNSConfig 
    {
        /// <summary>A list of DNS name server IP addresses.
        /// This will be appended to the base nameservers generated from DNSPolicy.
        /// Duplicated nameservers will be removed.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("nameservers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Nameservers { get; set; }
    
        /// <summary>A list of DNS resolver options.
        /// This will be merged with the base options generated from DNSPolicy.
        /// Duplicated entries will be removed. Resolution options given in Options
        /// will override those that appear in the base DNSPolicy.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1PodDNSConfigOption> Options { get; set; }
    
        /// <summary>A list of DNS search domains for host-name lookup.
        /// This will be appended to the base search paths generated from DNSPolicy.
        /// Duplicated search paths will be removed.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("searches", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Searches { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PodDNSConfigOption 
    {
        /// <summary>Required.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>+optional</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>PodReadinessGate contains the reference to a pod condition</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PodReadinessGate 
    {
        [Newtonsoft.Json.JsonProperty("conditionType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConditionType { get; set; }
    
    
    }
    
    /// <summary>Some fields are also present in container.securityContext.  Field values of
    /// container.securityContext take precedence over field values of PodSecurityContext.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PodSecurityContext 
    {
        /// <summary>A special supplemental group that applies to all containers in a pod.
        /// Some volume types allow the Kubelet to change the ownership of that volume
        /// to be owned by the pod:
        /// 
        /// 1. The owning GID will be the FSGroup
        /// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
        /// 3. The permission bits are OR'd with rw-rw----
        /// 
        /// If unset, the Kubelet will not modify the ownership and permissions of any volume.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? FsGroup { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fsGroupChangePolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsGroupChangePolicy { get; set; }
    
        /// <summary>The GID to run the entrypoint of the container process.
        /// Uses runtime default if unset.
        /// May also be set in SecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence
        /// for that container.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("runAsGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RunAsGroup { get; set; }
    
        /// <summary>Indicates that the container must run as a non-root user.
        /// If true, the Kubelet will validate the image at runtime to ensure that it
        /// does not run as UID 0 (root) and fail to start the container if it does.
        /// If unset or false, no such validation will be performed.
        /// May also be set in SecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("runAsNonRoot", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RunAsNonRoot { get; set; }
    
        /// <summary>The UID to run the entrypoint of the container process.
        /// Defaults to user specified in image metadata if unspecified.
        /// May also be set in SecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence
        /// for that container.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("runAsUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RunAsUser { get; set; }
    
        [Newtonsoft.Json.JsonProperty("seLinuxOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SELinuxOptions SeLinuxOptions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("seccompProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SeccompProfile SeccompProfile { get; set; }
    
        /// <summary>A list of groups applied to the first process run in each container, in addition
        /// to the container's primary GID.  If unspecified, no groups will be added to
        /// any container.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("supplementalGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> SupplementalGroups { get; set; }
    
        /// <summary>Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
        /// sysctls (by the container runtime) might fail to launch.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("sysctls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1Sysctl> Sysctls { get; set; }
    
        [Newtonsoft.Json.JsonProperty("windowsOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1WindowsSecurityContextOptions WindowsOptions { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PodSpec 
    {
        /// <summary>Optional duration in seconds the pod may be active on the node relative to
        /// StartTime before the system will actively try to mark it failed and kill associated containers.
        /// Value must be a positive integer.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("activeDeadlineSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ActiveDeadlineSeconds { get; set; }
    
        [Newtonsoft.Json.JsonProperty("affinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Affinity Affinity { get; set; }
    
        /// <summary>AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("automountServiceAccountToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AutomountServiceAccountToken { get; set; }
    
        /// <summary>List of containers belonging to the pod.
        /// Containers cannot currently be added or removed.
        /// There must be at least one container in a Pod.
        /// Cannot be updated.
        /// +patchMergeKey=name
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("containers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1Container> Containers { get; set; }
    
        [Newtonsoft.Json.JsonProperty("dnsConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PodDNSConfig DnsConfig { get; set; }
    
        [Newtonsoft.Json.JsonProperty("dnsPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DnsPolicy { get; set; }
    
        /// <summary>EnableServiceLinks indicates whether information about services should be injected into pod's
        /// environment variables, matching the syntax of Docker links.
        /// Optional: Defaults to true.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("enableServiceLinks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableServiceLinks { get; set; }
    
        /// <summary>List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
        /// pod to perform user-initiated actions such as debugging. This list cannot be specified when
        /// creating a pod, and it cannot be modified by updating the pod spec. In order to add an
        /// ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
        /// This field is alpha-level and is only honored by servers that enable the EphemeralContainers feature.
        /// +optional
        /// +patchMergeKey=name
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("ephemeralContainers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1EphemeralContainer> EphemeralContainers { get; set; }
    
        /// <summary>HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
        /// file if specified. This is only valid for non-hostNetwork pods.
        /// +optional
        /// +patchMergeKey=ip
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("hostAliases", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1HostAlias> HostAliases { get; set; }
    
        /// <summary>Use the host's ipc namespace.
        /// Optional: Default to false.
        /// +k8s:conversion-gen=false
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("hostIPC", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HostIPC { get; set; }
    
        /// <summary>Host networking requested for this pod. Use the host's network namespace.
        /// If this option is set, the ports that will be used must be specified.
        /// Default to false.
        /// +k8s:conversion-gen=false
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("hostNetwork", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HostNetwork { get; set; }
    
        /// <summary>Use the host's pid namespace.
        /// Optional: Default to false.
        /// +k8s:conversion-gen=false
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("hostPID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HostPID { get; set; }
    
        /// <summary>Specifies the hostname of the Pod
        /// If not specified, the pod's hostname will be set to a system-defined value.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("hostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Hostname { get; set; }
    
        /// <summary>ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
        /// If specified, these secrets will be passed to individual puller implementations for them to use. For example,
        /// in the case of docker, only DockerConfig type secrets are honored.
        /// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
        /// +optional
        /// +patchMergeKey=name
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("imagePullSecrets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1LocalObjectReference> ImagePullSecrets { get; set; }
    
        /// <summary>List of initialization containers belonging to the pod.
        /// Init containers are executed in order prior to containers being started. If any
        /// init container fails, the pod is considered to have failed and is handled according
        /// to its restartPolicy. The name for an init container or normal container must be
        /// unique among all containers.
        /// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
        /// The resourceRequirements of an init container are taken into account during scheduling
        /// by finding the highest request/limit for each resource type, and then using the max of
        /// of that value or the sum of the normal containers. Limits are applied to init containers
        /// in a similar fashion.
        /// Init containers cannot currently be added or removed.
        /// Cannot be updated.
        /// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
        /// +patchMergeKey=name
        /// +patchStrategy=merge</summary>
        [Newtonsoft.Json.JsonProperty("initContainers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1Container> InitContainers { get; set; }
    
        /// <summary>NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
        /// the scheduler simply schedules this pod onto that node, assuming that it fits resource
        /// requirements.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("nodeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeName { get; set; }
    
        /// <summary>NodeSelector is a selector which must be true for the pod to fit on a node.
        /// Selector which must match a node's labels for the pod to be scheduled on that node.
        /// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
        /// +optional
        /// +mapType=atomic</summary>
        [Newtonsoft.Json.JsonProperty("nodeSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> NodeSelector { get; set; }
    
        [Newtonsoft.Json.JsonProperty("overhead", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ResourceList Overhead { get; set; }
    
        [Newtonsoft.Json.JsonProperty("preemptionPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PreemptionPolicy { get; set; }
    
        /// <summary>The priority value. Various system components use this field to find the
        /// priority of the pod. When Priority Admission Controller is enabled, it
        /// prevents users from setting this field. The admission controller populates
        /// this field from PriorityClassName.
        /// The higher the value, the higher the priority.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Priority { get; set; }
    
        /// <summary>If specified, indicates the pod's priority. "system-node-critical" and
        /// "system-cluster-critical" are two special keywords which indicate the
        /// highest priorities with the former being the highest priority. Any other
        /// name must be defined by creating a PriorityClass object with that name.
        /// If not specified, the pod priority will be default or zero if there is no
        /// default.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("priorityClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PriorityClassName { get; set; }
    
        /// <summary>If specified, all readiness gates will be evaluated for pod readiness.
        /// A pod is ready when all its containers are ready AND
        /// all conditions specified in the readiness gates have status equal to "True"
        /// More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readinessGates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1PodReadinessGate> ReadinessGates { get; set; }
    
        [Newtonsoft.Json.JsonProperty("restartPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RestartPolicy { get; set; }
    
        /// <summary>RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
        /// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
        /// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
        /// empty definition that uses the default runtime handler.
        /// More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
        /// This is a beta feature as of Kubernetes v1.14.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("runtimeClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RuntimeClassName { get; set; }
    
        /// <summary>If specified, the pod will be dispatched by specified scheduler.
        /// If not specified, the pod will be dispatched by default scheduler.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("schedulerName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SchedulerName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("securityContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PodSecurityContext SecurityContext { get; set; }
    
        /// <summary>DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
        /// Deprecated: Use serviceAccountName instead.
        /// +k8s:conversion-gen=false
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("serviceAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceAccount { get; set; }
    
        /// <summary>ServiceAccountName is the name of the ServiceAccount to use to run this pod.
        /// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("serviceAccountName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceAccountName { get; set; }
    
        /// <summary>If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
        /// In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
        /// In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
        /// If a pod does not have FQDN, this has no effect.
        /// Default to false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("setHostnameAsFQDN", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SetHostnameAsFQDN { get; set; }
    
        /// <summary>Share a single process namespace between all of the containers in a pod.
        /// When this is set containers will be able to view and signal processes from other containers
        /// in the same pod, and the first process in each container will not be assigned PID 1.
        /// HostPID and ShareProcessNamespace cannot both be set.
        /// Optional: Default to false.
        /// +k8s:conversion-gen=false
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("shareProcessNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ShareProcessNamespace { get; set; }
    
        /// <summary>If specified, the fully qualified Pod hostname will be "&lt;hostname&gt;.&lt;subdomain&gt;.&lt;pod namespace&gt;.svc.&lt;cluster domain&gt;".
        /// If not specified, the pod will not have a domainname at all.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("subdomain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subdomain { get; set; }
    
        /// <summary>Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
        /// Value must be non-negative integer. The value zero indicates stop immediately via
        /// the kill signal (no opportunity to shut down).
        /// If this value is nil, the default grace period will be used instead.
        /// The grace period is the duration in seconds after the processes running in the pod are sent
        /// a termination signal and the time when the processes are forcibly halted with a kill signal.
        /// Set this value longer than the expected cleanup time for your process.
        /// Defaults to 30 seconds.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("terminationGracePeriodSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TerminationGracePeriodSeconds { get; set; }
    
        /// <summary>If specified, the pod's tolerations.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("tolerations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1Toleration> Tolerations { get; set; }
    
        /// <summary>TopologySpreadConstraints describes how a group of pods ought to spread across topology
        /// domains. Scheduler will schedule pods in a way which abides by the constraints.
        /// All topologySpreadConstraints are ANDed.
        /// +optional
        /// +patchMergeKey=topologyKey
        /// +patchStrategy=merge
        /// +listType=map
        /// +listMapKey=topologyKey
        /// +listMapKey=whenUnsatisfiable</summary>
        [Newtonsoft.Json.JsonProperty("topologySpreadConstraints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1TopologySpreadConstraint> TopologySpreadConstraints { get; set; }
    
        /// <summary>List of volumes that can be mounted by containers belonging to the pod.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes
        /// +optional
        /// +patchMergeKey=name
        /// +patchStrategy=merge,retainKeys</summary>
        [Newtonsoft.Json.JsonProperty("volumes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1Volume> Volumes { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PortStatus 
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Port { get; set; }
    
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Protocol { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PortworxVolumeSource 
    {
        /// <summary>FSType represents the filesystem type to mount
        /// Must be a filesystem type supported by the host operating system.
        /// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>Defaults to false (read/write). ReadOnly here will force
        /// the ReadOnly setting in VolumeMounts.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        /// <summary>VolumeID uniquely identifies a Portworx volume</summary>
        [Newtonsoft.Json.JsonProperty("volumeID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeID { get; set; }
    
    
    }
    
    /// <summary>An empty preferred scheduling term matches all objects with implicit weight 0
    /// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1PreferredSchedulingTerm 
    {
        [Newtonsoft.Json.JsonProperty("preference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1NodeSelectorTerm Preference { get; set; }
    
        /// <summary>Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.</summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Weight { get; set; }
    
    
    }
    
    /// <summary>Probe describes a health check to be performed against a container to determine whether it is
    /// alive or ready to receive traffic.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Probe 
    {
        [Newtonsoft.Json.JsonProperty("exec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ExecAction Exec { get; set; }
    
        /// <summary>Minimum consecutive failures for the probe to be considered failed after having succeeded.
        /// Defaults to 3. Minimum value is 1.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("failureThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FailureThreshold { get; set; }
    
        [Newtonsoft.Json.JsonProperty("httpGet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1HTTPGetAction HttpGet { get; set; }
    
        /// <summary>Number of seconds after the container has started before liveness probes are initiated.
        /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("initialDelaySeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? InitialDelaySeconds { get; set; }
    
        /// <summary>How often (in seconds) to perform the probe.
        /// Default to 10 seconds. Minimum value is 1.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("periodSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PeriodSeconds { get; set; }
    
        /// <summary>Minimum consecutive successes for the probe to be considered successful after having failed.
        /// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("successThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SuccessThreshold { get; set; }
    
        [Newtonsoft.Json.JsonProperty("tcpSocket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1TCPSocketAction TcpSocket { get; set; }
    
        /// <summary>Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
        /// The grace period is the duration in seconds after the processes running in the pod are sent
        /// a termination signal and the time when the processes are forcibly halted with a kill signal.
        /// Set this value longer than the expected cleanup time for your process.
        /// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
        /// value overrides the value provided by the pod spec.
        /// Value must be non-negative integer. The value zero indicates stop immediately via
        /// the kill signal (no opportunity to shut down).
        /// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
        /// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("terminationGracePeriodSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TerminationGracePeriodSeconds { get; set; }
    
        /// <summary>Number of seconds after which the probe times out.
        /// Defaults to 1 second. Minimum value is 1.
        /// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("timeoutSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TimeoutSeconds { get; set; }
    
    
    }
    
    /// <summary>Represents a projected volume source</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ProjectedVolumeSource 
    {
        /// <summary>Mode bits used to set permissions on created files by default.
        /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
        /// YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
        /// Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file
        /// mode, like fsGroup, and the result can be other mode bits set.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("defaultMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DefaultMode { get; set; }
    
        /// <summary>list of volume projections
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1VolumeProjection> Sources { get; set; }
    
    
    }
    
    /// <summary>Quobyte volumes do not support ownership management or SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1QuobyteVolumeSource 
    {
        /// <summary>Group to map volume access to
        /// Default is no group
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }
    
        /// <summary>ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
        /// Defaults to false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        /// <summary>Registry represents a single or multiple Quobyte Registry services
        /// specified as a string as host:port pair (multiple entries are separated with commas)
        /// which acts as the central registry for volumes</summary>
        [Newtonsoft.Json.JsonProperty("registry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Registry { get; set; }
    
        /// <summary>Tenant owning the given Quobyte volume in the Backend
        /// Used with dynamically provisioned Quobyte volumes, value is set by the plugin
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("tenant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tenant { get; set; }
    
        /// <summary>User to map volume access to
        /// Defaults to serivceaccount user
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }
    
        /// <summary>Volume is a string that references an already created Quobyte volume by name.</summary>
        [Newtonsoft.Json.JsonProperty("volume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Volume { get; set; }
    
    
    }
    
    /// <summary>RBD volumes support ownership management and SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1RBDVolumeSource 
    {
        /// <summary>Filesystem type of the volume that you want to mount.
        /// Tip: Ensure that the filesystem type is supported by the host operating system.
        /// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
        /// TODO: how do we prevent errors in the filesystem from compromising the machine
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>The rados image name.
        /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it</summary>
        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Image { get; set; }
    
        /// <summary>Keyring is the path to key ring for RBDUser.
        /// Default is /etc/ceph/keyring.
        /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("keyring", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Keyring { get; set; }
    
        /// <summary>A collection of Ceph monitors.
        /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it</summary>
        [Newtonsoft.Json.JsonProperty("monitors", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Monitors { get; set; }
    
        /// <summary>The rados pool name.
        /// Default is rbd.
        /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("pool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool { get; set; }
    
        /// <summary>ReadOnly here will force the ReadOnly setting in VolumeMounts.
        /// Defaults to false.
        /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LocalObjectReference SecretRef { get; set; }
    
        /// <summary>The rados user name.
        /// Default is admin.
        /// More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }
    
    
    }
    
    /// <summary>ResourceFieldSelector represents container resources (cpu, memory) and their output format
    /// +structType=atomic</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ResourceFieldSelector 
    {
        /// <summary>Container name: required for volumes, optional for env vars
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("containerName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContainerName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("divisor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Divisor { get; set; }
    
        /// <summary>Required: resource to select</summary>
        [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Resource { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ResourceList : System.Collections.Generic.Dictionary<string, string>
    {
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ResourceRequirements 
    {
        [Newtonsoft.Json.JsonProperty("limits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ResourceList Limits { get; set; }
    
        [Newtonsoft.Json.JsonProperty("requests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ResourceList Requests { get; set; }
    
    
    }
    
    /// <summary>SELinuxOptions are the labels to be applied to the container</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1SELinuxOptions 
    {
        /// <summary>Level is SELinux level label that applies to the container.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Level { get; set; }
    
        /// <summary>Role is a SELinux role label that applies to the container.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Role { get; set; }
    
        /// <summary>Type is a SELinux type label that applies to the container.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }
    
        /// <summary>User is a SELinux user label that applies to the container.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }
    
    
    }
    
    /// <summary>ScaleIOVolumeSource represents a persistent ScaleIO volume</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ScaleIOVolumeSource 
    {
        /// <summary>Filesystem type to mount.
        /// Must be a filesystem type supported by the host operating system.
        /// Ex. "ext4", "xfs", "ntfs".
        /// Default is "xfs".
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>The host address of the ScaleIO API Gateway.</summary>
        [Newtonsoft.Json.JsonProperty("gateway", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Gateway { get; set; }
    
        /// <summary>The name of the ScaleIO Protection Domain for the configured storage.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("protectionDomain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProtectionDomain { get; set; }
    
        /// <summary>Defaults to false (read/write). ReadOnly here will force
        /// the ReadOnly setting in VolumeMounts.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LocalObjectReference SecretRef { get; set; }
    
        /// <summary>Flag to enable/disable SSL communication with Gateway, default false
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("sslEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SslEnabled { get; set; }
    
        /// <summary>Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
        /// Default is ThinProvisioned.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("storageMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StorageMode { get; set; }
    
        /// <summary>The ScaleIO Storage Pool associated with the protection domain.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("storagePool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StoragePool { get; set; }
    
        /// <summary>The name of the storage system as configured in ScaleIO.</summary>
        [Newtonsoft.Json.JsonProperty("system", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string System { get; set; }
    
        /// <summary>The name of a volume already created in the ScaleIO system
        /// that is associated with this volume source.</summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }
    
    
    }
    
    /// <summary>Only one profile source may be set.
    /// +union</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1SeccompProfile 
    {
        /// <summary>localhostProfile indicates a profile defined in a file on the node should be used.
        /// The profile must be preconfigured on the node to work.
        /// Must be a descending path, relative to the kubelet's configured seccomp profile location.
        /// Must only be set if type is "Localhost".
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("localhostProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LocalhostProfile { get; set; }
    
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }
    
    
    }
    
    /// <summary>The contents of the target Secret's Data field will represent the
    /// key-value pairs as environment variables.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1SecretEnvSource 
    {
        /// <summary>Name of the referent.
        /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// TODO: Add other useful fields. apiVersion, kind, uid?
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Specify whether the Secret must be defined
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    
    
    }
    
    /// <summary>+structType=atomic</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1SecretKeySelector 
    {
        /// <summary>The key of the secret to select from.  Must be a valid secret key.</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        /// <summary>Name of the referent.
        /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// TODO: Add other useful fields. apiVersion, kind, uid?
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Specify whether the Secret or its key must be defined
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    
    
    }
    
    /// <summary>The contents of the target Secret's Data field will be presented in a
    /// projected volume as files using the keys in the Data field as the file names.
    /// Note that this is identical to a secret volume source without the default
    /// mode.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1SecretProjection 
    {
        /// <summary>If unspecified, each key-value pair in the Data field of the referenced
        /// Secret will be projected into the volume as a file whose name is the
        /// key and content is the value. If specified, the listed keys will be
        /// projected into the specified paths, and unlisted keys will not be
        /// present. If a key is specified which is not present in the Secret,
        /// the volume setup will error unless it is marked optional. Paths must be
        /// relative and may not contain the '..' path or start with '..'.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1KeyToPath> Items { get; set; }
    
        /// <summary>Name of the referent.
        /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// TODO: Add other useful fields. apiVersion, kind, uid?
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Specify whether the Secret or its key must be defined
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    
    
    }
    
    /// <summary>The contents of the target Secret's Data field will be presented in a volume
    /// as files using the keys in the Data field as the file names.
    /// Secret volumes support ownership management and SELinux relabeling.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1SecretVolumeSource 
    {
        /// <summary>Optional: mode bits used to set permissions on created files by default.
        /// Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
        /// YAML accepts both octal and decimal values, JSON requires decimal values
        /// for mode bits. Defaults to 0644.
        /// Directories within the path are not affected by this setting.
        /// This might be in conflict with other options that affect the file
        /// mode, like fsGroup, and the result can be other mode bits set.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("defaultMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DefaultMode { get; set; }
    
        /// <summary>If unspecified, each key-value pair in the Data field of the referenced
        /// Secret will be projected into the volume as a file whose name is the
        /// key and content is the value. If specified, the listed keys will be
        /// projected into the specified paths, and unlisted keys will not be
        /// present. If a key is specified which is not present in the Secret,
        /// the volume setup will error unless it is marked optional. Paths must be
        /// relative and may not contain the '..' path or start with '..'.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1KeyToPath> Items { get; set; }
    
        /// <summary>Specify whether the Secret or its keys must be defined
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    
        /// <summary>Name of the secret in the pod's namespace to use.
        /// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("secretName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SecretName { get; set; }
    
    
    }
    
    /// <summary>Some fields are present in both SecurityContext and PodSecurityContext.  When both
    /// are set, the values in SecurityContext take precedence.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1SecurityContext 
    {
        /// <summary>AllowPrivilegeEscalation controls whether a process can gain more
        /// privileges than its parent process. This bool directly controls if
        /// the no_new_privs flag will be set on the container process.
        /// AllowPrivilegeEscalation is true always when the container is:
        /// 1) run as Privileged
        /// 2) has CAP_SYS_ADMIN
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("allowPrivilegeEscalation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AllowPrivilegeEscalation { get; set; }
    
        [Newtonsoft.Json.JsonProperty("capabilities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1Capabilities Capabilities { get; set; }
    
        /// <summary>Run container in privileged mode.
        /// Processes in privileged containers are essentially equivalent to root on the host.
        /// Defaults to false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("privileged", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Privileged { get; set; }
    
        [Newtonsoft.Json.JsonProperty("procMount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcMount { get; set; }
    
        /// <summary>Whether this container has a read-only root filesystem.
        /// Default is false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnlyRootFilesystem", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnlyRootFilesystem { get; set; }
    
        /// <summary>The GID to run the entrypoint of the container process.
        /// Uses runtime default if unset.
        /// May also be set in PodSecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("runAsGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RunAsGroup { get; set; }
    
        /// <summary>Indicates that the container must run as a non-root user.
        /// If true, the Kubelet will validate the image at runtime to ensure that it
        /// does not run as UID 0 (root) and fail to start the container if it does.
        /// If unset or false, no such validation will be performed.
        /// May also be set in PodSecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("runAsNonRoot", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RunAsNonRoot { get; set; }
    
        /// <summary>The UID to run the entrypoint of the container process.
        /// Defaults to user specified in image metadata if unspecified.
        /// May also be set in PodSecurityContext.  If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("runAsUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? RunAsUser { get; set; }
    
        [Newtonsoft.Json.JsonProperty("seLinuxOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SELinuxOptions SeLinuxOptions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("seccompProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SeccompProfile SeccompProfile { get; set; }
    
        [Newtonsoft.Json.JsonProperty("windowsOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1WindowsSecurityContextOptions WindowsOptions { get; set; }
    
    
    }
    
    /// <summary>Service is a named abstraction of software service (for example, mysql) consisting of local port
    /// (for example 3306) that the proxy listens on, and the selector that determines which pods
    /// will answer requests sent through the proxy.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Service 
    {
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ObjectMeta Metadata { get; set; }
    
        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ServiceSpec Spec { get; set; }
    
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ServiceStatus Status { get; set; }
    
    
    }
    
    /// <summary>ServiceAccountTokenProjection represents a projected service account token
    /// volume. This projection can be used to insert a service account token into
    /// the pods runtime filesystem for use against APIs (Kubernetes API Server or
    /// otherwise).</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ServiceAccountTokenProjection 
    {
        /// <summary>Audience is the intended audience of the token. A recipient of a token
        /// must identify itself with an identifier specified in the audience of the
        /// token, and otherwise should reject the token. The audience defaults to the
        /// identifier of the apiserver.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("audience", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Audience { get; set; }
    
        /// <summary>ExpirationSeconds is the requested duration of validity of the service
        /// account token. As the token approaches expiration, the kubelet volume
        /// plugin will proactively rotate the service account token. The kubelet will
        /// start trying to rotate the token if the token is older than 80 percent of
        /// its time to live or if the token is older than 24 hours.Defaults to 1 hour
        /// and must be at least 10 minutes.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("expirationSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ExpirationSeconds { get; set; }
    
        /// <summary>Path is the path relative to the mount point of the file to project the
        /// token into.</summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }
    
    
    }
    
    /// <summary>ServiceBackendPort is the service port being referenced.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ServiceBackendPort 
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Number { get; set; }
    
    
    }
    
    /// <summary>ServicePort contains information on service's port.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ServicePort 
    {
        [Newtonsoft.Json.JsonProperty("appProtocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AppProtocol { get; set; }
    
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nodePort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NodePort { get; set; }
    
        /// <summary>The port that will be exposed by this service.</summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Port { get; set; }
    
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Protocol { get; set; }
    
        [Newtonsoft.Json.JsonProperty("targetPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IntstrIntOrString TargetPort { get; set; }
    
    
    }
    
    /// <summary>ServiceSpec describes the attributes that a user creates on a service.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ServiceSpec 
    {
        [Newtonsoft.Json.JsonProperty("allocateLoadBalancerNodePorts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AllocateLoadBalancerNodePorts { get; set; }
    
        [Newtonsoft.Json.JsonProperty("clusterIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterIP { get; set; }
    
        /// <summary>ClusterIPs is a list of IP addresses assigned to this service, and are
        /// usually assigned randomly.  If an address is specified manually, is
        /// in-range (as per system configuration), and is not in use, it will be
        /// allocated to the service; otherwise creation of the service will fail.
        /// This field may not be changed through updates unless the type field is
        /// also being changed to ExternalName (which requires this field to be
        /// empty) or the type field is being changed from ExternalName (in which
        /// case this field may optionally be specified, as describe above).  Valid
        /// values are "None", empty string (""), or a valid IP address.  Setting
        /// this to "None" makes a "headless service" (no virtual IP), which is
        /// useful when direct endpoint connections are preferred and proxying is
        /// not required.  Only applies to types ClusterIP, NodePort, and
        /// LoadBalancer. If this field is specified when creating a Service of type
        /// ExternalName, creation will fail. This field will be wiped when updating
        /// a Service to type ExternalName.  If this field is not specified, it will
        /// be initialized from the clusterIP field.  If this field is specified,
        /// clients must ensure that clusterIPs[0] and clusterIP have the same
        /// value.
        /// 
        /// Unless the "IPv6DualStack" feature gate is enabled, this field is
        /// limited to one value, which must be the same as the clusterIP field.  If
        /// the feature gate is enabled, this field may hold a maximum of two
        /// entries (dual-stack IPs, in either order).  These IPs must correspond to
        /// the values of the ipFamilies field. Both clusterIPs and ipFamilies are
        /// governed by the ipFamilyPolicy field.
        /// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        /// +listType=atomic
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("clusterIPs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ClusterIPs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("externalIPs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ExternalIPs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("externalName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExternalName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("externalTrafficPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExternalTrafficPolicy { get; set; }
    
        [Newtonsoft.Json.JsonProperty("healthCheckNodePort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HealthCheckNodePort { get; set; }
    
        [Newtonsoft.Json.JsonProperty("internalTrafficPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InternalTrafficPolicy { get; set; }
    
        /// <summary>IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
        /// service, and is gated by the "IPv6DualStack" feature gate.  This field
        /// is usually assigned automatically based on cluster configuration and the
        /// ipFamilyPolicy field. If this field is specified manually, the requested
        /// family is available in the cluster, and ipFamilyPolicy allows it, it
        /// will be used; otherwise creation of the service will fail.  This field
        /// is conditionally mutable: it allows for adding or removing a secondary
        /// IP family, but it does not allow changing the primary IP family of the
        /// Service.  Valid values are "IPv4" and "IPv6".  This field only applies
        /// to Services of types ClusterIP, NodePort, and LoadBalancer, and does
        /// apply to "headless" services.  This field will be wiped when updating a
        /// Service to type ExternalName.
        /// 
        /// This field may hold a maximum of two entries (dual-stack families, in
        /// either order).  These families must correspond to the values of the
        /// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
        /// governed by the ipFamilyPolicy field.
        /// +listType=atomic
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("ipFamilies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> IpFamilies { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ipFamilyPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IpFamilyPolicy { get; set; }
    
        [Newtonsoft.Json.JsonProperty("loadBalancerClass", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LoadBalancerClass { get; set; }
    
        [Newtonsoft.Json.JsonProperty("loadBalancerIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LoadBalancerIP { get; set; }
    
        [Newtonsoft.Json.JsonProperty("loadBalancerSourceRanges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> LoadBalancerSourceRanges { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1ServicePort> Ports { get; set; }
    
        [Newtonsoft.Json.JsonProperty("publishNotReadyAddresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? PublishNotReadyAddresses { get; set; }
    
        [Newtonsoft.Json.JsonProperty("selector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Selector { get; set; }
    
        [Newtonsoft.Json.JsonProperty("sessionAffinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SessionAffinity { get; set; }
    
        [Newtonsoft.Json.JsonProperty("sessionAffinityConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SessionAffinityConfig SessionAffinityConfig { get; set; }
    
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }
    
    
    }
    
    /// <summary>ServiceStatus represents the current status of a service.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1ServiceStatus 
    {
        [Newtonsoft.Json.JsonProperty("conditions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<V1Condition> Conditions { get; set; }
    
        [Newtonsoft.Json.JsonProperty("loadBalancer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LoadBalancerStatus LoadBalancer { get; set; }
    
    
    }
    
    /// <summary>SessionAffinityConfig represents the configurations of session affinity.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1SessionAffinityConfig 
    {
        [Newtonsoft.Json.JsonProperty("clientIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ClientIPConfig ClientIP { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1StorageOSVolumeSource 
    {
        /// <summary>Filesystem type to mount.
        /// Must be a filesystem type supported by the host operating system.
        /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>Defaults to false (read/write). ReadOnly here will force
        /// the ReadOnly setting in VolumeMounts.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LocalObjectReference SecretRef { get; set; }
    
        /// <summary>VolumeName is the human-readable name of the StorageOS volume.  Volume
        /// names are only unique within a namespace.</summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }
    
        /// <summary>VolumeNamespace specifies the scope of the volume within StorageOS.  If no
        /// namespace is specified then the Pod's namespace will be used.  This allows the
        /// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
        /// Set VolumeName to any name to override the default behaviour.
        /// Set to "default" if you are not using namespaces within StorageOS.
        /// Namespaces that do not pre-exist within StorageOS will be created.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("volumeNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeNamespace { get; set; }
    
    
    }
    
    /// <summary>Sysctl defines a kernel parameter to be set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Sysctl 
    {
        /// <summary>Name of a property to set</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Value of a property to set</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    /// <summary>TCPSocketAction describes an action based on opening a socket</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1TCPSocketAction 
    {
        /// <summary>Optional: Host name to connect to, defaults to the pod IP.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host { get; set; }
    
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public IntstrIntOrString Port { get; set; }
    
    
    }
    
    /// <summary>The pod this Toleration is attached to tolerates any taint that matches
    /// the triple &lt;key,value,effect&gt; using the matching operator &lt;operator&gt;.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Toleration 
    {
        [Newtonsoft.Json.JsonProperty("effect", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Effect { get; set; }
    
        /// <summary>Key is the taint key that the toleration applies to. Empty means match all taint keys.
        /// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Operator { get; set; }
    
        /// <summary>TolerationSeconds represents the period of time the toleration (which must be
        /// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
        /// it is not set, which means tolerate the taint forever (do not evict). Zero and
        /// negative values will be treated as 0 (evict immediately) by the system.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("tolerationSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TolerationSeconds { get; set; }
    
        /// <summary>Value is the taint value the toleration matches to.
        /// If the operator is Exists, the value should be empty, otherwise just a regular string.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1TopologySpreadConstraint 
    {
        [Newtonsoft.Json.JsonProperty("labelSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1LabelSelector LabelSelector { get; set; }
    
        /// <summary>MaxSkew describes the degree to which pods may be unevenly distributed.
        /// When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
        /// between the number of matching pods in the target topology and the global minimum.
        /// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
        /// labelSelector spread as 1/1/0:
        /// +-------+-------+-------+
        ///  zone1 | zone2 | zone3 |
        /// +-------+-------+-------+
        ///    P   |   P   |       |
        /// +-------+-------+-------+
        /// if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
        /// scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
        /// violate MaxSkew(1).
        /// if MaxSkew is 2, incoming pod can be scheduled onto any zone.
        /// When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
        /// to topologies that satisfy it.
        /// It's a required field. Default value is 1 and 0 is not allowed.</summary>
        [Newtonsoft.Json.JsonProperty("maxSkew", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxSkew { get; set; }
    
        /// <summary>TopologyKey is the key of node labels. Nodes that have a label with this key
        /// and identical values are considered to be in the same topology.
        /// We consider each &lt;key, value&gt; as a "bucket", and try to put balanced number
        /// of pods into each bucket.
        /// It's a required field.</summary>
        [Newtonsoft.Json.JsonProperty("topologyKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TopologyKey { get; set; }
    
        [Newtonsoft.Json.JsonProperty("whenUnsatisfiable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WhenUnsatisfiable { get; set; }
    
    
    }
    
    /// <summary>TypedLocalObjectReference contains enough information to let you locate the
    /// typed referenced object inside the same namespace.
    /// +structType=atomic</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1TypedLocalObjectReference 
    {
        /// <summary>APIGroup is the group for the resource being referenced.
        /// If APIGroup is not specified, the specified Kind must be in the core API group.
        /// For any other third-party types, APIGroup is required.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("apiGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiGroup { get; set; }
    
        /// <summary>Kind is the type of resource being referenced</summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }
    
        /// <summary>Name is the name of resource being referenced</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1Volume 
    {
        [Newtonsoft.Json.JsonProperty("awsElasticBlockStore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1AWSElasticBlockStoreVolumeSource AwsElasticBlockStore { get; set; }
    
        [Newtonsoft.Json.JsonProperty("azureDisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1AzureDiskVolumeSource AzureDisk { get; set; }
    
        [Newtonsoft.Json.JsonProperty("azureFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1AzureFileVolumeSource AzureFile { get; set; }
    
        [Newtonsoft.Json.JsonProperty("cephfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1CephFSVolumeSource Cephfs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("cinder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1CinderVolumeSource Cinder { get; set; }
    
        [Newtonsoft.Json.JsonProperty("configMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ConfigMapVolumeSource ConfigMap { get; set; }
    
        [Newtonsoft.Json.JsonProperty("csi", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1CSIVolumeSource Csi { get; set; }
    
        [Newtonsoft.Json.JsonProperty("downwardAPI", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1DownwardAPIVolumeSource DownwardAPI { get; set; }
    
        [Newtonsoft.Json.JsonProperty("emptyDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1EmptyDirVolumeSource EmptyDir { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ephemeral", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1EphemeralVolumeSource Ephemeral { get; set; }
    
        [Newtonsoft.Json.JsonProperty("fc", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1FCVolumeSource Fc { get; set; }
    
        [Newtonsoft.Json.JsonProperty("flexVolume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1FlexVolumeSource FlexVolume { get; set; }
    
        [Newtonsoft.Json.JsonProperty("flocker", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1FlockerVolumeSource Flocker { get; set; }
    
        [Newtonsoft.Json.JsonProperty("gcePersistentDisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1GCEPersistentDiskVolumeSource GcePersistentDisk { get; set; }
    
        [Newtonsoft.Json.JsonProperty("gitRepo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1GitRepoVolumeSource GitRepo { get; set; }
    
        [Newtonsoft.Json.JsonProperty("glusterfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1GlusterfsVolumeSource Glusterfs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("hostPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1HostPathVolumeSource HostPath { get; set; }
    
        [Newtonsoft.Json.JsonProperty("iscsi", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ISCSIVolumeSource Iscsi { get; set; }
    
        /// <summary>Volume's name.
        /// Must be a DNS_LABEL and unique within the pod.
        /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("nfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1NFSVolumeSource Nfs { get; set; }
    
        [Newtonsoft.Json.JsonProperty("persistentVolumeClaim", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PersistentVolumeClaimVolumeSource PersistentVolumeClaim { get; set; }
    
        [Newtonsoft.Json.JsonProperty("photonPersistentDisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PhotonPersistentDiskVolumeSource PhotonPersistentDisk { get; set; }
    
        [Newtonsoft.Json.JsonProperty("portworxVolume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PortworxVolumeSource PortworxVolume { get; set; }
    
        [Newtonsoft.Json.JsonProperty("projected", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ProjectedVolumeSource Projected { get; set; }
    
        [Newtonsoft.Json.JsonProperty("quobyte", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1QuobyteVolumeSource Quobyte { get; set; }
    
        [Newtonsoft.Json.JsonProperty("rbd", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1RBDVolumeSource Rbd { get; set; }
    
        [Newtonsoft.Json.JsonProperty("scaleIO", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ScaleIOVolumeSource ScaleIO { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SecretVolumeSource Secret { get; set; }
    
        [Newtonsoft.Json.JsonProperty("storageos", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1StorageOSVolumeSource Storageos { get; set; }
    
        [Newtonsoft.Json.JsonProperty("vsphereVolume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1VsphereVirtualDiskVolumeSource VsphereVolume { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1VolumeDevice 
    {
        /// <summary>devicePath is the path inside of the container that the device will be mapped to.</summary>
        [Newtonsoft.Json.JsonProperty("devicePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DevicePath { get; set; }
    
        /// <summary>name must match the name of a persistentVolumeClaim in the pod</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1VolumeMount 
    {
        /// <summary>Path within the container at which the volume should be mounted.  Must
        /// not contain ':'.</summary>
        [Newtonsoft.Json.JsonProperty("mountPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MountPath { get; set; }
    
        [Newtonsoft.Json.JsonProperty("mountPropagation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MountPropagation { get; set; }
    
        /// <summary>This must match the Name of a Volume.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Mounted read-only if true, read-write otherwise (false or unspecified).
        /// Defaults to false.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }
    
        /// <summary>Path within the volume from which the container's volume should be mounted.
        /// Defaults to "" (volume's root).
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("subPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubPath { get; set; }
    
        /// <summary>Expanded path within the volume from which the container's volume should be mounted.
        /// Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
        /// Defaults to "" (volume's root).
        /// SubPathExpr and SubPath are mutually exclusive.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("subPathExpr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubPathExpr { get; set; }
    
    
    }
    
    /// <summary>Projection that may be projected along with other supported volume types</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1VolumeProjection 
    {
        [Newtonsoft.Json.JsonProperty("configMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ConfigMapProjection ConfigMap { get; set; }
    
        [Newtonsoft.Json.JsonProperty("downwardAPI", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1DownwardAPIProjection DownwardAPI { get; set; }
    
        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1SecretProjection Secret { get; set; }
    
        [Newtonsoft.Json.JsonProperty("serviceAccountToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1ServiceAccountTokenProjection ServiceAccountToken { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1VsphereVirtualDiskVolumeSource 
    {
        /// <summary>Filesystem type to mount.
        /// Must be a filesystem type supported by the host operating system.
        /// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }
    
        /// <summary>Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("storagePolicyID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StoragePolicyID { get; set; }
    
        /// <summary>Storage Policy Based Management (SPBM) profile name.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("storagePolicyName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StoragePolicyName { get; set; }
    
        /// <summary>Path that identifies vSphere volume vmdk</summary>
        [Newtonsoft.Json.JsonProperty("volumePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumePath { get; set; }
    
    
    }
    
    /// <summary>The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1WeightedPodAffinityTerm 
    {
        [Newtonsoft.Json.JsonProperty("podAffinityTerm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public V1PodAffinityTerm PodAffinityTerm { get; set; }
    
        /// <summary>weight associated with matching the corresponding podAffinityTerm,
        /// in the range 1-100.</summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Weight { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.27.0 (Newtonsoft.Json v12.0.0.0)")]
    public partial class V1WindowsSecurityContextOptions 
    {
        /// <summary>GMSACredentialSpec is where the GMSA admission webhook
        /// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
        /// GMSA credential spec named by the GMSACredentialSpecName field.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("gmsaCredentialSpec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GmsaCredentialSpec { get; set; }
    
        /// <summary>GMSACredentialSpecName is the name of the GMSA credential spec to use.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("gmsaCredentialSpecName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GmsaCredentialSpecName { get; set; }
    
        /// <summary>HostProcess determines if a container should be run as a 'Host Process' container.
        /// This field is alpha-level and will only be honored by components that enable the
        /// WindowsHostProcessContainers feature flag. Setting this field without the feature
        /// flag will result in errors when validating the Pod. All of a Pod's containers must
        /// have the same effective HostProcess value (it is not allowed to have a mix of HostProcess
        /// containers and non-HostProcess containers).  In addition, if HostProcess is true
        /// then HostNetwork must also be set to true.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("hostProcess", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HostProcess { get; set; }
    
        /// <summary>The UserName in Windows to run the entrypoint of the container process.
        /// Defaults to the user specified in image metadata if unspecified.
        /// May also be set in PodSecurityContext. If set in both SecurityContext and
        /// PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// +optional</summary>
        [Newtonsoft.Json.JsonProperty("runAsUserName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RunAsUserName { get; set; }
    
    
    }

    public partial class FileResponse : System.IDisposable
    {
        private System.IDisposable _client; 
        private System.IDisposable _response; 

        public int StatusCode { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public System.IO.Stream Stream { get; private set; }

        public bool IsPartial
        {
            get { return StatusCode == 206; }
        }

        public FileResponse(int statusCode, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.IO.Stream stream, System.IDisposable client, System.IDisposable response)
        {
            StatusCode = statusCode; 
            Headers = headers; 
            Stream = stream; 
            _client = client; 
            _response = response;
        }

        public void Dispose() 
        {
            if (Stream != null)
                Stream.Dispose();
            if (_response != null)
                _response.Dispose();
            if (_client != null)
                _client.Dispose();
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.1.3.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.1.3.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v12.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108